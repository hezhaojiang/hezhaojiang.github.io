<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何照江的博客</title>
  
  
  <link href="http://github.hezhaojiang.io/atom.xml" rel="self"/>
  
  <link href="http://github.hezhaojiang.io/"/>
  <updated>2021-03-03T16:26:32.907Z</updated>
  <id>http://github.hezhaojiang.io/</id>
  
  <author>
    <name>何照江</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法 - 最短路径</title>
    <link href="http://github.hezhaojiang.io/post/2021/b1770ae8/"/>
    <id>http://github.hezhaojiang.io/post/2021/b1770ae8/</id>
    <published>2021-03-03T06:44:06.000Z</published>
    <updated>2021-03-03T16:26:32.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>图的最短路算法有很多，在此记录一下非常常用的四个算法</p><ul><li>单源最短路：<ul><li>不带负权边：<code>Dijkstra</code></li><li>带负权边：<code>Bellman-Ford</code>、<code>SPFA</code></li></ul></li><li>多源最短路：<ul><li>适用于正负权边：<code>Floyd</code>（但不能有负环）</li></ul></li></ul><a id="more"></a><h2 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a>743. 网络延迟时间</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/network-delay-time/">https://leetcode-cn.com/problems/network-delay-time/</a></p><p>有 <code>n</code> 个网络节点，标记为 <code>1</code> 到 <code>n</code>。</p><p>给你一个列表 times，表示信号经过 有向 边的传递时间。<code>times[i] = (ui, vi, wi)</code>，其中 <code>ui</code> 是源节点，<code>vi</code> 是目标节点，<code>wi</code> 是一个信号从源节点传递到目标节点的时间。</p><p>现在，从某个节点 <code>K</code> 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 <code>-1</code> 。</p><p>示例：</p><p><img data-src="https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png" alt="743. 网络延迟时间"></p><pre><code>输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2输出：2</code></pre><h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><p>支持负权。能找到某个结点出发到所有结点的最短路，或者报告某些最短路不存在。</p><p><code>SPFA</code> 算法就是 <code>Bellman-Ford</code> 算法的一种实现。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distance</span><span class="params">(n + <span class="number">1</span>, INT_MAX / <span class="number">2</span>)</span></span>;</span><br><span class="line">        distance[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; n; t++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; relax = distance;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; time : times) &#123;</span><br><span class="line">                relax[time[<span class="number">1</span>]] = <span class="built_in">min</span>(relax[time[<span class="number">1</span>]], distance[time[<span class="number">0</span>]] + time[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            distance = relax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = *max_element(distance.<span class="built_in">begin</span>() + <span class="number">1</span>, distance.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX / <span class="number">2</span> ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>Accepted52/52 cases passed (248 ms)Your runtime beats 24.45 % of cpp submissionsYour memory usage beats 45.09 % of cpp submissions (36.2 MB)</code></pre><h3 id="队列优化：SPFA"><a href="#队列优化：SPFA" class="headerlink" title="队列优化：SPFA"></a>队列优化：SPFA</h3><p>即 <code>Shortest Path Faster Algorithm</code>，很显然，只有上一次被松弛的结点所连接的边，才有可能引起下一次的松弛操作。</p><p>那么我们用队列来维护哪些结点可能会引起松弛操作，就能只访问必要的边了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 建图 存储方式：邻接表（索引方式）</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">edges</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            edges[times[i][<span class="number">0</span>]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 通过队列来判断哪些结点需要更新</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distance</span><span class="params">(n + <span class="number">1</span>, INT_MAX / <span class="number">2</span>)</span></span>;</span><br><span class="line">        distance[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">in_queue</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        q.push(k);</span><br><span class="line">        in_queue[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            in_queue[u] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; index : edges[u]) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = times[index][<span class="number">1</span>], w = times[index][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (distance[v] &gt; distance[u] + w) &#123;</span><br><span class="line">                    distance[v] = distance[u] + w;</span><br><span class="line">                    <span class="keyword">if</span> (!in_queue[v]) &#123;</span><br><span class="line">                        q.push(v);</span><br><span class="line">                        in_queue[v] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = *max_element(distance.<span class="built_in">begin</span>() + <span class="number">1</span>, distance.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX / <span class="number">2</span> ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>Accepted52/52 cases passed (128 ms)Your runtime beats 89.48 % of cpp submissionsYour memory usage beats 32.26 % of cpp submissions (37.6 MB)</code></pre><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>这种算法只适用于非负权图，但是时间复杂度非常优秀。是可以用来求单源最短路径的算法。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Target</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    Target(<span class="keyword">int</span> p = <span class="number">0</span>, <span class="keyword">int</span> t = <span class="number">0</span>) : pos(p), time(t) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Target&amp; a) <span class="keyword">const</span> &#123; <span class="keyword">return</span> time &gt; a.time; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">edges</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            edges[times[i][<span class="number">0</span>]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Target&gt; Q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cost</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        Q.push(Target&#123;k, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            Target t = Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">if</span> (!visited[t.pos]) &#123;</span><br><span class="line">                cost[t.pos] = t.time;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; index : edges[t.pos]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[times[index][<span class="number">1</span>]]) &#123;</span><br><span class="line">                        Q.push(Target&#123;times[index][<span class="number">1</span>], times[index][<span class="number">2</span>] + t.time&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[t.pos] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = *max_element(cost.<span class="built_in">begin</span>() + <span class="number">1</span>, cost.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>Accepted52/52 cases passed (164 ms)Your runtime beats 61.02 % of cpp submissionsYour memory usage beats 31.36 % of cpp submissions (38.7 MB)</code></pre><h2 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h2><p>本质是动态规划，能解决任意两点间的最短路径，时间复杂度 O(V^3)</p><p>主要算法思想如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// i 到 j 的最短路径 = i 到 k 的最短路径 + k 到 j 的最短路径</span></span><br><span class="line">            <span class="comment">// 当然 要取较小值</span></span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">cost</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, INT_MAX / <span class="number">2</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cost[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : times) cost[t[<span class="number">0</span>] - <span class="number">1</span>][t[<span class="number">1</span>] - <span class="number">1</span>] = t[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; n; m++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    cost[i][j] = <span class="built_in">min</span>(cost[i][j], cost[i][m] + cost[m][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = *max_element(cost[k - <span class="number">1</span>].<span class="built_in">begin</span>(), cost[k - <span class="number">1</span>].<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX / <span class="number">2</span> ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>Accepted52/52 cases passed (240 ms)Your runtime beats 26.05 % of cpp submissionsYour memory usage beats 40.68 % of cpp submissions (36.4 MB)</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://oi-wiki.org/graph/shortest-path/">最短路 - OI Wiki</a></li><li>[2] <a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间 - 力扣（LeetCode）</a></li><li>[3] <a href="https://www.bilibili.com/video/BV1L5411G7P8">图的基础算法 (二) - SSSP/MSSP 单源 / 多源 最短路径_哔哩哔哩 (゜ - ゜) つロ 干杯~-bilibili</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;图的最短路算法有很多，在此记录一下非常常用的四个算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单源最短路：&lt;ul&gt;
&lt;li&gt;不带负权边：&lt;code&gt;Dijkstra&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;带负权边：&lt;code&gt;Bellman-Ford&lt;/code&gt;、&lt;code&gt;SPFA&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多源最短路：&lt;ul&gt;
&lt;li&gt;适用于正负权边：&lt;code&gt;Floyd&lt;/code&gt;（但不能有负环）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://github.hezhaojiang.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="图论" scheme="http://github.hezhaojiang.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 - 最小生成树</title>
    <link href="http://github.hezhaojiang.io/post/2021/2d042192/"/>
    <id>http://github.hezhaojiang.io/post/2021/2d042192/</id>
    <published>2021-03-03T04:54:32.000Z</published>
    <updated>2021-03-03T16:26:32.901Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们定义无向连通图的 最小生成树（Minimum Spanning Tree，MST）为边权和最小的生成树。</p><blockquote><p>注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。</p></blockquote><a id="more"></a><h2 id="1584-连接所有点的最小费用"><a href="#1584-连接所有点的最小费用" class="headerlink" title="1584. 连接所有点的最小费用"></a>1584. 连接所有点的最小费用</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">https://leetcode-cn.com/problems/min-cost-to-connect-all-points/</a></p><p>给你一个 points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。</p><p>连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。</p><p>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。</p><p>示例：</p><pre><code>输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]输出：20</code></pre><h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>Kruskal 算法是一种常见并且好写的最小生成树算法，由 Kruskal 发明。该算法的基本思想是从小到大加入边，是个贪心算法。</p><p>前置知识：</p><ol><li>并查集：<a href="/post/2020/4fe8298f/" title="数据结构与算法 - 并查集">数据结构与算法 - 并查集</a>)</li><li>贪心</li><li>图的存储（直接存边，邻接矩阵，邻接表）</li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是基础的并查集实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> n) : count(n) &#123;</span><br><span class="line">        parent.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n == parent[n] ? n : parent[n] = Find(parent[n]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = Find(a), rootB = Find(b);</span><br><span class="line">        <span class="keyword">if</span> (rootA != rootB) count--, parent[rootA] = rootB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个结构体使用直接存边的方式存图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len, x, y;</span><br><span class="line">    Edge(<span class="keyword">int</span> len = <span class="number">0</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>) : len(len), x(x), y(y) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> caldist = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 1. 建图 存储方式：直接存边</span></span><br><span class="line">        <span class="keyword">int</span> N = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            edges.emplace_back(caldist(i, j), i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 排序所有的边，贪心选择较短的边</span></span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        sort(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](Edge &amp;a, Edge &amp;b) &#123; <span class="keyword">return</span> a.len &lt; b.len; &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; edge : edges) &#123;</span><br><span class="line">            <span class="comment">// 如果这条边的左右顶点已经连接上 则跳过这条边 否则这条边加入最小生成树</span></span><br><span class="line">            <span class="keyword">if</span> (uf.Find(edge.x) == uf.Find(edge.y)) <span class="keyword">continue</span>;</span><br><span class="line">            uf.Union(edge.x, edge.y);</span><br><span class="line">            cost += edge.len;</span><br><span class="line">            <span class="keyword">if</span> (uf.Count() == <span class="number">1</span>) <span class="keyword">return</span> cost; <span class="comment">// 最小生成树已经生成</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>Accepted72/72 cases passed (532 ms)Your runtime beats 58.35 % of cpp submissionsYour memory usage beats 25.13 % of cpp submissions (56.9 MB)</code></pre><h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><p>Prim 算法是一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。</p><p>在稠密图尤其是完全图上，暴力 Prim 的复杂度比 Kruskal 优，但不一定实际跑得更快。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Distance 用来存储定点到最小生成树的距离</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Distance</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> index <span class="comment">/* 定点在 points 中的索引值 */</span>, len <span class="comment">/* 定点到最小生成树的距离 */</span>;</span><br><span class="line">    Distance(<span class="keyword">int</span> index = <span class="number">0</span>, <span class="keyword">int</span> len = <span class="number">0</span>) : index(index), len(len) &#123;&#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Distance&amp; a) <span class="keyword">const</span> &#123; <span class="keyword">return</span> len &gt; a.len; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> caldist = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Distance&gt; Q; <span class="comment">// 优先队列 用来查找距离最小生成树最近的点</span></span><br><span class="line">        Q.push(Distance&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            Distance e = Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">if</span> (!visited[e.index]) &#123;</span><br><span class="line">                cost += e.len;</span><br><span class="line">                visited[e.index] = <span class="number">1</span>; <span class="comment">// 将找到的最近的点加入最小生成树</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                    <span class="comment">// 遍历计算未加入点距离最小生成树的距离 这里不是最小距离 最小距离由优先队列选择</span></span><br><span class="line">                    <span class="keyword">if</span> (!visited[i] &amp;&amp; i != e.index) Q.push(Distance&#123;i, caldist(i, e.index)&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>Accepted72/72 cases passed (668 ms)Your runtime beats 24.34 % of cpp submissionsYour memory usage beats 64.91 % of cpp submissions (41.3 MB)</code></pre><h2 id="特殊的-Prim-算法"><a href="#特殊的-Prim-算法" class="headerlink" title="特殊的 Prim 算法"></a>特殊的 Prim 算法</h2><p>对于稠密图来说，有一种特殊的 Prim 算法可以达到 O(n^2) 的时间复杂度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> caldist = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 1. 建图 存储方式：邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span> N = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">edges</span><span class="params">(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">            edges[i][j] = edges[j][i] = caldist(i, j);</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; distance(N, INT_MAX), visited(N, 0);</span><br><span class="line">        distance[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 将 0 点加入最小生成树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123; <span class="comment">// 在剩余定点中，找到最小路径值的定点</span></span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; (next == <span class="number">-1</span> || distance[j] &lt; distance[next])) next = j;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[next] = <span class="literal">true</span>;         <span class="comment">// 将找到最小路径值的定点加入最小生成树</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; k++) &#123; <span class="comment">// 加入新定点后，导致连通分量到其他定点距离变化</span></span><br><span class="line">                <span class="keyword">if</span> (!visited[k]) distance[k] = <span class="built_in">min</span>(distance[k], edges[next][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(distance.<span class="built_in">begin</span>(), distance.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>Accepted72/72 cases passed (128 ms)Your runtime beats 82.67 % of cpp submissionsYour memory usage beats 75.12 % of cpp submissions (26.1 MB)</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://oi-wiki.org/graph/mst/">最小生成树 - OI Wiki</a></li><li>[2] <a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用 - 力扣（LeetCode）</a></li><li>[3] <a href="https://www.bilibili.com/video/BV1yh41117re">图的基础算法 (一) - MST 最小生成树_哔哩哔哩 (゜ - ゜) つロ 干杯~-bilibili</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们定义无向连通图的 最小生成树（Minimum Spanning Tree，MST）为边权和最小的生成树。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://github.hezhaojiang.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="图论" scheme="http://github.hezhaojiang.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 - 链表</title>
    <link href="http://github.hezhaojiang.io/post/2021/759c397f/"/>
    <id>http://github.hezhaojiang.io/post/2021/759c397f/</id>
    <published>2021-02-16T23:46:21.000Z</published>
    <updated>2021-02-17T08:06:41.813Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="链表基础"><a href="#链表基础" class="headerlink" title="链表基础"></a>链表基础</h2><p>链表的定义（来自维基百科）：</p><p>在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个或下一个节点的位置的链接。</p><a id="more"></a><p>链表与顺序表的区别（来自维基百科）：</p><p>链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针 (Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到 O(1) 的复杂度，比顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要 O(n) 的时间，而顺序表相应的时间复杂度分别是 O(logn) 和 O(1)。</p><p>链表的优缺点（来自维基百科）：</p><p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。<br>链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p><p>链表的类型（来自维基百科）：</p><p>单向链表，双向链表以及循环链表。</p><h2 id="链表练习题目"><a href="#链表练习题目" class="headerlink" title="链表练习题目"></a>链表练习题目</h2><h3 id="链表中的双指针技巧"><a href="#链表中的双指针技巧" class="headerlink" title="链表中的双指针技巧"></a>链表中的双指针技巧</h3><ul><li><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个节点</a></li><li><a href="https://leetcode-cn.com/problems/partition-list">86. 分隔链表</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii">92. 反转链表 II</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">142. 环形链表 II</a></li><li><a href="https://leetcode-cn.com/problems/reorder-list">143. 重排链表</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">160. 相交链表</a></li><li><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree">109. 有序链表转换二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list">206. 反转链表</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-linked-list">234. 回文链表</a></li><li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">876. 链表的中间结点</a></li></ul><h3 id="链表排序问题"><a href="#链表排序问题" class="headerlink" title="链表排序问题"></a>链表排序问题</h3><ul><li><a href="https://leetcode-cn.com/problems/insertion-sort-list">147. 对链表进行插入排序</a></li><li><a href="https://leetcode-cn.com/problems/sort-list">148. 排序链表</a></li></ul><h3 id="链表其他经典题目"><a href="#链表其他经典题目" class="headerlink" title="链表其他经典题目"></a>链表其他经典题目</h3><ul><li><a href="https://leetcode-cn.com/problems/add-two-numbers">2. 两数相加</a></li><li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a></li><li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">23. 合并 K 个排序链表</a></li><li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs">24. 两两交换链表中的节点</a></li><li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group">25. K 个一组翻转链表</a></li><li><a href="https://leetcode-cn.com/problems/rotate-list">61. 旋转链表</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii">82. 删除排序链表中的重复元素 II</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list">83. 删除排序链表中的重复元素</a></li><li><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer">138. 复制带随机指针的链表</a></li><li><a href="https://leetcode-cn.com/problems/remove-linked-list-elements">203. 移除链表元素</a></li><li><a href="https://leetcode-cn.com/problems/add-two-numbers-ii">445. 两数相加 II</a></li><li><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts">725. 分隔链表</a></li><li><a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list">430. 扁平化多级双向链表</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-components">817. 链表组件</a></li><li><a href="https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list">1171. 从链表中删去总和值为零的连续节点</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://xiaoneng.blog.csdn.net/article/details/104007259">leetcode 刷题总结之链表_algsup-CSDN 博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;链表基础&quot;&gt;&lt;a href=&quot;#链表基础&quot; class=&quot;headerlink&quot; title=&quot;链表基础&quot;&gt;&lt;/a&gt;链表基础&lt;/h2&gt;&lt;p&gt;链表的定义（来自维基百科）：&lt;/p&gt;
&lt;p&gt;在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个或下一个节点的位置的链接。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://github.hezhaojiang.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="链表" scheme="http://github.hezhaojiang.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 - 泛洪填充算法</title>
    <link href="http://github.hezhaojiang.io/post/2021/70c4ac0c/"/>
    <id>http://github.hezhaojiang.io/post/2021/70c4ac0c/</id>
    <published>2021-02-09T03:44:49.000Z</published>
    <updated>2021-02-17T07:48:18.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>泛洪填充算法 (Flood Fill Algorithm) 泛洪填充算法又称洪水填充算法是在很多图形绘制软件中常用的填充算法，最熟悉不过就是 windows paint 的油漆桶功能。算法的原理很简单，就是从一个点开始附近像素点，填充成新的颜色，直到封闭区域内的所有像素点都被填充新颜色为止。泛红填充实现最常见有四邻域像素填充法，八邻域像素填充法，基于扫描线的像素填充方法。根据实现又可以分为递归与非递归方法，递归方法一般通过深度优先搜索进行实现，非递归方法一般通过广度优先搜索或并查集实现。</p><a id="more"></a><h2 id="泛洪填充题目解析"><a href="#泛洪填充题目解析" class="headerlink" title="泛洪填充题目解析"></a>泛洪填充题目解析</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h4><p>题目描述：</p><pre><code>给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。示例 1：    输入：grid = [        [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],        [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],        [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],        [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]    ]    输出：1</code></pre><p>深度优先搜索解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> M, N;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dis&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isvalid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; M &amp;&amp; j &lt; N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markIand</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;d : dis) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + d[<span class="number">0</span>], y = j + d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isvalid(x, y) &amp;&amp; grid[x][y] == <span class="string">&#x27;1&#x27;</span>) markIand(grid, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        M = grid.<span class="built_in">size</span>();</span><br><span class="line">        N = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">/* 寻找未发现的岛屿 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123; <span class="comment">/* 找到新岛屿 进行标记 */</span></span><br><span class="line">                markIand(grid, i, j);</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><h4 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733. 图像渲染"></a>733. 图像渲染</h4><p>题目描述：</p><pre><code>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。最后返回经过上色渲染后的图像。示例 1:    输入: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2    输出: [[2,2,2],[2,2,0],[2,0,1]]    解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),          在路径上所有符合条件的像素点的颜色都被更改成2。          注意，右下角的像素没有更改为2，          因为它不是在上下左右四个方向上与初始点相连的像素点。</code></pre><p>广度优先搜索解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> M, N;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dis&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isvalid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; M &amp;&amp; j &lt; N;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="built_in">image</span>, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preColor = <span class="built_in">image</span>[sr][sc];</span><br><span class="line">        <span class="keyword">if</span> (preColor == newColor) <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">        M = <span class="built_in">image</span>.<span class="built_in">size</span>();</span><br><span class="line">        N = <span class="built_in">image</span>[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace_back(sr, sc);</span><br><span class="line">        <span class="built_in">image</span>[sr][sc] = newColor;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = q.front().first, j = q.front().second;</span><br><span class="line">            q.pop_front();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; d : dis) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = i + d[<span class="number">0</span>], y = j + d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (isvalid(x, y) &amp;&amp; <span class="built_in">image</span>[x][y] == preColor) &#123;</span><br><span class="line">                    q.emplace_back(x, y);</span><br><span class="line">                    <span class="built_in">image</span>[x][y] = newColor;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="1020-飞地的数量"><a href="#1020-飞地的数量" class="headerlink" title="1020. 飞地的数量"></a>1020. 飞地的数量</h4><p>题目描述：</p><pre><code>给出一个二维数组 A，每个单元格为 0（代表海）或 1（代表陆地）。移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。示例 1：    输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]    输出：3    解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。示例 2：    输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]    输出：0    解释：所有 1 都在边界上或可以到达边界。</code></pre><p>并查集解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        parent.resize(n);</span><br><span class="line">        rank.resize(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n == parent[n] ? n : parent[n] = Find(parent[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = Find(a), rootB = Find(b);</span><br><span class="line">        <span class="keyword">if</span> (rootA != rootB) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootA] &gt; rank[rootB]) swap(rootA, rootB);</span><br><span class="line">            parent[rootA] = rootB;</span><br><span class="line">            rank[rootB] += rank[rootA] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rank</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> rank[Find(a)]; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> N = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> landCount = <span class="number">0</span>;</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(N * M + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> INDEX(i,j) ((i) * N + (j))</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            landCount++;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == M - <span class="number">1</span> || j == <span class="number">0</span> || j == N - <span class="number">1</span>) uf.Union(M * N, INDEX(i,j)); <span class="comment">// 边界</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; A[i - <span class="number">1</span>][j] == <span class="number">1</span>) uf.Union(INDEX(i - <span class="number">1</span>,j), INDEX(i,j)); <span class="comment">// 上侧</span></span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; A[i][j - <span class="number">1</span>] == <span class="number">1</span>) uf.Union(INDEX(i,j - <span class="number">1</span>), INDEX(i,j)); <span class="comment">// 左侧</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> landCount - uf.Rank(N * M);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="泛洪填充算法题目"><a href="#泛洪填充算法题目" class="headerlink" title="泛洪填充算法题目"></a>泛洪填充算法题目</h2><ul><li>「力扣」第 733 题：图像渲染（简单）<a href="https://leetcode-cn.com/problems/flood-fill/">https://leetcode-cn.com/problems/flood-fill/</a></li><li>「力扣」第 1034 题：边框着色（中等）<a href="https://leetcode-cn.com/problems/coloring-a-border">https://leetcode-cn.com/problems/coloring-a-border</a></li><li>「力扣」第 785 题：判断二分图（中等）<a href="https://leetcode-cn.com/problems/is-graph-bipartite">https://leetcode-cn.com/problems/is-graph-bipartite</a></li><li>「力扣」第 886 题：可能的二分法（中等）<a href="https://leetcode-cn.com/problems/possible-bipartition">https://leetcode-cn.com/problems/possible-bipartition</a></li><li>「力扣」第 529 题：扫雷游戏（中等）<a href="https://leetcode-cn.com/problems/minesweeper">https://leetcode-cn.com/problems/minesweeper</a></li><li>「力扣」第 200 题：岛屿数量（中等）<a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a></li><li>「力扣」第 827 题：最大人工岛（困难）<a href="https://leetcode-cn.com/problems/making-a-large-island">https://leetcode-cn.com/problems/making-a-large-island</a></li><li>「力扣」第 695 题：岛屿的最大面积（中等）<a href="https://leetcode-cn.com/problems/max-area-of-island">https://leetcode-cn.com/problems/max-area-of-island</a></li><li>「力扣」第 463 题：岛屿的周长（简单）<a href="https://leetcode-cn.com/problems/island-perimeter">https://leetcode-cn.com/problems/island-perimeter</a></li><li>「力扣」第 1254 题：统计封闭岛屿的数目（中等）<a href="https://leetcode-cn.com/problems/number-of-closed-islands">https://leetcode-cn.com/problems/number-of-closed-islands</a></li><li>「力扣」第 130 题：被围绕的区域（中等）<a href="https://leetcode-cn.com/problems/surrounded-regions">https://leetcode-cn.com/problems/surrounded-regions</a></li><li>「力扣」第 289 题：生命游戏（中等）<a href="https://leetcode-cn.com/problems/game-of-life">https://leetcode-cn.com/problems/game-of-life</a></li><li>「力扣」第 1020 题：飞地的数量（困难）<a href="https://leetcode-cn.com/problems/number-of-enclaves/">https://leetcode-cn.com/problems/number-of-enclaves/</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/wat1r/article/details/113702607">搜索与图论之 FloodFill_wat1r 的博客 - CSDN 博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;泛洪填充算法 (Flood Fill Algorithm) 泛洪填充算法又称洪水填充算法是在很多图形绘制软件中常用的填充算法，最熟悉不过就是 windows paint 的油漆桶功能。算法的原理很简单，就是从一个点开始附近像素点，填充成新的颜色，直到封闭区域内的所有像素点都被填充新颜色为止。泛红填充实现最常见有四邻域像素填充法，八邻域像素填充法，基于扫描线的像素填充方法。根据实现又可以分为递归与非递归方法，递归方法一般通过深度优先搜索进行实现，非递归方法一般通过广度优先搜索或并查集实现。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://github.hezhaojiang.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="图论" scheme="http://github.hezhaojiang.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="深度优先搜索" scheme="http://github.hezhaojiang.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="广度优先搜索" scheme="http://github.hezhaojiang.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="并查集" scheme="http://github.hezhaojiang.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>编解码技术：H264 - 去块效应滤波</title>
    <link href="http://github.hezhaojiang.io/post/2021/e059d0/"/>
    <id>http://github.hezhaojiang.io/post/2021/e059d0/</id>
    <published>2021-02-01T05:32:12.000Z</published>
    <updated>2021-02-04T16:46:01.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们知道现在的主流编码器都是使用基于块的混合编码框架，以编码块为单位进行预测、变换、量化。</p><p>这就导致不同的编码块会使用不同的编码参数，进而不同编码重建块之间的存在一定的差异，尤其在编码块边界处较为明显。编码块边界处不连续的现象就是块效应，产生这种效应的原因主要有两个：</p><ol><li>预测时出现不准的地方称为残量（<code>Residual</code>），残量会利用离散余弦变换（<code>Discrete Cosine Transform, DCT</code>）做量化（<code>Quantization</code>），由于量化与反量化会产生误差，因此会在区块边界上产生视觉上的不连续。</li><li>运动补偿，同一个画面内相邻区块可能不是从前几个编码影像中相邻区块获取来做预测，因此造成不连续的现象。同样地，画面内预测的方式也可能会造成影像不连续。</li></ol><p>这种现象在 <code>QP</code> 较大时比较明显，因此 <code>QP</code> 越大 <code>Deblocking</code> 的强度也越大。</p><p>正是由于这种块效应的存在，才需要添加环路滤波器调整相邻的块边缘上的像素值以减轻这种视觉上的不连续感。</p><a id="more"></a><p>去区块滤波器主要有三个工作，分别是边界强度计算（Boundary Strength Computation）、边界分析（Boundary Analysis）及滤波器应用（Filter Implementation）。</p><ol><li>边界强度计算：主要是去计算边界强度（Boundary Strength, Bs）这个参数，边界强度呈现出相邻区块边界不连续的程度，而这个参数会跟量化的方式、区块类型、移动向量以及边界取样的梯度有关。</li><li>边界分析：因为区块边缘不连续的现象可能真的是对象边缘所产生，并非所谓的人造边界，这个工作主要在判断是否为人造边界。</li><li>滤波器的应用：做完前面两个工作可以决定边界强度以及判断是否真的为人造边界，这个工作主要对人造边界依造对应的边界强度选择该应用的滤波器。</li></ol><h2 id="边界强度"><a href="#边界强度" class="headerlink" title="边界强度"></a>边界强度</h2><p>每一个 4x4 的亮度区块中需要做滤波的区块都会计算出一个边界强度。色度区块的边界强度是对亮度区块已经求得的边界强度做取样，如图所示：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210201230151.png" alt="色度区块的边界强度与亮度区块边界强度的关系"></p><p><code>H.264</code> 的边界强度 <code>Bs</code> 的判定方式如下：</p><div class="table-container"><table><thead><tr><th>条件（针对两边的图像块）</th><th>Bs</th></tr></thead><tbody><tr><td>若两个区块皆属于帧内预测且边界属于宏区块的边界</td><td>4</td></tr><tr><td>有一个块为帧内预测或是不在宏区块的边界上</td><td>3</td></tr><tr><td>区块的转换系数非 0</td><td>2</td></tr><tr><td>如果使用不同的参考影像或是两个区块间的移动向量大于等于 4</td><td>1</td></tr><tr><td>其它</td><td>0</td></tr></tbody></table></div><blockquote><p>《ITU-T Rec. H.264-200305》 8.7.2.1 亮度的依赖内容的边界滤波强度的推导过程</p></blockquote><p>从上表得出边界强度的判断流程如图所示：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210201231001.png" alt="边界强度的判断流程"></p><h2 id="边界分析"><a href="#边界分析" class="headerlink" title="边界分析"></a>边界分析</h2><p>并不是所有的块的边界处都需要环路滤波。例如画面中物体的边界正好和块的边界重合的话，就不能进行滤波，否则会使画面中物体的边界变模糊。因此需要区别开物体边界和块效应边界。一般情况下，物体边界两边的像素值差别很大，而块效应边界两边像素值差别比较小。</p><p>边界强度如果大于 0 则对这个边界进行分析，判断是否为人造边界。下图是利用水平滤波器对垂直边界做滤波的示意图，一行有八个点 p3、p2、p1、p0、q0、q1、q2 以及 q3，p0 及 q0 之间为两区块的边界。H.264 标准定义了 2 个变量 <code>α</code> 和 <code>β</code> 来判决边界是否需要进行环路滤波。只有满足下面条件的时候才能进行环路滤波：：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210201221354.png" alt="描述一个 4x4 块横向或者纵向边界的样点的惯例"></p><pre><code> Bs != 0|p0 - q0| &lt;α (IndexA)|p1 - p0| &lt;β (IndexA)|q1 - q0| &lt;β (IndexB)</code></pre><p>简而言之，就是边界两边的两个点的像素值不能太大，即不能超过 <code>α</code>；边界一边的前两个点之间的像素值也不能太大，即不能超过 <code>β</code>。其中 <code>α</code> 和 <code>β</code> 是根据量化参数 <code>QP</code> 推算出来（具体方法不再记录）。总体说来 <code>QP</code> 越大，<code>α</code> 和 <code>β</code> 的值也越大，也就越容易触发环路滤波。由于 <code>QP</code> 越大表明压缩的程度越大，所以也可以得知高压缩比的情况下更需要进行环路滤波。</p><p><code>α</code> 与 <code>β</code> 两个函数一般利用查表法计算值，而 <code>IndexA</code> 和 <code>IndexB</code> 计算方式如下</p><pre><code>IndexA = Min（Max(0,QP + OffsetA）, 51)IndexB = Min（Max(0,QP + OffsetB）, 51)</code></pre><p>其中 <code>OffsetA</code> 和 <code>OffsetB</code> 为编码器的参数，<code>QP</code> 为量化参数（<code>Quantization Parameter</code>）。如果上面四个条件是都成立则 <code>p0</code> 与 <code>q0</code> 之间的边界为人造边界。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们知道现在的主流编码器都是使用基于块的混合编码框架，以编码块为单位进行预测、变换、量化。&lt;/p&gt;
&lt;p&gt;这就导致不同的编码块会使用不同的编码参数，进而不同编码重建块之间的存在一定的差异，尤其在编码块边界处较为明显。编码块边界处不连续的现象就是块效应，产生这种效应的原因主要有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;预测时出现不准的地方称为残量（&lt;code&gt;Residual&lt;/code&gt;），残量会利用离散余弦变换（&lt;code&gt;Discrete Cosine Transform, DCT&lt;/code&gt;）做量化（&lt;code&gt;Quantization&lt;/code&gt;），由于量化与反量化会产生误差，因此会在区块边界上产生视觉上的不连续。&lt;/li&gt;
&lt;li&gt;运动补偿，同一个画面内相邻区块可能不是从前几个编码影像中相邻区块获取来做预测，因此造成不连续的现象。同样地，画面内预测的方式也可能会造成影像不连续。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种现象在 &lt;code&gt;QP&lt;/code&gt; 较大时比较明显，因此 &lt;code&gt;QP&lt;/code&gt; 越大 &lt;code&gt;Deblocking&lt;/code&gt; 的强度也越大。&lt;/p&gt;
&lt;p&gt;正是由于这种块效应的存在，才需要添加环路滤波器调整相邻的块边缘上的像素值以减轻这种视觉上的不连续感。&lt;/p&gt;</summary>
    
    
    
    <category term="编解码技术" scheme="http://github.hezhaojiang.io/categories/%E7%BC%96%E8%A7%A3%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="H.264" scheme="http://github.hezhaojiang.io/tags/H-264/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 x264 - 去块效应滤波</title>
    <link href="http://github.hezhaojiang.io/post/2021/10604d20/"/>
    <id>http://github.hezhaojiang.io/post/2021/10604d20/</id>
    <published>2021-02-01T05:21:10.000Z</published>
    <updated>2021-02-04T16:46:01.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>x264_deblock_init()</code> 中初始化了一系列环路滤波函数。</p><ol><li>包含 “v” 的是垂直滤波器，用于处理水平边界；包含 “h” 的是水平滤波器，用于处理垂直边界。</li><li>包含 “luma” 的是亮度滤波器，包含 “chroma” 的是色度滤波器。</li><li>包含 “intra” 的是处理边界强度 Bs 为 4 的强滤波器，不包含 “intra” 的是普通滤波器。</li></ol><a id="more"></a><p><code>x264_deblock_init</code> 函数代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_deblock_init</span><span class="params">(<span class="keyword">uint32_t</span> cpu, <span class="keyword">x264_deblock_function_t</span> *pf, <span class="keyword">int</span> b_mbaff)</span> </span>&#123;</span><br><span class="line">    pf-&gt;deblock_luma[<span class="number">1</span>] = deblock_v_luma_c;</span><br><span class="line">    pf-&gt;deblock_luma[<span class="number">0</span>] = deblock_h_luma_c;</span><br><span class="line">    pf-&gt;deblock_chroma[<span class="number">1</span>] = deblock_v_chroma_c;</span><br><span class="line">    pf-&gt;deblock_h_chroma_420 = deblock_h_chroma_c;</span><br><span class="line">    pf-&gt;deblock_h_chroma_422 = deblock_h_chroma_422_c;</span><br><span class="line">    pf-&gt;deblock_luma_intra[<span class="number">1</span>] = deblock_v_luma_intra_c;</span><br><span class="line">    pf-&gt;deblock_luma_intra[<span class="number">0</span>] = deblock_h_luma_intra_c;</span><br><span class="line">    pf-&gt;deblock_chroma_intra[<span class="number">1</span>] = deblock_v_chroma_intra_c;</span><br><span class="line">    pf-&gt;deblock_h_chroma_420_intra = deblock_h_chroma_intra_c;</span><br><span class="line">    pf-&gt;deblock_h_chroma_422_intra = deblock_h_chroma_422_intra_c;</span><br><span class="line">    pf-&gt;deblock_luma_mbaff = deblock_h_luma_mbaff_c;</span><br><span class="line">    pf-&gt;deblock_chroma_420_mbaff = deblock_h_chroma_mbaff_c;</span><br><span class="line">    pf-&gt;deblock_luma_intra_mbaff = deblock_h_luma_intra_mbaff_c;</span><br><span class="line">    pf-&gt;deblock_chroma_420_intra_mbaff = deblock_h_chroma_intra_mbaff_c;</span><br><span class="line">    pf-&gt;deblock_strength = deblock_strength_c;</span><br><span class="line">    <span class="comment">/* 此处省略大量平台的汇编函数初始化代码 */</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环路滤波分类"><a href="#环路滤波分类" class="headerlink" title="环路滤波分类"></a>环路滤波分类</h2><p>环路滤波器根据滤波的强度可以分为两种：</p><ol><li>普通滤波器。针对边界的 <code>Bs</code>（边界强度）为 1、2、3 的滤波器。</li><li>强滤波器。针对边界的 <code>Bs</code>（边界强度）为 4 的滤波器。</li></ol><h3 id="普通滤波器"><a href="#普通滤波器" class="headerlink" title="普通滤波器"></a>普通滤波器</h3><p>此时环路滤波涉及到方块边界周围的 6 个点（边界两边各 3 个点）：$p2,p1,p0,q0,q1,q2$<br>需要处理 4 个点（边界两边各 2 个点，只以 p 侧的点为例）：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210201221354.png" alt="描述一个 4x4 块横向或者纵向边界的样点的惯例"></p><pre><code>p0&#39; = p0 + (((q0 - p0) &lt;&lt; 2) + (p1 - q1) + 4) &gt;&gt; 3p1&#39; = (p2 + ( ( p0 + q0 + 1) &gt;&gt; 1) – 2p1 ) &gt;&gt; 1</code></pre><h3 id="强滤波器"><a href="#强滤波器" class="headerlink" title="强滤波器"></a>强滤波器</h3><p>此时环路滤波涉及到方块边界周围的 8 个点（边界两边各 4 个点）：$p3,p2,p1,p0,q0,q1,q2,q3$<br>需要处理 6 个点（边界两边各 3 个点，只以 p 侧的点为例）：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210201221354.png" alt="描述一个 4x4 块横向或者纵向边界的样点的惯例"></p><pre><code>p0&#39; = (p2 + 2*p1 + 2*p0 + 2*q0 + q1 + 4) &gt;&gt; 3p1&#39; = (p2 + p1 + p0 + q0 + 2) &gt;&gt; 2p2&#39; = (2*p3 + 3*p2 + p1 + p0 + q0 + 4) &gt;&gt; 3</code></pre><blockquote><p>边界强度的计算和边界分析方法详见：<a href="/post/2021/e059d0/" title="编解码技术：H264 - 去块效应滤波">编解码技术：H264 - 去块效应滤波</a></p></blockquote><h2 id="普通滤波函数"><a href="#普通滤波函数" class="headerlink" title="普通滤波函数"></a>普通滤波函数</h2><h3 id="deblock-v-luma-c"><a href="#deblock-v-luma-c" class="headerlink" title="deblock_v_luma_c"></a>deblock_v_luma_c</h3><p><code>deblock_v_luma_c()</code> 是一个普通强度的垂直滤波器，用于处理边界强度 <code>Bs</code> 为 1，2，3 的水平边界。该函数的定义位于 <code>common/deblock.c</code>，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 去块效应滤波 - 普通滤波，Bs 为 1,2,3</span></span><br><span class="line"><span class="comment"> * 垂直 Vertical 滤波器</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> * 边界 ==========</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deblock_v_luma_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> stride, <span class="keyword">int</span> `alpha`, <span class="keyword">int</span> beta, <span class="keyword">int8_t</span> *tc0)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// xstride = stride（用于选择滤波的像素）</span></span><br><span class="line">    <span class="comment">// ystride = 1</span></span><br><span class="line">    deblock_luma_c(pix, stride, <span class="number">1</span>, alpha, beta, tc0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>deblock_v_luma_c()</code> 调用了另一个函数 <code>deblock_luma_c()</code>。需要注意传递给 <code>deblock_luma_c()</code> 是一个水平滤波器和垂直滤波器都会调用的通用滤波器函数。在这里传递给 <code>deblock_luma_c()</code> 第二个参数 <code>xstride</code> 的值为 <code>stride</code>，第三个参数 <code>ystride</code> 的值为 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deblock_luma_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> xstride, <span class="keyword">intptr_t</span> ystride, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta, <span class="keyword">int8_t</span> *tc0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tc0[i] &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">            pix += <span class="number">4</span>*ystride;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++, pix += ystride)</span><br><span class="line">            deblock_edge_luma_c(pix, xstride, alpha, beta, tc0[i] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的滤波在 <code>deblock_edge_luma_c()</code> 中完成。处理完一个像素后，会继续处理与当前像素距离为 <code>ystride</code> 的像素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deblock_edge_luma_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> xstride, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta, <span class="keyword">int8_t</span> tc0)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * p 和 q</span></span><br><span class="line"><span class="comment">     * 如果 xstride = stride，ystride = 1</span></span><br><span class="line"><span class="comment">     * 就是处理纵向的 6 个像素</span></span><br><span class="line"><span class="comment">     * 对应的是方块的横向边界的滤波，即如下所示：</span></span><br><span class="line"><span class="comment">     *         p2</span></span><br><span class="line"><span class="comment">     *         p1</span></span><br><span class="line"><span class="comment">     *         p0</span></span><br><span class="line"><span class="comment">     * ===== 图像边界 =====</span></span><br><span class="line"><span class="comment">     *         q0</span></span><br><span class="line"><span class="comment">     *         q1</span></span><br><span class="line"><span class="comment">     *         q2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果 xstride = 1，ystride = stride</span></span><br><span class="line"><span class="comment">     * 就是处理纵向的 6 个像素</span></span><br><span class="line"><span class="comment">     * 对应的是方块的横向边界的滤波，即如下所示：</span></span><br><span class="line"><span class="comment">     *           ||</span></span><br><span class="line"><span class="comment">     *  p2 p1 p0 || q0 q1 q2</span></span><br><span class="line"><span class="comment">     *           ||</span></span><br><span class="line"><span class="comment">     *          边界</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：这里乘的是 xstride</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> p2 = pix[<span class="number">-3</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> p1 = pix[<span class="number">-2</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> p0 = pix[<span class="number">-1</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> q0 = pix[<span class="number">0</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> q1 = pix[<span class="number">1</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> q2 = pix[<span class="number">2</span>*xstride];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方法参考相关的标准</span></span><br><span class="line">    <span class="comment">// alpha 和 beta 是用于检查图像内容的 2 个参数</span></span><br><span class="line">    <span class="comment">// 只有满足 if() 里面 3 个取值条件的时候（只涉及边界旁边的 4 个点），才会滤波</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>( p0 - q0) &lt; alpha &amp;&amp; <span class="built_in">abs</span>( p1 - p0 ) &lt; beta &amp;&amp; <span class="built_in">abs</span>( q1 - q0 ) &lt; beta ) &#123;</span><br><span class="line">        <span class="keyword">int</span> tc = tc0;</span><br><span class="line">        <span class="keyword">int</span> delta;</span><br><span class="line">        <span class="comment">// 上面 2 个点（p0，p2）满足条件的时候，滤波 p1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>( p2 - p0) &lt; beta ) &#123;</span><br><span class="line">            <span class="comment">// p1&#x27; = (p2 + ( ( p0 + q0 + 1) &gt;&gt; 1) – 2p1 ) &gt;&gt; 1</span></span><br><span class="line">            <span class="comment">//     = (p2 + ( ( p0 + q0 + 1) &gt;&gt; 1)) &gt;&gt; 1 - p1</span></span><br><span class="line">            <span class="keyword">if</span> (tc0) pix[<span class="number">-2</span>*xstride] = p1 + x264_clip3( (( p2 + ((p0 + q0 + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>)) &gt;&gt; <span class="number">1</span>) - p1, -tc0, tc0 );</span><br><span class="line">            tc++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面 2 个点（q0，q2）满足条件的时候，滤波 q1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>( q2 - q0) &lt; beta ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tc0) pix[<span class="number">1</span>*xstride] = q1 + x264_clip3( (( q2 + ((p0 + q0 + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>)) &gt;&gt; <span class="number">1</span>) - q1, -tc0, tc0 );</span><br><span class="line">            tc++;</span><br><span class="line">        &#125;</span><br><span class="line">        delta = x264_clip3((((q0 - p0) &lt;&lt; <span class="number">2</span>) + (p1 - q1) + <span class="number">4</span>) &gt;&gt; <span class="number">3</span>, -tc, tc );</span><br><span class="line">        <span class="comment">// p0&#x27; = p0 + (((q0 - p0) &lt;&lt; 2) + (p1 - q1) + 4) &gt;&gt; 3</span></span><br><span class="line">        pix[<span class="number">-1</span>*xstride] = x264_clip_pixel( p0 + delta );    <span class="comment">/* p0&#x27; */</span></span><br><span class="line">        pix[<span class="number">0</span>*xstride] = x264_clip_pixel( q0 - delta );     <span class="comment">/* q0&#x27; */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">x264_clip3</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> i_min, <span class="keyword">int</span> i_max)</span> </span>&#123;   <span class="comment">// 将 v 限制在 i_min 和 i_max 之间</span></span><br><span class="line">    <span class="keyword">return</span> ((v &lt; i_min) ? i_min : (v &gt; i_max) ? i_max : v );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> pixel <span class="title">x264_clip_pixel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;                  <span class="comment">// 将 x 限制在 0 和 255 之间</span></span><br><span class="line">    <span class="keyword">return</span> ((x &amp; ~PIXEL_MAX) ? (-x)&gt;&gt;<span class="number">31</span> &amp; PIXEL_MAX : x );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deblock-h-luma-c"><a href="#deblock-h-luma-c" class="headerlink" title="deblock_h_luma_c"></a>deblock_h_luma_c</h3><p><code>deblock_h_luma_c()</code> 是一个普通强度的水平滤波器，用于处理边界强度 <code>Bs</code> 为 1，2，3 的垂直边界。该函数的定义如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 去块效应滤波 - 普通滤波，Bs 为 1,2,3</span></span><br><span class="line"><span class="comment"> * 水平 Horizontal 滤波器</span></span><br><span class="line"><span class="comment"> *      边界</span></span><br><span class="line"><span class="comment"> *       ||</span></span><br><span class="line"><span class="comment"> * x x x || x x x</span></span><br><span class="line"><span class="comment"> *       ||</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deblock_h_luma_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> stride, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta, <span class="keyword">int8_t</span> *tc0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// xstride = 1（用于选择滤波的像素）</span></span><br><span class="line">    <span class="comment">// ystride = stride</span></span><br><span class="line">    deblock_luma_c(pix, <span class="number">1</span>, stride, alpha, beta, tc0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>deblock_v_luma_c()</code> 类似，<code>deblock_h_luma_c()</code> 同样调用了 <code>deblock_luma_c()</code> 函数。唯一的不同在于它传递给 <code>deblock_luma_c()</code> 的第 2 个参数 <code>xstride</code> 为 1，第 3 个参数 <code>ystride</code> 为 <code>stride</code>。</p><h2 id="强滤波函数"><a href="#强滤波函数" class="headerlink" title="强滤波函数"></a>强滤波函数</h2><h3 id="deblock-v-luma-intra-c"><a href="#deblock-v-luma-intra-c" class="headerlink" title="deblock_v_luma_intra_c"></a>deblock_v_luma_intra_c</h3><p><code>deblock_v_luma_intra_c()</code> 是一个强滤波的垂直滤波器，用于处理边界强度 <code>Bs</code> 为 4 的水平边界。该函数的定义位于 <code>common/deblock.c</code>，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 垂直 Vertical 强滤波器 - Bs 为 4</span></span><br><span class="line"><span class="comment"> *        边界</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> * 边界 ----------</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deblock_v_luma_intra_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> stride, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">    <span class="comment">// xstride = stride</span></span><br><span class="line">    <span class="comment">// ystride = 1</span></span><br><span class="line">    <span class="comment">// 处理完 1 个像素点之后，pix 增加 ystride</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 水平滤波和垂直滤波通用的强滤波函数</span></span><br><span class="line">    deblock_luma_intra_c(pix, stride, <span class="number">1</span>, alpha, beta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>deblock_v_luma_intra_c()</code> 调用了另一个函数 <code>deblock_luma_intra_c()</code>。需要注意 <code>deblock_luma_intra_c()</code> 是一个水平滤波器和垂直滤波器都会调用的通用滤波器函数。在这里传递给 <code>deblock_luma_intra_c()</code> 第二个参数 <code>xstride</code> 的值为 <code>stride</code>，第三个参数 <code>ystride</code> 的值为 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 水平滤波和垂直滤波通用的强滤波函数 - Bs 为 4</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deblock_luma_intra_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> xstride, <span class="keyword">intptr_t</span> ystride, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环处理 16 个点</span></span><br><span class="line">    <span class="comment">// 处理完 1 个像素点之后，pix 增加 ystride</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">16</span>; d++, pix += ystride)</span><br><span class="line">        <span class="comment">// 每次处理 1 个点</span></span><br><span class="line">        deblock_edge_luma_intra_c(pix, xstride, alpha, beta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的滤波在 <code>deblock_edge_luma_intra_c()</code> 中完成。处理完一个像素后，会继续处理与当前像素距离为 <code>ystride</code> 的像素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 水平滤波和垂直滤波通用的强滤波函数 - 处理 1 个点 - Bs 为 4</span></span><br><span class="line"><span class="comment">// 注意涉及到 8 个像素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deblock_edge_luma_intra_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> xstride, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 xstride = stride，ystride = 1</span></span><br><span class="line"><span class="comment">     * 就是处理纵向的 6 个像素</span></span><br><span class="line"><span class="comment">     * 对应的是方块的横向边界的滤波。如下所示：</span></span><br><span class="line"><span class="comment">     *         p2</span></span><br><span class="line"><span class="comment">     *         p1</span></span><br><span class="line"><span class="comment">     *         p0</span></span><br><span class="line"><span class="comment">     * ===== 图像边界 =====</span></span><br><span class="line"><span class="comment">     *         q0</span></span><br><span class="line"><span class="comment">     *         q1</span></span><br><span class="line"><span class="comment">     *         q2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果 xstride = 1，ystride = stride</span></span><br><span class="line"><span class="comment">     * 就是处理纵向的 6 个像素</span></span><br><span class="line"><span class="comment">     * 对应的是方块的横向边界的滤波，即如下所示：</span></span><br><span class="line"><span class="comment">     *           ||</span></span><br><span class="line"><span class="comment">     *  p2 p1 p0 || q0 q1 q2</span></span><br><span class="line"><span class="comment">     *           ||</span></span><br><span class="line"><span class="comment">     *          边界</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 注意：这里乘的是 xstride</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> p2 = pix[<span class="number">-3</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> p1 = pix[<span class="number">-2</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> p0 = pix[<span class="number">-1</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> q0 = pix[<span class="number">0</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> q1 = pix[<span class="number">1</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> q2 = pix[<span class="number">2</span>*xstride];</span><br><span class="line">    <span class="comment">// 满足条件的时候，才滤波</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>( p0 - q0) &lt; alpha &amp;&amp; <span class="built_in">abs</span>( p1 - p0 ) &lt; beta &amp;&amp; <span class="built_in">abs</span>( q1 - q0 ) &lt; beta ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>( p0 - q0) &lt; ((alpha &gt;&gt; <span class="number">2</span>) + <span class="number">2</span>) ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>( p2 - p0) &lt; beta ) <span class="comment">/* p0&#x27;, p1&#x27;, p2&#x27; */</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> p3 = pix[<span class="number">-4</span>*xstride];</span><br><span class="line">                <span class="comment">// p0&#x27; = (p2 + 2*p1 + 2*p0 + 2*q0 + q1 + 4) &gt;&gt; 3</span></span><br><span class="line">                pix[<span class="number">-1</span>*xstride] = ( p2 + <span class="number">2</span>*p1 + <span class="number">2</span>*p0 + <span class="number">2</span>*q0 + q1 + <span class="number">4</span> ) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">                <span class="comment">// p1&#x27; = (p2 + p1 + p0 + q0 + 2) &gt;&gt; 2</span></span><br><span class="line">                pix[<span class="number">-2</span>*xstride] = ( p2 + p1 + p0 + q0 + <span class="number">2</span> ) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// p2&#x27; = (2*p3 + 3*p2 + p1 + p0 + q0 + 4) &gt;&gt; 3</span></span><br><span class="line">                pix[<span class="number">-3</span>*xstride] = ( <span class="number">2</span>*p3 + <span class="number">3</span>*p2 + p1 + p0 + q0 + <span class="number">4</span> ) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">/* p0&#x27; */</span> pix[<span class="number">-1</span>*xstride] = ( <span class="number">2</span>*p1 + p0 + q1 + <span class="number">2</span> ) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>( q2 - q0) &lt; beta ) <span class="comment">/* q0&#x27;, q1&#x27;, q2&#x27; */</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> q3 = pix[<span class="number">3</span>*xstride];</span><br><span class="line">                pix[<span class="number">0</span>*xstride] = ( p1 + <span class="number">2</span>*p0 + <span class="number">2</span>*q0 + <span class="number">2</span>*q1 + q2 + <span class="number">4</span> ) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">                pix[<span class="number">1</span>*xstride] = ( p0 + q0 + q1 + q2 + <span class="number">2</span> ) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">                pix[<span class="number">2</span>*xstride] = ( <span class="number">2</span>*q3 + <span class="number">3</span>*q2 + q1 + q0 + p0 + <span class="number">4</span> ) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">/* q0&#x27; */</span> pix[<span class="number">0</span>*xstride] = ( <span class="number">2</span>*q1 + q0 + p1 + <span class="number">2</span> ) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">/* p0&#x27;, q0&#x27; */</span> &#123;</span><br><span class="line">            pix[<span class="number">-1</span>*xstride] = ( <span class="number">2</span>*p1 + p0 + q1 + <span class="number">2</span> ) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">            pix[<span class="number">0</span>*xstride] = ( <span class="number">2</span>*q1 + q0 + p1 + <span class="number">2</span> ) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li><li>[2] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45870269">x264 源代码简单分析：滤波（Filter）部分 雷霄骅的专栏 - CSDN 博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;x264_deblock_init()&lt;/code&gt; 中初始化了一系列环路滤波函数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;包含 “v” 的是垂直滤波器，用于处理水平边界；包含 “h” 的是水平滤波器，用于处理垂直边界。&lt;/li&gt;
&lt;li&gt;包含 “luma” 的是亮度滤波器，包含 “chroma” 的是色度滤波器。&lt;/li&gt;
&lt;li&gt;包含 “intra” 的是处理边界强度 Bs 为 4 的强滤波器，不包含 “intra” 的是普通滤波器。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="x264" scheme="http://github.hezhaojiang.io/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - 手写 H264 编码器</title>
    <link href="http://github.hezhaojiang.io/post/2021/6db02507/"/>
    <id>http://github.hezhaojiang.io/post/2021/6db02507/</id>
    <published>2021-01-30T02:58:31.000Z</published>
    <updated>2021-01-30T13:00:23.709Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[转载] <a href="https://blog.csdn.net/u012165769/article/details/107700527">深入讲解音视频编码原理，H264 码流详解——手写 H264 编码器_黎程雨的博客 - CSDN 博客</a></p><p>要彻底理解视频编码原理，看书都是虚的，需要实际动手，实现一个简单的视频编码器：</p><p>知识准备：基本图像处理知识，信号的时域和频域问题，熟练掌握傅立叶正反变换，一维、二维傅立叶变换，以及其变种，<code>dct</code> 变换，快速 <code>dct</code> 变换。</p><a id="more"></a><h3 id="第一步：实现有损图像压缩和解压"><a href="#第一步：实现有损图像压缩和解压" class="headerlink" title="第一步：实现有损图像压缩和解压"></a>第一步：实现有损图像压缩和解压</h3><p>参考 <code>JPEG</code> 原理，将 <code>RGB-&gt;YUV</code>，然后将 <code>Y/U/V</code> 看成三张不同的图片，将其中一张图片分为 8x8 的 <code>block</code> 进行 <code>dct</code> 变换（可以直接进行二维 <code>dct</code> 变换，或者按一定顺序将 8x8 的二维数组整理成一个 64 字节的一维数组），还是得到一个 8x8 的整数频率数据。于是表示图像大轮廓的低频信号（人眼敏感的信号）集中在 8x8 的左上角；表示图像细节的高频信号集中在右下角。</p><p>接着将其量化，所谓量化，就是信号采样的步长，8x8 的整数频率数据块，每个数据都要除以对应位置的步长，左上角相对重要的低频信号步长是 1，也就是说 0-255，是多少就是多少。而右下角是不太重要的高频信号，比如步长取 10，那么这些位置的数据都要 / 10，实际解码的时候再将他们 × 10 恢复出来，这样经过编码的时候 / 10 和解码的时候 × 10，那么步长为 10 的信号 1, 13, 25, 37 就会变成规矩的：0, 10, 20, 30, 对小于步长 10 的部分我们直接丢弃了，因为高频不太重要。</p><p>经过量化以后，8x8 的数据块左上角的数据由于步长小，都是比较离散的，而靠近右下角的高频数据，都比较统一，或者是一串 0，因此图像大量的细节被我们丢弃了，这时候，我们用无损压缩方式，比如 <code>lzma2</code> 算法（<code>jpeg</code> 是 <code>rle + huffman</code>）将这 64 个 <code>byte</code> 压缩起来，由于后面高频数据步长大，做了除法以后，这些值都比较小，而且比较靠近，甚至右下部分都是一串 0，十分便于压缩。</p><p><code>JPEG</code> 图像有个问题就是低码率时 <code>block</code> 边界比较严重，现代图片压缩技术往往要配合一些 <code>de-block</code> 算法，比如最简单的就是边界部分几个像素点和周围插值模糊一下。</p><blockquote><p>做到这里我们实现了一个同 <code>jpeg</code> 类似的静态图片有损压缩算法。在视频里面用来保存 I 帧数据。</p></blockquote><h3 id="2-1-2-第二步：实现宏块误差计算"><a href="#2-1-2-第二步：实现宏块误差计算" class="headerlink" title="2.1.2 第二步：实现宏块误差计算"></a>2.1.2 第二步：实现宏块误差计算</h3><p>视频由连续的若干图像帧组成，分为 I 帧，P 帧，所谓 I 帧，就是不依赖就可以独立解码的视频图像帧，而 P 帧则需要依赖前面已解码的视频帧，配合一定数据才能生成出来。所以视频中 I 帧往往都比较大，而 P 帧比较小，如果播放器一开始收到了 P 帧那么是无法播放的，只有收到下一个 I 帧才能开始播放。I 帧多了视频就变大，I 帧少了，数据量是小了，但视频受到丢包或者数据错误的影响却又会更严重。</p><p>那么所谓运动预测编码，其实就是 P 帧的生成过程：继续将图片分成 16x16 的 <code>block</code>（为了简单只讨论 yuv 的 y 分量压缩）。I 帧内部单帧图片压缩我们采用了 8x8 的 <code>block</code>，而这里用 16x16 的 <code>block</code> 来提高帧间编码压缩率（当然也会有更多细节损失），我们用 <code>x</code>,<code>y</code> 表示像素点坐标，而 <code>s</code>,<code>t</code> 表示 <code>block</code> 坐标，那么坐标为（x,y）的像素点所属的 <code>block</code> 坐标为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = x / <span class="number">16</span> = x &gt;&gt; <span class="number">4</span></span><br><span class="line">t = y / <span class="number">16</span> = y &gt;&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure><p>接着要计算两个 <code>block</code> 的相似度，即矢量的距离，可以表示为一个 256 维矢量（16x16）像素点色彩距离的平方，我们先定义两个颜色的误差为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PixelDiff(c1, c2) = (c1- c2) ^ 2</span><br></pre></td></tr></table></figure><p>那么 256 个点的误差可以表示为所有对应点的像素误差和：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockDiff(b1, b2) = sum( PixelDiff(c1, c2) for c1 in b1 for c2 in b2)</span><br></pre></td></tr></table></figure><p>代码化为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">block_diff</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> b1[<span class="number">16</span>][<span class="number">16</span>], <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> b2[<span class="number">16</span>][<span class="number">16</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">              <span class="keyword">int</span> c1 = b1[i][j];</span><br><span class="line">              <span class="keyword">int</span> c2 = b2[i][j];</span><br><span class="line">              sum += (c1 - c2) * (c1 - c2);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个 <code>block</code> 求差的函数，我们就可以针对特定 block，搜索另外若干个 <code>block</code> 中哪个和它最相似了（误差最小）。</p><h4 id="第三步：实现运动预测编码"><a href="#第三步：实现运动预测编码" class="headerlink" title="第三步：实现运动预测编码"></a>第三步：实现运动预测编码</h4><p>根据上面的宏块比较函数，你已经可以知道两个 <code>block</code> 到底像不像了，越象的 <code>block</code>，<code>block_diff</code> 返回值越低。那么我们有两帧相邻的图片，P1，P2，假设 P1 已经完成编码了，现在要对 P2 进行 P 帧编码，其实就是轮询 P2 里面的每一个 <code>block</code>，为 P2 中每一个 <code>block</code> 找出上一帧中相似度最高的 <code>block</code> 坐标，并记录下来，具体伪代码可以表示为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> block[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= maxt; t++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= maxs; s++) &#123;</span><br><span class="line">         picture_get_block(P2, s * <span class="number">16</span>, t * <span class="number">16</span>, block); <span class="comment">// 取得图片 P2 的 block</span></span><br><span class="line">         <span class="keyword">int</span> x, y;</span><br><span class="line">         block_search_nearest(P1, &amp;x, &amp;y, block); <span class="comment">// 在 P1 中搜索最相似的 block</span></span><br><span class="line">         output(x, y);  <span class="comment">// 将 P1 中最相似的 block 的左上角像素坐标 (x, y) 输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中在 P1 中搜索最相似 <code>block</code> 的 <code>block_search_nearest</code> 函数原理是比较简单的，我们可以暴力点用两个 <code>for</code> 循环轮询 P1 中每个像素点开始的 16x16 的 <code>block</code>（速度较慢），当然实际中不可能这么暴力搜索，而是围绕 P2 中该 <code>block</code> 对应坐标在 P1 中位置作为中心，慢慢四周扩散，搜索一定步长，并得到一个 ：按照一定顺序进行搜索，并且在一定范围内最相似的宏块坐标。</p><blockquote><p>于是 P2 进行运动预测编码的结果就是一大堆 <code>(x,y)</code> 的坐标，代表 P2 上每个 <code>block</code> 在上一帧 P1 里面最相似的 <code>block</code> 的位置。反过来说可能更容易理解，我们可以把第三步整个过程定义为：</p><p>怎么用若干 P1 里不同起始位置的 <code>block</code> 拼凑出图片 P2 来，使得拼凑以后的结果和 P2 最像。</p></blockquote><h3 id="第四步：实现-P-帧编码"><a href="#第四步：实现-P-帧编码" class="headerlink" title="第四步：实现 P 帧编码"></a>第四步：实现 P 帧编码</h3><p>拼凑的结果就是一系列 <code>(x,y)</code> 的坐标数据，我们继续用 <code>lzma2</code> 将它们先压缩起来，按照 <code>vcd</code> 的分辨率</p><p><code>352 x 240</code>，我们横向需要 <code>352 / 16 = 22</code> 个 <code>block</code>，纵向需要 <code>240 / 16 = 15</code> 个 <code>block</code>，可以用 P1 中 <code>22 x 15 = 330</code></p><p>个 <code>block</code> 的坐标信息生成一张和 P2 很类似的图片 P2’ ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">15</span>; t++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">22</span>; s++, next++) &#123;</span><br><span class="line">         <span class="keyword">int</span> x = block_positions[next].x;   <span class="comment">// 取得对应 P1 上的 block 像素位置 x</span></span><br><span class="line">         <span class="keyword">int</span> y = block_positions[next].y;   <span class="comment">// 取得对应 P1 上的 block 像素位置 y</span></span><br><span class="line">         <span class="comment">// 将 P1 位置 (x,y) 开始的 16 x 16 的图块拷贝到 P2&#x27;的 (s * 16, t * 16) 处</span></span><br><span class="line">         CopyRect(P2<span class="number">&#x27;</span>, s * <span class="number">16</span>, t * <span class="number">16</span>, P1, x, y, <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把用来生成 P2 的 P1 称为 P2 的参考帧，再把刚才那一堆 P1 内用来拼成 P2 的 block 坐标称为「运动矢量」，这是 P 帧里面最主要的数据内容。但是此时由 P1 和这些坐标数据拼凑出来的 P2，你会发现粗看和 P2 很象，但细看会发现有些支离破碎，并且边缘比较明显，怎么办呢？我们需要第四步。</p><h3 id="第五步：实现-P-帧编码"><a href="#第五步：实现-P-帧编码" class="headerlink" title="第五步：实现 P 帧编码"></a>第五步：实现 P 帧编码</h3><p>有了刚才的运动预测矢量（一堆 <code>block</code> 的坐标），我们先用 P1 按照这些数据拼凑出一张类似 P2 的新图片叫做 P2’，然后同 P2 上每个像素做减法，得到一张保存 <code>differ</code> 的图片：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D2 = (P2 - P2<span class="number">&#x27;</span>) / <span class="number">2</span></span><br></pre></td></tr></table></figure><p>误差图片 D2 上每一个点等于 P2 上对应位置的点的颜色减去 P2’上对应位置的点的颜色再除以 2，用 8 位表示差值，值是循环的，比如 - 2 就是 255，这里一般可以在结果上 + 0x80，即 128 代表 0，129 代表 2，127 代表 - 2。继续用一个 8 位的整数可以表示 [-254, 254] 之间的误差范围，步长精度是 2。</p><p>按照第三步实现的逻辑，P2’其实已经很像 P2 了，只是有些误差，我们将这些误差保存成了图片 D2，所以图片 D2 中，信息量其实已经很小了，都是些细节修善，比起直接保存一张完整图片熵要低很多的。所以我们将 D2 用类似第一步提到的有损图片压缩方法进行编码，得到最终的 P 帧数据：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Encode(P2) = Lzma2(block_positions) + 有损图像编码（D2）</span><br></pre></td></tr></table></figure><p>具体在操作的时候，D2 的图像块可以用 16x16 进行有损编码，因为前面的运动预测数据是按 16x16 的宏块搜索的，而不用象 I 帧那样精确的用 8x8 表示，同时保存误差图时，量化的精度可以更粗一些用不着象 I 帧那么精确，可以理解成用质量更低的 <code>JPEG</code> 编码，按照 16x16 的块进行编码，加上误差图 D2 本来信息量就不高，这样的保存方式能够节省不少空间。</p><p>​</p><h3 id="第六步：实现-GOP-生成"><a href="#第六步：实现-GOP-生成" class="headerlink" title="第六步：实现 GOP 生成"></a>第六步：实现 GOP 生成</h3><p>通过前面的代码，我们实现了 I 帧编码和 P 帧编码，P 帧是参考 P1 对 P2 进行编码，而所谓 B 帧，就是参考 P1 和 P3 对 P2 进行编码，当然间隔不一定是 1，比如可以是参考 P1 和 P5 对 P2 进行编码，前提条件是 P5 可以依赖 P1 及以前的数据进行解码。</p><p>不过对于一个完整的简版视频编码器，I 帧和 P 帧编码已经够了，市面上任然有很多面向低延迟的商用编码器是直接干掉 B 帧的，因为做实时传输时收到 B 帧没法播放，之后再往后好几帧收到下一个 I 或者 P 帧时，先前收到的 B 帧才能被解码出来，造成不少的延迟。</p><p>而所谓的 <code>GOP</code> (<code>Group of picture</code>) 就是由一系列类似 I, P, B, B, P, B, B, P, B, B P 组成的一个可以完整被解码出来的图像组，而所谓视频文件，就是一个接一个的 <code>GOP</code>，每个 <code>GOP</code> 由一个 I 帧开头，然后接下来一组连续的 P 或者 B 构成，播放时只有完整收到下一个 <code>GOP</code> 的 I 帧才能开始播放。</p><p>最后是关于参考帧选择，前面提到的 P2 生成过程是参考了 P1，假设一个 <code>GOP</code> 中十张图片，是 I1, P1, P2, P3, P4, … P9 保存的，如果 P1 参考 I1，P2 参考 P1, P3 参考 P2 …. P9 参考 P8 这样每一个 P 帧都是参考上一帧进行编码的话，误差容易越来越大，因为 P1 已经引入一定误差了，P2 在 P1 的基础上误差更大，到了 P9 的话，图片质量可能已经没法看了。</p><p>因此正确的参考帧选择往往不需要这样死板，比如可以 P1-P9 全部参考 I1 来生成，或者，P1-P4 参考 I1 来生成，而 P5-P9 则参考 P5 来生成，这样步子小点，误差也不算太离谱。</p><h3 id="第七步：容器组装"><a href="#第七步：容器组装" class="headerlink" title="第七步：容器组装"></a>第七步：容器组装</h3><p>我们生成了一组组编码过的 <code>GOP</code> 了，这时候需要一定的文件格式将他们恰当的保存下来，记录视频信息，比如分辨率，帧率，时间索引等，就是一个类似 <code>MP4</code>（<code>h.264</code> 的容器）文件的东西。至此一个简单的小型编码器我们已经完成了，可以用 <code>SDL</code> / <code>DirectX</code> / <code>OpenGL</code> 配合实现一个播放器，愉快的将自己编码器编码的视频播放出来。</p><h3 id="第八步：优化改进"><a href="#第八步：优化改进" class="headerlink" title="第八步：优化改进"></a>第八步：优化改进</h3><p>这时候你已经大概学习并掌握了视频编码的基础原理了，接下来大量的优化改进的坑等着你去填呢。优化有两大方向，编码效率优化和编码性能优化：前者追求同质量（同信噪比）下更低的码率，后者追求同样质量和码率的情况下，更快的编码速度。</p><p>有这个基础后接下来可以回过头去看 <code>JPEG</code> 标准，<code>MPEG1-2</code> 标准，并阅读相关实现代码，你会发现简单很多了，接着肯 <code>H.264</code> 代码，不用全部看可以针对性的了解以下 <code>H.264</code> 的 I 帧编码和各种搜索预测方法，有 <code>H.264</code> 的底子，你了解 <code>HEVC</code> 和 <code>vpx</code> 就比较容易了。</p><p>参考这些编码器一些有意思的实现来改进自己的编码器，试验性质，可以侧重原理，各种优化技巧了解下即可，本来就是 <code>hack</code> 性质的。</p><blockquote><p>有卯用呢？首先肯定很好玩，其次，当你有需要使用并修改这些编码器为他们增加新特性的时候，你会发现前面的知识很管用了。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;[转载] &lt;a href=&quot;https://blog.csdn.net/u012165769/article/details/107700527&quot;&gt;深入讲解音视频编码原理，H264 码流详解——手写 H264 编码器_黎程雨的博客 - CSDN 博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要彻底理解视频编码原理，看书都是虚的，需要实际动手，实现一个简单的视频编码器：&lt;/p&gt;
&lt;p&gt;知识准备：基本图像处理知识，信号的时域和频域问题，熟练掌握傅立叶正反变换，一维、二维傅立叶变换，以及其变种，&lt;code&gt;dct&lt;/code&gt; 变换，快速 &lt;code&gt;dct&lt;/code&gt; 变换。&lt;/p&gt;</summary>
    
    
    
    <category term="音视频日记" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="H.264" scheme="http://github.hezhaojiang.io/tags/H-264/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 x264 - 量化</title>
    <link href="http://github.hezhaojiang.io/post/2021/6f5ffb09/"/>
    <id>http://github.hezhaojiang.io/post/2021/6f5ffb09/</id>
    <published>2021-01-28T07:50:47.000Z</published>
    <updated>2021-04-11T14:11:42.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>x264</code> 中 <code>x264_quant_init</code> 函数中初始化了量化有关的函数，本文分析部分量化函数的实现</p><a id="more"></a><p>量化是 <code>H.264</code> 视频压缩编码中对视频质量影响最大的地方，也是会导致信息丢失的地方。量化的原理可以表示为下面公式：</p><script type="math/tex; mode=display">FQ = round(y / Qstep)</script><p>其中:</p><ul><li>$y$ 为输入样本点编码</li><li>$Qstep$ 为量化步长</li><li>$FQ$ 为 $y$ 的量化值</li><li>$round()$ 为取整函数（其输出为与输入实数最近的整数）</li></ul><p>其相反过程，即反量化为：</p><script type="math/tex; mode=display">y' = FQ \times Qstep</script><p>如果 <code>Qstep</code> 较大，则量化值 <code>FQ</code> 取值较小，其相应的编码长度较小，但是但反量化时损失较多的图像细节信息。简而言之，<code>Qstep</code> 越大，视频压缩编码后体积越小，视频质量越差。</p><p>在 <code>H.264</code> 中，量化步长 <code>Qstep</code> 共有 <code>52</code> 个值，如下表所示。其中 <code>QP</code> 是量化参数，是量化步长的序号。当 <code>QP</code> 取最小值 0 时代表最精细的量化，当 <code>QP</code> 取最大值 51 时代表最粗糙的量化。<code>QP</code> 每增加 6，<code>Qstep</code> 增加一倍。</p><h3 id="x264-quant-init"><a href="#x264-quant-init" class="headerlink" title="x264_quant_init"></a>x264_quant_init</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_quant_init</span><span class="params">(<span class="keyword">x264_t</span> *h, <span class="keyword">uint32_t</span> cpu, <span class="keyword">x264_quant_function_t</span> *pf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pf-&gt;quant_8x8 = quant_8x8;                              <span class="comment">// 针对 8x8DCT 的量化</span></span><br><span class="line">    pf-&gt;quant_4x4 = quant_4x4;                              <span class="comment">// 量化 4x4=16 个</span></span><br><span class="line">    pf-&gt;quant_4x4x4 = quant_4x4x4;                          <span class="comment">// 处理 4 个 4x4 的块</span></span><br><span class="line">    <span class="comment">//Intra16x16 中，16 个 DC 系数 Hadamard 变换后对的它们量化</span></span><br><span class="line">    pf-&gt;quant_4x4_dc = quant_4x4_dc;</span><br><span class="line">    pf-&gt;quant_2x2_dc = quant_2x2_dc;</span><br><span class="line"></span><br><span class="line">    pf-&gt;dequant_4x4 = dequant_4x4;                          <span class="comment">// 反量化 4x4=16 个</span></span><br><span class="line">    pf-&gt;dequant_4x4_dc = dequant_4x4_dc;                    <span class="comment">// 处理 4 个 4x4 的块</span></span><br><span class="line">    pf-&gt;dequant_8x8 = dequant_8x8;                          <span class="comment">// 针对 8x8DCT 的反量化</span></span><br><span class="line">    <span class="comment">// Intra16x16 中，16 个 DC 系数 Hadamard 变换后对的它们反量化</span></span><br><span class="line">    pf-&gt;idct_dequant_2x4_dc = idct_dequant_2x4_dc;</span><br><span class="line">    pf-&gt;idct_dequant_2x4_dconly = idct_dequant_2x4_dconly;</span><br><span class="line"></span><br><span class="line">    pf-&gt;optimize_chroma_2x2_dc = optimize_chroma_2x2_dc;</span><br><span class="line">    pf-&gt;optimize_chroma_2x4_dc = optimize_chroma_2x4_dc;</span><br><span class="line"></span><br><span class="line">    pf-&gt;denoise_dct = denoise_dct;</span><br><span class="line">    pf-&gt;decimate_score15 = decimate_score15;</span><br><span class="line">    pf-&gt;decimate_score16 = decimate_score16;</span><br><span class="line">    pf-&gt;decimate_score64 = decimate_score64;</span><br><span class="line"></span><br><span class="line">    pf-&gt;coeff_last4 = coeff_last4;</span><br><span class="line">    pf-&gt;coeff_last8 = coeff_last8;</span><br><span class="line">    pf-&gt;coeff_last[DCT_LUMA_AC] = coeff_last15;</span><br><span class="line">    pf-&gt;coeff_last[DCT_LUMA_4x4] = coeff_last16;</span><br><span class="line">    pf-&gt;coeff_last[DCT_LUMA_8x8] = coeff_last64;</span><br><span class="line">    pf-&gt;coeff_level_run4 = coeff_level_run4;</span><br><span class="line">    pf-&gt;coeff_level_run8 = coeff_level_run8;</span><br><span class="line">    pf-&gt;coeff_level_run[DCT_LUMA_AC] = coeff_level_run15;</span><br><span class="line">    pf-&gt;coeff_level_run[DCT_LUMA_4x4] = coeff_level_run16;</span><br><span class="line">    <span class="comment">/* 此处省略大量平台的汇编函数初始化代码 */</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h2 id="quant-4x4"><a href="#quant-4x4" class="headerlink" title="quant_4x4"></a>quant_4x4</h2><p><code>quant_4x4()</code> 用于对 <code>4x4</code> 的 <code>DCT</code> 残差矩阵进行量化。该函数的定义位于 <code>common/quant.c</code>，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 功能：quant_4x4() 用于对 4x4 的 DCT 残差矩阵进行量化 */</span></span><br><span class="line"><span class="comment">// 输入输出都是 dct[16]</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quant_4x4</span><span class="params">(dctcoef dct[<span class="number">16</span>], udctcoef mf[<span class="number">16</span>], udctcoef bias[<span class="number">16</span>] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        QUANT_ONE(dct[i], mf[i], bias[i] );</span><br><span class="line">    <span class="keyword">return</span> !!nz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其中 QUANT_ONE 定义如下 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUANT_ONE(coef, mf, f) &#123; \</span></span><br><span class="line">    <span class="keyword">if</span>((coef) &gt; <span class="number">0</span> ) (coef) = (f + (coef)) * (mf) &gt;&gt; <span class="number">16</span>; \</span><br><span class="line">    <span class="keyword">else</span> (coef) = - ((f - (coef)) * (mf) &gt;&gt; <span class="number">16</span>); \</span><br><span class="line">    nz |= (coef); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>QUANT_ONE()</code> 完成了一个 <code>DCT</code> 系数的量化工作，从 <code>QUANT_ONE()</code> 的定义可以看出，它实现了上文提到的 <code>H.264</code> 标准中的量化公式：</p><script type="math/tex; mode=display">\left | Z_{ij}\right | = (\left | W_{ij}\right | \cdot MF + f) >> qbits</script><p>可以看出 <code>quant_4x4()</code> 循环 <code>16</code> 次调用了 <code>QUANT_ONE()</code> 完成了量化工作。并且将 <code>DCT</code> 系数值，<code>MF</code> 值，<code>bias</code> 偏移值直接传递给了该宏。</p><h2 id="quant-4x4x4"><a href="#quant-4x4x4" class="headerlink" title="quant_4x4x4"></a>quant_4x4x4</h2><p><code>quant_4x4x4()</code> 用于对 4 个 4x4 的 DCT 残差矩阵进行量化。该函数的定义位于 <code>common/quant.c</code>，从 <code>quant_4x4x4()</code> 的定义可以看出，该函数相当于调用了 4 次 <code>quant_4x4()</code> 函数。对应的代码分析如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对 4 个 4x4 的 DCT 残差矩阵进行量化, 从 quant_4x4x4() 的定义可以看出，该函数相当于调用了 4 次 quant_4x4() 函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quant_4x4x4</span><span class="params">(dctcoef dct[<span class="number">4</span>][<span class="number">16</span>], udctcoef mf[<span class="number">16</span>], udctcoef bias[<span class="number">16</span>] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nza = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            QUANT_ONE(dct[j][i], mf[i], bias[i] );</span><br><span class="line">        nza |= (!!nz)&lt;&lt;j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quant-8x8"><a href="#quant-8x8" class="headerlink" title="quant_8x8"></a>quant_8x8</h2><p><code>quant_8x8()</code> 函数的定义位于 <code>common/quant.c</code> 中，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quant_8x8</span><span class="params">(dctcoef dct[<span class="number">64</span>], udctcoef mf[<span class="number">64</span>], udctcoef bias[<span class="number">64</span>] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">        QUANT_ONE(dct[i], mf[i], bias[i] );</span><br><span class="line">    <span class="keyword">return</span> !!nz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;x264&lt;/code&gt; 中 &lt;code&gt;x264_quant_init&lt;/code&gt; 函数中初始化了量化有关的函数，本文分析部分量化函数的实现&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="x264" scheme="http://github.hezhaojiang.io/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 x264 - SPS &amp; PPS</title>
    <link href="http://github.hezhaojiang.io/post/2021/2633a00a/"/>
    <id>http://github.hezhaojiang.io/post/2021/2633a00a/</id>
    <published>2021-01-28T07:34:00.000Z</published>
    <updated>2021-01-30T13:00:23.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>x264</code> 中参数集初始化主要包括如下两个函数：</p><ul><li><code>x264_sps_init()</code>：根据输入参数生成 <code>H.264</code> 码流的 <code>SPS</code> 信息。</li><li><code>x264_pps_init()</code>：根据输入参数生成 <code>H.264</code> 码流的 <code>PPS</code> 信息。</li></ul><a id="more"></a><h3 id="x264-sps-init"><a href="#x264-sps-init" class="headerlink" title="x264_sps_init"></a>x264_sps_init</h3><p><code>x264_sps_init()</code> 会根据 <code>x264_param_t</code> 结构体中的参数来设置 <code>x264_sps_t</code> 结构体中的参数。</p><p>具体代码及注释如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                            初始化 SPS</span></span><br><span class="line"><span class="comment">* @param[out]       sps             x264_sps_t 结构体指针</span></span><br><span class="line"><span class="comment">* @param[in]        i_id            i_id</span></span><br><span class="line"><span class="comment">* @param[in]        param           x264_param_t 结构体指针</span></span><br><span class="line"><span class="comment">* @return                           x264_t 结构体指针</span></span><br><span class="line"><span class="comment">                                    # not nullptr   执行成功</span></span><br><span class="line"><span class="comment">*                                   # nullptr       执行失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_sps_init</span><span class="params">(<span class="keyword">x264_sps_t</span> *sps, <span class="keyword">int</span> i_id, <span class="keyword">x264_param_t</span> *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> csp = param-&gt;i_csp &amp; X264_CSP_MASK;</span><br><span class="line"></span><br><span class="line">    sps-&gt;i_id = i_id;</span><br><span class="line">    <span class="comment">/* 以宏块为单位的图像宽度 */</span></span><br><span class="line">    sps-&gt;i_mb_width = (param-&gt;i_width + <span class="number">15</span> ) / <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/* 以宏块为单位的图像高度 */</span></span><br><span class="line">    sps-&gt;i_mb_height= (param-&gt;i_height + <span class="number">15</span> ) / <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/* 所有图像均使用帧编码 */</span></span><br><span class="line">    sps-&gt;b_frame_mbs_only = !(param-&gt;b_interlaced || param-&gt;b_fake_interlaced);</span><br><span class="line">    <span class="keyword">if</span>(!sps-&gt;b_frame_mbs_only )</span><br><span class="line">        <span class="comment">/* 场编码时 以宏块为单位的图像高度为偶数 */</span></span><br><span class="line">        sps-&gt;i_mb_height = (sps-&gt;i_mb_height + <span class="number">1</span> ) &amp; ~<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 色度采样结构 yuv444 yuv422 yuv420 yuv400 */</span></span><br><span class="line">    sps-&gt;i_chroma_format_idc = csp &gt;= X264_CSP_I444 ? CHROMA_444 :</span><br><span class="line">                               csp &gt;= X264_CSP_I422 ? CHROMA_422 :</span><br><span class="line">                               csp &gt;= X264_CSP_I420 ? CHROMA_420 : CHROMA_400;</span><br><span class="line"></span><br><span class="line">    sps-&gt;b_qpprime_y_zero_transform_bypass = param-&gt;rc.i_rc_method == X264_RC_CQP &amp;&amp; param-&gt;rc.i_qp_constant == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据其他质量参数 设置 profile */</span></span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;b_qpprime_y_zero_transform_bypass || sps-&gt;i_chroma_format_idc == CHROMA_444 )</span><br><span class="line">        sps-&gt;i_profile_idc  = PROFILE_HIGH444_PREDICTIVE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sps-&gt;i_chroma_format_idc == CHROMA_422 )</span><br><span class="line">        sps-&gt;i_profile_idc  = PROFILE_HIGH422;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(BIT_DEPTH&gt; <span class="number">8</span> )</span><br><span class="line">        sps-&gt;i_profile_idc  = PROFILE_HIGH10;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;analyse.b_transform_8x8 || param-&gt;i_cqm_preset != X264_CQM_FLAT || sps-&gt;i_chroma_format_idc == CHROMA_400 )</span><br><span class="line">        sps-&gt;i_profile_idc  = PROFILE_HIGH;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;b_cabac || param-&gt;i_bframe &gt; <span class="number">0</span> || param-&gt;b_interlaced || param-&gt;b_fake_interlaced || param-&gt;analyse.i_weighted_pred &gt; <span class="number">0</span> )</span><br><span class="line">        sps-&gt;i_profile_idc  = PROFILE_MAIN;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sps-&gt;i_profile_idc  = PROFILE_BASELINE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constraint_set0 表示编码视频序列遵守 Baseline profile 的所有约束 */</span></span><br><span class="line">    sps-&gt;b_constraint_set0  = sps-&gt;i_profile_idc == PROFILE_BASELINE;</span><br><span class="line">    <span class="comment">/* constraint_set1 表示编码视频序列遵守 Main profile 的所有约束 */</span></span><br><span class="line">    <span class="comment">/* x264 不支持 baseline 中存在，却不存在 main 中的约束，包括 arbitrary_slice_order 和 slice_groups */</span></span><br><span class="line">    sps-&gt;b_constraint_set1  = sps-&gt;i_profile_idc &lt;= PROFILE_MAIN;</span><br><span class="line">    <span class="comment">/* Never set constraint_set2, it is not necessary and not used in real world. */</span></span><br><span class="line">    sps-&gt;b_constraint_set2  = <span class="number">0</span>;</span><br><span class="line">    sps-&gt;b_constraint_set3  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sps-&gt;i_level_idc = param-&gt;i_level_idc;</span><br><span class="line">    <span class="keyword">if</span>(param-&gt;i_level_idc == <span class="number">9</span> &amp;&amp; ( sps-&gt;i_profile_idc == PROFILE_BASELINE || sps-&gt;i_profile_idc == PROFILE_MAIN ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 在一些高级 profile 情况下，level_idc 值为 9 代表等级为 1b */</span></span><br><span class="line">        <span class="comment">/* 在 Baseline or Main profile，level_idc 值为 11 且 constraint_set3 值为 1 代表等级为 1b，（level_idc 值为 11 且 constraint_set3 值为 0 代表等级为 1.1）*/</span></span><br><span class="line">        sps-&gt;b_constraint_set3 = <span class="number">1</span>;</span><br><span class="line">        sps-&gt;i_level_idc      = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Intra profiles */</span></span><br><span class="line">    <span class="keyword">if</span>(param-&gt;i_keyint_max == <span class="number">1</span> &amp;&amp; sps-&gt;i_profile_idc &gt;= PROFILE_HIGH )</span><br><span class="line">        sps-&gt;b_constraint_set3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.i_num_reorder_frames = param-&gt;i_bframe_pyramid ? <span class="number">2</span> : param-&gt;i_bframe ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* extra slot with pyramid so that we don&#x27;t have to override the</span></span><br><span class="line"><span class="comment">     * order of forgetting old pictures */</span></span><br><span class="line">    sps-&gt;vui.i_max_dec_frame_buffering =</span><br><span class="line">    sps-&gt;i_num_ref_frames = X264_MIN(X264_REF_MAX, X264_MAX4(param-&gt;i_frame_reference, <span class="number">1</span> + sps-&gt;vui.i_num_reorder_frames,</span><br><span class="line">                            param-&gt;i_bframe_pyramid ? <span class="number">4</span> : <span class="number">1</span>, param-&gt;i_dpb_size));</span><br><span class="line">    sps-&gt;i_num_ref_frames -= param-&gt;i_bframe_pyramid == X264_B_PYRAMID_STRICT;</span><br><span class="line">    <span class="keyword">if</span>(param-&gt;i_keyint_max == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        sps-&gt;i_num_ref_frames = <span class="number">0</span>;</span><br><span class="line">        sps-&gt;vui.i_max_dec_frame_buffering = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* number of refs + current frame */</span></span><br><span class="line">    <span class="keyword">int</span> max_frame_num = sps-&gt;vui.i_max_dec_frame_buffering * (!!param-&gt;i_bframe_pyramid+<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Intra refresh cannot write a recovery time greater than max frame num-1 */</span></span><br><span class="line">    <span class="keyword">if</span>(param-&gt;b_intra_refresh )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> time_to_recovery = X264_MIN(sps-&gt;i_mb_width - <span class="number">1</span>, param-&gt;i_keyint_max ) + param-&gt;i_bframe - <span class="number">1</span>;</span><br><span class="line">        max_frame_num = X264_MAX(max_frame_num, time_to_recovery+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sps-&gt;i_log2_max_frame_num = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span> &lt;&lt; sps-&gt;i_log2_max_frame_num) &lt;= max_frame_num )</span><br><span class="line">        sps-&gt;i_log2_max_frame_num++;</span><br><span class="line"></span><br><span class="line">    sps-&gt;i_poc_type = param-&gt;i_bframe || param-&gt;b_interlaced || param-&gt;i_avcintra_class ? <span class="number">0</span> : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;i_poc_type == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> max_delta_poc = (param-&gt;i_bframe + <span class="number">2</span>) * (!!param-&gt;i_bframe_pyramid + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        sps-&gt;i_log2_max_poc_lsb = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">1</span> &lt;&lt; sps-&gt;i_log2_max_poc_lsb) &lt;= max_delta_poc * <span class="number">2</span> )</span><br><span class="line">            sps-&gt;i_log2_max_poc_lsb++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 默认带有 VUI 信息 */</span></span><br><span class="line">    sps-&gt;b_vui = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sps-&gt;b_gaps_in_frame_num_value_allowed = <span class="number">0</span>;</span><br><span class="line">    sps-&gt;b_mb_adaptive_frame_field = param-&gt;b_interlaced;</span><br><span class="line">    sps-&gt;b_direct8x8_inference = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    x264_sps_init_reconfigurable(sps, param);</span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.b_overscan_info_present = param-&gt;vui.i_overscan &gt; <span class="number">0</span> &amp;&amp; param-&gt;vui.i_overscan &lt;= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;vui.b_overscan_info_present )</span><br><span class="line">        sps-&gt;vui.b_overscan_info = (param-&gt;vui.i_overscan == <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.b_signal_type_present = <span class="number">0</span>;</span><br><span class="line">    sps-&gt;vui.i_vidformat = (param-&gt;vui.i_vidformat &gt;= <span class="number">0</span> &amp;&amp; param-&gt;vui.i_vidformat &lt;= <span class="number">5</span> ? param-&gt;vui.i_vidformat : <span class="number">5</span> );</span><br><span class="line">    sps-&gt;vui.b_fullrange = (param-&gt;vui.b_fullrange &gt;= <span class="number">0</span> &amp;&amp; param-&gt;vui.b_fullrange &lt;= <span class="number">1</span> ? param-&gt;vui.b_fullrange :</span><br><span class="line">                           (csp&gt;= X264_CSP_BGR ? <span class="number">1</span> : <span class="number">0</span> ) );</span><br><span class="line">    sps-&gt;vui.b_color_description_present = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.i_colorprim = (param-&gt;vui.i_colorprim &gt;= <span class="number">0</span> &amp;&amp; param-&gt;vui.i_colorprim &lt;= <span class="number">12</span> ? param-&gt;vui.i_colorprim : <span class="number">2</span> );</span><br><span class="line">    sps-&gt;vui.i_transfer  = (param-&gt;vui.i_transfer  &gt;= <span class="number">0</span> &amp;&amp; param-&gt;vui.i_transfer  &lt;= <span class="number">18</span> ? param-&gt;vui.i_transfer  : <span class="number">2</span> );</span><br><span class="line">    sps-&gt;vui.i_colmatrix = (param-&gt;vui.i_colmatrix &gt;= <span class="number">0</span> &amp;&amp; param-&gt;vui.i_colmatrix &lt;= <span class="number">14</span> ? param-&gt;vui.i_colmatrix :</span><br><span class="line">                           (csp&gt;= X264_CSP_BGR ? <span class="number">0</span> : <span class="number">2</span> ) );</span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;vui.i_colorprim != <span class="number">2</span> || sps-&gt;vui.i_transfer != <span class="number">2</span> || sps-&gt;vui.i_colmatrix != <span class="number">2</span> )</span><br><span class="line">        sps-&gt;vui.b_color_description_present = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;vui.i_vidformat != <span class="number">5</span> || sps-&gt;vui.b_fullrange || sps-&gt;vui.b_color_description_present )</span><br><span class="line">        sps-&gt;vui.b_signal_type_present = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">FIXME:</span> not sufficient for interlaced video */</span></span><br><span class="line">    sps-&gt;vui.b_chroma_loc_info_present = param-&gt;vui.i_chroma_loc &gt; <span class="number">0</span> &amp;&amp; param-&gt;vui.i_chroma_loc &lt;= <span class="number">5</span> &amp;&amp;</span><br><span class="line">                                         sps-&gt;i_chroma_format_idc == CHROMA_420;</span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;vui.b_chroma_loc_info_present )</span><br><span class="line">    &#123;</span><br><span class="line">        sps-&gt;vui.i_chroma_loc_top = param-&gt;vui.i_chroma_loc;</span><br><span class="line">        sps-&gt;vui.i_chroma_loc_bottom = param-&gt;vui.i_chroma_loc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.b_timing_info_present = param-&gt;i_timebase_num &gt; <span class="number">0</span> &amp;&amp; param-&gt;i_timebase_den &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;vui.b_timing_info_present )</span><br><span class="line">    &#123;</span><br><span class="line">        sps-&gt;vui.i_num_units_in_tick = param-&gt;i_timebase_num;</span><br><span class="line">        sps-&gt;vui.i_time_scale = param-&gt;i_timebase_den * <span class="number">2</span>;</span><br><span class="line">        sps-&gt;vui.b_fixed_frame_rate = !param-&gt;b_vfr_input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.b_vcl_hrd_parameters_present = <span class="number">0</span>; <span class="comment">// we don&#x27;t support VCL HRD</span></span><br><span class="line">    sps-&gt;vui.b_nal_hrd_parameters_present = !!param-&gt;i_nal_hrd;</span><br><span class="line">    sps-&gt;vui.b_pic_struct_present = param-&gt;b_pic_struct;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> HRD related parts of the SPS are initialised in x264_ratecontrol_init_reconfigurable</span></span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.b_bitstream_restriction = !(sps-&gt;b_constraint_set3 &amp;&amp; sps-&gt;i_profile_idc &gt;= PROFILE_HIGH);</span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;vui.b_bitstream_restriction )</span><br><span class="line">    &#123;</span><br><span class="line">        sps-&gt;vui.b_motion_vectors_over_pic_boundaries = <span class="number">1</span>;</span><br><span class="line">        sps-&gt;vui.i_max_bytes_per_pic_denom = <span class="number">0</span>;</span><br><span class="line">        sps-&gt;vui.i_max_bits_per_mb_denom = <span class="number">0</span>;</span><br><span class="line">        sps-&gt;vui.i_log2_max_mv_length_horizontal =</span><br><span class="line">        sps-&gt;vui.i_log2_max_mv_length_vertical = (<span class="keyword">int</span>)log2f( X264_MAX( <span class="number">1</span>, param-&gt;analyse.i_mv_range*<span class="number">4</span><span class="number">-1</span> ) ) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sps-&gt;b_avcintra = !!param-&gt;i_avcintra_class;</span><br><span class="line">    sps-&gt;i_cqm_preset = param-&gt;i_cqm_preset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="x264-pps-init"><a href="#x264-pps-init" class="headerlink" title="x264_pps_init"></a>x264_pps_init</h3><p><code>x264_pps_init()</code> 会根据 <code>x264_param_t</code> 结构体和 <code>x264_sps_t</code> 结构体对 <code>x264_pps_t</code> 进行设置。</p><p>具体代码及注释如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                            初始化 SPS</span></span><br><span class="line"><span class="comment">* @param[out]       sps             x264_sps_t 结构体指针</span></span><br><span class="line"><span class="comment">* @param[in]        i_id            i_id</span></span><br><span class="line"><span class="comment">* @param[in]        param           x264_param_t 结构体指针</span></span><br><span class="line"><span class="comment">* @param[in]        param           x264_sps_t 结构体指针</span></span><br><span class="line"><span class="comment">* @return                           x264_t 结构体指针</span></span><br><span class="line"><span class="comment">                                    # not nullptr   执行成功</span></span><br><span class="line"><span class="comment">*                                   # nullptr       执行失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_pps_init</span><span class="params">(<span class="keyword">x264_pps_t</span> *pps, <span class="keyword">int</span> i_id, <span class="keyword">x264_param_t</span> *param, <span class="keyword">x264_sps_t</span> *sps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pps-&gt;i_id = i_id;</span><br><span class="line">    pps-&gt;i_sps_id = sps-&gt;i_id;</span><br><span class="line">    pps-&gt;b_cabac = param-&gt;b_cabac;</span><br><span class="line"></span><br><span class="line">    pps-&gt;b_pic_order = !param-&gt;i_avcintra_class &amp;&amp; param-&gt;b_interlaced;</span><br><span class="line">    pps-&gt;i_num_slice_groups = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pps-&gt;i_num_ref_idx_l0_default_active = param-&gt;i_frame_reference;</span><br><span class="line">    pps-&gt;i_num_ref_idx_l1_default_active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pps-&gt;b_weighted_pred = param-&gt;analyse.i_weighted_pred &gt; <span class="number">0</span>;</span><br><span class="line">    pps-&gt;b_weighted_bipred = param-&gt;analyse.b_weighted_bipred ? <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pps-&gt;i_pic_init_qp = param-&gt;rc.i_rc_method == X264_RC_ABR || param-&gt;b_stitchable ? <span class="number">26</span> + QP_BD_OFFSET : SPEC_QP(param-&gt;rc.i_qp_constant );</span><br><span class="line">    pps-&gt;i_pic_init_qs = <span class="number">26</span> + QP_BD_OFFSET;</span><br><span class="line"></span><br><span class="line">    pps-&gt;i_chroma_qp_index_offset = param-&gt;analyse.i_chroma_qp_offset;</span><br><span class="line">    pps-&gt;b_deblocking_filter_control = <span class="number">1</span>;</span><br><span class="line">    pps-&gt;b_constrained_intra_pred = param-&gt;b_constrained_intra;</span><br><span class="line">    pps-&gt;b_redundant_pic_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pps-&gt;b_transform_8x8_mode = param-&gt;analyse.b_transform_8x8 ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;x264&lt;/code&gt; 中参数集初始化主要包括如下两个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x264_sps_init()&lt;/code&gt;：根据输入参数生成 &lt;code&gt;H.264&lt;/code&gt; 码流的 &lt;code&gt;SPS&lt;/code&gt; 信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x264_pps_init()&lt;/code&gt;：根据输入参数生成 &lt;code&gt;H.264&lt;/code&gt; 码流的 &lt;code&gt;PPS&lt;/code&gt; 信息。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="x264" scheme="http://github.hezhaojiang.io/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 - 逆元</title>
    <link href="http://github.hezhaojiang.io/post/2021/47588647/"/>
    <id>http://github.hezhaojiang.io/post/2021/47588647/</id>
    <published>2021-01-24T01:33:58.000Z</published>
    <updated>2021-02-09T11:38:38.052Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于加减乘运算都会满足：</p><p>　　<script type="math/tex">(a + b) \bmod p = a \bmod p + b \bmod p</script></p><p>　　<script type="math/tex">(a - b) \bmod p = a \bmod p - b \bmod p</script></p><p>　　<script type="math/tex">(a \times b) \bmod p = a \bmod p \times (b \bmod p)</script></p><p>但是对于除法而言 $ (a/b) \bmod p \neq (a \bmod p) / (b \bmod p) $</p><p>这个可以通过举例验证一下或者可以通过 $b \bmod p$ 可以为 0 但是分母不能为 0 得到对于除法而言不满足这个运算的结论。</p><p>但是如果非要求 $(a/b) \bmod p$ 要怎么办呢？</p><a id="more"></a><h2 id="逆元的定义"><a href="#逆元的定义" class="headerlink" title="逆元的定义"></a>逆元的定义</h2><p>为了解决模意义下的除法问题，我们引入了逆元 $\text{inv}(a)$。 $\text{inv}(a)$ 其实可以看做模 $p$ 意义下的 $\displaystyle\frac{1}{a}$ ，那么在模 $p$ 意义下， $\displaystyle\frac{a}{b}$ 就可以变形为 $a\cdot \text{inv}(b))$</p><p>定义：如果一个线性同余方程 $ax \equiv 1 \pmod b$ ，则 $x$ 称为 $a \bmod b$ 的逆元，记作 $\text{inv}(a)$ 。</p><h2 id="逆元的求解"><a href="#逆元的求解" class="headerlink" title="逆元的求解"></a>逆元的求解</h2><p>这里介绍三种计算逆元的方法：拓展欧几里得，费马小定理，线性递推。</p><h3 id="拓展欧几里得"><a href="#拓展欧几里得" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h3><h4 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h4><p>如果我们已知两个数 $a$ 和 $b$ ，如何求出二者的最大公约数呢？</p><p>不妨设 $a &gt; b$</p><p>我们发现如果 $b$ 是 $a$ 的约数，那么 $b$ 就是二者的最大公约数。<br>下面讨论不能整除的情况，即 $a = b \times q + r$ ，其中 $r &lt; b$ 。</p><p>我们通过证明可以得到 $\gcd(a,b)=\gcd(b,a \bmod b)$ ，过程如下：</p><hr><p>设 $a=bk+c$ ，显然有 $c=a \bmod b$ 。设 $d|a\ \ \ d|b$ ，则 $c=a-bk$  $\frac{c}{d}=\frac{a}{d}-\frac{b}{d}k$ 由右边的式子可知 $\frac{c}{d}$ 为整数，即 $d|c$ 所以对于 $a,b$ 的公约数，它也会是 $a \bmod b$ 的公约数。</p><p>反过来也需要证明</p><p>设 $d|b\ \ \ d|(a \bmod b)$ ，我们还是可以像之前一样得到以下式子 $\frac{a\bmod b}{d}=\frac{a}{d}-\frac{b}{d}k$  $\frac{a\bmod b}{d}+\frac{b}{d}k=\frac{a}{d}$ 因为左边式子显然为整数，所以 $\frac{a}{d}$ 也为整数，即 $d|a$ ，所以 $b,a\bmod b$ 的公约数也是 $a,b$ 的公约数。</p><p>既然两式公约数都是相同的，那么最大公约数也会相同。</p><p>所以得到式子 $\gcd(a,b)=\gcd(b,a\bmod b)$</p><p>既然得到了 $\gcd(a, b) = \gcd(b, r)$ ，这里两个数的大小是不会增大的，那么我们也就得到了关于两个数的最大公约数的一个递归求法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归至 <code>b==0</code> （即上一步的 <code>a%b==0</code> ) 的情况再返回值即可。</p><hr><h4 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h4><p>扩展欧几里德定理（Extended Euclidean algorithm, EXGCD），常用于求 $ax+by=\gcd(a,b)$ 的一组可行解。</p><p>证明：</p><p>设</p><p>$ax_1+by_1=\gcd(a,b)$</p><p>$bx_2+(a\bmod b)y_2=\gcd(b,a\bmod b)$</p><p>由欧几里得定理可知： $\gcd(a,b)=\gcd(b,a\bmod b)$</p><p>所以 $ax_1+by_1=bx_2+(a\bmod b)y_2$</p><p>又因为 $a\bmod b=a-(\lfloor\frac{a}{b}\rfloor\times b)$</p><p>所以 $ax_1+by_1=bx_2+(a-(\lfloor\frac{a}{b}\rfloor\times b))y_2$</p><p> $ax_1+by_1=ay_2+bx_2-\lfloor\frac{a}{b}\rfloor\times by_2=ay_2+b(x_2-\lfloor\frac{a}{b}\rfloor y_2)$</p><p>因为 $a=a,b=b$ ，所以可令 $x_1=y_2,y_1=x_2-\lfloor\frac{a}{b}\rfloor y_2$</p><p>将 $x_2,y_2$ 不断代入递归求解直至 GCD（最大公约数，下同）为 <code>0</code> 递归 <code>x=1,y=0</code> 回去求解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = Exgcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数返回的值为 GCD，在这个过程中计算 $x,y$ 即可。</p><h4 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h4><p>形如 $ax \equiv c \pmod b$ 的方程被称为 线性同余方程 (Congruence Equation)。</p><p>根据以下两个定理，我们可以求出同余方程 $ax \equiv c \pmod b$ 的解。</p><p>定理 1 ：方程 $ax+by=c$ 与方程 $ax \equiv c \pmod b$ 是等价的，有整数解的充要条件为 $\gcd(a,b) \mid c$</p><p>根据定理 1，方程 $ax+by=c$，我们可以先用扩展欧几里得算法求出一组 $x_0,y_0$ ，也就是 $ax_0+by_0=\gcd(a,b)$，然后两边同时除以 $\gcd(a,b)$，再乘 $c$。然后就得到了方程 $a\dfrac{c}{\gcd(a,b)}x_0+b\dfrac{c}{\gcd(a,b)}y_0=c$，然后我们就找到了方程的一个解。</p><p>定理 2 ：若 $\gcd(a,b)=1$，且 $x_0$、$y_0$ 为方程 $ax+by=c$ 的一组解，则该方程的任意解可表示为：$x=x_0+bt$，$y=y_0-at$ , 且对任意整数 $t$ 都成立。</p><p>根据定理 2，可以求出方程的所有解。但在实际问题中，我们往往被要求求出一个最小整数解，也就是一个特解 $x=(x \bmod t+t) \bmod t$，其中 $t=\dfrac{b}{\gcd(a,b)}$。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展欧几里得法和求解 线性同余方程 是一个原理，在这里不展开解释。</p><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>费马小定理是数论里的重要定理，叙述如下：</p><blockquote><p>若 $p$ 是质数，且 $\gcd(a,p)=1$ ，则有 $a^{p-1}\equiv1\pmod{p}$</p></blockquote><p>从逆元的定义推导，可得：</p><script type="math/tex; mode=display">a\cdot\text{inv}(a)\equiv1\equiv a^{p-1}\pmod{p}</script><p>于是有：</p><script type="math/tex; mode=display">\text{inv}(a)\equiv a^{p-2}\pmod{p}</script><p>于是对 $a^{p-2}$ 算一下快速幂就好了。注意这个方法只对 $p$ 是质数的情形有效。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速幂算法 (a ^ n) mod p</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    a = (a % p + p) % p;</span><br><span class="line">    <span class="keyword">for</span> (; n; n&gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans = (a * ans) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a mod b</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qpow(a, p - <span class="number">2</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h4><pre><code>快速幂算法解读（以 3^10 为例）：3^10 = (3*3*3*3*3*3*3*3*3*3)尽量想办法把指数变小来，这里的指数为 103^10 = (3*3)*(3*3)*(3*3)*(3*3)*(3*3)     = (3*3)^5     = 9^5此时指数由 10 缩减一半变成了 5，而底数变成了原来的平方求 3^10 原本需要执行 10 次循环操作，求 9^5 却只需要执行 5 次循环操作但是 3^10 却等于 9^5, 我们用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好例如 2^10000=4^5000, 底数只是做了一个小小的平方操作，而指数就从 10000 变成了 5000，减少了 5000 次的循环操作。现在我们的问题是如何把指数 5 变成原来的一半，5 是一个奇数，5 的一半是 2.5但是我们知道，指数不能为小数，因此我们不能这么简单粗暴的直接执行 5/2然而，这里还有另一种方法能表示 9^59^5 =（9^4）*（9^1）此时我们抽出了一个底数的一次方，这里即为 9^1，这个 9^1 我们先单独移出来剩下的 9^4 又能够在执行缩指数操作了，把指数缩小一半，底数执行平方操作9^5 =（81^2）*(9^1)把指数缩小一半，底数执行平方操作9^5 =（6561^1）*(9^1)此时，我们发现指数又变成了一个奇数 1按照上面对指数为奇数的操作方法，应该抽出了一个底数的一次方，这里即为 6561^1这个 6561^1 我们先单独移出来，但是此时指数却变成了 0，也就意味着我们无法再进行缩指数操作了9^5 =（6561^0）*(9^1)*(6561^1)    = 1*(9^1)*(6561^1)    = (9^1)*(6561^1)    = 9*6561    = 59049我们能够发现，最后的结果是 9*6561而 9 是怎么产生的？是不是当指数为奇数 5 时，此时底数为 9那 6561 又是怎么产生的呢？是不是当指数为奇数 1 时，此时的底数为 6561所以我们能发现一个规律：最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于加减乘运算都会满足：&lt;/p&gt;
&lt;p&gt;　　&lt;script type=&quot;math/tex&quot;&gt;(a + b) \bmod p = a \bmod p + b \bmod p&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;script type=&quot;math/tex&quot;&gt;(a - b) \bmod p = a \bmod p - b \bmod p&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;script type=&quot;math/tex&quot;&gt;(a \times b) \bmod p = a \bmod p \times (b \bmod p)&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;但是对于除法而言 $ (a/b) \bmod p \neq (a \bmod p) / (b \bmod p) $&lt;/p&gt;
&lt;p&gt;这个可以通过举例验证一下或者可以通过 $b \bmod p$ 可以为 0 但是分母不能为 0 得到对于除法而言不满足这个运算的结论。&lt;/p&gt;
&lt;p&gt;但是如果非要求 $(a/b) \bmod p$ 要怎么办呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://github.hezhaojiang.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数论" scheme="http://github.hezhaojiang.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>编解码技术：H264 - 运动补偿</title>
    <link href="http://github.hezhaojiang.io/post/2021/b556f4df/"/>
    <id>http://github.hezhaojiang.io/post/2021/b556f4df/</id>
    <published>2021-01-22T06:56:58.000Z</published>
    <updated>2021-01-30T13:00:23.708Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>运动补偿是一种描述相邻帧（相邻在这里表示在编码关系上相邻，在播放顺序上两帧未必相邻）差别的方法，具体来说是描述前面一帧（相邻在这里表示在编码关系上的前面，在播放顺序上未必在当前帧前面）的每个小块怎样移动到当前帧中的某个位置去。这种方法经常被视频压缩 / 视频编解码器用来减少视频序列中的时域冗余。它也可以用来进行去交织（deinterlacing）以及运动插值（motion interpolation）的操作。</p><a id="more"></a><h2 id="运动补偿原理"><a href="#运动补偿原理" class="headerlink" title="运动补偿原理"></a>运动补偿原理</h2><p>一个视频序列包含一定数量的图片 — 通常称为帧（frame）。相邻的图片通常很相似，也就是说，包含了很多冗余。使用运动补偿的目的是通过消除这种冗余，来提高压缩比。</p><p>最早的运动补偿的设计只是简单的从当前帧中减去参考帧，从而得到通常含有较少能量（或者称为信息）的 “残差”，从而可以用较低的码率进行编码。解码器可以通过简单的加法完全恢复编码帧。</p><p>一个稍微复杂一点的设计是估计一下整帧场景的移动和场景中物体的移动，并将这些运动通过一定的参数编码到码流中去。这样预测帧上的像素值就是由参考帧上具有一定位移的相应像素值而生成的。这样的方法比简单的相减可以获得能量更小的残差，从而获得更好的压缩比 — 当然，用来描述运动的参数不能在码流中占据太大的部分，否则就会抵消复杂的运动估计带来的好处。</p><p>通常，图像帧是一组一组进行处理的。每组的第一帧（通常是第一帧）在编码的时候不使用运动估计的办法，这种帧称为帧内编码帧（Intra frame）或者 I 帧。该组中的其它帧使用帧间编码帧（Inter frame），通常是 P 帧。这种编码方式通常被称为 IPPPP，表示编码的时候第一帧是 I 帧，其它帧是 P 帧。</p><p>在进行预测的时候，不仅仅可以从过去的帧来预测当前帧，还可以使用未来的帧来预测当前帧。当然在编码的时候，未来的帧必须比当前帧更早的编码，也就是说，编码的顺序和播放的顺序是不同的。通常这样的当前帧是使用过去和未来的 I 帧或者 P 帧同时进行预测，被称为双向预测帧，即 B 帧。这种编码方式的编码顺序的一个例子为 IBBPBBPBBPBB。</p><p>运动补偿的方法包含：全局运动补偿、分块运动补偿、可变分块运动补偿、重叠分块运动个补偿。</p><h2 id="全局运动补偿"><a href="#全局运动补偿" class="headerlink" title="全局运动补偿"></a>全局运动补偿</h2><p>在全局运动补偿中，运动模型基本上就是反映摄像机的各种运动，包括平移，旋转，变焦等等。这种模型特别适合对没有运动物体的静止场景的编码。 全局运动补偿有下面的一些优点：</p><ol><li>该模型仅仅使用少数的参数对全局的运行进行描述，参数所占用的码率基本上可以忽略不计。</li><li>该方法不对帧进行分区编码，这避免了分区造成的块效应。</li><li>在时间方向的一条直线的点如果在空间方向具有相等的间隔，就对应了在实际空间中连续移动的点。其它的运动估计算法通常会在时间方向引入非连续性。<br>但是，缺点是，如果场景中有运动物体的话，全局运动补偿就不足以表示了。这时候应该选用其它的方法。</li></ol><h2 id="分块运动补偿"><a href="#分块运动补偿" class="headerlink" title="分块运动补偿"></a>分块运动补偿</h2><p>在分块运动补偿（BMC for block motion compensation）中，每帧被分为若干像素块（在大多数视频编码标准，如 MPEG 中，是分为 16x16 的像素块）。从参考帧的某个位置的等大小的块对当前块进行预测，预测的过程中只有平移，平移的大小被称为运动矢量。</p><p>对分块运动补偿来说，运动矢量是模型的必要参数，必须一起编码加入码流中。由于运动矢量之间并不是独立的（例如属于同一个运动物体的相邻两块通常运动的相关性很大），通常使用差分编码来降低码率。这意味着在相邻的运动矢量编码之前对它们作差，只对差分的部分进行编码。使用熵编码对运动矢量的成分进行编码可以进一步消除运动矢量的统计冗余（通常运动矢量的差分集中于 0 矢量附近）。</p><p>运动矢量的值可以是非整数的，此时的运动补偿被称为亚像素精度的运动补偿。这是通过对参考帧像素值进行亚像素级插值，而后进行运动补偿做到的。最简单的亚像素精度运动补偿使用半像素精度，也有使用 1/4 像素和 1/8 像素精度的运动补偿算法。更高的亚像素精度可以提高运动补偿的精确度，但是大量的插值操作大大增加了计算复杂度。</p><p>分块运动补偿的一个大缺点在于在块之间引入的非连续性，通常称为块效应。当块效应严重时，解码图像看起来会有像马赛克一样的效果，严重影响视觉质量。另外一个缺点是，当高频分量较大时，会引起振铃效应。关于高频分量，请参见对运动补偿后的残差进行变换的方法：变换编码。</p><h2 id="可变分块运动补偿"><a href="#可变分块运动补偿" class="headerlink" title="可变分块运动补偿"></a>可变分块运动补偿</h2><p>可变分块运动补偿（VBSMC，全称 Variable Block Size Motion Compensation）是 BMC 的变种，编码器可以动态选择分块大小。进行视频编码时，使用大的分块可以减少表征运动向量所需的比特数，使用小的分块则可以在编码时产生更少的预测余量信息。较老的设计，象 H.261 和 MPEG-1 视频编码，典型的使用了固定分块，而较新的设计，像 H.263、MPEG-4 Part 2、H.264/MPEG-4 AVC 和 VC-1 则赋予了编码器动态选择何种分块来表征运动图像的能力。</p><h2 id="重叠分块运动补偿"><a href="#重叠分块运动补偿" class="headerlink" title="重叠分块运动补偿"></a>重叠分块运动补偿</h2><p>重叠分块运动补偿（OBMC for Overlapped block motion compensation）是一种更好的解决方案，它不但能增加预测精度，而且能够避免块失真。 因此，每个像素第属于 4 个分块。基于此方案，每个像素的 4 个预测值求和后得到一个加权平均数。</p><p>为此目的，分块被关联到一个窗口函数，该窗口函数具有任何地方的 4 个重叠窗口的总和为 1 的特质。</p><h2 id="运动估计"><a href="#运动估计" class="headerlink" title="运动估计"></a>运动估计</h2><p>运动估计就是寻找最优或次优的运动向量的过程。某个块的预测误差量常常是指在运动补偿区域所有像素中，预测像素和实际像素数值的均方差或者绝对差别总和。</p><p>发现最优向量，一个最基本的方法是不得不为在固定探测范围内，给每一个运动向量，计算块的预测误差计算邻近祯之中找寻前后 frame 之中相似的 Macro Block，两者之间的差异值。以及估算表示此 Motion Vector 所需的位元数目，和在错误数和比特数之间挑选一个最折中作为运动向量值。运动估计技术尽量简单的测试在执行前一个简单的探测测试技术为：估计所有可能的运动表现，比如这样的最优化被称做全探测。</p><p>一个稍快但不是最优的方法是用第一个近似值作为一个粗略探测栅格，然后在接下来的步骤里在近似值的周围精确栅格。</p><p>一个通用办法是 3 步探测，用 3 次探测栅格；3 个运动向量和 3 个精确步骤来得到 15 次 15 个像素范围内的全面探测。</p><p>对于分块运动估计，一个块的像素预测误差和它的附近搭接块，根据此前自乘的窗函数，都被测重和求和。</p><p>分块运动估计最主要的缺点是增加计算的复杂性，和实际的预测误差，因而最优向量依靠于临近运动块向量。</p><p>因此，没有一个多项式（计算的复杂性）算法可以保证最优运动向量。</p><p>然而，在可接受的计算的复杂性上，存在最接近最理想迭代和非迭代方法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://zh.wikipedia.org/wiki/%E8%BF%90%E5%8A%A8%E8%A1%A5%E5%81%BF">运动补偿 - 维基百科，自由的百科全书</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;运动补偿是一种描述相邻帧（相邻在这里表示在编码关系上相邻，在播放顺序上两帧未必相邻）差别的方法，具体来说是描述前面一帧（相邻在这里表示在编码关系上的前面，在播放顺序上未必在当前帧前面）的每个小块怎样移动到当前帧中的某个位置去。这种方法经常被视频压缩 / 视频编解码器用来减少视频序列中的时域冗余。它也可以用来进行去交织（deinterlacing）以及运动插值（motion interpolation）的操作。&lt;/p&gt;</summary>
    
    
    
    <category term="编解码技术" scheme="http://github.hezhaojiang.io/categories/%E7%BC%96%E8%A7%A3%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="H.264" scheme="http://github.hezhaojiang.io/tags/H-264/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 x264 - 运动补偿</title>
    <link href="http://github.hezhaojiang.io/post/2021/83dc3ab7/"/>
    <id>http://github.hezhaojiang.io/post/2021/83dc3ab7/</id>
    <published>2021-01-22T06:52:43.000Z</published>
    <updated>2021-02-04T16:46:01.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要记录 <code>x264</code> 中的 <code>x264_mc_init</code> 函数，该函数主要对 <code>x264_mc_functions_t</code> 结构体中的函数指针进行赋值， 完成了像素内插、拷贝、求平均的等运动补偿相关函数的初始化。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_mc_init</span><span class="params">(<span class="keyword">uint32_t</span> cpu, <span class="keyword">x264_mc_functions_t</span> *pf, <span class="keyword">int</span> cpu_independent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pf-&gt;mc_luma   = mc_luma;</span><br><span class="line">    pf-&gt;get_ref   = get_ref;</span><br><span class="line"></span><br><span class="line">    pf-&gt;mc_chroma = mc_chroma;</span><br><span class="line"></span><br><span class="line">    pf-&gt;avg[PIXEL_16x16]= pixel_avg_16x16;</span><br><span class="line">    pf-&gt;avg[PIXEL_16x8] = pixel_avg_16x8;</span><br><span class="line">    pf-&gt;avg[PIXEL_8x16] = pixel_avg_8x16;</span><br><span class="line">    pf-&gt;avg[PIXEL_8x8]  = pixel_avg_8x8;</span><br><span class="line">    pf-&gt;avg[PIXEL_8x4]  = pixel_avg_8x4;</span><br><span class="line">    pf-&gt;avg[PIXEL_4x16] = pixel_avg_4x16;</span><br><span class="line">    pf-&gt;avg[PIXEL_4x8]  = pixel_avg_4x8;</span><br><span class="line">    pf-&gt;avg[PIXEL_4x4]  = pixel_avg_4x4;</span><br><span class="line">    pf-&gt;avg[PIXEL_4x2]  = pixel_avg_4x2;</span><br><span class="line">    pf-&gt;avg[PIXEL_2x8]  = pixel_avg_2x8;</span><br><span class="line">    pf-&gt;avg[PIXEL_2x4]  = pixel_avg_2x4;</span><br><span class="line">    pf-&gt;avg[PIXEL_2x2]  = pixel_avg_2x2;</span><br><span class="line"></span><br><span class="line">    pf-&gt;weight    = mc_weight_wtab;</span><br><span class="line">    pf-&gt;offsetadd = mc_weight_wtab;</span><br><span class="line">    pf-&gt;offsetsub = mc_weight_wtab;</span><br><span class="line">    pf-&gt;weight_cache = weight_cache;</span><br><span class="line"></span><br><span class="line">    pf-&gt;copy_16x16_unaligned = mc_copy_w16;</span><br><span class="line">    pf-&gt;copy[PIXEL_16x16] = mc_copy_w16;</span><br><span class="line">    pf-&gt;copy[PIXEL_8x8]   = mc_copy_w8;</span><br><span class="line">    pf-&gt;copy[PIXEL_4x4]   = mc_copy_w4;</span><br><span class="line"></span><br><span class="line">    pf-&gt;store_interleave_chroma       = store_interleave_chroma;</span><br><span class="line">    pf-&gt;load_deinterleave_chroma_fenc = load_deinterleave_chroma_fenc;</span><br><span class="line">    pf-&gt;load_deinterleave_chroma_fdec = load_deinterleave_chroma_fdec;</span><br><span class="line"></span><br><span class="line">    pf-&gt;plane_copy = x264_plane_copy_c;</span><br><span class="line">    pf-&gt;plane_copy_swap = x264_plane_copy_swap_c;</span><br><span class="line">    pf-&gt;plane_copy_interleave = x264_plane_copy_interleave_c;</span><br><span class="line"></span><br><span class="line">    pf-&gt;plane_copy_deinterleave = x264_plane_copy_deinterleave_c;</span><br><span class="line">    pf-&gt;plane_copy_deinterleave_yuyv = x264_plane_copy_deinterleave_c;</span><br><span class="line">    pf-&gt;plane_copy_deinterleave_rgb = plane_copy_deinterleave_rgb_c;</span><br><span class="line">    pf-&gt;plane_copy_deinterleave_v210 = plane_copy_deinterleave_v210_c;</span><br><span class="line"></span><br><span class="line">    pf-&gt;hpel_filter = hpel_filter;</span><br><span class="line"></span><br><span class="line">    pf-&gt;prefetch_fenc_400 = prefetch_fenc_null;</span><br><span class="line">    pf-&gt;prefetch_fenc_420 = prefetch_fenc_null;</span><br><span class="line">    pf-&gt;prefetch_fenc_422 = prefetch_fenc_null;</span><br><span class="line">    pf-&gt;prefetch_ref  = prefetch_ref_null;</span><br><span class="line">    pf-&gt;memcpy_aligned = <span class="built_in">memcpy</span>;</span><br><span class="line">    pf-&gt;memzero_aligned = memzero_aligned;</span><br><span class="line">    pf-&gt;frame_init_lowres_core = frame_init_lowres_core;</span><br><span class="line"></span><br><span class="line">    pf-&gt;integral_init4h = integral_init4h;</span><br><span class="line">    pf-&gt;integral_init8h = integral_init8h;</span><br><span class="line">    pf-&gt;integral_init4v = integral_init4v;</span><br><span class="line">    pf-&gt;integral_init8v = integral_init8v;</span><br><span class="line"></span><br><span class="line">    pf-&gt;mbtree_propagate_cost = mbtree_propagate_cost;</span><br><span class="line">    pf-&gt;mbtree_propagate_list = mbtree_propagate_list;</span><br><span class="line">    pf-&gt;mbtree_fix8_pack      = mbtree_fix8_pack;</span><br><span class="line">    pf-&gt;mbtree_fix8_unpack    = mbtree_fix8_unpack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处省略台的汇编函数初始化代码 */</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于运动估计和运动补偿在 <code>x264</code> 中属于相对复杂的环节，其中许多函数的作用很难三言两语表述出来，因此只分析两个相对重要的例子：</p><ol><li>半像素内插函数 <code>hpel_filter()</code></li><li>获取亚像素数据的函数 <code>get_ref()</code></li></ol><h2 id="半像素内插函数"><a href="#半像素内插函数" class="headerlink" title="半像素内插函数"></a>半像素内插函数</h2><p><code>hpel_filter()</code> 用于进行半像素插值，函数定义如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 半像素插值公式</span></span><br><span class="line"><span class="comment">// b = (E - 5F + 20G + 20H - 5I + J) / 32</span></span><br><span class="line"><span class="comment">// d 取 1，水平滤波器</span></span><br><span class="line"><span class="comment">// d 取 stride，垂直滤波器（这里没有除以 32）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAPFILTER(pix, d) ((pix)[x-2*d] + (pix)[x+3*d] - 5*((pix)[x-d] + (pix)[x+2*d]) + 20*((pix)[x] + (pix)[x+d]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x &gt; 0 return 0;</span></span><br><span class="line"><span class="comment">// 0 &lt;= x &lt;= 255 return x;</span></span><br><span class="line"><span class="comment">// x &gt; 255 return 255;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ALWAYS_INLINE pixel <span class="title">x264_clip_pixel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x &amp; ~PIXEL_MAX) ? (-x)&gt;&gt;<span class="number">31</span> &amp; PIXEL_MAX : x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 半像素插值</span></span><br><span class="line"><span class="comment"> * dsth : 水平滤波得到的半像素点 (aa,bb,b,s,gg,hh)</span></span><br><span class="line"><span class="comment"> * dstv : 垂直滤波的到的半像素点 (cc,dd,h,m,ee,ff)</span></span><br><span class="line"><span class="comment"> * dstc : &quot;水平 + 垂直&quot; 滤波得到的位于 4 个像素中间的半像素点（j）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hpel_filter</span><span class="params">( pixel *dsth, pixel *dstv, pixel *dstc, pixel *src,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">intptr_t</span> stride, <span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int16_t</span> *buf )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> pad = (BIT_DEPTH&gt; <span class="number">9</span>) ? (<span class="number">-10</span> * PIXEL_MAX) : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 几种半像素点之间的位置关系</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * X : 像素点</span></span><br><span class="line"><span class="comment">     * H : 水平滤波半像素点</span></span><br><span class="line"><span class="comment">     * V : 垂直滤波半像素点</span></span><br><span class="line"><span class="comment">     * C : 中间位置半像素点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * X   H   X       X       X</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * V   C</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * X       X       X       X</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * X       X       X       X</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 一行一行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">-2</span>; x &lt; <span class="built_in">width</span> + <span class="number">3</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = TAPFILTER(src,stride);</span><br><span class="line">            dstv[x] = x264_clip_pixel( (v + <span class="number">16</span>) &gt;&gt; <span class="number">5</span> );</span><br><span class="line">            <span class="comment">/* transform v for storage in a 16-bit integer */</span></span><br><span class="line">            buf[x+<span class="number">2</span>] = v + pad;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)</span><br><span class="line">            dstc[x] = x264_clip_pixel( (TAPFILTER(buf+<span class="number">2</span>,<span class="number">1</span>) - <span class="number">32</span>*pad + <span class="number">512</span>) &gt;&gt; <span class="number">10</span> );</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)</span><br><span class="line">            dsth[x] = x264_clip_pixel( (TAPFILTER(src,<span class="number">1</span>) + <span class="number">16</span>) &gt;&gt; <span class="number">5</span> );</span><br><span class="line">        dsth += stride;</span><br><span class="line">        dstv += stride;</span><br><span class="line">        dstc += stride;</span><br><span class="line">        src  += stride;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>半像素插值示意图如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210123210246.png" alt="半像素插值示意图"></p><p>半像素点的计算关系如下：</p><ul><li>m : 由 B、D、H、N、S、U 计算</li><li>h : 由 A、C、G、M、R、T 计算</li><li>s : 由 K、L、M、N、P、Q 计算</li><li>j : 由 cc、dd、h、m、ee、ff 计算。需要注意 j 点的运算量比较大，因为 cc、dd、ee、ff 都需要通过半像素内插方法进行计算。</li></ul><h2 id="获取亚像素数据"><a href="#获取亚像素数据" class="headerlink" title="获取亚像素数据"></a>获取亚像素数据</h2><p><code>get_ref()</code> 函数用于获取亚像素数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> x264_hpel_ref0[<span class="number">16</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> x264_hpel_ref1[<span class="number">16</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运动矢量中亚像素的部分的数据</span></span><br><span class="line"><span class="comment">// 可以是半像素数据或者 1/4 像素数据</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> pixel *<span class="title">get_ref</span><span class="params">( pixel *dst,   <span class="keyword">intptr_t</span> *i_dst_stride,</span></span></span><br><span class="line"><span class="function"><span class="params">                       pixel *src[<span class="number">4</span>], <span class="keyword">intptr_t</span> i_src_stride,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> mvx, <span class="keyword">int</span> mvy,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> i_width, <span class="keyword">int</span> i_height, <span class="keyword">const</span> <span class="keyword">x264_weight_t</span> *weight )</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * qpel_idx 为 hpel_ref0[]，hpel_ref1[] 的索引值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 运动矢量 (mvy,mvx) 位置和 qpel_idx 对应关系如下</span></span><br><span class="line"><span class="comment">     *  0pixel |   0p   | 1/4p   | 1/2p   | 3/4p   | 1pixel |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *      0p | 0&lt;&lt;2+0 | 0&lt;&lt;2+1 | 0&lt;&lt;2+2 | 0&lt;&lt;2+3 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *    1/4p | 1&lt;&lt;2+0 | 1&lt;&lt;2+1 | 1&lt;&lt;2+2 | 1&lt;&lt;2+3 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *    1/2p | 2&lt;&lt;2+0 | 2&lt;&lt;2+1 | 2&lt;&lt;2+2 | 2&lt;&lt;2+3 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *    3/4p | 3&lt;&lt;2+0 | 3&lt;&lt;2+1 | 3&lt;&lt;2+2 | 3&lt;&lt;2+3 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *  1pixel |</span></span><br><span class="line"><span class="comment">     * --------+</span></span><br><span class="line"><span class="comment">     * 计算出来后</span></span><br><span class="line"><span class="comment">     *  0pixel |   0p   | 1/4p   | 1/2p   | 3/4p   | 1pixel |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *      0p |      0 |      1 |      2 |      3 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *    1/4p |      4 |      5 |      6 |      7 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *    1/2p |      8 |      9 |     10 |     11 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *    3/4p |     12 |     13 |     14 |     15 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *  1pixel |</span></span><br><span class="line"><span class="comment">     * --------+</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> qpel_idx = ((mvy&amp;<span class="number">3</span>)&lt;&lt;<span class="number">2</span>) + (mvx&amp;<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// offset 是匹配块相对当前宏块的整数偏移量</span></span><br><span class="line">    <span class="keyword">int</span> offset = (mvy&gt;&gt;<span class="number">2</span>)*i_src_stride + (mvx&gt;&gt;<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// src[4] 中有 4 个分量，分别代表：整像素点 Full，水平半像素点 H，垂直半像素点 V，对角线半像素点 C 的取值</span></span><br><span class="line">    <span class="comment">// 几种半像素点的值已经提前计算出来，而 1/4 像素点的值则是临时计算</span></span><br><span class="line">    <span class="comment">// 注意上述几种半像素点是按照 &quot;分量&quot; 的方式存储的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// src1[] 为选择后的半像素数据</span></span><br><span class="line">    <span class="comment">// 选择了 Full,H,V,C 几种 &quot;分量&quot; 中的 1 种</span></span><br><span class="line">    pixel *src1 = src[x264_hpel_ref0[qpel_idx]] + offset + ((mvy&amp;<span class="number">3</span>) == <span class="number">3</span>) * i_src_stride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// qpel_idx &amp; 5，5 是 0101， 代表 qpel_idx 最后 1 位（对应 x 分量）为 1 或者倒数第 3 位为 1（对应 y 分量）</span></span><br><span class="line">    <span class="comment">// 即 x 或者 y 中有 1/4 或者 3/4 像素点（此时需要 1/4 像素内插）</span></span><br><span class="line">    <span class="comment">// 只有需要 1/4 内插的点才会 qpel_idx &amp; 5!=0。这时候需要通过线性内插获得 1/4 像素点的值</span></span><br><span class="line">    <span class="keyword">if</span> (qpel_idx &amp; <span class="number">5</span>) <span class="comment">/* qpel interpolation needed */</span> &#123;</span><br><span class="line">        <span class="comment">// src2[] 为用于内插的数据另一组数据</span></span><br><span class="line">        pixel *src2 = src[x264_hpel_ref1[qpel_idx]] + offset + ((mvx&amp;<span class="number">3</span>) == <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 进行 1/4 像素线性内插</span></span><br><span class="line">        pixel_avg( dst, *i_dst_stride, src1, i_src_stride,</span><br><span class="line">                   src2, i_src_stride, i_width, i_height );</span><br><span class="line">        <span class="keyword">if</span> (weight-&gt;weightfn )</span><br><span class="line">            mc_weight(dst, *i_dst_stride, dst, *i_dst_stride, weight, i_width, i_height);</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weight-&gt;weightfn ) &#123;</span><br><span class="line">        mc_weight(dst, *i_dst_stride, src1, i_src_stride, weight, i_width, i_height);</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *i_dst_stride = i_src_stride; <span class="comment">// 只需要半像素滤波</span></span><br><span class="line">        <span class="keyword">return</span> src1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要记录 &lt;code&gt;x264&lt;/code&gt; 中的 &lt;code&gt;x264_mc_init&lt;/code&gt; 函数，该函数主要对 &lt;code&gt;x264_mc_functions_t&lt;/code&gt; 结构体中的函数指针进行赋值， 完成了像素内插、拷贝、求平均的等运动补偿相关函数的初始化。&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="x264" scheme="http://github.hezhaojiang.io/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 x264 - 离散余弦变换</title>
    <link href="http://github.hezhaojiang.io/post/2021/f0753f9a/"/>
    <id>http://github.hezhaojiang.io/post/2021/f0753f9a/</id>
    <published>2021-01-21T08:23:29.000Z</published>
    <updated>2021-01-30T12:55:55.530Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>x264</code> 中 <code>x264_dct_init</code> 函数中初始化了与离散余弦变换有关的函数，本文分析部分离散余弦变换函数的实现</p><a id="more"></a><p>DCT 变换的核心理念就是把图像的低频信息（对应大面积平坦区域）变换到系数矩阵的左上角，而把高频信息变换到系数矩阵的右下角，之后在压缩时就可以去除掉人眼不敏感的高频信息（位于矩阵右下角的系数），从而达到压缩数据的目的。</p><p>关于 DCT 的计算，都是通过 <code>x264_dct_init</code> 函数内定义的 <code>DCT</code> 和 <code>IDCT</code> 函数完成的，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_dct_init</span><span class="params">(<span class="keyword">uint32_t</span> cpu, <span class="keyword">x264_dct_function_t</span> *dctf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dctf-&gt;sub4x4_dct    = sub4x4_dct;</span><br><span class="line">    dctf-&gt;add4x4_idct   = add4x4_idct;</span><br><span class="line"></span><br><span class="line">    dctf-&gt;sub8x8_dct    = sub8x8_dct;</span><br><span class="line">    dctf-&gt;sub8x8_dct_dc = sub8x8_dct_dc;</span><br><span class="line">    dctf-&gt;add8x8_idct   = add8x8_idct;</span><br><span class="line">    dctf-&gt;add8x8_idct_dc = add8x8_idct_dc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处省略大量平台的汇编函数初始化代码 */</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h2 id="dct-函数命名规律"><a href="#dct-函数命名规律" class="headerlink" title="dct 函数命名规律"></a>dct 函数命名规律</h2><p>从源代码可以看出，<code>x264_dct_init()</code> 初始化了一系列的 <code>DCT</code> 变换的函数，这些 <code>DCT</code> 函数名称有如下规律：</p><ol><li><code>DCT</code> 函数名称前面有 <code>sub</code>，代表对两块像素相减得到残差之后，再进行 <code>DCT</code> 变换。</li><li><code>DCT</code> 反变换函数名称前面有 <code>add</code>，代表将 <code>DCT</code> 反变换之后的残差数据叠加到预测数据上。</li><li>以 <code>dct8</code> 为结尾的函数使用了 <code>8x8DCT</code>，其余函数是用的都是 <code>4x4DCT</code>。</li></ol><h2 id="sub4x4-dct"><a href="#sub4x4-dct" class="headerlink" title="sub4x4_dct"></a>sub4x4_dct</h2><p><code>sub4x4_dct()</code> 可以将两块 <code>4x4</code> 的图像相减求残差后，进行 <code>DCT</code> 变换，源代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 4x4 DCT 变换</span></span><br><span class="line"><span class="comment"> * 注意首先获取 pix1 和 pix2 两块数据的残差，然后再进行变换</span></span><br><span class="line"><span class="comment"> * 返回 dct[16]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sub4x4_dct</span><span class="params">(dctcoef dct[<span class="number">16</span>], pixel *pix1, pixel *pix2 )</span> </span>&#123;</span><br><span class="line">    dctcoef d[<span class="number">16</span>];</span><br><span class="line">    dctcoef tmp[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    pixel_sub_wxh(d, <span class="number">4</span>, pix1, FENC_STRIDE, pix2, FDEC_STRIDE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s03 = d[i*<span class="number">4</span>+<span class="number">0</span>] + d[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> s12 = d[i*<span class="number">4</span>+<span class="number">1</span>] + d[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> d03 = d[i*<span class="number">4</span>+<span class="number">0</span>] - d[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> d12 = d[i*<span class="number">4</span>+<span class="number">1</span>] - d[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        tmp[<span class="number">0</span>*<span class="number">4</span>+i] =   s03 +   s12;</span><br><span class="line">        tmp[<span class="number">1</span>*<span class="number">4</span>+i] = <span class="number">2</span>*d03 +   d12;</span><br><span class="line">        tmp[<span class="number">2</span>*<span class="number">4</span>+i] =   s03 -   s12;</span><br><span class="line">        tmp[<span class="number">3</span>*<span class="number">4</span>+i] =   d03 - <span class="number">2</span>*d12;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s03 = tmp[i*<span class="number">4</span>+<span class="number">0</span>] + tmp[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> s12 = tmp[i*<span class="number">4</span>+<span class="number">1</span>] + tmp[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> d03 = tmp[i*<span class="number">4</span>+<span class="number">0</span>] - tmp[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> d12 = tmp[i*<span class="number">4</span>+<span class="number">1</span>] - tmp[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        dct[i*<span class="number">4</span>+<span class="number">0</span>] =   s03 +   s12;</span><br><span class="line">        dct[i*<span class="number">4</span>+<span class="number">1</span>] = <span class="number">2</span>*d03 +   d12;</span><br><span class="line">        dct[i*<span class="number">4</span>+<span class="number">2</span>] =   s03 -   s12;</span><br><span class="line">        dct[i*<span class="number">4</span>+<span class="number">3</span>] =   d03 - <span class="number">2</span>*d12;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码中涉及函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 求残差用 注意求的是一个方块形像素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数的含义如下：</span></span><br><span class="line"><span class="comment"> * diff：输出的残差数据</span></span><br><span class="line"><span class="comment"> * i_size：方块的大小</span></span><br><span class="line"><span class="comment"> * pix1：输入数据 1</span></span><br><span class="line"><span class="comment"> * i_pix1：输入数据 1 一行像素大小（stride）</span></span><br><span class="line"><span class="comment"> * pix2：输入数据 2</span></span><br><span class="line"><span class="comment"> * i_pix2：输入数据 2 一行像素大小（stride）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pixel_sub_wxh</span><span class="params">( dctcoef *diff, <span class="keyword">int</span> i_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  pixel *pix1, <span class="keyword">int</span> i_pix1, pixel *pix2, <span class="keyword">int</span> i_pix2 )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; i_size; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; i_size; x++)</span><br><span class="line">            diff[x + y * i_size] = pix1[x] - pix2[x];</span><br><span class="line">        pix1 += i_pix1;</span><br><span class="line">        pix2 += i_pix2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add4x4-idct"><a href="#add4x4-idct" class="headerlink" title="add4x4_idct"></a>add4x4_idct</h2><p><code>add4x4_idct()</code> 可以将残差数据进行 <code>DCT</code> 反变换，并将变换后得到的残差像素数据叠加到预测数据上，源代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ALWAYS_INLINE pixel <span class="title">x264_clip_pixel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x &amp; ~PIXEL_MAX) ? (-x)&gt;&gt;<span class="number">31</span> &amp; PIXEL_MAX : x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add4x4_idct</span><span class="params">(pixel *p_dst, dctcoef dct[<span class="number">16</span>] )</span> </span>&#123;</span><br><span class="line">    dctcoef d[<span class="number">16</span>];</span><br><span class="line">    dctcoef tmp[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s02 =  dct[<span class="number">0</span>*<span class="number">4</span>+i]     +  dct[<span class="number">2</span>*<span class="number">4</span>+i];</span><br><span class="line">        <span class="keyword">int</span> d02 =  dct[<span class="number">0</span>*<span class="number">4</span>+i]     -  dct[<span class="number">2</span>*<span class="number">4</span>+i];</span><br><span class="line">        <span class="keyword">int</span> s13 =  dct[<span class="number">1</span>*<span class="number">4</span>+i]     + (dct[<span class="number">3</span>*<span class="number">4</span>+i]&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> d13 = (dct[<span class="number">1</span>*<span class="number">4</span>+i]&gt;&gt;<span class="number">1</span>) -  dct[<span class="number">3</span>*<span class="number">4</span>+i];</span><br><span class="line"></span><br><span class="line">        tmp[i*<span class="number">4</span>+<span class="number">0</span>] = s02 + s13;</span><br><span class="line">        tmp[i*<span class="number">4</span>+<span class="number">1</span>] = d02 + d13;</span><br><span class="line">        tmp[i*<span class="number">4</span>+<span class="number">2</span>] = d02 - d13;</span><br><span class="line">        tmp[i*<span class="number">4</span>+<span class="number">3</span>] = s02 - s13;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s02 =  tmp[<span class="number">0</span>*<span class="number">4</span>+i]     +  tmp[<span class="number">2</span>*<span class="number">4</span>+i];</span><br><span class="line">        <span class="keyword">int</span> d02 =  tmp[<span class="number">0</span>*<span class="number">4</span>+i]     -  tmp[<span class="number">2</span>*<span class="number">4</span>+i];</span><br><span class="line">        <span class="keyword">int</span> s13 =  tmp[<span class="number">1</span>*<span class="number">4</span>+i]     + (tmp[<span class="number">3</span>*<span class="number">4</span>+i]&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> d13 = (tmp[<span class="number">1</span>*<span class="number">4</span>+i]&gt;&gt;<span class="number">1</span>) -  tmp[<span class="number">3</span>*<span class="number">4</span>+i];</span><br><span class="line"></span><br><span class="line">        d[<span class="number">0</span>*<span class="number">4</span>+i] = ( s02 + s13 + <span class="number">32</span> ) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">        d[<span class="number">1</span>*<span class="number">4</span>+i] = ( d02 + d13 + <span class="number">32</span> ) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">        d[<span class="number">2</span>*<span class="number">4</span>+i] = ( d02 - d13 + <span class="number">32</span> ) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">        d[<span class="number">3</span>*<span class="number">4</span>+i] = ( s02 - s13 + <span class="number">32</span> ) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++)</span><br><span class="line">            p_dst[x] = x264_clip_pixel( p_dst[x] + d[y*<span class="number">4</span>+x] );</span><br><span class="line">        p_dst += FDEC_STRIDE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li><li>[2] <a href="http://lazybing.github.io/blog/2017/07/10/x264-dct-init/">X264 源码解析之 x264_dct_init 函数 - 懒人李冰</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;x264&lt;/code&gt; 中 &lt;code&gt;x264_dct_init&lt;/code&gt; 函数中初始化了与离散余弦变换有关的函数，本文分析部分离散余弦变换函数的实现&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="x264" scheme="http://github.hezhaojiang.io/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 x264 - 代价计算</title>
    <link href="http://github.hezhaojiang.io/post/2021/ae3a0f38/"/>
    <id>http://github.hezhaojiang.io/post/2021/ae3a0f38/</id>
    <published>2021-01-21T06:43:32.000Z</published>
    <updated>2021-01-30T12:55:55.530Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>x264</code> 中 <code>x264_pixel_init</code> 函数中初始化了与代价计算有关的函数，本文分析部分代价计算函数的实现，包括 <code>SAD</code>、<code>SATD</code>、<code>SSD</code>、等</p><ul><li>SAD (Sum of Absolute Difference) = SAE(Sum of Absolute Error) 绝对误差和</li><li>SATD（Sum of Absolute Transformed Difference）即 hadamard 变换后再绝对值求和</li><li>SSD（Sum of Squared Difference）= SSE（Sum of Squared Error) 差值的平方和</li><li>MAD（Mean Absolute Difference）= MAE（Mean Absolute Error) 平均绝对差值</li><li>MSD（Mean Squared Difference）= MSE（Mean Squared Error）平均平方误差</li></ul><a id="more"></a><p>下面分别介绍 <code>SAD</code>、<code>SSD</code>、<code>SATD</code> 的实现过程。</p><h2 id="SAD-实现过程"><a href="#SAD-实现过程" class="headerlink" title="SAD 实现过程"></a>SAD 实现过程</h2><p>将 <code>x264_pixel_init</code> 函数中的 INIT8(sad,) 展开，可以得到如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pixf-&gt;sad[PIXEL_16x16] = x264_pixel_sad_16x16;</span><br><span class="line">pixf-&gt;sad[PIXEL_16x8]  = x264_pixel_sad_16x8;</span><br><span class="line">pixf-&gt;sad[PIXEL_8x16]  = x264_pixel_sad_8x16;</span><br><span class="line">pixf-&gt;sad[PIXEL_8x8]   = x264_pixel_sad_8x8;</span><br><span class="line">pixf-&gt;sad[PIXEL_8x4]   = x264_pixel_sad_8x4;</span><br><span class="line">pixf-&gt;sad[PIXEL_4x8]   = x264_pixel_sad_4x8;</span><br><span class="line">pixf-&gt;sad[PIXEL_4x4]   = x264_pixel_sad_4x4;</span><br><span class="line">pixf-&gt;sad[PIXEL_4x16]  = x264_pixel_sad_4x16;</span><br></pre></td></tr></table></figure><p>我们选取其中最简单的 <code>x264_pixel_sad_4x4</code> 继续展开，它是通过一个宏来定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_SAD_C(name, lx, ly) \</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">name</span><span class="params">( pixel *pix1, <span class="keyword">intptr_t</span> i_stride_pix1,  \</span></span></span><br><span class="line">                 pixel *pix2, intptr_t i_stride_pix2 ) \</span><br><span class="line">&#123;                                                   \</span><br><span class="line">    <span class="keyword">int</span> i_sum = <span class="number">0</span>;                                  \</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; ly; y++)                   \</span><br><span class="line">    &#123;                                               \</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; lx; x++)               \</span><br><span class="line">        &#123;                                           \</span><br><span class="line">            i_sum += <span class="built_in">abs</span>(pix1[x] - pix2[x] );      \</span><br><span class="line">        &#125;                                           \</span><br><span class="line">        pix1 += i_stride_pix1;                      \</span><br><span class="line">        pix2 += i_stride_pix2;                      \</span><br><span class="line">    &#125;                                               \</span><br><span class="line">    <span class="keyword">return</span> i_sum;                                   \</span><br><span class="line">&#125;</span><br><span class="line">PIXEL_SAD_C(x264_pixel_sad_4x4, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">/* 展开宏定义如下 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">x264_pixel_sad_4x4</span><span class="params">(<span class="keyword">uint8_t</span> *pix1, <span class="keyword">intptr_t</span> i_stride_pix1, <span class="keyword">uint8_t</span> *pix2, <span class="keyword">intptr_t</span> i_stride_pix2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">            i_sum += <span class="built_in">abs</span>(pix1[x] - pix2[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        pix1 += i_stride_pix1;</span><br><span class="line">        pix2 += i_stride_pix2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SSD-实现过程"><a href="#SSD-实现过程" class="headerlink" title="SSD 实现过程"></a>SSD 实现过程</h2><p>将 <code>x264_pixel_init</code> 函数中的 <code>INIT8(ssd,)</code> 展开，可以得到如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pixf-&gt;ssd[PIXEL_16x16] = x264_pixel_ssd_16x16;</span><br><span class="line">pixf-&gt;ssd[PIXEL_16x8]  = x264_pixel_ssd_16x8;</span><br><span class="line">pixf-&gt;ssd[PIXEL_8x16]  = x264_pixel_ssd_8x16;</span><br><span class="line">pixf-&gt;ssd[PIXEL_8x8]   = x264_pixel_ssd_8x8;</span><br><span class="line">pixf-&gt;ssd[PIXEL_8x4]   = x264_pixel_ssd_8x4;</span><br><span class="line">pixf-&gt;ssd[PIXEL_4x8]   = x264_pixel_ssd_4x8;</span><br><span class="line">pixf-&gt;ssd[PIXEL_4x4]   = x264_pixel_ssd_4x4;</span><br><span class="line">pixf-&gt;ssd[PIXEL_4x16]  = x264_pixel_ssd_4x16;</span><br></pre></td></tr></table></figure><p>我们选取其中最简单的 <code>x264_pixel_ssd_4x4</code> 继续展开，它也是通过一个宏来定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_SSD_C(name, lx, ly) \</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">x264_pixel_ssd_4x4</span><span class="params">( pixel *pix1, <span class="keyword">intptr_t</span> i_stride_pix1,  \</span></span></span><br><span class="line">                 pixel *pix2, intptr_t i_stride_pix2 ) \</span><br><span class="line">&#123;                                                   \</span><br><span class="line">    <span class="keyword">int</span> i_sum = <span class="number">0</span>;                                  \</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; ly; y++)                   \</span><br><span class="line">    &#123;                                               \</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; lx; x++)               \</span><br><span class="line">        &#123;                                           \</span><br><span class="line">            <span class="keyword">int</span> d = pix1[x] - pix2[x];              \</span><br><span class="line">            i_sum += d*d;                           \</span><br><span class="line">        &#125;                                           \</span><br><span class="line">        pix1 += i_stride_pix1;                      \</span><br><span class="line">        pix2 += i_stride_pix2;                      \</span><br><span class="line">    &#125;                                               \</span><br><span class="line">    <span class="keyword">return</span> i_sum;                                   \</span><br><span class="line">&#125;</span><br><span class="line">PIXEL_SSD_C(x264_pixel_ssd_4x4, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">/* 展开宏定义如下 */</span></span><br><span class="line"><span class="function">tatic <span class="keyword">int</span> <span class="title">name</span><span class="params">(<span class="keyword">uint8_t</span> *pix1, <span class="keyword">intptr_t</span> i_stride_pix1, <span class="keyword">uint8_t</span> *pix2, <span class="keyword">intptr_t</span> i_stride_pix2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = pix1[x] - pix2[x];</span><br><span class="line">            i_sum += d*d;</span><br><span class="line">        &#125;</span><br><span class="line">        pix1 += i_stride_pix1;</span><br><span class="line">        pix2 += i_stride_pix2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SATD-实现过程"><a href="#SATD-实现过程" class="headerlink" title="SATD 实现过程"></a>SATD 实现过程</h2><p>将 <code>x264_pixel_init</code> 函数中的 <code>INIT8(satd,)</code> 展开，可以得到如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pixf-&gt;satd[PIXEL_16x16] = x264_pixel_satd_16x16;</span><br><span class="line">pixf-&gt;satd[PIXEL_16x8]  = x264_pixel_satd_16x8;</span><br><span class="line">pixf-&gt;satd[PIXEL_8x16]  = x264_pixel_satd_8x16;</span><br><span class="line">pixf-&gt;satd[PIXEL_8x8]   = x264_pixel_satd_8x8;</span><br><span class="line">pixf-&gt;satd[PIXEL_8x4]   = x264_pixel_satd_8x4;</span><br><span class="line">pixf-&gt;satd[PIXEL_4x8]   = x264_pixel_satd_4x8;</span><br><span class="line">pixf-&gt;satd[PIXEL_4x4]   = x264_pixel_satd_4x4;</span><br><span class="line">pixf-&gt;satd[PIXEL_4x16]  = x264_pixel_satd_4x16;</span><br></pre></td></tr></table></figure><p>同样，选取最简单的 <code>x264_pixel_satd_4x4</code> 继续展开，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint8_t</span>  pixel;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">sum_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">sum2_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_SUM (8 * sizeof(sum_t))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HADAMARD4(d0, d1, d2, d3, s0, s1, s2, s3) &#123;\</span></span><br><span class="line">    <span class="keyword">sum2_t</span> t0 = s0 + s1;\</span><br><span class="line">    <span class="keyword">sum2_t</span> t1 = s0 - s1;\</span><br><span class="line">    <span class="keyword">sum2_t</span> t2 = s2 + s3;\</span><br><span class="line">    <span class="keyword">sum2_t</span> t3 = s2 - s3;\</span><br><span class="line">    d0 = t0 + t2;\</span><br><span class="line">    d2 = t0 - t2;\</span><br><span class="line">    d1 = t1 + t3;\</span><br><span class="line">    d3 = t1 - t3;\</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> NOINLINE <span class="keyword">int</span> <span class="title">x264_pixel_satd_4x4</span><span class="params">(pixel *pix1, <span class="keyword">intptr_t</span> i_pix1, pixel *pix2, <span class="keyword">intptr_t</span> i_pix2 )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sum2_t</span> tmp[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">sum2_t</span> a0, a1, a2, a3, b0, b1;</span><br><span class="line">    <span class="keyword">sum2_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++, pix1 += i_pix1, pix2 += i_pix2 ) &#123;</span><br><span class="line">        a0 = pix1[<span class="number">0</span>] - pix2[<span class="number">0</span>];</span><br><span class="line">        a1 = pix1[<span class="number">1</span>] - pix2[<span class="number">1</span>];</span><br><span class="line">        b0 = (a0+a1) + ((a0-a1)&lt;&lt;BITS_PER_SUM);</span><br><span class="line">        a2 = pix1[<span class="number">2</span>] - pix2[<span class="number">2</span>];</span><br><span class="line">        a3 = pix1[<span class="number">3</span>] - pix2[<span class="number">3</span>];</span><br><span class="line">        b1 = (a2+a3) + ((a2-a3)&lt;&lt;BITS_PER_SUM);</span><br><span class="line">        tmp[i][<span class="number">0</span>] = b0 + b1;</span><br><span class="line">        tmp[i][<span class="number">1</span>] = b0 - b1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ ) &#123;</span><br><span class="line">        HADAMARD4( a0, a1, a2, a3, tmp[<span class="number">0</span>][i], tmp[<span class="number">1</span>][i], tmp[<span class="number">2</span>][i], tmp[<span class="number">3</span>][i] );</span><br><span class="line">        a0 = abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);</span><br><span class="line">        sum += ((<span class="keyword">sum_t</span>)a0) + (a0&gt;&gt;BITS_PER_SUM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li><li>[2] <a href="http://lazybing.github.io/blog/2017/07/08/x264-pixel-init-function/">X264 源码解析之 x264_pixel_init 函数 - 懒人李冰</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;x264&lt;/code&gt; 中 &lt;code&gt;x264_pixel_init&lt;/code&gt; 函数中初始化了与代价计算有关的函数，本文分析部分代价计算函数的实现，包括 &lt;code&gt;SAD&lt;/code&gt;、&lt;code&gt;SATD&lt;/code&gt;、&lt;code&gt;SSD&lt;/code&gt;、等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SAD (Sum of Absolute Difference) = SAE(Sum of Absolute Error) 绝对误差和&lt;/li&gt;
&lt;li&gt;SATD（Sum of Absolute Transformed Difference）即 hadamard 变换后再绝对值求和&lt;/li&gt;
&lt;li&gt;SSD（Sum of Squared Difference）= SSE（Sum of Squared Error) 差值的平方和&lt;/li&gt;
&lt;li&gt;MAD（Mean Absolute Difference）= MAE（Mean Absolute Error) 平均绝对差值&lt;/li&gt;
&lt;li&gt;MSD（Mean Squared Difference）= MSE（Mean Squared Error）平均平方误差&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="x264" scheme="http://github.hezhaojiang.io/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读 x264 - 帧内预测</title>
    <link href="http://github.hezhaojiang.io/post/2021/b66cfff2/"/>
    <id>http://github.hezhaojiang.io/post/2021/b66cfff2/</id>
    <published>2021-01-19T06:06:39.000Z</published>
    <updated>2021-02-04T16:46:01.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文分析 <code>x264</code> 库中的帧内预测的 <code>C</code> 语言函数。</p><a id="more"></a><h2 id="16x16-预测"><a href="#16x16-预测" class="headerlink" title="16x16 预测"></a>16x16 预测</h2><p><code>x264</code> 代码通过 <code>x264_predict_16x16_init()</code> 函数初始化 <code>Intra16x16</code> 帧内预测汇编函数，初始化的预测模式如下：</p><div class="table-container"><table><thead><tr><th><code>intra16x16Predmode</code></th><th><code>Name of Intra16x16PredMode</code></th><th><code>Note</code></th><th><code>Function</code></th></tr></thead><tbody><tr><td><code>0</code></td><td><code>Intra_16x16_Vertical</code></td><td>由上边像素推出相应像素值</td><td><code>x264_predict_16x16_v_c</code></td></tr><tr><td><code>1</code></td><td><code>Intra_16x16_Horicontal</code></td><td>由左边像素推出相应像素值</td><td><code>x264_predict_16x16_h_c</code></td></tr><tr><td><code>2</code></td><td><code>Intra_16x16_DC</code></td><td>由上边和左边像素平均值推出相应像素值</td><td><code>x264_predict_16x16_dc_c</code></td></tr><tr><td><code>3</code></td><td><code>Intra_16x16_Plane</code></td><td>利用线性 plan 函数及左、上像素推出相应像素值，适用于亮度变化平缓区域</td><td><code>x264_predict_16x16_p_c</code></td></tr></tbody></table></div><h3 id="Intra-16x16-Vertical"><a href="#Intra-16x16-Vertical" class="headerlink" title="Intra_16x16_Vertical"></a>Intra_16x16_Vertical</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121220616.png" alt="Intra_16x16_Vertical"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Vertical</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* common/predict.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_16x16_v_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pixel4 实际上是 uint32_t（占用 32bit），存储 4 个像素的值（每个像素占用 8bit）</span></span><br><span class="line">    pixel4 v0 = MPIXEL_X4(&amp;src[ <span class="number">0</span> - FDEC_STRIDE]);</span><br><span class="line">    pixel4 v1 = MPIXEL_X4(&amp;src[ <span class="number">4</span> - FDEC_STRIDE]);</span><br><span class="line">    pixel4 v2 = MPIXEL_X4(&amp;src[ <span class="number">8</span> - FDEC_STRIDE]);</span><br><span class="line">    pixel4 v3 = MPIXEL_X4(&amp;src[<span class="number">12</span> - FDEC_STRIDE]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Vertical 预测方式</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     * --+-----------</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * uint32_t v0 = ((x264_union32_t*)(&amp;src[ 0-FDEC_STRIDE]))-&gt;i;</span></span><br><span class="line"><span class="comment">     * uint32_t v1 = ((x264_union32_t*)(&amp;src[ 4-FDEC_STRIDE]))-&gt;i;</span></span><br><span class="line"><span class="comment">     * uint32_t v2 = ((x264_union32_t*)(&amp;src[ 8-FDEC_STRIDE]))-&gt;i;</span></span><br><span class="line"><span class="comment">     * uint32_t v3 = ((x264_union32_t*)(&amp;src[12-FDEC_STRIDE]))-&gt;i;</span></span><br><span class="line"><span class="comment">     * x264_union32_t 的定义如下：</span></span><br><span class="line"><span class="comment">     * typedef union &#123;uint64_t i; uint32_t d[2]; uint16_t w[4]; uint8_t b[8]; &#125; MAY_ALIAS x264_union64_t;</span></span><br><span class="line"><span class="comment">     * 即将一行 16 字节数据分成 4 次，每次取出 4 个像素（一共 16 个像素），分别赋值给 v0，v1，v2，v3</span></span><br><span class="line"><span class="comment">     * 取出的值源自于 16x16 块上面的一行像素</span></span><br><span class="line"><span class="comment">     *    0|          4          8          12         16</span></span><br><span class="line"><span class="comment">     *    ||    v0    |    v1    |    v2    |    v3    |</span></span><br><span class="line"><span class="comment">     * ---++==========+==========+==========+==========+</span></span><br><span class="line"><span class="comment">     *    ||</span></span><br><span class="line"><span class="comment">     *    ||</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        MPIXEL_X4(src +  <span class="number">0</span>) = v0;</span><br><span class="line">        MPIXEL_X4(src +  <span class="number">4</span>) = v1;</span><br><span class="line">        MPIXEL_X4(src +  <span class="number">8</span>) = v2;</span><br><span class="line">        MPIXEL_X4(src + <span class="number">12</span>) = v3;</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(src +  0))-&gt;i = v0;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(src +  4))-&gt;i = v1;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(src +  8))-&gt;i = v2;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(src + 12))-&gt;i = v3;</span></span><br><span class="line"><span class="comment">     * 即分成 4 次，每次赋值 4 个像素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        src += FDEC_STRIDE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-16x16-Horicontal"><a href="#Intra-16x16-Horicontal" class="headerlink" title="Intra_16x16_Horicontal"></a>Intra_16x16_Horicontal</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121220849.png" alt="Intra_16x16_Horicontal"></p><p><code>x264</code> 中关于模式 <code>Intra_16x16_Horicontal</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_SPLAT_X4(x) ((x)*0x01010101U)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_16x16_h_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">const</span> pixel4 v = PIXEL_SPLAT_X4( src[<span class="number">-1</span>] );</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">0</span> ) = v;</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">4</span> ) = v;</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">8</span> ) = v;</span><br><span class="line">        MPIXEL_X4( src+<span class="number">12</span> ) = v;</span><br><span class="line">        <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">         * uint32_t v = src[-1] * 0x01010101U;</span></span><br><span class="line"><span class="comment">         * ((x264_union32_t*)(src +  0))-&gt;i = v;</span></span><br><span class="line"><span class="comment">         * ((x264_union32_t*)(src +  4))-&gt;i = v;</span></span><br><span class="line"><span class="comment">         * ((x264_union32_t*)(src +  8))-&gt;i = v;</span></span><br><span class="line"><span class="comment">         * ((x264_union32_t*)(src + 12))-&gt;i = v;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        src += FDEC_STRIDE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-16x16-DC"><a href="#Intra-16x16-DC" class="headerlink" title="Intra_16x16_DC"></a>Intra_16x16_DC</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121222206.jpg" alt="Intra_16x16_DC"></p><p><code>x264</code> 中关于模式 <code>Intra_16x16_DC</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_16x16_DC(v)\</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ )\</span><br><span class="line">    &#123;\</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">0</span> ) = v;\</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">4</span> ) = v;\</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">8</span> ) = v;\</span><br><span class="line">        MPIXEL_X4( src+<span class="number">12</span> ) = v;\</span><br><span class="line">        src += FDEC_STRIDE;\</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_16x16_dc_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ ) &#123;</span><br><span class="line">        dc += src[<span class="number">-1</span> + i * FDEC_STRIDE];</span><br><span class="line">        dc += src[i - FDEC_STRIDE];</span><br><span class="line">    &#125;</span><br><span class="line">    pixel4 dcsplat = PIXEL_SPLAT_X4( ( dc + <span class="number">16</span> ) &gt;&gt; <span class="number">5</span> );</span><br><span class="line">    PREDICT_16x16_DC( dcsplat );</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * uint32_t dcsplat = ((dc + 16) &gt;&gt; 5) * 0x01010101U;</span></span><br><span class="line"><span class="comment">     * for ( int i = 0; i &lt; 16; i++ ) &#123;</span></span><br><span class="line"><span class="comment">     *     ((x264_union32_t*)(src +  0))-&gt;i = v;</span></span><br><span class="line"><span class="comment">     *     ((x264_union32_t*)(src +  4))-&gt;i = v;</span></span><br><span class="line"><span class="comment">     *     ((x264_union32_t*)(src +  8))-&gt;i = v;</span></span><br><span class="line"><span class="comment">     *     ((x264_union32_t*)(src + 12))-&gt;i = v;</span></span><br><span class="line"><span class="comment">     *     src += FDEC_STRIDE;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-16x16-Plane"><a href="#Intra-16x16-Plane" class="headerlink" title="Intra_16x16_Plane"></a>Intra_16x16_Plane</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121222712.png" alt="Intra_16x16_Plane"></p><p><code>x264</code> 中关于模式 <code>Intra_16x16_Plane</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_MAX 255</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ALWAYS_INLINE pixel <span class="title">x264_clip_pixel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x &amp; ~PIXEL_MAX) ? (-x)&gt;&gt;<span class="number">31</span> &amp; PIXEL_MAX : x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_16x16_p_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> H = <span class="number">0</span>, V = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calculate H and V */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">        H += (i + <span class="number">1</span>) * ( src[ <span class="number">8</span> + i - FDEC_STRIDE ] - src[<span class="number">6</span> - i - FDEC_STRIDE] );</span><br><span class="line">        V += (i + <span class="number">1</span>) * ( src[<span class="number">-1</span> + (<span class="number">8</span>+i) * FDEC_STRIDE] - src[<span class="number">-1</span> + (<span class="number">6</span>-i) * FDEC_STRIDE] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">16</span> * (src[<span class="number">-1</span> + <span class="number">15</span>*FDEC_STRIDE] + src[<span class="number">15</span> - FDEC_STRIDE] );</span><br><span class="line">    <span class="keyword">int</span> b = (<span class="number">5</span> * H + <span class="number">32</span>) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> c = (<span class="number">5</span> * V + <span class="number">32</span>) &gt;&gt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i00 = a - b * <span class="number">7</span> - c * <span class="number">7</span> + <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">16</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pix = i00;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">16</span>; x++) &#123;</span><br><span class="line">            src[x] = x264_clip_pixel( pix &gt;&gt; <span class="number">5</span> );</span><br><span class="line">            pix += b;</span><br><span class="line">        &#125;</span><br><span class="line">        src += FDEC_STRIDE;</span><br><span class="line">        i00 += c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4x4-预测"><a href="#4x4-预测" class="headerlink" title="4x4 预测"></a>4x4 预测</h2><p><code>x264</code> 中对 <code>4x4</code> 的预测模式如下：</p><div class="table-container"><table><thead><tr><th><code>Intra4x4PredMode[luma4x4BlkIdx]</code></th><th><code>Name of Intra4x4PredMode[luma4x4BlkIdx]</code></th><th><code>x264 Function</code></th></tr></thead><tbody><tr><td><code>0</code></td><td><code>Intra_4x4_Vertical</code></td><td><code>x264_predict_4x4_v_c()</code></td></tr><tr><td><code>1</code></td><td><code>Intra_4x4_Horizontal</code></td><td><code>x264_predict_4x4_h_c()</code></td></tr><tr><td><code>2</code></td><td><code>Intra_4x4_DC</code></td><td><code>x264_predict_4x4_dc_c()</code></td></tr><tr><td><code>3</code></td><td><code>Intra_4x4_Diagonal_Down_Left</code></td><td><code>predict_4x4_ddl_c()</code></td></tr><tr><td><code>4</code></td><td><code>Intra_4x4_Diagonal_Down_Right</code></td><td><code>predict_4x4_ddr_c()</code></td></tr><tr><td><code>5</code></td><td><code>Intra_4x4_Vertical_Right</code></td><td><code>predict_4x4_vr_c()</code></td></tr><tr><td><code>6</code></td><td><code>Intra_4x4_Horizontal_Down</code></td><td><code>predict_4x4_hd_c()</code></td></tr><tr><td><code>7</code></td><td><code>Intra_4x4_Vertical_Left</code></td><td><code>predict_4x4_vl_c()</code></td></tr><tr><td><code>8</code></td><td><code>Intra_4x4_Horizontal_Up</code></td><td><code>predict_4x4_hu_c()</code></td></tr></tbody></table></div><h3 id="Intra-4x4-Vertical"><a href="#Intra-4x4-Vertical" class="headerlink" title="Intra_4x4_Vertical"></a>Intra_4x4_Vertical</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210120234537.png" alt="Intra_4x4_Vertical"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Vertical</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC(x,y) src[(x)+(y)*FDEC_STRIDE]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC_X4(x,y) MPIXEL_X4( &amp;SRC(x,y) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_DC(v)\</span></span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">0</span>) = SRC_X4(<span class="number">0</span>,<span class="number">1</span>) = SRC_X4(<span class="number">0</span>,<span class="number">2</span>) = SRC_X4(<span class="number">0</span>,<span class="number">3</span>) = v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_4x4_v_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    PREDICT_4x4_DC(SRC_X4(<span class="number">0</span>,<span class="number">-1</span>));</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+0*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+1*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+2*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+3*FDEC_STRIDE])-&gt;i = ((x264_union32_t*)(&amp;src[0+(-1)*FDEC_STRIDE])-&gt;i;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Horizontal"><a href="#Intra-4x4-Horizontal" class="headerlink" title="Intra_4x4_Horizontal"></a>Intra_4x4_Horizontal</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210120235209.png" alt="Intra_4x4_Horizontal"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Horizontal</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M32(src) (((x264_union32_t*)(src))-&gt;i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPIXEL_X4(src) M32(src)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC(x,y) src[(x)+(y)*FDEC_STRIDE]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC_X4(x,y) MPIXEL_X4( &amp;SRC(x,y) )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_SPLAT_X4(x) ((x)*0x01010101U)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_4x4_h_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">0</span>) = PIXEL_SPLAT_X4( SRC(<span class="number">-1</span>,<span class="number">0</span>) );</span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">1</span>) = PIXEL_SPLAT_X4( SRC(<span class="number">-1</span>,<span class="number">1</span>) );</span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">2</span>) = PIXEL_SPLAT_X4( SRC(<span class="number">-1</span>,<span class="number">2</span>) );</span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">3</span>) = PIXEL_SPLAT_X4( SRC(<span class="number">-1</span>,<span class="number">3</span>) );</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+0*FDEC_STRIDE])-&gt;i = src[-1+0*FDEC_STRIDE]*0x01010101U;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+1*FDEC_STRIDE])-&gt;i = src[-1+1*FDEC_STRIDE]*0x01010101U;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+2*FDEC_STRIDE])-&gt;i = src[-1+2*FDEC_STRIDE]*0x01010101U;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+3*FDEC_STRIDE])-&gt;i = src[-1+3*FDEC_STRIDE]*0x01010101U;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-DC"><a href="#Intra-4x4-DC" class="headerlink" title="Intra_4x4_DC"></a>Intra_4x4_DC</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121000124.png" alt="Intra_4x4_DC"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_DC</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> pixel4;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_DC(v) SRC_X4(0,0) = SRC_X4(0,1) = SRC_X4(0,2) = SRC_X4(0,3) = v;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_4x4_dc_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    pixel4 dc = PIXEL_SPLAT_X4((SRC(<span class="number">-1</span>,<span class="number">0</span>) + SRC(<span class="number">-1</span>,<span class="number">1</span>) + SRC(<span class="number">-1</span>,<span class="number">2</span>) + SRC(<span class="number">-1</span>,<span class="number">3</span>) +</span><br><span class="line">                                 SRC(<span class="number">0</span>,<span class="number">-1</span>) + SRC(<span class="number">1</span>,<span class="number">-1</span>) + SRC(<span class="number">2</span>,<span class="number">-1</span>) + SRC(<span class="number">3</span>,<span class="number">-1</span>) + <span class="number">4</span>) &gt;&gt; <span class="number">3</span> );</span><br><span class="line">    PREDICT_4x4_DC(dc);</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * uint32_t dc = (( src[-1+0*FDEC_STRIDE] + src[-1+1*FDEC_STRIDE] +</span></span><br><span class="line"><span class="comment">                        src[-1+2*FDEC_STRIDE] + src[-1+3*FDEC_STRIDE] +</span></span><br><span class="line"><span class="comment">                        src[0+(-1)*FDEC_STRIDE] + src[1+(-1)*FDEC_STRIDE] +</span></span><br><span class="line"><span class="comment">                        src[2+(-1)*FDEC_STRIDE] + src[3+(-1)*FDEC_STRIDE] ) &gt;&gt; 3 ) * 0x01010101U;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[(0)+(0)*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[(0)+(1)*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[(0)+(2)*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[(0)+(3)*FDEC_STRIDE])-&gt;i = dc;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Diagonal-Down-Left"><a href="#Intra-4x4-Diagonal-Down-Left" class="headerlink" title="Intra_4x4_Diagonal_Down_Left"></a>Intra_4x4_Diagonal_Down_Left</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121001324.png" alt="Intra_4x4_Diagonal_Down_Left"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Diagonal_Down_Left</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_LOAD_TOP\</span></span><br><span class="line">    <span class="keyword">int</span> t0 = SRC(<span class="number">0</span>,<span class="number">-1</span>);\</span><br><span class="line">    <span class="keyword">int</span> t1 = SRC(<span class="number">1</span>,<span class="number">-1</span>);\</span><br><span class="line">    <span class="keyword">int</span> t2 = SRC(<span class="number">2</span>,<span class="number">-1</span>);\</span><br><span class="line">    UNUSED <span class="keyword">int</span> t3 = SRC(<span class="number">3</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_LOAD_TOP_RIGHT\</span></span><br><span class="line">    <span class="keyword">int</span> t4 = SRC(<span class="number">4</span>,<span class="number">-1</span>);\</span><br><span class="line">    <span class="keyword">int</span> t5 = SRC(<span class="number">5</span>,<span class="number">-1</span>);\</span><br><span class="line">    <span class="keyword">int</span> t6 = SRC(<span class="number">6</span>,<span class="number">-1</span>);\</span><br><span class="line">    UNUSED <span class="keyword">int</span> t7 = SRC(<span class="number">7</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F2(a,b,c) (((a)+2*(b)+(c)+2)&gt;&gt;2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_ddl_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    PREDICT_4x4_LOAD_TOP_RIGHT</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)= F2(t0,t1,t2);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">0</span>,<span class="number">1</span>)= F2(t1,t2,t3);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">0</span>,<span class="number">2</span>)= F2(t2,t3,t4);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)=SRC(<span class="number">0</span>,<span class="number">3</span>)= F2(t3,t4,t5);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(t4,t5,t6);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">2</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F2(t5,t6,t7);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(t6,t7,t7);</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * int t0 = src[0+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t1 = src[1+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t2 = src[2+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t3 = src[3+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t4 = src[4+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t5 = src[5+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t6 = src[6+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t7 = src[7+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * src[0+0*FDEC_STRIDE] = (t0+2*t1+t2+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[1+0*FDEC_STRIDE] = src[0+1*FDEC_STRIDE] = (t1+2*t2+t3+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[2+0*FDEC_STRIDE] = src[1+1*FDEC_STRIDE] = src[0+2*FDEC_STRIDE] = (t2+2*t3+t4+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[3+0*FDEC_STRIDE] = src[2+1*FDEC_STRIDE] = src[1+2*FDEC_STRIDE] = src[0+3*FDEC_STRIDE] = (t3+2*t4+t5+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[3+1*FDEC_STRIDE] = src[2+2*FDEC_STRIDE] = src[1+3*FDEC_STRIDE] = (t4+2*t5+t6+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[3+2*FDEC_STRIDE] = src[2+3*FDEC_STRIDE] = (t5+2*t6+t7+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[3+3*FDEC_STRIDE] = (t6+2*t7+t7+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Diagonal-Down-Right"><a href="#Intra-4x4-Diagonal-Down-Right" class="headerlink" title="Intra_4x4_Diagonal_Down_Right"></a>Intra_4x4_Diagonal_Down_Right</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121003328.png" alt="Intra_4x4_Diagonal_Down_Right"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Diagonal_Down_Right</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_LOAD_LEFT\</span></span><br><span class="line">    <span class="keyword">int</span> l0 = SRC(<span class="number">-1</span>,<span class="number">0</span>);\</span><br><span class="line">    <span class="keyword">int</span> l1 = SRC(<span class="number">-1</span>,<span class="number">1</span>);\</span><br><span class="line">    <span class="keyword">int</span> l2 = SRC(<span class="number">-1</span>,<span class="number">2</span>);\</span><br><span class="line">    UNUSED <span class="keyword">int</span> l3 = SRC(<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_ddr_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lt = SRC(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    PREDICT_4x4_LOAD_LEFT</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)= F2(t3,t2,t1);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">3</span>,<span class="number">1</span>)= F2(t2,t1,t0);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">3</span>,<span class="number">2</span>)= F2(t1,t0,lt);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)=SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(t0,lt,l0);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F2(lt,l0,l1);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">2</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(l0,l1,l2);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">3</span>)= F2(l1,l2,l3);</span><br><span class="line">    <span class="comment">/* 展开宏定义如下，后续类似代码不再进行宏定义展开：</span></span><br><span class="line"><span class="comment">     * int lt = src[-1+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int l0 = src[-1+0*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int l1 = src[-1+1*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int l2 = src[-1+2*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t0 = src[0+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t1 = src[1+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t2 = src[2+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t3 = src[3+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * src[3+0*FDEC_STRIDE] = (t3+2*t2+t1+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[2+0*FDEC_STRIDE] = src[3+1*FDEC_STRIDE] = (t2+2*t1+t0+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[1+0*FDEC_STRIDE] = src[2+1*FDEC_STRIDE] = src[3+2*FDEC_STRIDE] = (t1+2*t0+lt+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[0+0*FDEC_STRIDE] = src[1+1*FDEC_STRIDE] = src[2+2*FDEC_STRIDE] = src[3+3*FDEC_STRIDE] = (t0+2*lt+l0+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[0+1*FDEC_STRIDE] = src[1+2*FDEC_STRIDE] = src[2+3*FDEC_STRIDE] = (lt+2*l0+l1+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[0+2*FDEC_STRIDE] = src[1+3*FDEC_STRIDE] = (l0+2*l1+l2+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[0+3*FDEC_STRIDE] = (l1+2*l2+l3+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Vertical-Right"><a href="#Intra-4x4-Vertical-Right" class="headerlink" title="Intra_4x4_Vertical_Right"></a>Intra_4x4_Vertical_Right</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121004449.png" alt="Intra_4x4_Vertical_Right"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Vertical_Right</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_vr_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lt = SRC(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    PREDICT_4x4_LOAD_LEFT</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">3</span>)= F2(l2,l1,l0);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">2</span>)= F2(l1,l0,lt);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(l0,lt,t0);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)= F1(lt,t0);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F2(lt,t0,t1);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)= F1(t0,t1);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(t0,t1,t2);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">3</span>,<span class="number">2</span>)= F1(t1,t2);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">1</span>)= F2(t1,t2,t3);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)= F1(t2,t3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Horizontal-Down"><a href="#Intra-4x4-Horizontal-Down" class="headerlink" title="Intra_4x4_Horizontal_Down"></a>Intra_4x4_Horizontal_Down</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121004515.png" alt="Intra_4x4_Horizontal_Down"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Horizontal_Down</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_hd_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lt= SRC(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    PREDICT_4x4_LOAD_LEFT</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">3</span>)= F1(l2,l3);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(l1,l2,l3);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">2</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F1(l1,l2);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">2</span>)=SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(l0,l1,l2);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)= F1(l0,l1);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">3</span>,<span class="number">2</span>)= F2(lt,l0,l1);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">1</span>)= F1(lt,l0);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">3</span>,<span class="number">1</span>)= F2(t0,lt,l0);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)= F2(t1,t0,lt);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)= F2(t2,t1,t0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Vertical-Left"><a href="#Intra-4x4-Vertical-Left" class="headerlink" title="Intra_4x4_Vertical_Left"></a>Intra_4x4_Vertical_Left</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121004528.png" alt="Intra_4x4_Vertical_Left"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Vertical_Left</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_vl_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    PREDICT_4x4_LOAD_TOP_RIGHT</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)= F1(t0,t1);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">1</span>)= F2(t0,t1,t2);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">0</span>,<span class="number">2</span>)= F1(t1,t2);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">0</span>,<span class="number">3</span>)= F2(t1,t2,t3);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)= F1(t2,t3);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(t2,t3,t4);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)= F1(t3,t4);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F2(t3,t4,t5);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">2</span>)= F1(t4,t5);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(t4,t5,t6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intra-4x4-Horizontal-Up"><a href="#Intra-4x4-Horizontal-Up" class="headerlink" title="Intra_4x4_Horizontal_Up"></a>Intra_4x4_Horizontal_Up</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121004541.png" alt="Intra_4x4_Horizontal_Up"></p><p><code>x264</code> 中关于模式 <code>Intra_4x4_Horizontal_Up</code> 的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_hu_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    PREDICT_4x4_LOAD_LEFT</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)= F1(l0,l1);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)= F2(l0,l1,l2);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">0</span>,<span class="number">1</span>)= F1(l1,l2);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">1</span>)= F2(l1,l2,l3);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">0</span>,<span class="number">2</span>)= F1(l2,l3);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)= F2(l2,l3,l3);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">2</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)=SRC(<span class="number">0</span>,<span class="number">3</span>)=</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">2</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)=SRC(<span class="number">3</span>,<span class="number">3</span>)= l3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8x8-预测"><a href="#8x8-预测" class="headerlink" title="8x8 预测"></a>8x8 预测</h2><p>x264 中对 8x8 的预测模式如下：</p><div class="table-container"><table><thead><tr><th><code>intra8x8Predmodei[luma8x8BlkIdx]</code></th><th><code>Name of Intra8x8PredMode[luma8x8BlkIdx]</code></th><th>Function</th></tr></thead><tbody><tr><td>0</td><td><code>Intra_8x8_Vertical</code></td></tr><tr><td>1</td><td><code>Intra_8x8_Horizontal</code></td></tr><tr><td>2</td><td><code>Intra_8x8_DC</code></td></tr><tr><td>3</td><td><code>Intra_8x8_Diagonal_Down_Left</code></td></tr><tr><td>4</td><td><code>Intra_8x8_Diagonal_Down_Right</code></td></tr><tr><td>5</td><td><code>Intra_8x8_Vertical_Right</code></td></tr><tr><td>6</td><td><code>Intra_8x8_Horizontal_Down</code></td></tr><tr><td>7</td><td><code>Intra_8x8_Vertical_Left</code></td></tr><tr><td>8</td><td><code>Intra_8x8_Horizontal_Up</code></td></tr></tbody></table></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li><li>[2] <a href="http://lazybing.github.io/blog/2017/06/30/x264-intra-prediction/#intra4x4vertical-">X264 源码解析之帧内预测 - 懒人李冰</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文分析 &lt;code&gt;x264&lt;/code&gt; 库中的帧内预测的 &lt;code&gt;C&lt;/code&gt; 语言函数。&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://github.hezhaojiang.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="x264" scheme="http://github.hezhaojiang.io/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - ffmpeg 之 IO 架构分析</title>
    <link href="http://github.hezhaojiang.io/post/2021/ce615ee4/"/>
    <id>http://github.hezhaojiang.io/post/2021/ce615ee4/</id>
    <published>2021-01-13T05:11:40.000Z</published>
    <updated>2021-02-04T16:46:01.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>协议 (文件) 操作的顶层结构是 <code>AVIOContext</code>，该对象实现了带缓冲的读写操作</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210115000338.png" alt="协议操作对象结构"></p><a id="more"></a><p><code>ffmpeg</code> 的输入对象 <code>AVFormatContext</code> 的 <code>pb</code> 字段指向一个 <code>AVIOContext</code></p><p><code>AVIOContext</code> 的 <code>opaque</code> 实际指向一个 <code>URLContext</code> 对象，这个对象封装了协议对象及协议操作对象</p><pre><code>- `prot` 指向具体的协议操作对象 `URLProtocol`- `priv_data` 指向具体的协议对象</code></pre><p><code>URLProtocol</code> 为协议操作对象，针对每种协议，会有一个这样的对象，每个协议操作对象和一个协议对象关联</p><pre><code>- 比如，文件操作对象为 `ff_file_protocol` 关联的结构体是 `FileContext`</code></pre><h2 id="函数调用关系"><a href="#函数调用关系" class="headerlink" title="函数调用关系"></a>函数调用关系</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ avformat_open_input()</span><br><span class="line">+---+ init_input()                              <span class="comment">/* 打开输入的视频数据并且探测视频的格式 */</span></span><br><span class="line">    +---- av_probe_input_buffer2()</span><br><span class="line">        +---- avio_read()</span><br><span class="line">        +---- av_probe_input_format2()</span><br><span class="line">            +---- av_probe_input_format3()</span><br><span class="line">    +---+ avio_open2()</span><br><span class="line">        +---+ ffurl_open_whitelist()</span><br><span class="line">            +---+ ffurl_alloc()</span><br><span class="line">                +---- url_find_protocol()</span><br><span class="line">                +---- url_alloc_for_protocol()</span><br><span class="line">            +---+ ffurl_connect()</span><br><span class="line">                +---- prot-&gt;url_open2()</span><br><span class="line">                +---- prot-&gt;url_open()</span><br><span class="line">        +---+ ffio_fdopen()</span><br><span class="line">            +---- avio_alloc_context()</span><br></pre></td></tr></table></figure><h2 id="init-input"><a href="#init-input" class="headerlink" title="init_input()"></a>init_input()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Open input file and probe the format if necessary. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_input</span><span class="params">(AVFormatContext *s, <span class="keyword">const</span> <span class="keyword">char</span> *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                      AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    AVProbeData pd = &#123;filename, <span class="literal">NULL</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> score = AVPROBE_SCORE_RETRY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;pb) &#123;</span><br><span class="line">        s-&gt;flags |= AVFMT_FLAG_CUSTOM_IO;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;iformat)</span><br><span class="line">            <span class="keyword">return</span> av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                         s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE)</span><br><span class="line">            av_log(s, AV_LOG_WARNING, <span class="string">&quot;Custom AVIOContext makes no sense and&quot;</span></span><br><span class="line">                                      <span class="string">&quot;will be ignored with AVFMT_NOFILE format.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((s-&gt;iformat &amp;&amp; s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE) ||</span><br><span class="line">        (!s-&gt;iformat &amp;&amp; (s-&gt;iformat = av_probe_input_format2(&amp;pd, <span class="number">0</span>, &amp;score))))</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = s-&gt;io_open(s, &amp;s-&gt;pb, filename, AVIO_FLAG_READ | s-&gt;avio_flags, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;iformat) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                 s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数在短短的几行代码中包含了好几个 <code>return</code>，因此逻辑还是有点复杂的，我们可以梳理一下：</p><p>在函数的开头的 <code>score</code> 变量是一个判决 <code>AVInputFormat</code> 的分数的门限值，如果最后得到的 <code>AVInputFormat</code> 的分数低于该门限值，就认为没有找到合适的 <code>AVInputFormat</code>。<code>ffmpeg</code> 内部判断封装格式的原理实际上是对每种 <code>AVInputFormat</code> 给出一个分数，满分是 <code>100</code> 分，越有可能正确的 <code>AVInputFormat</code> 给出的分数就越高。最后选择分数最高的 <code>AVInputFormat</code> 作为推测结果。<code>score</code> 的值是一个宏定义 <code>AVPROBE_SCORE_RETRY</code>，我们可以看一下它的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVPROBE_SCORE_MAX       100 <span class="comment">///&lt; maximum score</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVPROBE_SCORE_RETRY (AVPROBE_SCORE_MAX/4)</span></span><br></pre></td></tr></table></figure><p>由此我们可以得出 <code>score</code> 取值是 <code>25</code>，即如果推测后得到的最佳 <code>AVInputFormat</code> 的分值低于 <code>25</code>，就认为没有找到合适的  <code>AVInputFormat</code></p><p>整个函数的逻辑大体如下：</p><ol><li>当使用了自定义的 <code>AVIOContext</code> 的时候（<code>AVFormatContext</code> 中的 <code>AVIOContext</code> 不为空，即 <code>s-&gt;pb!=NULL</code>），如果指定了 <code>AVInputFormat</code> 就直接返回，如果没有指定就调用 <code>av_probe_input_buffer2()</code> 推测 <code>AVInputFormat</code>。这一情况出现的不算很多，但是当我们从内存中读取数据的时候（需要初始化自定义的 <code>AVIOContext</code>），就会执行这一步骤</li><li>在更一般的情况下，如果已经指定了 <code>AVInputFormat</code>，就直接返回；如果没有指定 <code>AVInputFormat</code>，就调用 <code>av_probe_input_format(NULL,…)</code> 根据文件路径判断文件格式。这里特意把 <code>av_probe_input_format()</code> 的第 1 个参数写成 <code>NULL</code>，是为了强调这个时候实际上并没有给函数提供输入数据，此时仅仅通过文件路径推测 <code>AVInputFormat</code></li><li>如果发现通过文件路径判断不出来文件格式，那么就需要打开文件探测文件格式了，这个时候会首先调用 <code>avio_open2()</code> 打开文件，然后调用 <code>av_probe_input_buffer2()</code> 推测 <code>AVInputFormat</code></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/finewind/article/details/39433055">2——FFMPEG 之协议 (文件) 操作 ——AVIOContext, URLContext, URLProtocol_finewind 的专栏 - CSDN 博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;协议 (文件) 操作的顶层结构是 &lt;code&gt;AVIOContext&lt;/code&gt;，该对象实现了带缓冲的读写操作&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210115000338.png&quot; alt=&quot;协议操作对象结构&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="音视频日记" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="ffmpeg" scheme="http://github.hezhaojiang.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 - 拓扑排序</title>
    <link href="http://github.hezhaojiang.io/post/2021/fd828132/"/>
    <id>http://github.hezhaojiang.io/post/2021/fd828132/</id>
    <published>2021-01-12T06:40:43.000Z</published>
    <updated>2021-02-09T11:37:57.038Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>「先穿袜子，再穿鞋子」 —- 这就是一种拓扑排序</p><a id="more"></a><p>首先声明：拓扑排序并不是通常意义上的【排序】算法</p><h2 id="拓扑排序简介"><a href="#拓扑排序简介" class="headerlink" title="拓扑排序简介"></a>拓扑排序简介</h2><p>给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：</p><pre><code>对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面。</code></pre><p>那么称该排列是图 G 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：</p><ol><li><p>如果图 G 中存在环，那么图 G 不存在拓扑排序（即只有「有向无环图」存在拓扑排序）</p></li><li><p>如果图 G 是有向无环图，那么它的拓扑排序可能不止一种</p></li></ol><p>在很多应用中， 有向无回路图用于说明事件发生的先后次序， 下图给出了一个实例，说明 Bumstead 教授早晨穿衣的过程。他必须先穿好某些衣服， 才能再穿其他衣服（如先穿袜子后才能穿鞋） ， 其他的一些衣服前可以按任意次序穿戴（如袜子和裤子）</p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210112230616.png" alt="Bumstead 教授早晨穿衣的过程"></p><pre><code>图 a 为 Bumstead 教授对他所穿的衣服进行了拓扑排序每一条有向边 (u,v) 都意味若必须先穿衣服 u 再穿衣服 v深度优先搜索中的发现和完成时间都在每个顶点的旁边示出图 b 为 经过拓扑排序后的同一图形图中的各个顶点按照完成时间的递降顺序从左向右排列，注意所有的有向边都是从左指向右的</code></pre><h2 id="拓扑排序的实现"><a href="#拓扑排序的实现" class="headerlink" title="拓扑排序的实现"></a>拓扑排序的实现</h2><p>为了说明如何得到一个有向无环图的拓扑排序，我们首先需要了解有向图节点的入度（indegree）和出度（outdegree）的概念：</p><ul><li>入度：设有向图中有一节点 $v$，其入度即为当前所有从其他节点出发，终点为 $v$ 的的边的数目。也就是所有指向 $v$ 的有向边的数目。</li><li>出度：设有向图中有一节点 $v$，其出度即为当前所有起点为 $v$，指向其他节点的边的数目。也就是所有由 $v$ 发出的边的数目。</li></ul><p>在了解了入度和出度的概念之后，再根据拓扑排序的定义，我们自然就能够得出结论：要想完成拓扑排序，我们每次都应当从入度为 0 的节点开始遍历。因为只有入度为 0 的节点才能够成为拓扑排序的起点。否则根据拓扑排序的定义，只要一个节点 $v$ 的入度不为 0，则至少有一条边起始于其他节点而指向 $v$，那么这条边的起点在拓扑排序的顺序中应当位于 $v$ 之前，则 $v$ 不能成为当前遍历的起点。</p><p>由此我们可以进一步得出一个改进的深度优先遍历或广度优先遍历算法来完成拓扑排序。</p><h3 id="广度优先算法实现拓扑排序"><a href="#广度优先算法实现拓扑排序" class="headerlink" title="广度优先算法实现拓扑排序"></a>广度优先算法实现拓扑排序</h3><p>广度优先算法实现拓扑排序需要多保存每一个节点对应的入度（普通遍历算法只需要保存节点之间的关系），并在遍历的每一层选取入度为 0 的节点开始遍历（普通遍历算法则可以从该吃呢个任意一个节点开始遍历）。这个算法描述如下：</p><ol><li>保存每一个节点与其他节点之间的关系，可以使用邻接表或者哈希表</li><li>计算并保存每一个节点的入度，可以使用数组</li><li>遍历选取入度为 0 的节点，并将该节点加入队列</li><li>取队列中的节点，加入排序结果列表，并将该节点的子节点的入度减 1</li><li>重复步骤 5，直到队列为空</li><li>如果排序结果列表和节点总数相同，代表遍历完了所有节点，否则说明有节点没有遍历到<ul><li>如果遍历完所有的节点，则排序结果列表即为当前图的拓扑排序</li><li>如果无法遍历完所有的节点，则意味着当前图不是有向无环图，不存在拓扑排序</li></ul></li></ol><h2 id="拓扑排序题目解析"><a href="#拓扑排序题目解析" class="headerlink" title="拓扑排序题目解析"></a>拓扑排序题目解析</h2><h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h3><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul><li>「力扣」第 207 题：课程表（中等）</li><li>「力扣」第 210 题：课程表 II（中等）</li><li>「力扣」第 301 题：最小高度树（中等）</li><li>「力扣」第 802 题：找到最终的安全状态（中等）</li><li>「力扣」第 1203 题：项目管理（困难）</li><li>「力扣」第 630 题：课程表 III（困难）</li><li>「力扣」第 329 题：矩阵中的最长递增路径（困难）</li><li>「力扣」第 1245 题：树的直径（中等）</li><li>「力扣」第 444 题：序列重建（中等）</li><li>「力扣」第 1136 题：平行课程（困难）</li><li>「力扣」第 269 题：火星词典（困难）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/">课程表 - 课程表 - 力扣（LeetCode）</a></li><li>[2] <a href="https://www.jianshu.com/p/3347f54a3187">深入理解拓扑排序（Topological sort) - 简书</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;「先穿袜子，再穿鞋子」 —- 这就是一种拓扑排序&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://github.hezhaojiang.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="图论" scheme="http://github.hezhaojiang.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - ffmpeg 关键结构体</title>
    <link href="http://github.hezhaojiang.io/post/2021/e03178b1/"/>
    <id>http://github.hezhaojiang.io/post/2021/e03178b1/</id>
    <published>2021-01-08T08:53:09.000Z</published>
    <updated>2021-01-13T13:48:44.593Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><code>AVFormatContext</code> : 封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息</li><li><code>AVInputFormat</code> : 每种封装格式（例如 FLV, MKV, MP4, AVI）对应一个该结构体</li><li><code>AVStream</code> : 视频文件中每个视频（音频）流对应一个该结构体</li><li><code>AVCodecContext</code> : 编码器上下文结构体，保存了视频（音频）编解码相关信息</li><li><code>AVCodec</code> : 每种视频（音频）编解码器 (例如 H.264 解码器) 对应一个该结构体</li><li><code>AVPacket</code> : 存储一帧压缩编码数据</li><li><code>AVFrame</code> : 存储一帧解码后像素（采样）数据</li></ul><a id="more"></a><h2 id="协议封装-amp-解协议"><a href="#协议封装-amp-解协议" class="headerlink" title="协议封装 &amp; 解协议"></a>协议封装 &amp; 解协议</h2><h3 id="AVIOContext"><a href="#AVIOContext" class="headerlink" title="AVIOContext"></a>AVIOContext</h3><p><code>AVIOContext</code> 是 <code>ffmpeg</code> 管理输入输出数据的结构体</p><h4 id="AVIOContext-相关函数"><a href="#AVIOContext-相关函数" class="headerlink" title="AVIOContext 相关函数"></a>AVIOContext 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate and initialize an AVIOContext for buffered I/O. It must be later freed with avio_context_free().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param buffer Memory block for input/output operations via AVIOContext.</span></span><br><span class="line"><span class="comment"> *        The buffer must be allocated with av_malloc() and friends.</span></span><br><span class="line"><span class="comment"> *        It may be freed and replaced with a new buffer by libavformat.</span></span><br><span class="line"><span class="comment"> *        AVIOContext.buffer holds the buffer currently in use, which must be later freed with av_free().</span></span><br><span class="line"><span class="comment"> * @param buffer_size The buffer size is very important for performance.</span></span><br><span class="line"><span class="comment"> *        For protocols with fixed blocksize it should be set to this blocksize.</span></span><br><span class="line"><span class="comment"> *        For others a typical size is a cache page, e.g. 4kb.</span></span><br><span class="line"><span class="comment"> * @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.</span></span><br><span class="line"><span class="comment"> * @param opaque An opaque pointer to user-specific data.</span></span><br><span class="line"><span class="comment"> * @param read_packet  A function for refilling the buffer, may be NULL.</span></span><br><span class="line"><span class="comment"> *        For stream protocols, must never return 0 but rather a proper AVERROR code.</span></span><br><span class="line"><span class="comment"> * @param write_packet A function for writing the buffer contents, may be NULL.</span></span><br><span class="line"><span class="comment"> *        The function may not change the input buffers content.</span></span><br><span class="line"><span class="comment"> * @param seek A function for seeking to specified byte position, may be NULL.</span></span><br><span class="line"><span class="comment"> * @return Allocated AVIOContext or NULL on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVIOContext *<span class="title">avio_alloc_context</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="built_in">buffer</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> buffer_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> write_flag,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *opaque,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*read_packet)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*write_packet)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int64_t</span> (*<span class="built_in">seek</span>)(<span class="keyword">void</span> *opaque, <span class="keyword">int64_t</span> offset, <span class="keyword">int</span> whence))</span></span>;</span><br></pre></td></tr></table></figure><h4 id="AVIOContext-成员变量"><a href="#AVIOContext-成员变量" class="headerlink" title="AVIOContext 成员变量"></a>AVIOContext 成员变量</h4><ul><li><code>unsigned char *buffer;</code> : 缓存开始位置</li><li><code>int buffer_size;</code> : 缓存大小（默认 <code>32768</code>）</li><li><code>unsigned char *buf_ptr;</code> : 当前指针读取到的位置</li><li><code>unsigned char *buf_end;</code> : 缓存结束的位置</li><li><code>void *opaque;</code> : <code>URLContext</code> 结构体</li><li><code>int64_t pos;</code> : 文件读取指针位置</li><li><code>int eof_reached;</code> : 在读取失败或读取完成时置位</li><li><code>(*read_packet)</code> : 读取音视频数据的函数</li><li><code>(*write_packet)</code> : 写入音视频数据的函数</li><li><code>(*read_pause)</code> : 暂停或恢复网络流媒体协议的播放</li></ul><h3 id="URLContext-amp-URLProtocol"><a href="#URLContext-amp-URLProtocol" class="headerlink" title="URLContext &amp; URLProtocol"></a>URLContext &amp; URLProtocol</h3><p><code>URLContext</code> &amp; <code>URLProtocol</code> 并不在 <code>ffmpeg</code> 提供的头文件中，而是在源代码中</p><h4 id="URLContext-amp-URLProtocol-定义"><a href="#URLContext-amp-URLProtocol-定义" class="headerlink" title="URLContext &amp; URLProtocol 定义"></a>URLContext &amp; URLProtocol 定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLContext</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> AVClass *av_class;    <span class="comment">/**&lt;information for av_log(). Set by url_open(). */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span> *<span class="title">prot</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *priv_data;</span><br><span class="line">    <span class="keyword">char</span> *filename;             <span class="comment">/**&lt; specified URL */</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> max_packet_size;        <span class="comment">/**&lt; if non zero, the stream is packetized with this max packet size */</span></span><br><span class="line">    <span class="keyword">int</span> is_streamed;            <span class="comment">/**&lt;true if streamed (no seek possible), default = false */</span></span><br><span class="line">    <span class="keyword">int</span> is_connected;</span><br><span class="line">    AVIOInterruptCB interrupt_callback;</span><br><span class="line">    <span class="keyword">int64_t</span> rw_timeout;         <span class="comment">/**&lt;maximum time to wait for (network) read/write operation completion, in mcs */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocol_whitelist;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocol_blacklist;</span><br><span class="line">    <span class="keyword">int</span> min_packet_size;        <span class="comment">/**&lt; if non zero, the stream is packetized with this min packet size */</span></span><br><span class="line">&#125; URLContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span>     (*url_open)( URLContext *h, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This callback is to be used by protocols which open further nested</span></span><br><span class="line"><span class="comment">     * protocols. options are then to be passed to ffurl_open()/ffurl_connect()</span></span><br><span class="line"><span class="comment">     * for those nested protocols.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>     (*url_open2)(URLContext *h, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags, AVDictionary **options);</span><br><span class="line">    <span class="keyword">int</span>     (*url_accept)(URLContext *s, URLContext **c);</span><br><span class="line">    <span class="keyword">int</span>     (*url_handshake)(URLContext *c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read data from the protocol.</span></span><br><span class="line"><span class="comment">     * If data is immediately available (even less than size), EOF is</span></span><br><span class="line"><span class="comment">     * reached or an error occurs (including EINTR), return immediately.</span></span><br><span class="line"><span class="comment">     * Otherwise:</span></span><br><span class="line"><span class="comment">     * In non-blocking mode, return AVERROR(EAGAIN) immediately.</span></span><br><span class="line"><span class="comment">     * In blocking mode, wait for data/EOF/error with a short timeout (0.1s),</span></span><br><span class="line"><span class="comment">     * and return AVERROR(EAGAIN) on timeout.</span></span><br><span class="line"><span class="comment">     * Checking interrupt_callback, looping on EINTR and EAGAIN and until</span></span><br><span class="line"><span class="comment">     * enough data has been read is left to the calling function; see</span></span><br><span class="line"><span class="comment">     * retry_transfer_wrapper in avio.c.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>     (*url_read) (URLContext *h, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">int</span>     (*url_write)(URLContext *h, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_seek) (URLContext *h, <span class="keyword">int64_t</span> pos, <span class="keyword">int</span> whence);</span><br><span class="line">    <span class="keyword">int</span>     (*url_close)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_read_pause)(URLContext *h, <span class="keyword">int</span> pause);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_read_seek)(URLContext *h, <span class="keyword">int</span> stream_index,</span><br><span class="line">                             <span class="keyword">int64_t</span> timestamp, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_file_handle)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_multi_file_handle)(URLContext *h, <span class="keyword">int</span> **handles,</span><br><span class="line">                                     <span class="keyword">int</span> *numhandles);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_short_seek)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_shutdown)(URLContext *h, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> priv_data_size;</span><br><span class="line">    <span class="keyword">const</span> AVClass *priv_data_class;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> (*url_check)(URLContext *h, <span class="keyword">int</span> mask);</span><br><span class="line">    <span class="keyword">int</span> (*url_open_dir)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_read_dir)(URLContext *h, AVIODirEntry **next);</span><br><span class="line">    <span class="keyword">int</span> (*url_close_dir)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_delete)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_move)(URLContext *h_src, URLContext *h_dst);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *default_whitelist;</span><br><span class="line">&#125; URLProtocol;</span><br></pre></td></tr></table></figure><p>在 <code>URLProtocol</code> 结构体中，除了一些回调函数接口之外，有一个变量 <code>const char *name</code>，该变量存储了协议的名称。每一种输入协议都对应这样一个结构体对象。比如说，文件协议中代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.c</span></span><br><span class="line"><span class="keyword">const</span> URLProtocol ff_file_protocol = &#123;</span><br><span class="line">    .name                = <span class="string">&quot;file&quot;</span>,</span><br><span class="line">    .url_open            = file_open,</span><br><span class="line">    .url_read            = file_read,</span><br><span class="line">    .url_write           = file_write,</span><br><span class="line">    .url_seek            = file_seek,</span><br><span class="line">    .url_close           = file_close,</span><br><span class="line">    .url_get_file_handle = file_get_handle,</span><br><span class="line">    .url_check           = file_check,</span><br><span class="line">    .url_delete          = file_delete,</span><br><span class="line">    .url_move            = file_move,</span><br><span class="line">    .priv_data_size      = <span class="keyword">sizeof</span>(FileContext),</span><br><span class="line">    .priv_data_class     = &amp;file_class,</span><br><span class="line">    .url_open_dir        = file_open_dir,</span><br><span class="line">    .url_read_dir        = file_read_dir,</span><br><span class="line">    .url_close_dir       = file_close_dir,</span><br><span class="line">    .default_whitelist   = <span class="string">&quot;file,crypto,data&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="封装-amp-解封装"><a href="#封装-amp-解封装" class="headerlink" title="封装 &amp; 解封装"></a>封装 &amp; 解封装</h2><h3 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h3><h4 id="AVFormatContext-相关函数"><a href="#AVFormatContext-相关函数" class="headerlink" title="AVFormatContext 相关函数"></a>AVFormatContext 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个 AVFormatContext</span></span><br><span class="line"><span class="function">AVFormatContext *<span class="title">avformat_alloc_context</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 释放 AVFormatContext 及其所有 AVStream</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avformat_free_context</span><span class="params">(AVFormatContext *s)</span></span>;</span><br><span class="line"><span class="comment">// 打开一个输入流并读取报头，该函数不会打开编解码器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="keyword">const</span> <span class="keyword">char</span> *url, ff_const59 AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br><span class="line"><span class="comment">// 读取媒体文件的数据包以获取流信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="AVFormatContext-成员变量"><a href="#AVFormatContext-成员变量" class="headerlink" title="AVFormatContext 成员变量"></a>AVFormatContext 成员变量</h4><ul><li><code>struct AVInputFormat *iformat;</code> : 输入音视频的 <code>AVInputFormat</code></li><li><code>struct AVOutputFormat *oformat;</code> : 输出音视频的 <code>AVInputFormat</code></li><li><code>AVIOContext *pb;</code> : 输入 / 输出音视频数据的缓存</li><li><code>int64_t duration;</code> : 输入 / 输出音视频的时长（以微秒为单位）</li><li><code>int64_t bit_rate;</code> : 输入 / 输出音视频的码率</li><li><code>unsigned int nb_streams;</code> ： 输入 / 输出音视频的 <code>AVStream</code> 个数</li><li><code>AVStream **streams;</code> ： 输入 / 输出音视频的每个视频（音频流）</li><li><code>AVDictionary *metadata;</code> ： 元数据</li></ul><h3 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h3><p>视频文件中每个视频（音频）流对应一个 <code>AVStream</code> 对象</p><ul><li>在解封装时，<code>AVStream</code> 对象由 <code>libavformat</code> 中的函数 <code>xxxx_read_header()</code> 调用 <code>avformat_open_input()</code> 创建</li><li>如果解封装时，未在文件中读到文件头，即标志位 <code>AVFMTCTX_NOHEADER</code> 被置位，由函数 <code>xxxx_read_packet()</code> 调用 <code>avformat_open_input()</code> 创建</li><li>在封装时，<code>AVStream</code> 对象由用户调用函数 <code>avformat_new_stream()</code> 创建</li><li>调用 <code>libavformat</code> 中的函数 <code>avformat_free_context()</code> 销毁对象</li></ul><h4 id="AVStream-相关函数"><a href="#AVStream-相关函数" class="headerlink" title="AVStream 相关函数"></a>AVStream 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a new stream to a media file.</span></span><br><span class="line"><span class="comment"> * @param s media file handle</span></span><br><span class="line"><span class="comment"> * @param c If non-NULL, the AVCodecContext corresponding to the new stream will be initialized to use this codec.</span></span><br><span class="line"><span class="comment"> * This is needed for e.g. codec-specific defaults to be set, so codec should be provided if it is known.</span></span><br><span class="line"><span class="comment"> * @return newly created stream or NULL on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVStream *<span class="title">avformat_new_stream</span><span class="params">(AVFormatContext *s, <span class="keyword">const</span> AVCodec *c)</span></span></span><br></pre></td></tr></table></figure><h4 id="AVStream-成员变量"><a href="#AVStream-成员变量" class="headerlink" title="AVStream 成员变量"></a>AVStream 成员变量</h4><ul><li><code>int index</code> : stream index in AVFormatContext</li><li><code>AVCodecContext *codec;</code> : 指向该视频 / 音频流的 AVCodecContext 它们是一一对应的关系</li><li><code>AVRational time_base;</code> : 该流的时基 通过该值可以把 PTS/DTS 转化为真正的时间</li><li><code>int64_t duration;</code> : 该视频 / 音频流长度</li><li><code>AVRational r_frame_rate;</code> : 该流的帧率</li><li><code>AVDictionary *metadata;</code> : 元数据信息</li><li><code>AVRational avg_frame_rate;</code> : 平均帧率（注 : 对视频来说，这个挺重要的）</li><li><code>AVPacket attached_pic;</code> : 附带的图片。比如说一些 MP3，AAC 音频文件附带的专辑封面</li><li><code>AVCodecParameters *codecpar;</code> : 与此流相关的编解码器参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVRational 可以用来表示无理数：</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVRational</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">///&lt; Numerator 分子</span></span><br><span class="line">    <span class="keyword">int</span> den; <span class="comment">///&lt; Denominator 分母</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure><h3 id="AVInputFormat"><a href="#AVInputFormat" class="headerlink" title="AVInputFormat"></a>AVInputFormat</h3><p>该结构被称为 <code>demuxer</code>，是音视频文件的一个解封装器</p><blockquote><p><code>AVOutputFormat</code> 和 <code>AVInputFormat</code> 结构类似，是音视频文件的封装器</p></blockquote><h4 id="AVInputFormat-相关函数"><a href="#AVInputFormat-相关函数" class="headerlink" title="AVInputFormat 相关函数"></a>AVInputFormat 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If f is NULL, returns the first registered input format,</span></span><br><span class="line"><span class="comment"> * if f is non-NULL, returns the next registered input format after f or NULL if f is the last one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">attribute_deprecated AVInputFormat  *<span class="title">av_iformat_next</span><span class="params">(<span class="keyword">const</span> AVInputFormat  *f)</span></span>;</span><br></pre></td></tr></table></figure><p>遍历 <code>ffmpeg</code> 中的解封装器的方法：</p><ol><li>注册所有解封装器：<code>av_register_all();</code>。注意，需要调用该函数才可以将所有注册的解封装器连接为一个链表</li><li>声明一个 <code>AVInputFormat</code> 类型的指针，比如说 <code>AVInputFormat* first_f = nullptr;</code></li><li>调用 <code>av_iformat_next()</code> 函数，即可获得指向链表下一个解封装器的指针，循环往复可以获得所有解码器的信息</li></ol><h4 id="AVInputFormat-成员变量"><a href="#AVInputFormat-成员变量" class="headerlink" title="AVInputFormat 成员变量"></a>AVInputFormat 成员变量</h4><p>每种文件格式对应了一个 <code>AVInputFormat</code> 对象，这些对象中的成员变量基本为 <code>const</code> 类型</p><ul><li><code>const char *name;</code> : 封装格式名称</li><li><code>const char *long_name;</code> : 封装格式的长名称</li><li><code>const char *extensions;</code> : 封装格式的扩展名</li><li><code>int raw_codec_id;</code> : 封装格式 <code>ID</code></li><li>一些封装格式处理的接口回调函数，如 <code>read_header</code>, <code>read_packet</code>, <code>read_close</code>, <code>read_seek</code> 等</li></ul><h3 id="编码-amp-解码"><a href="#编码-amp-解码" class="headerlink" title="编码 &amp; 解码"></a>编码 &amp; 解码</h3><h3 id="AVCodecContext"><a href="#AVCodecContext" class="headerlink" title="AVCodecContext"></a>AVCodecContext</h3><h3 id="AVCodecContext-相关函数"><a href="#AVCodecContext-相关函数" class="headerlink" title="AVCodecContext 相关函数"></a>AVCodecContext 相关函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个 AVCodecContext，并将其字段设置为默认值</span></span><br><span class="line"><span class="function">AVCodecContext *<span class="title">avcodec_alloc_context3</span><span class="params">(<span class="keyword">const</span> AVCodec *codec)</span></span>;</span><br><span class="line"><span class="comment">// 释放 AVCodecContext 及其相关内容，并向提供的指针写入 nullptr</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avcodec_free_context</span><span class="params">(AVCodecContext **avctx)</span></span>;</span><br><span class="line"><span class="comment">// 关闭一个给定的 AVCodecContext 并释放所有与它相关的数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_close</span><span class="params">(AVCodecContext *avctx)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fill the codec context based on the values from the supplied codec parameters.</span></span><br><span class="line"><span class="comment"> * Any allocated fields in codec that have a corresponding field in par are</span></span><br><span class="line"><span class="comment"> * freed and replaced with duplicates of the corresponding field in par.</span></span><br><span class="line"><span class="comment"> * Fields in codec that do not have a counterpart in par are not touched.</span></span><br><span class="line"><span class="comment"> * @return &gt;= 0 on success, a negative AVERROR code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_parameters_to_context</span><span class="params">(AVCodecContext *codec, <span class="keyword">const</span> AVCodecParameters *par)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="AVCodecContext-成员变量"><a href="#AVCodecContext-成员变量" class="headerlink" title="AVCodecContext 成员变量"></a>AVCodecContext 成员变量</h4><ul><li><code>const struct AVCodec  *codec;</code> : 编解码器的 <code>AVCodec</code></li><li><code>int width, height;</code> : 图像的宽高（只针对视频）</li><li><code>int coded_width, coded_height;</code> 未裁剪的图像宽高</li><li><code>enum AVPixelFormat pix_fmt;</code> : 像素格式（只针对视频）</li><li><code>AVRational time_base;</code> : 帧率的信息</li><li><code>int sample_rate;</code> : 采样率（只针对音频）</li><li><code>int channels;</code> : 采样率（只针对音频）</li><li><code>enum AVSampleFormat sample_fmt;</code> : 采样格式（只针对音频）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    **** width&#x2F;coded_width &amp; height&#x2F;coded_height ****</span><br><span class="line">一些编码器要求帧尺寸是特定数字的倍数，例如 x264 的帧尺寸是 16 的倍数</span><br><span class="line">因此，如果需要，编码器将把帧填充到合适的数字，并为解码器存储裁剪值</span><br><span class="line">coded_width, coded_height 是裁剪前的大小</span><br><span class="line">width, height 是裁剪后的大小</span><br></pre></td></tr></table></figure><h3 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h3><p>AVCodec 是存储编解码器信息的结构体</p><h4 id="AVCodec-相关函数"><a href="#AVCodec-相关函数" class="headerlink" title="AVCodec 相关函数"></a>AVCodec 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 c 为空，返回第一个注册的编解码器</span></span><br><span class="line"><span class="comment">// 如果 c 非空，返回 c 之后的下一个注册编解码器，如果 c 是最后一个编解码器，返回 nullptr</span></span><br><span class="line"><span class="function">attribute_deprecated AVCodec *<span class="title">av_codec_next</span><span class="params">(<span class="keyword">const</span> AVCodec *c)</span></span>;</span><br><span class="line"><span class="comment">// 查找具有匹配编解码器 ID 的已注册解码器</span></span><br><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span>;</span><br><span class="line"><span class="comment">// 初始化 AVCodecContext 使用给定的 AVCodec。在使用这个函数之前，必须使用 avcodec_alloc_context3() 分配上下文。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_open2</span><span class="params">(AVCodecContext *avctx, <span class="keyword">const</span> AVCodec *codec, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><p>遍历 <code>ffmpeg</code> 中的解码器信息的方法：</p><ol><li>注册所有编解码器：<code>av_register_all();</code>。注意，需要调用该函数才可以将所有注册的解码器连接为一个链表</li><li>声明一个 <code>AVCodec</code> 类型的指针，比如说 <code>AVCodec* first_c = nullptr;</code></li><li>调用 <code>av_codec_next()</code> 函数，即可获得指向链表下一个解码器的指针，循环往复可以获得所有解码器的信息。注意，如果想要获得指向第一个解码器的指针，则需要将该函数的参数设置为 <code>nullptr</code></li></ol><h4 id="AVCodec-成员变量"><a href="#AVCodec-成员变量" class="headerlink" title="AVCodec 成员变量"></a>AVCodec 成员变量</h4><ul><li><code>const char *name;</code> : 编解码器的名字，比较短</li><li><code>const char *long_name;</code> : 编解码器的名字，全称，比较长</li><li><code>enum AVMediaType type;</code> : 指明了类型，是视频，音频，还是字幕</li><li><code>enum AVCodecID id;</code> : ID，不重复</li><li><code>const AVRational *supported_framerates;</code> : 支持的帧率（仅视频）</li><li><code>const enum AVPixelFormat *pix_fmts;</code> : 支持的像素格式（仅视频）</li><li><code>const int *supported_samplerates;</code> : 支持的采样率（仅音频）</li><li><code>const enum AVSampleFormat *sample_fmts;</code> : 支持的采样格式（仅音频）</li><li><code>const uint64_t *channel_layouts;</code> : 支持的声道数（仅音频）</li><li><code>int priv_data_size;</code> : 私有数据的大小</li></ul><p>每一个编解码器对应一个该结构体，查看一下 <code>ffmpeg</code> 的源代码，我们可以看一下 <code>H.264</code> 解码器的结构体如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h264.c</span></span><br><span class="line">AVCodec ff_h264_decoder = &#123;</span><br><span class="line">    .name                  = <span class="string">&quot;h264&quot;</span>,</span><br><span class="line">    .long_name             = NULL_IF_CONFIG_SMALL(<span class="string">&quot;H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10&quot;</span>),</span><br><span class="line">    .type                  = AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    .id                    = AV_CODEC_ID_H264,</span><br><span class="line">    .priv_data_size        = <span class="keyword">sizeof</span>(H264Context),</span><br><span class="line">    .init                  = h264_decode_init,</span><br><span class="line">    .<span class="built_in">close</span>                 = h264_decode_end,</span><br><span class="line">    .decode                = h264_decode_frame,</span><br><span class="line">    .capabilities          = <span class="comment">/*AV_CODEC_CAP_DRAW_HORIZ_BAND |*/</span> AV_CODEC_CAP_DR1 |</span><br><span class="line">                             AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS |</span><br><span class="line">                             AV_CODEC_CAP_FRAME_THREADS,</span><br><span class="line">    .hw_configs            = (<span class="keyword">const</span> AVCodecHWConfigInternal *<span class="keyword">const</span> []) &#123; <span class="literal">NULL</span> &#125;,</span><br><span class="line">    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_EXPORTS_CROPPING |</span><br><span class="line">                             FF_CODEC_CAP_ALLOCATE_PROGRESS | FF_CODEC_CAP_INIT_CLEANUP,</span><br><span class="line">    .<span class="built_in">flush</span>                 = h264_decode_flush,</span><br><span class="line">    .update_thread_context = ONLY_IF_THREADS_ENABLED(ff_h264_update_thread_context),</span><br><span class="line">    .profiles              = NULL_IF_CONFIG_SMALL(ff_h264_profiles),</span><br><span class="line">    .priv_class            = &amp;h264_class,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="音视频数据"><a href="#音视频数据" class="headerlink" title="音视频数据"></a>音视频数据</h2><h3 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h3><p><code>AVPacket</code> 是存储压缩编码数据相关信息的结构体</p><h4 id="AVPacket-相关函数"><a href="#AVPacket-相关函数" class="headerlink" title="AVPacket 相关函数"></a>AVPacket 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回流的下一帧</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br><span class="line"><span class="comment">// 向解码器提供原始数据包数据作为输入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_send_packet</span><span class="params">(AVCodecContext *avctx, <span class="keyword">const</span> AVPacket *avpkt)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="AVPacket-结构体定义"><a href="#AVPacket-结构体定义" class="headerlink" title="AVPacket 结构体定义"></a>AVPacket 结构体定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVPacket</span> &#123;</span></span><br><span class="line">    AVBufferRef *buf;</span><br><span class="line">    <span class="keyword">int64_t</span> pts;    <span class="comment">///&lt; 显示时间戳</span></span><br><span class="line">    <span class="keyword">int64_t</span> dts;    <span class="comment">///&lt; 解码时间戳</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *data;  <span class="comment">///&lt; 压缩编码数据</span></span><br><span class="line">    <span class="keyword">int</span>   <span class="built_in">size</span>;     <span class="comment">///&lt; 压缩编码数据大小</span></span><br><span class="line">    <span class="keyword">int</span>   stream_index; <span class="comment">///&lt; 所属的 AVStream</span></span><br><span class="line">    <span class="keyword">int</span>   flags;    <span class="comment">///&lt; A combination of AV_PKT_FLAG values</span></span><br><span class="line">    AVPacketSideData *side_data;</span><br><span class="line">    <span class="keyword">int</span> side_data_elems;</span><br><span class="line">    <span class="keyword">int64_t</span> duration;</span><br><span class="line">    <span class="keyword">int64_t</span> pos;    <span class="comment">///&lt; byte position in stream, -1 if unknown</span></span><br><span class="line">&#125; AVPacket;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   *** 对于 H.264 来说。1 个 AVPacket 的 data 通常对应一个 NALU ***</span><br><span class="line">通过查看 ffmpeg 源代码我们发现，AVPacket 中的数据起始处没有分隔符 0x00000001</span><br><span class="line">也不是 0x65、0x67、0x68、0x41 等字节</span><br><span class="line">所以 AVPacket 肯定这不是标准的 NALU</span><br><span class="line">其实，AVPacket 前 4 个字表示的是 NALU 的长度，从第 5 个字节开始才是 NALU 的数据</span><br><span class="line">所以直接将 AVPacket 前 4 个字节替换为 0x00000001 即可得到标准的 NALU 数据</span><br></pre></td></tr></table></figure><h3 id="AVFrame"><a href="#AVFrame" class="headerlink" title="AVFrame"></a>AVFrame</h3><h4 id="AVFrame-相关函数"><a href="#AVFrame-相关函数" class="headerlink" title="AVFrame 相关函数"></a>AVFrame 相关函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配 AVFrame 并将其字段设置为默认值</span></span><br><span class="line"><span class="function">AVFrame *<span class="title">av_frame_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 释放 AVFrame 和其中所有动态分配的成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_frame_free</span><span class="params">(AVFrame **frame)</span></span>;</span><br><span class="line"><span class="comment">// 从解码器返回已解码的输出数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_receive_frame</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="AVPacket-成员变量"><a href="#AVPacket-成员变量" class="headerlink" title="AVPacket 成员变量"></a>AVPacket 成员变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVFrame</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_NUM_DATA_POINTERS 8</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *data[AV_NUM_DATA_POINTERS];    <span class="comment">// 解码后原始数据 对视频来说是 YUV，RGB，对音频来说是 PCM</span></span><br><span class="line">    <span class="keyword">int</span> linesize[AV_NUM_DATA_POINTERS];     <span class="comment">// data 中一行数据的大小。注意：未必等于图像的宽，一般大于图像的宽</span></span><br><span class="line">    <span class="keyword">uint8_t</span> **extended_data;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;  <span class="comment">// 视频帧宽和高（1920x1080, 1280x720 ...）</span></span><br><span class="line">    <span class="keyword">int</span> nb_samples;     <span class="comment">// 音频的一个 AVFrame 中可能包含多个音频帧，在此标记包含了几个</span></span><br><span class="line">    <span class="keyword">int</span> format;         <span class="comment">// 解码后原始数据类型（YUV420, YUV422, RGB24 ...）</span></span><br><span class="line">    <span class="keyword">int</span> key_frame;      <span class="comment">// 1 -&gt; keyframe, 0-&gt; not</span></span><br><span class="line">    <span class="keyword">enum</span> AVPictureType pict_type;   <span class="comment">// 帧类型（I, B, P ...）</span></span><br><span class="line">    AVRational sample_aspect_ratio; <span class="comment">// 宽高比（16:9, 4:3 ...）</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts;        <span class="comment">// 显示时间戳</span></span><br><span class="line">    <span class="keyword">int64_t</span> pkt_dts;</span><br><span class="line">    <span class="keyword">int</span> coded_picture_number;   <span class="comment">// 编码帧序号</span></span><br><span class="line">    <span class="keyword">int</span> display_picture_number; <span class="comment">// 显示帧序号</span></span><br><span class="line">    ... ...</span><br><span class="line">&#125; AVFrame;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] 基于 FFmpeg + SDL 的视频播放器的制作 — 雷霄骅</li><li>[2] <a href="https://blog.csdn.net/leixiaohua1020/article/details/11693997">FFMPEG 中最关键的结构体之间的关系_雷霄骅 (leixiaohua1020) 的专栏 - CSDN 博客_ffmpeg 结构体</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AVFormatContext&lt;/code&gt; : 封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVInputFormat&lt;/code&gt; : 每种封装格式（例如 FLV, MKV, MP4, AVI）对应一个该结构体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVStream&lt;/code&gt; : 视频文件中每个视频（音频）流对应一个该结构体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVCodecContext&lt;/code&gt; : 编码器上下文结构体，保存了视频（音频）编解码相关信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVCodec&lt;/code&gt; : 每种视频（音频）编解码器 (例如 H.264 解码器) 对应一个该结构体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVPacket&lt;/code&gt; : 存储一帧压缩编码数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVFrame&lt;/code&gt; : 存储一帧解码后像素（采样）数据&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="音视频日记" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="ffmpeg" scheme="http://github.hezhaojiang.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - ffmpeg 命令行</title>
    <link href="http://github.hezhaojiang.io/post/2021/4765df61/"/>
    <id>http://github.hezhaojiang.io/post/2021/4765df61/</id>
    <published>2021-01-04T06:38:32.000Z</published>
    <updated>2021-01-13T13:48:34.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>ffmpeg</code> 是一个基于 <code>ffmpeg</code> 库的经典转码程序，几乎被所有的知名系统、软件工具、服务器后台等静默使用，通过命令行启动转码，这里主要以命令行语法讲解为主。</p><a id="more"></a><h2 id="查看-ffmpeg-帮助命令"><a href="#查看-ffmpeg-帮助命令" class="headerlink" title="查看 ffmpeg 帮助命令"></a>查看 ffmpeg 帮助命令</h2><p>在学习任何一个命令行程序前，首先要知道如何查看对应命令的帮助，在一般情况下，<code>linux</code> 平台下程序的帮助信息是通过 <code>程序名 -h</code> 的方式进行输出，<code>ffmpeg</code> 亦是如此。</p><p>精简帮助命令：<code>ffmpeg –h</code><br>更多帮助命令：<code>ffmpeg –h long</code><br>完整帮助命令：<code>ffmpeg –h full</code></p><h2 id="ffmpeg-的语法格式"><a href="#ffmpeg-的语法格式" class="headerlink" title="ffmpeg 的语法格式"></a>ffmpeg 的语法格式</h2><p>ffmpeg 的语法格式如下所示</p><pre><code>ffmpeg [输入源参数] -i [输入 URL] [输出参数] [输出 URL]其中 [输入源参数] 和 [输出参数] 的语法格式为：[options] [value(可以省略)] ... ...</code></pre><p>示例 1：</p><pre><code>ffmpeg -f mpegts -i &quot;http://AVTestFile/AVNormal/52&quot; -vcodec x264Encoder -r 15 -b:v 256000 -vf scale=800:600 -an -copyts -y &quot;51.avi&quot;* 输入源使用 mpegts 容器 http 协议的 URL* -vcodec x264Encoder 使用 x264Encoder 视频编码器* -r 15 视频帧率 15 fps* -b:v 256000 视频编码码率 265Kbps* -vf scale=800:600 使用视频滤器 scale 进行缩放到 800x600 尺寸* -an 禁用音频* -copyts 时间戳拷贝* -y 覆盖输出文件* 输出 URL 默认使用 file 协议，输出到文件 51.avi</code></pre><p>示例 2：</p><pre><code>ffmpeg -i BaiCaoYuan.mp4 -ss 00:00:19 -t 00:06:48 -dcodec copy -b:v 4000K -y cut.mp4* 输入源使用 file 协议，为 BaiCaoYuan.mp4 文件* -dcodec copy 使用与源视频一致的编解码器* -b:v 4000K 视频编码码率 4000Kbps* -y 覆盖输出文件* 输出 URL 默认使用 file 协议，输出到文件 cut.mp4</code></pre><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><div class="table-container"><table><thead><tr><th>参数</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>-t duration</td><td>-t 00:06:48</td><td>设置处理时间，格式为hh:mm:ss</td></tr><tr><td>-ss position</td><td>-ss 00:00:19</td><td>设置起始时间，格式为hh:mm:ss</td></tr><tr><td>-b:v bitrate</td><td>-b:v 256000</td><td>设置视频码率</td></tr><tr><td>-b:a bitrate</td><td>-b:a 320000</td><td>设置音频码率</td></tr><tr><td>-r fps</td><td>-r 25</td><td>设置帧率</td></tr><tr><td>-s wxh</td><td>-s 800x600</td><td>设置帧大小，格式为WxH</td></tr><tr><td>-c:v codec</td><td>-c:v h264</td><td>设置视频编码器</td></tr><tr><td>-c:a codec</td><td>-c:a aac</td><td>设置音频编码器</td></tr><tr><td>-ar freq</td><td>-ar 44100</td><td>设置音频采样率</td></tr></tbody></table></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] 基于 FFmpeg + SDL 的视频播放器的制作 — 雷霄骅</li><li>[2] 多媒体编程开发之 FFmpeg 基础库</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;ffmpeg&lt;/code&gt; 是一个基于 &lt;code&gt;ffmpeg&lt;/code&gt; 库的经典转码程序，几乎被所有的知名系统、软件工具、服务器后台等静默使用，通过命令行启动转码，这里主要以命令行语法讲解为主。&lt;/p&gt;</summary>
    
    
    
    <category term="音视频日记" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="ffmpeg" scheme="http://github.hezhaojiang.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频日记 - YUV 格式详解</title>
    <link href="http://github.hezhaojiang.io/post/2021/a4daf22d/"/>
    <id>http://github.hezhaojiang.io/post/2021/a4daf22d/</id>
    <published>2021-01-03T05:07:20.000Z</published>
    <updated>2021-02-04T16:46:01.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>YUV</code> 是一种彩色编码系统，主要用在视频、图形处理流水线中 (pipeline)。相对于 RGB 颜色空间，设计 <code>YUV</code> 的目的就是为了编码、传输的方便，减少带宽占用和信息出错。</p><p>人眼的视觉特点是对亮度更铭感，对位置、色彩相对来说不铭感。在视频编码系统中为了降低带宽，可以保存更多的亮度信息 (luma)，保存较少的色差信息 (chroma)。</p><a id="more"></a><h2 id="YUV-的相似概念"><a href="#YUV-的相似概念" class="headerlink" title="YUV 的相似概念"></a>YUV 的相似概念</h2><p><code>Y’UV</code>、<code>YUV</code>、<code>YCbCr</code>、<code>YPbPr</code> 几个概念其实是一回事儿。</p><p>由于历史关系，<code>Y’UV</code>、<code>YUV</code> 主要是用在彩色电视中，用于模拟信号表示。</p><p><code>YCbCr</code> 是用在数字视频、图像的压缩和传输，如 <code>MPEG</code>、<code>JPEG</code>。</p><p>今天大家所讲的 <code>YUV</code> 其实就是指 <code>YCbCr</code>。<code>Y</code> 表示亮度（luma），<code>CbCr</code> 表示色度（chroma）。</p><p>luminance 亮度，<code>luma</code> 是在视频编码系统中指亮度值；chrominance 色度，<code>chroma</code> 是在视频编码系统中指色度值。</p><p><code>Y’UV</code> 设计的初衷是为了使彩色电视能够兼容黑白电视。对于黑白电视信号，没有色度信息也就是 (<code>UV</code>)，那么在彩色电视显示的时候指显示亮度信息。</p><p><code>Y’UV</code> 不是 <code>Absolute Color Space</code>，只是一种 <code>RGB</code> 的信息编码，实际的显示还是通过 <code>RGB</code> 来显示。<code>Y’,U,V</code> 叫做不同的 component。</p><h2 id="YUV-后数字的含义"><a href="#YUV-后数字的含义" class="headerlink" title="YUV 后数字的含义"></a>YUV 后数字的含义</h2><pre><code>我们一般理解为 yuv444，yuv422，yuv420 的解释是后面三个数字分别对应前面三个字母。拿 yuv422 来说：y 对应 4，表示 4 个图形像素中，每个都有亮度值u 对应 2，表示 4 个图形像素中，Cb 占用两个像素v 对应 2，表示 4 个图形像素中，Cr 占用两个像素但是对于 yuv420 解释就不对了，不能说 4 个图形像素中，Cr 占用 0 个像素吧？</code></pre><p>我们通过下图来理解一下 <code>yuv</code> 各种格式后面数字的含义。图来源于 <a href="https://link.zhihu.com/?target=http%3A//dougkerr.net/Pumpkin/articles/Subsampling.pdf">Chrominance Subsampling in Digital Images</a></p><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210103211447.png" alt="YUV"></p><p>如上图中所示，左侧一列，每一个小矩形是图形像素表示，黑框矩形是色度像素表示，小黑点是表示色度像素值 (Cb + Cr)，表示图形像素和色度像素在水平和垂直方向的比例关系。比如，</p><pre><code>- 4:4:0 水平方向是 1/1，垂直方向是 1/2，表示 1 个色度像素对应了 2 个图形像素。- 4:2:2 水平方向是 1/2，垂直方向是 1/1，表示 1 个色度像素对应了 2 个图形像素。- 4:2:0 水平方向是 1/2，垂直方向是 1/2，表示 1 个色度像素对应了 4 个图形像素。</code></pre><p>右侧一列是二次采样模式记号表示, 是 <code>J:a:b</code> 模式，即 YUV 后数字表示的模式。图中实心黑色圆圈表示包含色度像素 (Cb + Cr），空心圆圈表示不包含色度像素。</p><pre><code>对于 J:a:b 模式，定义了一个 J x 2 的矩形参考块J 通常是 4，此参考块就是宽度有 4 个像素、高度有 2 个像素的矩形a 表示参考块的第一行包含的色度像素样本数b 表示在参考块的第二行包含的色度像素样本数- 4:4:0 参考块第 1 行包含 4 个色度样本，第 2 行没有包含色度样本。- 4:2:2 参考块第 1 行包含 2 个色度样本，第 2 行也包含 2 个色度样本，他们是交替出现。- 4:2:0 参考块第 1 行包含 2 个色度样本，第 2 行没有包含色度样本。</code></pre><blockquote><p>存在的一个例外是 4:1:0，其在每个亮度平面分辨率为 4 x 4 的块内提供一个色度样本。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://zhuanlan.zhihu.com/p/85620611">如何理解 YUV ？ - 知乎</a></li><li>[2] 多媒体编程开发之 FFmpeg 基础库</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;YUV&lt;/code&gt; 是一种彩色编码系统，主要用在视频、图形处理流水线中 (pipeline)。相对于 RGB 颜色空间，设计 &lt;code&gt;YUV&lt;/code&gt; 的目的就是为了编码、传输的方便，减少带宽占用和信息出错。&lt;/p&gt;
&lt;p&gt;人眼的视觉特点是对亮度更铭感，对位置、色彩相对来说不铭感。在视频编码系统中为了降低带宽，可以保存更多的亮度信息 (luma)，保存较少的色差信息 (chroma)。&lt;/p&gt;</summary>
    
    
    
    <category term="音视频日记" scheme="http://github.hezhaojiang.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="YUV" scheme="http://github.hezhaojiang.io/tags/YUV/"/>
    
  </entry>
  
</feed>
