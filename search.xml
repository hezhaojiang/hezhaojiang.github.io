<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GB28181 - 注册与注销</title>
    <url>/post/2020/de00def7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="注册要求"><a href="#注册要求" class="headerlink" title="注册要求"></a>注册要求</h2><p>在《GB/T28181—2016 公共安全视频监控联网系统信息传输、交换、控制技术要求》中对注册行为有以下要求：</p>
<blockquote>
<p>应支持设备或系统进入联网系统时向 SIP 服务器进行注册登记的工作模式。 如果设备或系统注册不成功, 宜延迟一定的随机时间后重新注册。</p>
</blockquote>
<a id="more"></a>
<h2 id="注册过程"><a href="#注册过程" class="headerlink" title="注册过程"></a>注册过程</h2><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><p>在《GB/T28181—2016 公共安全视频监控联网系统信息传输、交换、控制技术要求》中对注册过程有以下要求：</p>
<blockquote>
<p>SIP 客户端、网关、SIP 设备、联网系统等 SIP 代理 (SIPUA) 使用 IETF RFC 3261 中定义的方法 Register 进行注册和注销。注册和注销时应进行认证, 认证方式应支持数字摘要认证方式, 高安全级别的宜支持数字证书的认证方式。</p>
</blockquote>
<p>从上文中可看出，GB28181 规定了两种注册流程：</p>
<ol>
<li>基于数字摘要的注册流程</li>
<li>基于数字证书的注册流程</li>
</ol>
<p>本文中主要讨论基于数字摘要的注册流程。</p>
<blockquote>
<p>基于数字证书的注册流程涉及到公安部发布的另一个标准：《GB 35114-2017 公共安全视频监控联网信息安全技术要求》</p>
</blockquote>
<p>GB28181 中规定了注册相关的一些数字和状态：</p>
<ol>
<li>注册过期时间：可配置，默认值 86400s，不应短于 3600s，在注册过期之前，SIP 代理应向 SIP 服务器发起刷新注册。</li>
<li>注册失败后，SIP 代理应在重新发起注册，与上一次注册时间间隔可调，但不应短于 60s</li>
<li>对于 SIP 代理：<ul>
<li>注册成功则认为 SIP 服务器在线，注册失败则认为 SIP 服务器离线</li>
</ul>
</li>
<li>对于 SIP 服务器：<ul>
<li>注册成功则认为 SIP 代理在线，注册失败则认为 SIP 代理离线</li>
</ul>
</li>
</ol>
<h3 id="信令流程"><a href="#信令流程" class="headerlink" title="信令流程"></a>信令流程</h3><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200930132909.png" alt="GB28181 注册流程"></p>
<p>注册流程描述如下:</p>
<ol>
<li><p><code>SIP</code> 代理向 <code>SIP</code> 服务器发送 <code>Register</code> 请求</p>
<pre><code> REGISTER sip:130909115229300920@10.64.49.44:7100 SIP/2.0
 Via: SIP/2.0/UDP 10.64.49.218:7100;rport;branch=z9hG4bK4162288924
 From: &lt;sip:130909113319427420@10.64.49.218:7100&gt;;tag=382068091
 To: &lt;sip:130909113319427420@10.64.49.218:7100&gt;
 Call-ID: 143225205
 CSeq: 1 REGISTER
 Contact: &lt;sip:130909113319427420@10.64.49.218:7100&gt;
 Max-Forwards: 70
 User-Agent: Hikvision
 Expires: 7200
 Content-Length: 0
</code></pre></li>
<li><p><code>SIP</code> 服务器向 <code>SIP</code> 代理发送响应 <code>401</code>，并在响应的消息头 <code>WWW_Authenticate</code> 字段中给出适合 <code>SIP</code> 代理的认证体制和参数</p>
<pre><code> SIP/2.0 401 Unauthorized
 Via: SIP/2.0/UDP 10.64.49.218:7100;rport=7100;branch=z9hG4bK4162288924
 From: &lt;sip:130909113319427420@10.64.49.218:7100&gt;;tag=382068091
 To: &lt;sip:130909113319427420@10.64.49.218:7100&gt;;tag=916944766
 Call-ID: 143225205
 CSeq: 1 REGISTER
 WWW-Authenticate: Digest realm=&quot;hik&quot;, nonce=&quot;a8afe6fcbee6331d89d3eb0d3d19ce39&quot;, opaque=&quot;a853e4f25298413f9bf3a9aa6767857d&quot;, algorithm=MD5
 User-Agent: Hikvision
 Expires: 7200
 Content-Length: 0
</code></pre></li>
<li><p><code>SIP</code> 代理重新向 <code>SIP</code> 服务器发送 <code>Register</code> 请求, 在请求的 <code>Authorization</code> 字段给出信任书, 包含认证信息</p>
<pre><code> REGISTER sip:130909115229300920@10.64.49.44:7100 SIP/2.0
 Via: SIP/2.0/UDP 10.64.49.218:7100;rport;branch=z9hG4bK3997518011
 From: &lt;sip:130909113319427420@10.64.49.218:7100&gt;;tag=382068091
 To: &lt;sip:130909113319427420@10.64.49.218:7100&gt;
 Call-ID: 143225205
 CSeq: 2 REGISTER
 Contact: &lt;sip:130909113319427420@10.64.49.218:7100&gt;
 Authorization: Digest username=&quot;admin&quot;, realm=&quot;hik&quot;, nonce=&quot;a8afe6fcbee6331d89d3eb0d3d19ce39&quot;, uri=&quot;sip:130909115229300920@10.64.49.44:7100&quot;, response=&quot;907ddb1bcc25174d7de4a96c947fb066&quot;, algorithm=MD5, opaque=&quot;a853e4f25298413f9bf3a9aa6767857d&quot;
 Max-Forwards: 70
 User-Agent: Hikvision
 Expires: 7200
 Content-Length: 0
</code></pre></li>
<li><p><code>SIP</code> 服务器对请求进行验证, 如果检查出 <code>SIP</code> 代理身份合法, 向 <code>SIP</code> 代理发送成功响应 <code>200OK</code>，如果身份不合法则发送拒绝服务应答</p>
<pre><code> SIP/2.0 200 OK
 Via: SIP/2.0/UDP 10.64.49.218:7100;rport=7100;branch=z9hG4bK3997518011
 From: &lt;sip:130909113319427420@10.64.49.218:7100&gt;;tag=382068091
 To: &lt;sip:130909113319427420@10.64.49.218:7100&gt;;tag=705514612
 Call-ID: 143225205
 CSeq: 2 REGISTER
 Contact: &lt;sip:130909113319427420@10.64.49.218:7100&gt;
 User-Agent: Hikvision
 Date: 2013-09-10T16:01:51
 Content-Length: 0
</code></pre></li>
</ol>
<blockquote>
<p>需要注意的是，<code>SIP</code> 服务器在返回 <code>200OK</code> 时，携带了 <code>Date</code> 字段，这个字段是用来给 <code>SIP</code> 代理校时使用，<code>SIP</code> 代理应根据收到的 <code>Date</code> 字段对自身进行校时。</p>
</blockquote>
<h2 id="注销过程"><a href="#注销过程" class="headerlink" title="注销过程"></a>注销过程</h2><p>注销过程的信令流程与注册过程基本一致，只存在一处不同点：</p>
<ul>
<li>注销过程的注册过期时间字段值为 <code>0</code>，即 <code>Expires: 0</code></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 《GB/T28181—2016 公共安全视频监控联网系统信息传输、交换、控制技术要求》</li>
</ul>
]]></content>
      <tags>
        <tag>GB28181</tag>
      </tags>
  </entry>
  <entry>
    <title>GB28181 - 注册保活</title>
    <url>/post/2020/16184cca/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>注册保活，顾名思义，即保持注册成功的在线状态。SIP 代理向 SIP 服务器注册成功后，如果缺少保活机制，SIP 代理就很难发现 SIP 服务离线，SIP 服务也很难发现 SIP 代理离线，这是就需要有保活机制。</p>
<p>《GB/T28181—2016 公共安全视频监控联网系统信息传输、交换、控制技术要求》中要求了两种注册保活机制：</p>
<ol>
<li>刷新注册机制</li>
<li>状态信息报送机制</li>
</ol>
<a id="more"></a>
<h2 id="刷新注册"><a href="#刷新注册" class="headerlink" title="刷新注册"></a>刷新注册</h2><h3 id="刷新注册要求"><a href="#刷新注册要求" class="headerlink" title="刷新注册要求"></a>刷新注册要求</h3><p>在 <a href="/post/2020/de00def7/" title="GB28181 - 注册与注销">GB28181 - 注册与注销</a> 中，我们提到了注册过期时间的概念：</p>
<ul>
<li>注册过期时间：可配置，默认值 <code>86400s</code>，不应短于 <code>3600s</code>，在注册过期之前，<code>SIP</code> 代理应向 <code>SIP</code> 服务器发起刷新注册。</li>
</ul>
<p>从概念中我们就可以了解到：如果 <code>SIP</code> 服务器在注册过期时间的时间范围内没有收到刷新注册的请求或者是刷新注册请求失败，则会认为 SIP 代理离线。</p>
<h3 id="刷新注册过程"><a href="#刷新注册过程" class="headerlink" title="刷新注册过程"></a>刷新注册过程</h3><p>刷新注册过程与 <a href="/post/2020/de00def7/" title="GB28181 - 注册与注销">GB28181 - 注册与注销</a> 中注册过程一致，但要注意刷新注册需要保持 <code>Call-ID</code> 的值与注册时使用的 <code>Call-ID</code> 值一致。</p>
<h2 id="状态信息报送"><a href="#状态信息报送" class="headerlink" title="状态信息报送"></a>状态信息报送</h2><h3 id="状态信息报送要求"><a href="#状态信息报送要求" class="headerlink" title="状态信息报送要求"></a>状态信息报送要求</h3><p>另外，在《GB/T28181—2016 公共安全视频监控联网系统信息传输、交换、控制技术要求》中还要求了状态信息报送的交互过程：</p>
<blockquote>
<p>应支持以主动报送的方式搜集、检测网络内的监控设备、报警设备、相关服务器以及连接的联网系统的运行情况。</p>
</blockquote>
<p>这样在 <code>SIP</code> 代理和 <code>SIP</code> 服务器之间即可通过周期性的状态信息报送，实现注册服务器与源设备之间的状态检测即心跳机制。</p>
<p>心跳机制相关参数：</p>
<ol>
<li>心跳间隔：指定定时发送心跳消息的时间间隔, 默认心跳间隔 <code>60s</code>。<ul>
<li>心跳发送方、接收方需统一配置心跳间隔参数</li>
</ul>
</li>
<li>心跳超时次数：允许心跳间隔超时的次数，默认心跳超时次数为 <code>3</code> 次。<ul>
<li>心跳发送方、接收方需统一配置心跳超时次数参数</li>
</ul>
</li>
</ol>
<p>心跳机制在线状态判定：</p>
<ul>
<li>心跳接收方在心跳发送方在线状态下检测到心跳消息连续超时达到心跳超时次数则认为心跳发送方离线</li>
<li>心跳发送方在心跳接收方在线状态下检测到心跳消息响应消息连续超时达到心跳超时次数则认为心跳接收方离线。</li>
</ul>
<h3 id="状态信息报送过程"><a href="#状态信息报送过程" class="headerlink" title="状态信息报送过程"></a>状态信息报送过程</h3><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200930155027.png" alt="GB28181 状态信息报送过程"></p>
<p>状态信息报送流程描述如下:</p>
<ol>
<li><p>源设备向 <code>SIP</code> 服务器发送设备状态信息报送命令。设备状态信息报送命令采用 <code>Message</code> 方法携带;</p>
<pre><code> MESSAGE sip:130909115229300920@10.64.49.44:7100 SIP/2.0
 Via: SIP/2.0/UDP 10.64.49.218:7100;rport;branch=z9hG4bK2672759896
 From: &lt;sip:130909113319427420@10.64.49.218:7100&gt;;tag=308835751
 To: &lt;sip:130909115229300920@10.64.49.44:7100&gt;
 Call-ID: 63810466
 CSeq: 20 MESSAGE
 Content-Type: Application/MANSCDP+xml
 Max-Forwards: 70
 User-Agent: Hikvision
 Content-Length:   150

 &lt;?xml version=&quot;1.0&quot;?&gt;
 &lt;Notify&gt;
 &lt;CmdType&gt;Keepalive&lt;/CmdType&gt;
 &lt;SN&gt;2749&lt;/SN&gt;
 &lt;DeviceID&gt;130909113319427420&lt;/DeviceID&gt;
 &lt;Status&gt;OK&lt;/Status&gt;
 &lt;/Notify&gt;
</code></pre></li>
<li><p>SIP 服务器收到命令后返回 <code>200OK</code>。</p>
<pre><code> SIP/2.0 200 OK
 Via: SIP/2.0/UDP 10.64.49.218:7100;rport=7100;branch=z9hG4bK2672759896
 From: &lt;sip:130909113319427420@10.64.49.218:7100&gt;;tag=308835751
 To: &lt;sip:130909115229300920@10.64.49.44:7100&gt;;tag=1578583786
 Call-ID: 63810466
 CSeq: 20 MESSAGE
 User-Agent: Hikvision
 Content-Length: 0
</code></pre></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 《GB/T28181—2016 公共安全视频监控联网系统信息传输、交换、控制技术要求》</li>
</ul>
]]></content>
      <tags>
        <tag>GB28181</tag>
      </tags>
  </entry>
  <entry>
    <title>NRM - 环境搭建</title>
    <url>/post/2020/71c958c4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>NRM(Nginx-rtmp-module) 的出现，使得很多非专业的流媒体开发工程师也可以简单、迅速地搭建流媒体服务器。</p>
<p>在 NRM 安装之前，首先要确保完成了 <a href="/post/2020/8f761f75/" title="Nginx - 环境搭建">Nginx - 环境搭建</a> 中的内容，然后再进行后续操作。</p>
<a id="more"></a>
<h2 id="NRM-介绍"><a href="#NRM-介绍" class="headerlink" title="NRM 介绍"></a>NRM 介绍</h2><h2 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h2><h3 id="下载-NRM"><a href="#下载-NRM" class="headerlink" title="下载 NRM"></a>下载 NRM</h3><p>可以在 Github 中的 nginx-rtmp-module 项目仓库：<a href="https://github.com/arut/nginx-rtmp-module/releases">https://github.com/arut/nginx-rtmp-module/releases</a> 获取 nginx-rtmp-module 源码包。</p>
<p>至本文编写时，最新的 nginx-rtmp-module 稳定版本为 <code>nginx-rtmp-module-1.2.1</code>，下文也是用该版本的源码包 <code>nginx-rtmp-module-1.2.1.tar.gz</code> 进行安装。</p>
<p>将下载好的源码包 <code>nginx-rtmp-module-1.2.1.tar.gz</code> 放到准备好的 <code>Nginx</code> 源码目录（比如我的目录为 <code>/root/nginx/</code>）中，通过命令解压：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git clone https://github.com/arut/nginx-rtmp-module</span></span><br><span class="line">$ tar xzvf nginx-rtmp-module-1.2.1.tar.gz</span><br><span class="line">$ mv nginx-rtmp-module-1.2.1 rtmp-module</span><br></pre></td></tr></table></figure>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>进入 <code>Nginx</code> 源码目录（比如我的目录为 <code>/root/nginx/nginx-1.18.0/</code>），执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./configure --add-module=/path/src/rtmp-module/</span><br><span class="line"><span class="comment"># My configure option</span></span><br><span class="line">$ ./configure --add-module=/root/nginx/rtmp-module/ --prefix=/usr/<span class="built_in">local</span>/nginx --with-http_ssl_module --pid-path=/var/run/nginx.pid --with-debug</span><br><span class="line">$ make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ol>
<li><p>从原配置文件中拷贝一份作为新配置文件的模板：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/conf/</span><br><span class="line">$ cp nginx.conf live.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>在新配置文件末尾加入以下内容：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        application mylive &#123;</span><br><span class="line">            live on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用新配置文件：</p>
<p> ==1. Systemctl 工具配置（推荐）==</p>
<ul>
<li><p>修改系统服务脚本（<code>sudo vim /lib/systemd/system/nginx.service</code>）：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 找到如下行</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line"># 修改为</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;live.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 Nginx 服务使新配置生效：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_0_6_centos conf]<span class="comment"># sudo systemctl restart nginx</span></span><br></pre></td></tr></table></figure>
<p>==Service 工具配置==</p>
</li>
<li><p>修改系统服务脚本（<code>vim /etc/init.d/nginx</code>）：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 找到如下行</span><br><span class="line">NGINX_CONF_FILE&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf&quot;</span><br><span class="line"># 修改为</span><br><span class="line">NGINX_CONF_FILE&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;live.conf&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查配置文件正确性：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_0_6_centos conf]<span class="comment"># service nginx configtest</span></span><br><span class="line">nginx: the configuration file /usr/<span class="built_in">local</span>/nginx/conf/live.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/<span class="built_in">local</span>/nginx/conf/live.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 Nginx 服务使新配置生效：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_0_6_centos conf]<span class="comment"># service nginx restart</span></span><br><span class="line">Restarting nginx (via systemctl):                          [  OK  ]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="使用-ffmpeg-推流"><a href="#使用-ffmpeg-推流" class="headerlink" title="使用 ffmpeg 推流"></a>使用 ffmpeg 推流</h3><p>在服务器上使用 ffmpeg 向 Nginx-rtmp-module 服务进行推流：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i xxx.flv -r 25 -b 1M -f flv rtmp://127.0.0.1:1935/url</span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line">ffmpeg -re -i Read_Book_852x480.flv -ar 22050 -f flv rtmp://127.0.0.1:1935/mylive/1</span><br><span class="line">ffmpeg -re -stream_loop -1 -i Read_Book_1280x720.flv -vcodec libx264 -f flv rtmp://127.0.0.1:1935/mylive/1</span><br></pre></td></tr></table></figure>
<h3 id="使用-VLC-拉流"><a href="#使用-VLC-拉流" class="headerlink" title="使用 VLC 拉流"></a>使用 VLC 拉流</h3><p>使用可以连接到服务器的计算机打开 <code>VLC</code> 播放器进行拉流：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201007225859.png" alt="VLC 拉流测试"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 中国工信出版集团 《直播系统开发 基于 Nginx 与 Nginx-rtmp-module》</li>
</ul>
]]></content>
      <tags>
        <tag>NRM</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx - 命令行参数和信号</title>
    <url>/post/2020/f45df2c9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="nginx-命令行参数"><a href="#nginx-命令行参数" class="headerlink" title="nginx 命令行参数"></a>nginx 命令行参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM_0_6_centos ~]# nginx -?</span><br><span class="line">nginx version: nginx&#x2F;1.18.0</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this help</span><br><span class="line">  -v            : show version and exit</span><br><span class="line">  -V            : show version and configure options then exit</span><br><span class="line">  -t            : test configuration and exit</span><br><span class="line">  -T            : test configuration, dump it and exit</span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : set prefix path (default: &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;)</span><br><span class="line">  -c filename   : set configuration file (default: conf&#x2F;nginx.conf)</span><br><span class="line">  -g directives : set global directives out of configuration file</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="nginx-hvVtTq"><a href="#nginx-hvVtTq" class="headerlink" title="nginx [-?hvVtTq]"></a>nginx [-?hvVtTq]</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开帮助</span></span><br><span class="line">nginx -h/-?</span><br><span class="line"><span class="comment"># 打印 nginx 的版本信息</span></span><br><span class="line">nginx -v</span><br><span class="line"><span class="comment"># 打印 nginx 的版本和编译信息</span></span><br><span class="line">nginx -V</span><br><span class="line"><span class="comment"># 测试配置文件是否有语法错误</span></span><br><span class="line">nginx -t</span><br><span class="line"><span class="comment"># 测试配置文件，转储并退出</span></span><br><span class="line">nginx -T</span><br><span class="line"><span class="comment"># 检测配置文件时屏蔽非错误信息，制输出错误信息</span></span><br><span class="line">nginx -q</span><br></pre></td></tr></table></figure>
<h3 id="nginx-s-signal"><a href="#nginx-s-signal" class="headerlink" title="nginx [-s signal]"></a>nginx [-s signal]</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新开始记录日志文件</span></span><br><span class="line">nginx -s reopen</span><br><span class="line"><span class="comment"># 立刻停止服务</span></span><br><span class="line">nginx -s stop</span><br><span class="line"><span class="comment"># 优雅的停止服务</span></span><br><span class="line">nginx -s quit</span><br><span class="line"><span class="comment"># 重载加载配置文件并重启（平滑重启）</span></span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<h3 id="nginx-c-filename"><a href="#nginx-c-filename" class="headerlink" title="nginx [-c filename]"></a>nginx [-c filename]</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用指定的配置文件，而不是默认的 conf 文件夹下的配置文件</span></span><br><span class="line">nginx -c /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
<h3 id="nginx-p-prefix"><a href="#nginx-p-prefix" class="headerlink" title="nginx [-p prefix]"></a>nginx [-p prefix]</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定运行目录</span></span><br><span class="line">nginx -p /usr/<span class="built_in">local</span>/nginx</span><br></pre></td></tr></table></figure>
<h3 id="nginx-g-directives"><a href="#nginx-g-directives" class="headerlink" title="nginx [-g directives]"></a>nginx [-g directives]</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定配置命令，覆盖掉配置文件中的指令</span></span><br><span class="line">nginx -g <span class="string">&quot;pid /var/run/nginx.pid; worker_processes `sysctl -n hw,ncpu`;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="nginx-信号控制"><a href="#nginx-信号控制" class="headerlink" title="nginx 信号控制"></a>nginx 信号控制</h2><h3 id="常见信号控制"><a href="#常见信号控制" class="headerlink" title="常见信号控制"></a>常见信号控制</h3><p><code>nginx</code> 主进程可以处理以下的信号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>信号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TERM</code>, <code>INT</code></td>
<td>快速关闭</td>
</tr>
<tr>
<td><code>QUIT</code></td>
<td>从容关闭，等待请求结束后关闭</td>
</tr>
<tr>
<td><code>HUP</code></td>
<td>重载配置，用新的配置开始新的工作进程，从容关闭旧的工作进程</td>
</tr>
<tr>
<td><code>USR1</code></td>
<td>重新打开日志文件，用于切割日志</td>
</tr>
<tr>
<td><code>USR2</code></td>
<td>平滑升级可执行程序</td>
</tr>
<tr>
<td><code>WINCH</code></td>
<td>从容关闭工作进程，可配合 USR2 信号平滑升级可执行程序</td>
</tr>
</tbody>
</table>
</div>
<h3 id="使用信号控制"><a href="#使用信号控制" class="headerlink" title="使用信号控制"></a>使用信号控制</h3><p>信号控制的具体语法为： <code>kill</code> <code>-信号选项</code> <code>Nginx 主进程号</code>，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -INT 主进程号 <span class="comment"># 关闭 Nginx 进程</span></span><br><span class="line"><span class="built_in">kill</span> -HUP 主进程号 <span class="comment"># 平滑地读取新配置文件，不必重启 Nginx</span></span><br><span class="line"><span class="built_in">kill</span> -USR1 主进程号</span><br><span class="line"><span class="built_in">kill</span> -USR2 主进程号</span><br><span class="line"><span class="built_in">kill</span> -WINCH 主进程号</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 中国工信出版集团 《直播系统开发 基于 Nginx 与 Nginx-rtmp-module》</li>
</ul>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx - 环境搭建</title>
    <url>/post/2020/8f761f75/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Linux-操作系统"><a href="#Linux-操作系统" class="headerlink" title="Linux 操作系统"></a>Linux 操作系统</h3><p>首先我们需要一个内核为 <code>Linux 2.6</code> 及以上版本的操作系统，因为 <code>Linux 2.6</code> 及以上内核才支持 <code>epoll</code>，而在 <code>Linux</code> 上使用 <code>select</code> 和 <code>poll</code> 来解决事件的多路复用，是无法解决高并发压力问题的。</p>
<p>我们可以用 <code>uname -a</code> 命令来查询 <code>Linux</code> 内核版本，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Tencent Cloud Server：</span><br><span class="line">[root@VM_0_6_centos ~]# uname -a</span><br><span class="line">Linux VM_0_6_centos 3.10.0-1062.9.1.el7.x86_64 #1 SMP Fri Dec 6 15:49:49 UTC 2019 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>也推荐使用树莓派来安装运行 <code>Linux</code> 操作系统，具体步骤可参考：<a href="/post/2020/2e43eec/" title="树莓派日记 - 安装 Ubuntu 20.04">树莓派日记 - 安装 Ubuntu 20.04</a></p>
</blockquote>
<h3 id="安装必要软件"><a href="#安装必要软件" class="headerlink" title="安装必要软件"></a>安装必要软件</h3><h4 id="gcc-编译器"><a href="#gcc-编译器" class="headerlink" title="gcc 编译器"></a>gcc 编译器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For Centos</span></span><br><span class="line">$ sudo yum install -y gcc gcc-c++</span><br><span class="line"><span class="comment"># For Ubuntu</span></span><br><span class="line">$ sudo apt-get install -y build-essential</span><br></pre></td></tr></table></figure>
<h4 id="pcre-库"><a href="#pcre-库" class="headerlink" title="pcre 库"></a>pcre 库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For Centos</span></span><br><span class="line">$ sudo yum install -y pcre pcre-devel</span><br><span class="line"><span class="comment"># For Ubuntu</span></span><br><span class="line">$ sudo apt-get install -y libpcre3 libpcre3-dev</span><br></pre></td></tr></table></figure>
<h4 id="zlib-库"><a href="#zlib-库" class="headerlink" title="zlib 库"></a>zlib 库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For Centos</span></span><br><span class="line">$ sudo yum install -y zlib zlib-devel</span><br><span class="line"><span class="comment"># For Ubuntu</span></span><br><span class="line">$ sudo apt-get install -y zlib1g-dev</span><br></pre></td></tr></table></figure>
<h4 id="OpenSSL-库"><a href="#OpenSSL-库" class="headerlink" title="OpenSSL 库"></a>OpenSSL 库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For Centos</span></span><br><span class="line">$ sudo yum install -y openssl openssl-devel</span><br><span class="line"><span class="comment"># For Ubuntu</span></span><br><span class="line">$ sudo apt-get install -y openssl libssl-dev</span><br></pre></td></tr></table></figure>
<h3 id="创建部署目录"><a href="#创建部署目录" class="headerlink" title="创建部署目录"></a>创建部署目录</h3><p>要使用 <code>Nginx</code>，还需要再 <code>Linux</code> 文件系统上准备以下目录：</p>
<ol>
<li><code>Nginx</code> 源代码存放目录<br> 用于放置从官网下载的 <code>Nginx</code> 源码文件，以及第三方或我们自己写的模块代码文件</li>
<li><code>Nginx</code> 编译阶段产生的中间文件存放目录<br> 默认会将该目录命名为 obgs，并放置于 <code>Nginx</code> 源代码目录下</li>
<li>部署目录<br> 默认路径为 <code>/usr/local/nginx</code></li>
<li>日志存放目录<br> 日志文件通常会比较大，尤其是在研究 <code>Nginx</code> 底层架构和自己编写模块代码时，需要打开 <code>debug</code> 级别的日志，故建议预先分配一个拥有较大磁盘空间的目录用来存放日志。</li>
</ol>
<h3 id="优化内核参数"><a href="#优化内核参数" class="headerlink" title="优化内核参数"></a>优化内核参数</h3><p><code>Nginx</code> 提供 <code>Web</code> 服务时 <code>Linux</code> 内核参数调整是必不可少的。</p>
<p>首先需要修改 <code>/etc/sysctl.conf</code> 来更改内核参数，各参数的意义及修改值如下：</p>
<h3 id="获取-Nginx-源码"><a href="#获取-Nginx-源码" class="headerlink" title="获取 Nginx 源码"></a>获取 Nginx 源码</h3><p>可以在 Nginx 官方网站：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a> 获取 Nginx 源码包</p>
<p>至本文编写时，最新的 <code>Nginx</code> 稳定版本为 <code>nginx-1.18.0</code>，下文也是用该版本的源码包进行安装</p>
<p>将下载好的源码包 <code>nginx-1.18.0.tar.gz</code> 放到准备好的 <code>Nginx</code> 源代码目录中，通过命令解压：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## sudo apt install -y mercurial</span></span><br><span class="line"><span class="comment">## hg clone http://hg.nginx.org/nginx</span></span><br><span class="line">$ tar xzvf nginx-1.18.0.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="编译-amp-安装"><a href="#编译-amp-安装" class="headerlink" title="编译 &amp; 安装"></a>编译 &amp; 安装</h2><h3 id="编译-amp-安装命令"><a href="#编译-amp-安装命令" class="headerlink" title="编译 &amp; 安装命令"></a>编译 &amp; 安装命令</h3><p>安装过程极为容易，依次执行以下命令即可完成安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> nginx-1.18.0</span><br><span class="line">$ ./configure</span><br><span class="line"><span class="comment"># My configure option</span></span><br><span class="line">$ ./configure--with-http_ssl_module --pid-path=/run/nginx.pid</span><br><span class="line">$ make -j4 &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>
<h3 id="编译前的可选参数"><a href="#编译前的可选参数" class="headerlink" title="编译前的可选参数"></a>编译前的可选参数</h3><p>以上命令中，<code>configure</code> 命令可以携带参数，以下是对其部分常用参数的说明：</p>
<ul>
<li><code>--prefix=</code> 指定安装目录</li>
<li><code>--sbin-path=</code> 指定执行程序文件存放位置</li>
<li><code>--modules-path=</code> 指定第三方模块的存放路径</li>
<li><code>--conf-path=</code> 指定配置文件存放位置</li>
<li><code>--error-log-path=</code> 指定错误日志存放位置</li>
<li><code>--http-log-path=</code> 指定 <code>access log</code> 路径</li>
<li><code>--pid-path=</code> 指定 <code>pid</code> 文件存放位置</li>
<li><code>--lock-path=</code> 指定 <code>lock</code> 文件存放位置</li>
<li><code>--user=</code> 指定程序运行时的非特权用户</li>
<li><code>--group=</code> 指定程序运行时的非特权用户组</li>
<li><code>--builddir=</code>  指向编译目录</li>
<li><code>--with-threads</code> 启用 <code>thread pool</code> 支持</li>
<li><code>--with-http_ssl_module</code> 启用 <code>https</code> 支持</li>
<li><code>--with-http_v2_module</code> 启用 <code>ngx_http_v2_module</code> 支持</li>
<li><code>--with-ipv6</code> 启用 <code>ipv6</code> 支持</li>
<li><code>--without-http</code>  禁用 <code>http server</code> 功能</li>
<li><code>--without-http-cache</code>  禁用 <code>http cache</code> 功能</li>
<li><code>--without-pcre</code> 禁用 <code>pcre</code> 库</li>
<li><code>--with-pcre</code> 启用 <code>pcre</code> 库</li>
<li><code>--with-pcre=</code> 指向 <code>pcre</code> 库文件目录</li>
<li><code>--with-pcre-opt=</code> 在编译时为 <code>pcre</code> 库设置附加参数</li>
<li><code>--with-zlib=</code> 指向 <code>zlib</code> 库文件目录</li>
<li><code>--with-zlib-opt=</code> 在编译时为 <code>zlib</code> 设置附加参数</li>
<li><code>--with-zlib-asm=</code> 为指定的 <code>CPU</code> 使用汇编源进行优化</li>
<li><code>--with-openssl=</code> 指向 <code>openssl</code> 安装目录</li>
<li><code>--with-openssl-opt=</code> 在编译时为 <code>openssl</code> 设置附加参数</li>
<li><code>--with-debug</code> 启用 <code>debug</code> 日志</li>
<li><code>--with-http_mp4_module</code>  启用 <code>ngx_http_mp4_module</code> 支持，启用对 <code>mp4</code> 类视频文件的支持</li>
<li><code>--with-http_gzip_static_module</code>  启用 <code>ngx_http_gzip_static_module</code> 支持，支持在线实时压缩输出数据流</li>
<li><code>--with-http_random_index_module</code>  启用 <code>ngx_http_random_index_module</code> 支持，从目录中随机挑选一个目录索引</li>
<li><code>--with-http_secure_link_module</code>  启用 <code>ngx_http_secure_link_module</code> 支持，计算和检查要求所需的安全链接网址</li>
<li><code>--with-http_degradation_module</code>  启用 <code>ngx_http_degradation_module</code> 支持允许在内存不足的情况下返回 <code>204</code> 或 <code>444</code> 代码</li>
<li><code>--with-http_stub_status_module</code>  启用 <code>ngx_http_stub_status_module</code> 支持查看 <code>nginx</code> 的状态页</li>
</ul>
<h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><h4 id="error-fall-through"><a href="#error-fall-through" class="headerlink" title="error: fall through"></a>error: fall through</h4><p>问题现象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;ubuntu&#x2F;nginx&#x2F;rtmp-module&#x2F;&#x2F;ngx_rtmp_eval.c: In function ‘ngx_rtmp_eval’:</span><br><span class="line">&#x2F;home&#x2F;ubuntu&#x2F;nginx&#x2F;rtmp-module&#x2F;&#x2F;ngx_rtmp_eval.c:160:17: error: this statement may fall through [-Werror&#x3D;implicit-fallthrough&#x3D;]</span><br><span class="line">  160 |                 switch (c) &#123;</span><br><span class="line">      |                 ^~~~~~</span><br><span class="line">&#x2F;home&#x2F;ubuntu&#x2F;nginx&#x2F;rtmp-module&#x2F;&#x2F;ngx_rtmp_eval.c:170:13: note: here</span><br><span class="line">  170 |             case ESCAPE:</span><br><span class="line">      |             ^~~~</span><br><span class="line">cc1: all warnings being treated as errors</span><br><span class="line">make[1]: *** [objs&#x2F;Makefile:1349: objs&#x2F;addon&#x2F;rtmp-module&#x2F;ngx_rtmp_eval.o] Error 1</span><br><span class="line">make[1]: Leaving directory &#39;&#x2F;home&#x2F;ubuntu&#x2F;nginx&#x2F;nginx-1.18.0&#39;</span><br><span class="line">make: *** [Makefile:8: build] Error 2</span><br></pre></td></tr></table></figure>
<p>问题原因：</p>
<p>如果 <code>gcc</code> 版本号较高，那么源代码的 <code>switch-case</code> 块中如果忘了加上 <code>break</code>，有可能会报错 <code>Implicit fallthrough error</code>。解决方法有几种，比如：</p>
<ol>
<li>更换 <code>gcc</code> 版本，具体是升级还是降级还需测试（实测 <code>gcc version 4.8.5</code> 可以正常编译，<code>gcc version 9.3.0</code> 编译不通过）。</li>
<li>在报错的 <code>switch-case</code> 块中加上 <code>break</code>。此时要对代码逻辑理解清楚，否则加上 <code>break</code> 有可能会破坏原来的逻辑。</li>
<li>编译时忽略 <code>Implicit fallthrough error</code> 这个错误。</li>
</ol>
<p>笔者采用了第三种方法，即在编译的时候就忽略这个错误。方法如下：</p>
<p>修改 objs/Makefile 的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 找到改行</span><br><span class="line">CFLAGS &#x3D;  -pipe  -O -W -Wall -Wpointer-arith -Wno-unused-parameter -Werror -g</span><br><span class="line"># 修改为如下内容</span><br><span class="line">CFLAGS &#x3D;  -pipe  -O -W -Wall -Wpointer-arith -Wno-unused-parameter -Wno-implicit-fallthrough -Werror -g</span><br><span class="line"># *以上修改需在 configure 之后 make 之前执行</span><br></pre></td></tr></table></figure>
<p>重新 <code>make</code> 即可。</p>
<h2 id="安装完成后的工作"><a href="#安装完成后的工作" class="headerlink" title="安装完成后的工作"></a>安装完成后的工作</h2><h3 id="加入系统服务和开机启动"><a href="#加入系统服务和开机启动" class="headerlink" title="加入系统服务和开机启动"></a>加入系统服务和开机启动</h3><h4 id="Systemctl-工具（推荐）"><a href="#Systemctl-工具（推荐）" class="headerlink" title="Systemctl 工具（推荐）"></a>Systemctl 工具（推荐）</h4><ol>
<li><p>创建 nginx 服务脚本</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>填入以下内容：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;The NGINX HTTP and reverse proxy server</span><br><span class="line">After&#x3D;syslog.target network-online.target remote-fs.target nss-lookup.target</span><br><span class="line">Wants&#x3D;network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">PIDFile&#x3D;&#x2F;run&#x2F;nginx.pid</span><br><span class="line">ExecStartPre&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -t</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload</span><br><span class="line">ExecStop&#x3D;&#x2F;bin&#x2F;kill -s QUIT $MAINPID</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>
<p> 重新加载 systemctl 服务：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<p> 至此，我们可以通过系统 sytemctl 命令来控制 Ngnix 的启动与停止：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start nginx <span class="comment"># 启动 Nginx</span></span><br><span class="line">$ sudo systemctl stop nginx <span class="comment"># 关闭 Nginx</span></span><br><span class="line">$ sudo systemctl restart nginx <span class="comment"># 重启 Nginx</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加开机启动</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Service-工具"><a href="#Service-工具" class="headerlink" title="Service 工具"></a>Service 工具</h4><ol>
<li><p>创建 nginx 启动命令脚本</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/init.d/nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入以下内容, 注意修改 <code>nginx</code> 和 <code>NGINX_CONF_FILE</code> 字段, 匹配自己的安装路径和配置文件路径</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># nginx - this script starts and stops the nginx daemon</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig: - 85 15</span></span><br><span class="line"><span class="comment"># description: Nginx is an HTTP(S) server, HTTP(S) reverse</span></span><br><span class="line"><span class="comment"># proxy and IMAP/POP3 proxy server</span></span><br><span class="line"><span class="comment"># processname: nginx</span></span><br><span class="line"><span class="comment"># config: /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="comment"># config: /etc/sysconfig/nginx</span></span><br><span class="line"><span class="comment"># pidfile: /var/run/nginx.pid</span></span><br><span class="line"><span class="comment"># Source function library.</span></span><br><span class="line">. /etc/rc.d/init.d/<span class="built_in">functions</span></span><br><span class="line"><span class="comment"># Source networking configuration.</span></span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"><span class="comment"># Check that networking is up.</span></span><br><span class="line">[ <span class="string">&quot;<span class="variable">$NETWORKING</span>&quot;</span> = <span class="string">&quot;no&quot;</span> ] &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line">nginx=<span class="string">&quot;/usr/local/nginx/sbin/nginx&quot;</span></span><br><span class="line">prog=$(basename <span class="variable">$nginx</span>)</span><br><span class="line">NGINX_CONF_FILE=<span class="string">&quot;/usr/local/nginx/conf/nginx.conf&quot;</span></span><br><span class="line"></span><br><span class="line">[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx</span><br><span class="line"></span><br><span class="line">lockfile=/var/lock/subsys/nginx</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">    [ -x <span class="variable">$nginx</span> ] || <span class="built_in">exit</span> 5</span><br><span class="line">    [ -f <span class="variable">$NGINX_CONF_FILE</span> ] || <span class="built_in">exit</span> 6</span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">&quot;Starting <span class="variable">$prog</span>:&quot;</span></span><br><span class="line">    daemon <span class="variable">$nginx</span> -c <span class="variable">$NGINX_CONF_FILE</span></span><br><span class="line">    retval=$?</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    [ <span class="variable">$retval</span> -eq 0 ] &amp;&amp; touch <span class="variable">$lockfile</span></span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$retval</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">stop</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">&quot;Stopping <span class="variable">$prog</span>:&quot;</span></span><br><span class="line">    killproc <span class="variable">$prog</span> -QUIT</span><br><span class="line">    retval=$?</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    [ <span class="variable">$retval</span> -eq 0 ] &amp;&amp; rm -f <span class="variable">$lockfile</span></span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$retval</span></span><br><span class="line">    killall -9 nginx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">restart</span></span>() &#123;</span><br><span class="line">    configtest || <span class="built_in">return</span> $?</span><br><span class="line">    stop</span><br><span class="line">    sleep 1</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">reload</span></span>() &#123;</span><br><span class="line">    configtest || <span class="built_in">return</span> $?</span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">&quot;Reloading <span class="variable">$prog</span>:&quot;</span></span><br><span class="line">    killproc <span class="variable">$nginx</span> -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">force_reload</span></span>() &#123;</span><br><span class="line">    restart</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">configtest</span></span>() &#123;</span><br><span class="line">    <span class="variable">$nginx</span> -t -c <span class="variable">$NGINX_CONF_FILE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rh_status</span></span>() &#123;</span><br><span class="line">    status <span class="variable">$prog</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rh_status_q</span></span>() &#123;</span><br><span class="line">    rh_status &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">    rh_status_q &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line">    <span class="variable">$1</span></span><br><span class="line">    ;;</span><br><span class="line">stop)</span><br><span class="line">    rh_status_q || <span class="built_in">exit</span> 0</span><br><span class="line">    <span class="variable">$1</span></span><br><span class="line">    ;;</span><br><span class="line">restart|configtest)</span><br><span class="line">    <span class="variable">$1</span></span><br><span class="line">    ;;</span><br><span class="line">reload)</span><br><span class="line">    rh_status_q || <span class="built_in">exit</span> 7</span><br><span class="line">    <span class="variable">$1</span></span><br><span class="line">    ;;</span><br><span class="line">force-reload)</span><br><span class="line">    force_reload</span><br><span class="line">    ;;</span><br><span class="line">status)</span><br><span class="line">    rh_status</span><br><span class="line">    ;;</span><br><span class="line">condrestart|try-restart)</span><br><span class="line">    rh_status_q || <span class="built_in">exit</span> 0</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">echo</span> $<span class="string">&quot;Usage: <span class="variable">$0</span> &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置执行权限</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo chmod 755 /etc/init.d/nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>NGINX_CONF_FILE</code> 指向的配置文件 <code>/usr/local/nginx/conf/nginx.conf</code></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到如下位置：</span></span><br><span class="line"><span class="comment">#pid        /logs/nginx.pid;</span></span><br><span class="line"><span class="comment"># 修改为：</span></span><br><span class="line">pid        /var/run/nginx.pid;</span><br></pre></td></tr></table></figure>
<p> 至此，我们可以通过系统 service 命令来控制 Ngnix 的启动与停止：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service nginx start <span class="comment"># 启动 Nginx</span></span><br><span class="line">$ sudo service nginx stop <span class="comment"># 关闭 Nginx</span></span><br><span class="line">$ sudo service nginx restart <span class="comment"># 重启 Nginx</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加入自启动</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chkconfig --list <span class="comment"># 显示开机自启的服务</span></span><br><span class="line">$ chkconfig --add /etc/init.d/nginx <span class="comment"># 将 Nginx 加入 chkconfig 管理列表</span></span><br><span class="line">$ chkconfig nginx on <span class="comment"># 设置 Nginx 开机自启动</span></span><br></pre></td></tr></table></figure>
<h3 id="加入环境变量"><a href="#加入环境变量" class="headerlink" title="加入环境变量"></a>加入环境变量</h3><p>在 <code>/etc/profile</code> 文件最后加入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NGINX_HOME=/usr/<span class="built_in">local</span>/nginx</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$NGINX_HOME</span>/sbin</span><br></pre></td></tr></table></figure>
<p>保存，执行 <code>source /etc/profile</code>，使配置文件生效。</p>
<p>然后执行 <code>nginx -v</code> 能够正常返回，即为设置成功。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 机械工业出版社 《深入理解 Nginx：模块开发与架构解析 第二版》</li>
<li>[2] 中国工信出版集团 《直播系统开发 基于 Nginx 与 Nginx-rtmp-module》</li>
<li>[3] <a href="https://www.jianshu.com/p/0b52f8f3e787">Nginx 配置开机启动 /etc/init.d/nginx - 简书</a></li>
</ul>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx - 介绍</title>
    <url>/post/2020/bdeefaa3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Ngnix-的功能"><a href="#Ngnix-的功能" class="headerlink" title="Ngnix 的功能"></a>Ngnix 的功能</h2><p>Nginx 同 Apache、Tomcat 一样，是一种服务器软件。它是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP/POP3/SMTP 服务。因此，使用 Ngnix 可以搭建网站，也可以实现负载均衡的功能，还可以作为邮件代理服务器来接受和发送邮件。Ngnix 1.9.0 以后的版本还可以作为通用的 TCP/UDP 代理服务器，也可以提供一定的缓存服务功能。</p>
<a id="more"></a>
<h3 id="可做-Web-服务器"><a href="#可做-Web-服务器" class="headerlink" title="可做 Web 服务器"></a>可做 Web 服务器</h3><p>Nginx 还是 - 个高性能的 HTP Web 服务器（Web 服务器还有 Apache、IIS 等）, 它包含了基本的 HTTP 功能和拓展功能，可以先通过动态 / 静态内容分离, 而后为静态内容（HTML/CSS/JavaScript/Picture…）提供 HTTP 访问功能。而动态内容可以整合代理模块，代理给上游服务器，以支持对外部程序的直接调用或者解析，如 FastCGI 支持 PHP。</p>
<h3 id="可做反向代理服务器"><a href="#可做反向代理服务器" class="headerlink" title="可做反向代理服务器"></a>可做反向代理服务器</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">前向代理 - 维基百科，自由的百科全书</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">反向代理 - 维基百科，自由的百科全书</a></li>
<li><a href="https://www.zhihu.com/question/24723688/answer/99812236">反向代理为何叫反向代理 - 知乎</a></li>
</ul>
<blockquote>
<p>正向代理的过程隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 <a href="http://www.google.com">http://www.google.com</a> 时，被残忍的 block，于是你可以在国外搭建一台代理服务器，让代理帮浏览器去请求 <a href="http://www.google.com">http://www.google.com</a>，代理把请求返回的相应结构再返回给浏览器。</p>
<p>而反向代理隐藏了真实的服务端，当我们请求 <a href="http://www.baidu.com">http://www.baidu.com</a> 的时候，就像拨打 10086 一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，<a href="http://www.baidu.com">http://www.baidu.com</a> 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx 就是性能非常好的反向代理服务器，用来做负载均衡。</p>
</blockquote>
<h3 id="可做邮件代理服务器"><a href="#可做邮件代理服务器" class="headerlink" title="可做邮件代理服务器"></a>可做邮件代理服务器</h3><p>Ngnix 可部署成邮件代理服务器，最早开发 Nginx 的目的之一就是将其作为邮件代理服务器。</p>
<h2 id="Ngnix-的优势"><a href="#Ngnix-的优势" class="headerlink" title="Ngnix 的优势"></a>Ngnix 的优势</h2><p>Nginx 有着高并发、性能好和占用内存少等特点，其安装简单，配置文件简洁，启动容易，能长时间不间断运行，还能在不间断服务的情况下升级软件版本，而且成本低。</p>
<h3 id="高并发、性能好、占用内存少且稳定"><a href="#高并发、性能好、占用内存少且稳定" class="headerlink" title="高并发、性能好、占用内存少且稳定"></a>高并发、性能好、占用内存少且稳定</h3><p>作为 Web 服务器，相比 Apache，Nginx 占用内存更少，支持的并发连接更多，使用效率更高，而且 Nginx 比 Apache 更轻量，性能更好。</p>
<h3 id="功能强大"><a href="#功能强大" class="headerlink" title="功能强大"></a>功能强大</h3><p>Nginx 提供了大量功能模块，支持诸多特性，应用场景也多，可做 Web 服务器、反向代理服务器，也可做邮件服务器等。</p>
<h3 id="拓展性高"><a href="#拓展性高" class="headerlink" title="拓展性高"></a>拓展性高</h3><p>Nginx 的模块化设计极具拓展性，它完全是由多个不同功能、不同层次、不同类型且耦合度极低的模块组成的。因此，当对某一个模块进行缺陷修复或升级时，可以专注于模块自身，而不会影响其他模块。</p>
<p>这种低耦合度的设计，使得 Nginx 具有数量庞大的第三方模块。当然，则和谐公开的第三方模块也如同 Nginx 官方发布的模块一样易用。</p>
<h3 id="其他优点"><a href="#其他优点" class="headerlink" title="其他优点"></a>其他优点</h3><ul>
<li>跨平台</li>
<li>占用内存小</li>
<li>配置、操作简单</li>
<li>网络依赖性低</li>
<li>支持内置服务器检测</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 机械工业出版社 《深入理解 Nginx：模块开发与架构解析 第二版》</li>
<li>[2] 中国工信出版集团 《直播系统开发 基于 Nginx 与 Nginx-rtmp-module》</li>
</ul>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建 - NexT Snippets</title>
    <url>/post/2020/c73e32c0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note danger no-icon"><h2 id="Danger-段落"><a href="#Danger-段落" class="headerlink" title="Danger 段落"></a>Danger 段落</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;note danger&quot;</span>&gt;</span></span><br><span class="line">插入文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 方法二--&gt;</span></span><br><span class="line">&#123;% note danger no-icon %&#125;</span><br><span class="line">插入文字</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
</div>
<a id="more"></a>
<div class="note default no-icon"><h2 id="Default-段落"><a href="#Default-段落" class="headerlink" title="Default 段落"></a>Default 段落</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;note default&quot;</span>&gt;</span></span><br><span class="line">插入文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 方法二--&gt;</span></span><br><span class="line">&#123;% note default no-icon %&#125;</span><br><span class="line">插入文字</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
</div>
<div class="note info no-icon"><h2 id="Info-段落"><a href="#Info-段落" class="headerlink" title="Info 段落"></a>Info 段落</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;note info&quot;</span>&gt;</span></span><br><span class="line">插入文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 方法二--&gt;</span></span><br><span class="line">&#123;% note info no-icon %&#125;</span><br><span class="line">插入文字</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
</div>
<div class="note primary no-icon"><h2 id="Primary-段落"><a href="#Primary-段落" class="headerlink" title="Primary 段落"></a>Primary 段落</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;note primary&quot;</span>&gt;</span></span><br><span class="line">插入文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 方法二--&gt;</span></span><br><span class="line">&#123;% note primary no-icon %&#125;</span><br><span class="line">插入文字</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
</div>
<div class="note success no-icon"><h2 id="Success-段落"><a href="#Success-段落" class="headerlink" title="Success 段落"></a>Success 段落</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;note success&quot;</span>&gt;</span></span><br><span class="line">插入文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 方法二--&gt;</span></span><br><span class="line">&#123;% note success no-icon %&#125;</span><br><span class="line">插入文字</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
</div>
<div class="note warning no-icon"><h2 id="Warning-段落"><a href="#Warning-段落" class="headerlink" title="Warning 段落"></a>Warning 段落</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;note warning&quot;</span>&gt;</span></span><br><span class="line">插入文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 方法二--&gt;</span></span><br><span class="line">&#123;% note warning no-icon %&#125;</span><br><span class="line">插入文字</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
</div>
<blockquote class="blockquote-center">
<h2 id="引用段落"><a href="#引用段落" class="headerlink" title="引用段落"></a>引用段落</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% cq %&#125;</span><br><span class="line">插入文字</span><br><span class="line">&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建 - NexT 主题美化</title>
    <url>/post/2020/97e2582/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note danger no-icon"><p>看前必读：</p>
<p>本博客基于 <code>hexo v5.2.0</code> 和 <code>NexT v8.0.1</code> 搭建，本文的美化过程也是基于以上版本，不保证其他版本中的效果。</p>
</div>
<a id="more"></a>
<h2 id="增加背景图片"><a href="#增加背景图片" class="headerlink" title="增加背景图片"></a>增加背景图片</h2><ol>
<li><p>修改主题配置文件（如 <code>_config.next.yml</code>）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 找到以下内容</span><br><span class="line">  # style: source&#x2F;_data&#x2F;styles.styl</span><br><span class="line"># 放开注释</span><br><span class="line">  style: source&#x2F;_data&#x2F;styles.styl</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>source</code> 目录下 创建文件夹 <code>_data</code>，并在 <code>_data</code> 文件夹中创建名为 <code>styles.styl</code> 的新文件，并填入以下内容：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 增加背景图片</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">url</span>(http://www.dmoe.cc/random.php);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">    <span class="attribute">background-position</span>: center;</span><br><span class="line">    //background-position:50% 50%;</span><br><span class="line">    <span class="selector-tag">opacity</span>: 0<span class="selector-class">.95</span>;</span><br><span class="line">    +<span class="selector-tag">mobile</span>()&#123;</span><br><span class="line">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(https://acg.yanwz.cn/api.php);</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">10%</span> <span class="number">20%</span>;</span><br><span class="line">        <span class="attribute">background-size</span>: cover;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其中 <code>url</code> 可以使用网络图片地址，也可以使用本地图片，其他参数也可以根据 <code>css</code> 语法结合想要的效果自行修改。</p>
</li>
</ol>
<h2 id="页面元素美化"><a href="#页面元素美化" class="headerlink" title="页面元素美化"></a>页面元素美化</h2><p>接增加背景图片，可通过在 <code>source/_data/styles.styl</code> 增加内容对页面元素进行美化</p>
<p>如增加元素阴影效果、修改元素圆角效果、优化文字间距等</p>
<p>具体修改如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 调整组件位置</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-header</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.125em</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.post-button</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.post-block</span>&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 组件边框椭圆化</span><br><span class="line"><span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    .sub-menu,</span><br><span class="line">    <span class="selector-class">.post-block</span>,</span><br><span class="line">    <span class="selector-class">.tabs-comment</span>,</span><br><span class="line">    <span class="selector-class">.comments</span>,</span><br><span class="line">    <span class="selector-class">.pagination</span>,</span><br><span class="line">    <span class="selector-class">.sub-menu</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:first-child)</span><span class="selector-pseudo">:not(.sub-menu)</span>,</span><br><span class="line">    <span class="selector-class">.post-block</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:first-child)</span><span class="selector-pseudo">:not(.sub-menu)</span>,</span><br><span class="line">    <span class="selector-class">.tabs-comment</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:first-child)</span><span class="selector-pseudo">:not(.sub-menu)</span>,</span><br><span class="line">    <span class="selector-class">.comments</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:first-child)</span><span class="selector-pseudo">:not(.sub-menu)</span>,</span><br><span class="line">    <span class="selector-class">.pagination</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:first-child)</span><span class="selector-pseudo">:not(.sub-menu)</span> &#123;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">8px</span> <span class="number">7px</span> <span class="number">2px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span>), <span class="number">7px</span> <span class="number">4px</span> <span class="number">1px</span> -<span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.06</span>), <span class="number">0</span> <span class="number">1px</span> <span class="number">5px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">8px</span> <span class="number">7px</span> <span class="number">2px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span>), <span class="number">7px</span> <span class="number">4px</span> <span class="number">1px</span> -<span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.06</span>), <span class="number">0</span> <span class="number">1px</span> <span class="number">5px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar-inner</span>&#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">8px</span> <span class="number">7px</span> <span class="number">2px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span>), <span class="number">7px</span> <span class="number">4px</span> <span class="number">1px</span> -<span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.06</span>), <span class="number">0</span> <span class="number">1px</span> <span class="number">5px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改标题字体行距</span><br><span class="line"><span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-tag">h3</span>,</span><br><span class="line"><span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Bree+Serif, <span class="string">&quot;PingFang SC&quot;</span>, <span class="string">&quot;Microsoft YaHei&quot;</span>, sans-serif;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 缩小打赏行距</span><br><span class="line"><span class="selector-class">.reward-container</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line">// 缩小相关文章行距</span><br><span class="line"><span class="selector-class">.popular-posts-header</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.125em</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 缩小文章底部标签行距</span><br><span class="line"><span class="selector-class">.post-tags</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增加网易云音乐"><a href="#增加网易云音乐" class="headerlink" title="增加网易云音乐"></a>增加网易云音乐</h2><ol>
<li><p>修改 <code>layout/_partials/header/menu.njk</code> 文件，加入以下代码（也可以在自行在其他位置添加）：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> theme.background_music %&#125;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;iframe seamless frameborder=<span class="string">&quot;no&quot;</span> border=<span class="string">&quot;0&quot;</span> marginwidth=<span class="string">&quot;0&quot;</span> marginheight=<span class="string">&quot;0&quot;</span> width=<span class="number">288</span> height=<span class="number">52</span> src=<span class="string">&quot;//music.163.com/outchain/player?type=2&amp;id=&#123;&#123; theme.background_music &#125;&#125;&amp;auto=1&amp;height=32&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p> 我添加的位置示例：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> theme.algolia_search.enable or theme.local_search.enable %&#125;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;menu-item menu-item-search&quot;</span>&gt;</span><br><span class="line">        &lt;a role=<span class="string">&quot;button&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;popup-trigger&quot;</span>&gt;</span><br><span class="line">        &#123;%- <span class="keyword">if</span> theme.menu_settings.icons %&#125;&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fa fa-search fa-fw&quot;</span>&gt;&lt;/i&gt;&#123;%- endif %&#125;&#123;&#123; __(<span class="string">&#x27;menu.search&#x27;</span>) &#125;&#125;</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%- <span class="keyword">if</span> theme.background_music %&#125;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;iframe seamless frameborder=<span class="string">&quot;no&quot;</span> border=<span class="string">&quot;0&quot;</span> marginwidth=<span class="string">&quot;0&quot;</span> marginheight=<span class="string">&quot;0&quot;</span> width=<span class="number">288</span> height=<span class="number">52</span> src=<span class="string">&quot;//music.163.com/outchain/player?type=2&amp;id=&#123;&#123; theme.background_music &#125;&#125;&amp;auto=1&amp;height=32&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主题配置文件（如 <code>_config.next.yml</code>），添加如下内容：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background_music: 569214252</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>background_music</code> 字段后的音乐 <code>id</code> 可用下图方式获取：<br><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201011225105.png" alt="网易云音乐 id 获取方式"></p>
</blockquote>
</li>
</ol>
<h2 id="增加点击特效"><a href="#增加点击特效" class="headerlink" title="增加点击特效"></a>增加点击特效</h2><ol>
<li><p>创建 <code>source/js/click_magic.js</code> 文件，填入以下内容：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 鼠标特效 */</span></span><br><span class="line"><span class="keyword">var</span> a_idx = <span class="number">0</span>;</span><br><span class="line">jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">$(<span class="string">&quot;body&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Go&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;JavaScript&quot;</span> ,</span><br><span class="line">    <span class="string">&quot;Php&quot;</span>, <span class="string">&quot;Sql&quot;</span>, <span class="string">&quot;R&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> $i = $(<span class="string">&quot;&lt;span/&gt;&quot;</span>).text(a[a_idx]);</span><br><span class="line">    a_idx = (a_idx + <span class="number">1</span>) % a.length;</span><br><span class="line">    <span class="keyword">var</span> x = e.pageX,</span><br><span class="line">    y = e.pageY;</span><br><span class="line">    $i.css(&#123;</span><br><span class="line">        <span class="string">&quot;z-index&quot;</span>: <span class="number">9999</span>,</span><br><span class="line">        <span class="string">&quot;top&quot;</span>: y - <span class="number">20</span>,</span><br><span class="line">        <span class="string">&quot;left&quot;</span>: x,</span><br><span class="line">        <span class="string">&quot;position&quot;</span>: <span class="string">&quot;absolute&quot;</span>,</span><br><span class="line">        <span class="string">&quot;font-weight&quot;</span>: <span class="string">&quot;bold&quot;</span>,</span><br><span class="line">        <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#ff6651&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">&quot;body&quot;</span>).append($i);</span><br><span class="line">    $i.animate(&#123;</span><br><span class="line">        <span class="string">&quot;top&quot;</span>: y - <span class="number">180</span>,</span><br><span class="line">        <span class="string">&quot;opacity&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">1500</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $i.remove();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>layout/_layout.njk</code>，在该文件最末尾增加如下代码：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/click_magic.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="增加友链链接"><a href="#增加友链链接" class="headerlink" title="增加友链链接"></a>增加友链链接</h2><ol>
<li><p>创建 <code>layout/_partials/page/links.njk</code> 文件，填入以下内容：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">&#123;######################&#125;</span><br><span class="line">&#123;### LINKS BLOCK ###&#125;</span><br><span class="line">&#123;######################&#125;</span><br><span class="line"></span><br><span class="line">    &lt;div id=<span class="string">&quot;links&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #links&#123;</span><br><span class="line">            margin-top: <span class="number">5</span>rem;</span><br><span class="line">            &#125;</span><br><span class="line">            .links-content&#123;</span><br><span class="line">                margin-top:<span class="number">1</span>rem;</span><br><span class="line">            &#125;</span><br><span class="line">            .link-navigation::after &#123;</span><br><span class="line">                content: <span class="string">&quot; &quot;</span>;</span><br><span class="line">                display: block;</span><br><span class="line">                clear: both;</span><br><span class="line">            &#125;</span><br><span class="line">            .card &#123;</span><br><span class="line">                width: <span class="number">300</span>px;</span><br><span class="line">                font-size: <span class="number">1</span>rem;</span><br><span class="line">                padding: <span class="number">10</span>px <span class="number">20</span>px;</span><br><span class="line">                border-radius: <span class="number">4</span>px;</span><br><span class="line">                transition-duration: <span class="number">0.15</span>s;</span><br><span class="line">                margin-bottom: <span class="number">1</span>rem;</span><br><span class="line">                display:flex;</span><br><span class="line">            &#125;</span><br><span class="line">            .card:nth-child(odd) &#123;</span><br><span class="line">                float: left;</span><br><span class="line">            &#125;</span><br><span class="line">            .card:nth-child(even) &#123;</span><br><span class="line">                float: right;</span><br><span class="line">            &#125;</span><br><span class="line">            .card:hover &#123;</span><br><span class="line">                transform: scale(<span class="number">1.1</span>);</span><br><span class="line">                box-shadow: <span class="number">0</span> <span class="number">2</span>px <span class="number">6</span>px <span class="number">0</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.12</span>), <span class="number">0</span> <span class="number">0</span> <span class="number">6</span>px <span class="number">0</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.04</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            .card a &#123;</span><br><span class="line">                border:none;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .ava &#123;</span><br><span class="line">                width: <span class="number">3</span>rem!important;</span><br><span class="line">                height: <span class="number">3</span>rem!important;</span><br><span class="line">                margin:<span class="number">0</span>!important;</span><br><span class="line">                margin-right: <span class="number">1</span>em!important;</span><br><span class="line">                border-radius:<span class="number">4</span>px;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header &#123;</span><br><span class="line">                font-style: italic;</span><br><span class="line">                overflow: hidden;</span><br><span class="line">                width: <span class="number">236</span>px;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header a &#123;</span><br><span class="line">                font-style: normal;</span><br><span class="line">                color: #2bbc8a;</span><br><span class="line">                font-weight: bold;</span><br><span class="line">                text-decoration: none;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header a:hover &#123;</span><br><span class="line">                color: #d480aa;</span><br><span class="line">                text-decoration: none;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header .info &#123;</span><br><span class="line">                font-style:normal;</span><br><span class="line">                color:#a3a3a3;</span><br><span class="line">                font-size:<span class="number">14</span>px;</span><br><span class="line">                min-width: <span class="number">0</span>;</span><br><span class="line">                text-overflow: ellipsis;</span><br><span class="line">                overflow: hidden;</span><br><span class="line">                white-space: nowrap;</span><br><span class="line">            &#125;</span><br><span class="line">            span.focus-links &#123;</span><br><span class="line">                font-style: normal;</span><br><span class="line">                margin-left: <span class="number">10</span>px;</span><br><span class="line">                position: unset;</span><br><span class="line">                left: <span class="number">0</span>;</span><br><span class="line">                padding: <span class="number">0</span> <span class="number">7</span>px <span class="number">0</span> <span class="number">5</span>px;</span><br><span class="line">                font-size: <span class="number">11</span>px;</span><br><span class="line">                border-color: #42c02e;</span><br><span class="line">                border-radius: <span class="number">40</span>px;</span><br><span class="line">                line-height: <span class="number">24</span>px;</span><br><span class="line">                height: <span class="number">22</span>px;</span><br><span class="line">                color: #fff !important;</span><br><span class="line">                background-color: #42c02e;</span><br><span class="line">                display: inline-block;</span><br><span class="line">            &#125;</span><br><span class="line">            span.focus-links:hover&#123;</span><br><span class="line">                background-color: #318024;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;links-content&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;no-icon note warning&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;link-info&quot;</span>&gt;</span>👨‍🎓 跟着大佬走，成为小大佬<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;link-navigation&quot;</span>&gt;</span><br><span class="line">                &#123;% <span class="keyword">for</span> link <span class="keyword">in</span> theme.defaultlinks %&#125;</span><br><span class="line">                    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;card&quot;</span>&gt;</span><br><span class="line">                        &lt;img <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;ava nofancybox&quot;</span> src=<span class="string">&quot;&#123;&#123; link.avatar &#125;&#125;&quot;</span>/&gt;</span><br><span class="line">                        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;card-header&quot;</span>&gt;</span><br><span class="line">                        &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; link.site &#125;&#125;&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span> &#123;&#123; link.nickname &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; link.site &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;focus-links&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-plus&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="symbol">&amp;nbsp;</span>关注<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">                        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;info&quot;</span>&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;no-icon note primary&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;link-info&quot;</span>&gt;</span>🍭 五湖四海的朋友们<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;link-navigation&quot;</span>&gt;</span><br><span class="line">                &#123;% <span class="keyword">for</span> link <span class="keyword">in</span> theme.friendslinks %&#125;</span><br><span class="line">                    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;card&quot;</span>&gt;</span><br><span class="line">                        &lt;img <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;ava nofancybox&quot;</span> src=<span class="string">&quot;&#123;&#123; link.avatar &#125;&#125;&quot;</span>/&gt;</span><br><span class="line">                        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;card-header&quot;</span>&gt;</span><br><span class="line">                        &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; link.site &#125;&#125;&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span> &#123;&#123; link.nickname &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; link.site &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;focus-links&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-plus&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="symbol">&amp;nbsp;</span>关注<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">                        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;info&quot;</span>&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &#123;&#123; page.content &#125;&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#123;##########################&#125;</span><br><span class="line">&#123;### END LINKS BLOCK ###&#125;</span><br><span class="line">&#123;##########################&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>layout/page.njk</code>：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 找到如下两行代码 */</span></span><br><span class="line">&#123;%- elif page.type === <span class="string">&#x27;schedule&#x27;</span> and not page.title %&#125;</span><br><span class="line">    &#123;&#123;- __(<span class="string">&#x27;title.schedule&#x27;</span>) + page_title_suffix &#125;&#125;</span><br><span class="line"><span class="comment">/* 在上述代码后添加如下内容 */</span></span><br><span class="line">&#123;%- elif page.type === <span class="string">&#x27;links&#x27;</span> and not page.title %&#125;</span><br><span class="line">    &#123;&#123;- __(<span class="string">&#x27;title.links&#x27;</span>) + page_title_suffix &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 找到如下两行代码 */</span></span><br><span class="line">&#123;% elif page.type === <span class="string">&#x27;schedule&#x27;</span> %&#125;</span><br><span class="line">    &#123;% include <span class="string">&#x27;_partials/page/schedule.njk&#x27;</span> %&#125;</span><br><span class="line"><span class="comment">/* 在上述代码后添加如下内容 */</span></span><br><span class="line">&#123;% elif page.type === <span class="string">&#x27;links&#x27;</span> %&#125;</span><br><span class="line">    &#123;% include <span class="string">&#x27;_partials/page/links.njk&#x27;</span> %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主题配置文件（如 <code>_config.next.yml</code>）：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 找到如下代码</span><br><span class="line">archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line"># 在上述代码后添加如下内容</span><br><span class="line">links: &#x2F;links || fa fa-link</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改语言文件 <code>languages/zh-CN.yml</code>:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在合适位置添加以下内容</span><br><span class="line">links: 友链</span><br><span class="line"># 比如</span><br><span class="line">about: 关于</span><br><span class="line">links: 友链</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主题配置文件（如 <code>_config.next.yml</code>），添加如下内容：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># defaultlinks 会显示在 跟着大佬走，成为小大佬 标签中</span><br><span class="line">defaultlinks:</span><br><span class="line">  - nickname: 雷霄骅</span><br><span class="line">    site: https:&#x2F;&#x2F;me.csdn.net&#x2F;leixiaohua1020</span><br><span class="line">    avatar: https:&#x2F;&#x2F;gitee.com&#x2F;hezhaojiang&#x2F;MyPics&#x2F;raw&#x2F;master&#x2F;img&#x2F;20201008135337.png</span><br><span class="line">    info: 中国传媒大学一个搞广播电视相关的视音频技术的学生</span><br><span class="line"></span><br><span class="line"># friendslinks 会显示在 五湖四海的朋友们 标签中</span><br><span class="line">friendslinks:</span><br><span class="line">  - nickname: 何照江</span><br><span class="line">    site: https:&#x2F;&#x2F;xiaoqingdu.gitee.io&#x2F;</span><br><span class="line">    avatar: https:&#x2F;&#x2F;xiaoqingdu.gitee.io&#x2F;images&#x2F;head.jpeg</span><br><span class="line">    info: 无</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建 - Hexo 换机指导</title>
    <url>/post/2020/6a28acc4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于最近更换电脑，需要将旧电脑的一些资料转移至新电脑，其中 <code>Hexo</code> 的资料转移过程中踩了不少坑，所以在此记录以下，防止后续换机时继续踩坑。</p>
<a id="more"></a>
<h2 id="安装-Hexo-环境"><a href="#安装-Hexo-环境" class="headerlink" title="安装 Hexo 环境"></a>安装 Hexo 环境</h2><p>首先需要在新电脑上安装 <code>Hexo</code> 环境</p>
<h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>这里是第一个坑，安装的 <code>Node.js</code> 建议版本为 12.14，如果安装的版本过高，后续 <code>hexo</code> 命令执行时可能会出现以下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(node:2396) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency</span><br><span class="line">(Use &#96;node --trace-warnings ...&#96; to show where the warning was created)</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;column&#39; of module exports inside circular dependency</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;filename&#39; of module exports inside circular dependency</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;column&#39; of module exports inside circular dependency</span><br><span class="line">(node:2396) Warning: Accessing non-existent property &#39;filename&#39; of module exports inside circular dependency</span><br></pre></td></tr></table></figure>
<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>安装好 <code>Node.js</code> 后直接安装 <code>Hexo</code>，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure>
<p>安装完发现无法运行 <code>Hexo</code> 命令，需要进行如下设置：</p>
<ol>
<li><p>以管理员身份运行 <code>powershell</code></p>
</li>
<li><p>执行 <code>set-executionpolicy remotesigned</code></p>
</li>
</ol>
<h2 id="拷贝-Hexo-资料文件夹"><a href="#拷贝-Hexo-资料文件夹" class="headerlink" title="拷贝 Hexo 资料文件夹"></a>拷贝 Hexo 资料文件夹</h2><p>拷贝除 .deploy_git 和 public 文件夹以外的所有内容</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201220200545.png" alt="Hexo文件夹"></p>
<p>此时即可用 <code>hexo g</code> 等命令正常使用 <code>Hexo</code> 了~~</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发日记 - C++ 之位运算</title>
    <url>/post/2020/aa6f0789/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <code>LeetCode</code> 刷题时，经常会用到 <code>C++</code> 的一些位运算函数，在此记录下防止需要用时忘记。</p>
<blockquote>
<p>需要注意，以下函数均为 <code>gcc</code> 提供的内置位运算函数，在其他编译环境上无法使用。</p>
</blockquote>
<a id="more"></a>
<h2 id="builtin-parity-n"><a href="#builtin-parity-n" class="headerlink" title="__builtin_parity(n)"></a>__builtin_parity(n)</h2><p>该函数是判断 <code>n</code> 的二进制中 <code>1</code> 的个数的奇偶性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">15</span>;                         <span class="comment">// 二进制为 1111</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">7</span>;                          <span class="comment">// 二进制为 111</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_parity(n)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">// 偶数个 1，输出 0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_parity(m)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">// 奇数个 1，输出 1</span></span><br></pre></td></tr></table></figure>
<h2 id="builtin-popcount-n"><a href="#builtin-popcount-n" class="headerlink" title="__builtin_popcount(n)"></a>__builtin_popcount(n)</h2><p>该函数时判断 <code>n</code> 的二进制中有多少个 <code>1</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">15</span>;                         <span class="comment">// 二进制为 1111</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_popcount(n)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 输出结果为 4</span></span><br></pre></td></tr></table></figure>
<h2 id="builtin-ctz-n"><a href="#builtin-ctz-n" class="headerlink" title="__builtin_ctz(n)"></a>__builtin_ctz(n)</h2><p>该函数判断 <code>n</code> 的二进制末尾后面 <code>0</code> 的个数，<code>n = 0</code> 时结果未定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;                      <span class="comment">// 二进制为 1</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">8</span>;                      <span class="comment">// 二进制为 1000</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_ctzll(n)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_ctz(m)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>
<h2 id="builtin-clz-n"><a href="#builtin-clz-n" class="headerlink" title="__builtin_clz(n)"></a>__builtin_clz(n)</h2><p><code>n</code> 前导 <code>0</code> 的个数, <code>n = 0</code> 时结果未定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">1</span>;                <span class="comment">// 二进制为 000....001 64 位整数</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">8</span>;                      <span class="comment">// 二进制为 000...1000 32 位整数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_clzll(n)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出 63</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_clz(m)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// 输出 28</span></span><br></pre></td></tr></table></figure>
<h2 id="builtin-ffs-n"><a href="#builtin-ffs-n" class="headerlink" title="__builtin_ffs(n)"></a>__builtin_ffs(n)</h2><p>该函数判断 <code>n</code> 的二进制末尾最后一个 <code>1</code> 的位置，从 <code>1</code> 开始</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;                      <span class="comment">// 二进制为 1</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">8</span>;                      <span class="comment">// 二进制为 1000</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_ffs(n)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// 输出 1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;__builtin_ffs(m)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端开发日记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发日记 - HTTP 和 HTTPS 协议</title>
    <url>/post/2020/957af0a4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>说明：本文章非原创，转载自 <a href="https://blog.csdn.net/xiaoming100001/article/details/81109617">HTTP 和 HTTPS 协议，看一篇就够了_不一样的博客 - CSDN 博客</a></p>
</blockquote>
<h2 id="HTTP-和-HTTPS-发展历史"><a href="#HTTP-和-HTTPS-发展历史" class="headerlink" title="HTTP 和 HTTPS 发展历史"></a>HTTP 和 HTTPS 发展历史</h2><h3 id="什么是-HTTP"><a href="#什么是-HTTP" class="headerlink" title="什么是 HTTP"></a>什么是 HTTP</h3><blockquote>
<p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于 TCP/IP 协议传输数据，互联网上应用最为广泛的一种网络协议, 所有的 WWW 文件都必须遵守这个标准。设计 HTTP 的初衷是为了提供一种发布和接收 HTML 页面的方法。</p>
</blockquote>
<a id="more"></a>
<h3 id="HTTP-发展历史"><a href="#HTTP-发展历史" class="headerlink" title="HTTP 发展历史"></a>HTTP 发展历史</h3><div class="table-container">
<table>
<thead>
<tr>
<th>版本</th>
<th>产生时间</th>
<th>内容</th>
<th>发展现状</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP/0.9</td>
<td>1991 年</td>
<td>不涉及数据包传输，规定客户端和服务器之间通信格式，只能 GET 请求</td>
<td>没有作为正式的标准</td>
</tr>
<tr>
<td>HTTP/1.0</td>
<td>1996 年</td>
<td>传输内容格式不限制，增加 PUT、PATCH、HEAD、 OPTIONS、DELETE 命令</td>
<td>正式作为标准</td>
</tr>
<tr>
<td>HTTP/1.1</td>
<td>1997 年</td>
<td>持久连接 (长连接)、节约带宽、HOST 域、管道机制、分块传输编码</td>
<td>2015 年前使用最广泛</td>
</tr>
<tr>
<td>HTTP/2</td>
<td>2015 年</td>
<td>多路复用、服务器推送、头信息压缩、二进制协议等</td>
<td>逐渐覆盖市场</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>多路复用：通过单一的 HTTP/2 连接请求发起多重的请求 - 响应消息，多个请求 stream 共享一个 TCP 连接，实现多留并行而不是依赖建立多个 TCP 连接。</p>
</blockquote>
<h3 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h3><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200925215042.png" alt="HTTP 报文格式"></p>
<h3 id="什么是-HTTPS"><a href="#什么是-HTTPS" class="headerlink" title="什么是 HTTPS"></a>什么是 HTTPS</h3><blockquote>
<p>《图解 HTTP》这本书中曾提过 HTTPS 是身披 SSL 外壳的 HTTP。HTTPS 是一种通过计算机网络进行安全通信的传输协议，经由 HTTP 进行通信，利用 SSL/TLS 建立全信道，加密数据包。HTTPS 使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。<br>PS：TLS 是传输层加密协议，前身是 SSL 协议，由网景公司 1995 年发布，有时候两者不区分。</p>
</blockquote>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a href="https://kamranahmed.info/blog/2016/08/13/http-in-depth/">https://kamranahmed.info/blog/2016/08/13/http-in-depth/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a></li>
<li><a href="https://tools.ietf.org/html/rfc1945">https://tools.ietf.org/html/rfc1945</a></li>
<li><a href="https://http2.github.io/http2-spec/">https://http2.github.io/http2-spec/</a></li>
<li><a href="https://www.zhihu.com/question/34074946">https://www.zhihu.com/question/34074946</a></li>
</ol>
<h2 id="HTTP-VS-HTTPS"><a href="#HTTP-VS-HTTPS" class="headerlink" title="HTTP VS HTTPS"></a>HTTP VS HTTPS</h2><h3 id="HTTP-特点"><a href="#HTTP-特点" class="headerlink" title="HTTP 特点"></a>HTTP 特点</h3><ol>
<li>无状态：协议对客户端没有状态存储，对事物处理没有 “记忆” 能力，比如访问一个网站需要反复进行登录操作</li>
<li>无连接：HTTP/1.1 之前，由于无状态特点，每次请求需要通过 TCP 三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。</li>
<li>基于请求和响应：基本的特性，由客户端发起请求，服务端响应</li>
<li>简单快速、灵活</li>
<li>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</li>
</ol>
<h3 id="HTTPS-特点"><a href="#HTTPS-特点" class="headerlink" title="HTTPS 特点"></a>HTTPS 特点</h3><p>基于 HTTP 协议，通过 SSL 或 TLS 提供加密处理数据、验证对方身份以及数据完整性保护，通过抓包可以看到数据不是明文传输，而且 HTTPS 有如下特点：</p>
<ol>
<li>内容加密：采用混合加密技术，中间者无法直接查看明文内容</li>
<li>验证身份：通过证书认证客户端访问的是自己的服务器</li>
<li>保护数据完整性：防止传输的内容被中间人冒充或者篡改</li>
</ol>
<p>通过 HTTPS 可以实现以下目的：</p>
<ul>
<li>收方能够证实发送方的真实身份</li>
<li>发送方事后不能否认所发送过的报文</li>
<li>收方或非法者不能伪造、篡改报文</li>
</ul>
<h2 id="HTTPS-实现原理"><a href="#HTTPS-实现原理" class="headerlink" title="HTTPS 实现原理"></a>HTTPS 实现原理</h2><h3 id="SSL-建立连接过程"><a href="#SSL-建立连接过程" class="headerlink" title="SSL 建立连接过程"></a>SSL 建立连接过程</h3><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200925220221.png" alt="SSL 建立连接过程"></p>
<ol>
<li>Client 向 Server 发送请求 <a href="https://baidu.com">https://baidu.com</a>，连接到 Server 的 443 端口，发送的信息主要是 Random1 和客户端支持的加密算法。</li>
<li>Server 接收到信息之后给予 Client 响应握手信息，包括 Random2 和匹配好的协商加密算法，这个加密算法一定是 Client 发送给 Server 加密算法的子集。</li>
<li>随即 Server 给 Client 发送第二个响应报文是数字证书。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构 (CA) 的签名，服务端的域名信息等内容。</li>
<li>客户端解析证书，这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（预主秘钥）。</li>
<li>客户端认证证书通过之后，接下来是通过 Random1、Random2 和预主秘钥组装会话秘钥。然后通过证书的公钥加密会话秘钥。</li>
<li>传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到 Random1、Random2 和预主秘钥。</li>
<li>服务端解密得到 Random1、Random2 和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。</li>
<li>客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。</li>
<li>同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明 SSL 层连接建立完成了。</li>
</ol>
<h3 id="验证证书安全性过程"><a href="#验证证书安全性过程" class="headerlink" title="验证证书安全性过程"></a>验证证书安全性过程</h3><p>当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过 CA 公钥解密得到证书信息摘要。</p>
<p>然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。</p>
<h2 id="运用和总结"><a href="#运用和总结" class="headerlink" title="运用和总结"></a>运用和总结</h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ol>
<li>HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用</li>
<li>SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行</li>
</ol>
<blockquote>
<p>中间人攻击（MITM 攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动 MITM 和主动 MITM，被动 MITM 只窃取通信数据而不修改，而主动 MITM 不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共 wifi 或者公共路由上。</p>
</blockquote>
<h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ol>
<li>SSL 证书需要购买申请，功能越强大的证书费用越高</li>
<li>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗（SSL 有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP 就不支持这个扩展，考虑到 XP 的装机量，这个特性几乎没用）。</li>
<li>根据 ACM CoNEXT 数据显示，使用 HTTPS 协议会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电。</li>
<li>HTTPS 连接缓存不如 HTTP 高效，流量成本高。</li>
<li>HTTPS 连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。</li>
<li>HTTPS 协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似 12306 网站的主页使用 HTTP 协议，有关于用户信息等方面使用 HTTPS。</li>
</ol>
]]></content>
      <categories>
        <category>后端开发日记</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发日记 - Ubuntu_Kylin 的环境配置</title>
    <url>/post/2020/a9e409e6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc -->
<h2 id="1-更换国内源"><a href="#1-更换国内源" class="headerlink" title="1. 更换国内源"></a>1. 更换国内源</h2><p>首先要查看ubuntu版本代号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsb_release -c</span><br><span class="line">Codename: bionic</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>然后修改文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* 新系统没有vim 先凑合一下 */</span><br><span class="line">$ sudo vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>修改内容为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要注意 bionic 字段要和 ubuntu 版本代号匹配</span></span><br><span class="line"><span class="comment"># 阿里源</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新软件列表</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># 更新软件</span></span><br><span class="line">$ sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<h2 id="2-安装常用软件"><a href="#2-安装常用软件" class="headerlink" title="2. 安装常用软件"></a>2. 安装常用软件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim</span></span><br><span class="line">$ sudo apt-get install vim</span><br><span class="line">$ sudo apt-get install cscope</span><br><span class="line">$ sudo apt-get install ctags</span><br><span class="line"><span class="comment"># git</span></span><br><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure>
<h2 id="3-安装常用开发环境"><a href="#3-安装常用开发环境" class="headerlink" title="3. 安装常用开发环境"></a>3. 安装常用开发环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Kernel</span></span><br><span class="line">$ sudo apt-get install libncurses5-dev</span><br><span class="line">$ sudo apt-get install libncursesw5-dev</span><br><span class="line">$ sudo apt-get install ncurses-dev</span><br><span class="line">$ sudo apt-get install bison</span><br><span class="line">$ sudo apt-get install flex</span><br><span class="line"><span class="comment"># C/C++</span></span><br><span class="line">$ sudo apt-get install build-essential</span><br><span class="line">$ sudo apt-get install cmake  </span><br><span class="line"><span class="comment"># ssl</span></span><br><span class="line">$ sudo apt-get install libssl-dev</span><br><span class="line">$ sudo apt-get install openssl</span><br><span class="line"><span class="comment"># arm</span></span><br><span class="line">$ sudo apt-get install qemu</span><br><span class="line"><span class="comment"># arm-gcc</span></span><br><span class="line">$ sudo apt-get install gcc-arm-linux-gnueabi</span><br><span class="line">$ sudo apt-get install gcc-5-arm-linux-gnueabi</span><br><span class="line"><span class="comment"># update-alternatives 选择 gcc 版本</span></span><br><span class="line">$ sudo update-alternatives --install /usr/bin/arm-linux-gnueabi-gcc  arm-linux-gnueabi-gcc  /usr/bin/arm-linux-gnueabi-gcc-5 5</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/arm-linux-gnueabi-gcc  arm-linux-gnueabi-gcc  /usr/bin/arm-linux-gnueabi-gcc-7 7</span><br><span class="line">$ sudo update-alternatives --config arm-linux-gnueabi-gcc</span><br><span class="line"><span class="comment"># python</span></span><br><span class="line">$ sudo apt-get install python-dev</span><br><span class="line">$ sudo apt-get install python3-dev</span><br><span class="line"><span class="comment"># gdb-multiarch</span></span><br><span class="line">$ sudo apt-get install gdb-multiarch</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端开发日记</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发日记 - 检查内存泄漏</title>
    <url>/post/2020/f517d3b0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>内存泄漏一般是由于程序在堆上分配了内存而没有释放，随着程序的运行占用的内存越来越大，一方面会影响程序的稳定性，可能让运行速度越来越慢，或者造成 <code>OOM</code>，甚至会影响程序所运行的机器的稳定性，造成宕机。</p>
<p>而分析内存问题的常用工具有 <code>valgrind</code> 和 <code>gperftools</code> 等，当然也可以自行开发钩子函数，本文主要介绍 <code>gperftools</code> 来进行内存泄漏的分析。</p>
<a id="more"></a>
<h2 id="安装-gperftools"><a href="#安装-gperftools" class="headerlink" title="安装 gperftools"></a>安装 gperftools</h2><p>首先是一些依赖环境的安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## libunwind 64 位系统必选</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/libunwind/libunwind.git</span><br><span class="line"><span class="built_in">cd</span> libunwind</span><br><span class="line">sh ./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成 PDF 可视化必选</span></span><br><span class="line">sudo apt-get install graphviz graphviz-doc</span><br><span class="line">sudo yum install graphviz graphviz-doc</span><br><span class="line">sudo yum install ghostscript</span><br></pre></td></tr></table></figure>
<p>然后就可以安装 <code>gperftools</code> 工具了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/gperftools/gperftools.git</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>安装完成后，如果程序运行环境与编译环境不是同一台主机，需要拷贝出一些成果物放置到合适的位置，主要成果物包括：</p>
<ol>
<li><code>lib</code> 文件，需要放在运行环境中<ul>
<li><code>libunwind.so.8</code></li>
<li><code>libtcmalloc.so.4</code></li>
</ul>
</li>
<li>头文件，需要放在代码中方便集中管理<ul>
<li><code>heap-checker.h</code></li>
<li><code>heap-profiler.h</code></li>
</ul>
</li>
<li>工具文件，可以放在编译环境中使用，也可以拷贝到其他主机上使用<ul>
<li><code>pprof</code></li>
</ul>
</li>
</ol>
<h2 id="使用-gperftools"><a href="#使用-gperftools" class="headerlink" title="使用 gperftools"></a>使用 gperftools</h2><p><code>gperftools</code> 提供了 <code>4</code> 个工具：</p>
<ul>
<li><code>thread-caching malloc</code> : 简称 <code>tcmalloc</code>，可以用来替代 <code>glibc</code> 中原有的 <code>malloc/free</code>、<code>new/delete</code> 等函数</li>
<li><code>heap-checking using tcmalloc</code> : 用来检查程序中的内存泄漏位置，适用于 <code>C++</code></li>
<li><code>heap-profiling using tcmalloc</code> : 用来统计程序中的内存申请、释放情况，可用于检查内存使用情况和泄漏情况，适用于 <code>C/C++</code>，可应用于所有可执行文件</li>
<li><code>CPU profiler</code> : 用来统计程序中每个部分占用 CPU 性能情况，用于程序 CPU 性能的观察和优化</li>
</ul>
<p>以上 <code>4</code> 个工具中，用于分析内存泄漏的有两个工具：<code>heap-checking using tcmalloc</code> 和 <code>heap-profiling using tcmalloc</code></p>
<h3 id="使用-heap-checking"><a href="#使用-heap-checking" class="headerlink" title="使用 heap-checking"></a>使用 heap-checking</h3><p>使用 <code>heap-checking</code> 有两种方式，一种是设置环境变量的方法，一种是修改代码的方法</p>
<h4 id="设置环境变量来使用-heap-checking"><a href="#设置环境变量来使用-heap-checking" class="headerlink" title="设置环境变量来使用 heap-checking"></a>设置环境变量来使用 heap-checking</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">env LD_PRELOAD=<span class="string">&quot;/usr/lib/libtcmalloc.so&quot;</span></span><br><span class="line"><span class="comment">## 假设我们要检查的程序是 /usr/local/bin/my_binary_compiled_with_tcmalloc</span></span><br><span class="line">env HEAPCHECK=normal /usr/<span class="built_in">local</span>/bin/my_binary_compiled_with_tcmalloc</span><br></pre></td></tr></table></figure>
<ol>
<li>minimal</li>
<li>normal</li>
<li>strict</li>
<li>draconian</li>
</ol>
<p>“minimal”：堆检查在初始化中尽可能晚地开始，这意味着您可以在初始化例程中泄漏一些内存，并且不会触发泄漏消息。如果您经常在一次全局初始化中故意泄漏数据，则 “minimal” 模式对您非常有用。否则，应使用更严格的模式。</p>
<p>“normal” 堆检查跟踪活动对象，并报告程序退出时无法通过活动对象访问的任何数据的泄漏，是谷歌最常用的模式，适用于日常堆检查使用。</p>
<p>“strict” 堆检查很像 “normal”，但有一些额外的检查，即内存不会丢失在全局析构函数中。特别是，如果您有一个全局变量，该变量在程序执行期间分配内存，然后在全局析构函数中 “forgets” 内存（例如，将指针设置为 NULL），这将在 “strict” 模式下提示泄漏消息，而在 “normal” 模式下并不会进行提示。</p>
<p>“draconian” 堆检查适合那些喜欢非常精确地了解其内存管理，并且希望堆检查器帮助他们实施它的人。在 “draconian” 模式下，堆检查器不会执行 “live object” 检查，因此除非在程序退出之前释放了所有分配的内存，它都会报告泄漏。</p>
<h4 id="修改代码来使用-heap-checking"><a href="#修改代码来使用-heap-checking" class="headerlink" title="修改代码来使用 heap-checking"></a>修改代码来使用 heap-checking</h4><blockquote>
<p>可参考：<a href="https://gperftools.github.io/gperftools/heap_checker.html">https://gperftools.github.io/gperftools/heap_checker.html</a></p>
</blockquote>
<h3 id="分析-heap-checking-输出"><a href="#分析-heap-checking-输出" class="headerlink" title="分析 heap-checking 输出"></a>分析 heap-checking 输出</h3><h3 id="使用-heap-profiling"><a href="#使用-heap-profiling" class="headerlink" title="使用 heap-profiling"></a>使用 heap-profiling</h3><p>与 <code>heap-checking</code> 一样，<code>heap-profiling</code> 也有同样的两种方法来使用</p>
<h4 id="设置环境变量来使用-heap-profiling"><a href="#设置环境变量来使用-heap-profiling" class="headerlink" title="设置环境变量来使用 heap-profiling"></a>设置环境变量来使用 heap-profiling</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">env LD_PRELOAD=<span class="string">&quot;/usr/lib/libtcmalloc.so&quot;</span></span><br><span class="line"><span class="comment">## 假设我们要检查的程序是 /usr/local/bin/my_binary_compiled_with_tcmalloc</span></span><br><span class="line">env HEAPPROFILE=/tmp/mybin.hprof /usr/<span class="built_in">local</span>/bin/my_binary_compiled_with_tcmalloc</span><br></pre></td></tr></table></figure>
<p>除了以上环境变量，还有一些环境变量可以设置：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>环境变量</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>HEAP_PROFILE_ALLOCATION_INTERVAL</td>
<td>1073741824 (1GB)</td>
<td>每次程序分配指定字节数时，转储堆分析信息。</td>
</tr>
<tr>
<td>HEAP_PROFILE_INUSE_INTERVAL</td>
<td>104857600(100M)</td>
<td>每当高水位内存使用标记增加指定字节数时，转储堆分析信息。</td>
</tr>
<tr>
<td>HEAP_PROFILE_TIME_INTERVAL</td>
<td>0</td>
<td>每次经过指定的秒数时转储堆分析信息。</td>
</tr>
<tr>
<td>HEAPPROFILESIGNAL</td>
<td>已禁用</td>
<td>每当将指定的信号发送到进程时，转储堆分析信息。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="修改代码来使用-heap-profiling"><a href="#修改代码来使用-heap-profiling" class="headerlink" title="修改代码来使用 heap-profiling"></a>修改代码来使用 heap-profiling</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gperftools/heap-profiler.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 启动堆分析器 */</span></span><br><span class="line">HeapProfilerStart()</span><br><span class="line"><span class="comment">/* 停止堆分析器 */</span></span><br><span class="line">HeapProfilerStop()</span><br><span class="line"><span class="comment">/* 转储堆分析器分析结果 */</span></span><br><span class="line">HeapProfilerDump()</span><br><span class="line">GetHeapProfile()</span><br><span class="line"><span class="comment">/* 检查堆分析器是否启动 */</span></span><br><span class="line">IsHeapProfilerRunning()</span><br></pre></td></tr></table></figure>
<p>示例程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gperftools/heap-profiler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WAIT_FOREVER(t) do &#123; while(1) &#123; sleep(t); &#125; &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">leek_malloc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ptr = <span class="built_in">malloc</span>(<span class="number">1024</span>); <span class="comment">/* 1024 Byte */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc 1024 byte success.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (time(<span class="literal">NULL</span>) % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">free</span>(ptr);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">leek_check</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        HeapProfilerDump(<span class="string">&quot;check&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidmalloc;</span><br><span class="line">    <span class="keyword">pthread_t</span> tiddump;</span><br><span class="line">    HeapProfilerStart(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tidmalloc, <span class="literal">NULL</span>, leek_malloc, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tidmalloc, <span class="literal">NULL</span>, leek_check, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    WAIT_FOREVER(<span class="number">10</span>);</span><br><span class="line">    HeapProfilerStop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析-heap-profiling-输出"><a href="#分析-heap-profiling-输出" class="headerlink" title="分析 heap-profiling 输出"></a>分析 heap-profiling 输出</h4><p>如果在程序中打开堆分析，程序将定期将配置文件写入文件系统。配置文件序列将命名为：</p>
<pre><code>    &lt;prefix&gt;.0000.heap
    &lt;prefix&gt;.0001.heap
    &lt;prefix&gt;.0002.heap
    ...
</code></pre><p><code>&lt;prefix&gt;</code> 是运行代码时提供的文件名前缀（或者通过环境变量 <code>HEAPPROFILE</code> 提供）的位置。请注意，如果提供的前缀不是以 ‘/‘ 开头，则配置文件将写入程序的工作目录。</p>
<p>通过将配置文件输出传递到工具 <code>pprof</code> 可以查看配置文件输出。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://gperftools.github.io/gperftools/heap_checker.html">Gperftools Heap Leak Checker</a></li>
<li>[2] <a href="https://gperftools.github.io/gperftools/heapprofile.html">Gperftools Heap Profiler</a></li>
</ul>
]]></content>
      <categories>
        <category>后端开发日记</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发日记 - 深入理解多路 IO 复用</title>
    <url>/post/2020/1a0f9f15/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Linux-I-O-模型"><a href="#Linux-I-O-模型" class="headerlink" title="Linux I/O 模型"></a>Linux I/O 模型</h2><ul>
<li><code>Blocking IO</code> - 阻塞 IO</li>
<li><code>NoneBlocking IO</code> - 非阻塞 IO</li>
<li><code>IO multiplexing</code> - IO 多路复用</li>
<li><code>signal driven IO</code> - 信号驱动 IO</li>
<li><code>asynchronous IO</code> - 异步 IO</li>
</ul>
<p><code>Select</code>, <code>Poll</code>, <code>Epoll</code> 就是 <code>IO multiplexing</code> 的三种机制。</p>
<a id="more"></a>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><h3 id="Select-函数声明"><a href="#Select-函数声明" class="headerlink" title="Select 函数声明"></a>Select 函数声明</h3><p>首先通过 <code>man</code> 命令查看下 <code>select</code> 的函数声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *<span class="keyword">restrict</span> readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> errorfds,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct timeval *<span class="keyword">restrict</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="Select-函数参数说明"><a href="#Select-函数参数说明" class="headerlink" title="Select 函数参数说明"></a>Select 函数参数说明</h3><p><code>int nfds</code> : <code>nfds</code> 指定待测试的文件描述字个数，它的值是待测试的最大描述字加 <code>1</code> 。</p>
<blockquote>
<p>The nfds argument specifies the range of descriptors to be tested. The first nfds descriptors shall be checked in each set; that is, the descriptors from zero through nfds-1 in the descriptor sets shall be examined.</p>
</blockquote>
<p><code>fd_set *readset</code> , <code>fd_set *writeset</code> , <code>fd_set *exceptset</code> : <code>fd_set</code> 可以理解为一个集合，这个集合中存放的是文件描述符( <code>file descriptor</code> )。这三个参数指定我们要让内核测试读、写和异常条件的文件描述符集合。如果对某一个的条件不感兴趣，就可以把它设为空指针。</p>
<blockquote>
<p>If the readfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the file descriptors to be checked for being ready to read, and on output indicates which file descriptors are ready to read.<br>If the writefds argument is not a null pointer, it points to an object of type fd_set that on input specifies the file descriptors to be checked for being ready to write, and on output indicates which file descriptors are ready to write.<br>If the errorfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the file descriptors to be checked for error conditions pending, and on output indicates which file descriptors have error conditions pending.</p>
</blockquote>
<p><code>const struct timeval *timeout</code> : <code>timeout</code> 告知内核等待所指定文件描述符集合中的任何一个就绪可花多少时间。其 <code>timeval</code> 结构用于指定这段时间的秒数和微秒数。</p>
<blockquote>
<p>The timeout parameter controls how long the pselect() or select() function shall take before timing out. If the timeout parameter is not a null pointer, it specifies a maximum interval to wait for the selection to complete. If the specified time interval expires without any requested operation becoming ready, the function shall return. If the timeout parameter is a null pointer, then the call to pselect() or select() shall block indefinitely until at least one descriptor meets the specified criteria. To effect a poll, the timeout parameter should not be a null pointer, and should point to a zero-valued timespec structure.<br>If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument is not a null pointer, the pselect() or select() function shall block for the time specified, or until interrupted by a signal. If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument is a null pointer, the pselect() or select() function shall block until interrupted by a signal.</p>
</blockquote>
<h3 id="Select-函数返回值"><a href="#Select-函数返回值" class="headerlink" title="Select 函数返回值"></a>Select 函数返回值</h3><p><code>select</code> 的返回类型为 <code>int</code> , 若有就绪描述符返回其数目，若超时则为 <code>0</code> ，若出错则为 <code>-1</code> 。</p>
<blockquote>
<p>Upon successful completion, the pselect() and select() functions shall return the total number of bits set in the bit masks. Otherwise, -1 shall be returned, and errno shall be set to indicate the error.</p>
</blockquote>
<p><code>FD_CLR(), FD_SET(), FD_ZERO()</code> 无返回值, <code>FD_ISSET()</code> 在当前文件描述符被 <code>FD_SET()</code> 时会返回非 <code>0</code> 值, 否则返回 <code>0</code> 。</p>
<blockquote>
<p>FD_CLR(), FD_SET(), and FD_ZERO() do not return a value. FD_ISSET() shall return a non-zero value if the bit for the file descriptor fd is set in the file descriptor set pointed to by fdset, and 0 otherwise.</p>
</blockquote>
<h3 id="Select-实现框架"><a href="#Select-实现框架" class="headerlink" title="Select 实现框架"></a>Select 实现框架</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fd_set read_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    FD_ZERO(&amp;read_fd);</span><br><span class="line">    FD_SET(<span class="number">0</span>,&amp;read_fd);</span><br><span class="line"></span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    err = select(<span class="number">1</span>,&amp;read_fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;tv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;select time out!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to select!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;data is available!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>执行 <code>fd_set set;</code>  <code>FD_ZERO(&amp;set);</code> 则 <code>set</code> 用位表示是 <code>0000,0000</code></li>
<li><p>若 <code>fd = 5</code> , 执行 <code>FD_SET(fd, &amp;set);</code> 后 <code>set</code> 变为 <code>0001,0000</code> (第 <code>5</code> 位置为 <code>1</code> )</p>
</li>
<li><p>若再加入 <code>fd=2</code> ， <code>fd=1</code> , 则 <code>set</code> 变为 <code>0001,0011</code></p>
</li>
<li><p>执行 <code>select(6, &amp;set, 0, 0, 0)</code> 阻塞等待</p>
</li>
<li><p>若 <code>fd = 1</code> , <code>fd = 2</code> 上都发生可读事件，则 <code>select</code> 返回，此时 <code>set</code> 变为 <code>0000,0011</code> 。注意：没有事件发生的 <code>fd = 5</code> 被清空</p>
</li>
</ol>
<h3 id="Select-的优缺点"><a href="#Select-的优缺点" class="headerlink" title="Select 的优缺点"></a>Select 的优缺点</h3><ol>
<li><p>被监控的fds集合限制为 <code>1024</code> ， <code>1024</code> 太小了，我们希望能够有个比较大的可监控 <code>fds</code> 集合。</p>
</li>
<li><p><code>fds</code> 集合需要从用户空间拷贝到内核空间的问题，我们希望不需要拷贝。</p>
</li>
<li><p>当被监控的 <code>fds</code> 中某些有数据可读的时候，我们希望通知更加精细一点，就是我们希望能够从通知中得到有可读事件的 <code>fds</code> 列表，而不是需要遍历整个 <code>fds</code> 来收集。</p>
</li>
</ol>
<h2 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h2><h3 id="Epoll-函数集声明"><a href="#Epoll-函数集声明" class="headerlink" title="Epoll 函数集声明"></a>Epoll 函数集声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="Epoll-函数集参数说明"><a href="#Epoll-函数集参数说明" class="headerlink" title="Epoll 函数集参数说明"></a>Epoll 函数集参数说明</h3><h3 id="Epoll-函数集返回值"><a href="#Epoll-函数集返回值" class="headerlink" title="Epoll 函数集返回值"></a>Epoll 函数集返回值</h3><h3 id="Epoll实现框架"><a href="#Epoll实现框架" class="headerlink" title="Epoll实现框架"></a>Epoll实现框架</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line"><span class="keyword">int</span> listen_sock, conn_sock, nfds, epollfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set up listening socket, &#x27;listen_sock&#x27; (socket(),</span></span><br><span class="line"><span class="comment">    bind(), listen()) */</span></span><br><span class="line"></span><br><span class="line">epollfd = epoll_create(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (epollfd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = listen_sock;</span><br><span class="line"><span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;epoll_ctl: listen_sock&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    nfds = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nfds; ++n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[n].data.fd == listen_sock) &#123;</span><br><span class="line">            conn_sock = accept(listen_sock,</span><br><span class="line">                            (struct sockaddr *) &amp;local, &amp;addrlen);</span><br><span class="line">            <span class="keyword">if</span> (conn_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            setnonblocking(conn_sock);</span><br><span class="line">            ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">            ev.data.fd = conn_sock;</span><br><span class="line">            <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,</span><br><span class="line">                        &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;epoll_ctl: conn_sock&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            do_use_fd(events[n].data.fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Epoll-的优缺点"><a href="#Epoll-的优缺点" class="headerlink" title="Epoll 的优缺点"></a>Epoll 的优缺点</h3>]]></content>
      <categories>
        <category>后端开发日记</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>善用佳软 - Astyle 安装与使用</title>
    <url>/post/2020/e2bb409/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ Astyle --style=ansi --indent=spaces=4 -L -xC100 -V -f -z2 -H -p -U --suffix=none --quiet</span><br><span class="line"><span class="comment"># --style=ansi</span></span><br><span class="line"><span class="comment"># --indent=spaces=4 更改缩进 4 个空格</span></span><br><span class="line"><span class="comment"># -L 缩进label，让 label 比当前的内容先前一个缩进距离，而不是通通靠左</span></span><br><span class="line"><span class="comment"># -xC100 最长80个字符</span></span><br><span class="line"><span class="comment"># -V 将tab转换为空格</span></span><br><span class="line"><span class="comment"># -f 在两行不相关的代码之间插入空行</span></span><br><span class="line"><span class="comment"># -H 在if for等关键字后面，加一个空格</span></span><br><span class="line"><span class="comment"># -p 在操作符两边加空格</span></span><br><span class="line"><span class="comment"># -U 去掉()内部不必要的空格</span></span><br><span class="line"><span class="comment"># --suffix=none 不备份原始文件</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具软件</category>
      </categories>
      <tags>
        <tag>Astyle</tag>
      </tags>
  </entry>
  <entry>
    <title>善用佳软 - ProxyChains-NG 安装与使用</title>
    <url>/post/2020/b7dd7417/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为某些原因，我们需要在命令行下载一些国外的资源，这个时候如果使用 <code>wget</code>，<code>curl</code>，或者 <code>aria2c</code> 的时候，往往又没有速度。这个时候我们需要使用代理来进行加速。</p>
<p>我本地搭的有 <code>ss</code>，但 <code>ss</code> 只支持 <code>socks5</code> 协议，而 <code>wget</code>，<code>curl</code> 之类使用 <code>http_proxy</code> 进行代理的软件往往无法通过代理进行科学上网。我们可以利用一款名叫 <code>ProxyChains-NG</code> 的软件，<code>chains</code> 故名思义，可以支持代理链，这样我们可以在内部使用 <code>Proxychains</code> 把 <code>http_proxy</code> 代理到 <code>socks5</code> 上，达到想要的效果。</p>
<blockquote>
<p>项目开源地址：Github : <a href="https://github.com/rofl0r/proxychains-ng">https://github.com/rofl0r/proxychains-ng</a></p>
</blockquote>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git clone https://gitee.com/hezhaojiang/proxychains-ng</span></span><br><span class="line"><span class="comment"># cd proxychains-ng/ &amp;&amp; git remote set-url origin https://github.com/rofl0r/proxychains-ng &amp;&amp; git pull</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/rofl0r/proxychains-ng &amp;&amp; <span class="built_in">cd</span> proxychains-ng/</span><br><span class="line">./configure &amp;&amp; make</span><br><span class="line"><span class="comment"># 以下命令非 root 用户注意使用 sudo 命令</span></span><br><span class="line">make install</span><br><span class="line">make install-config</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>编辑 <code>/etc/proxychains.conf</code>, 在最后一行改为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socks5 192.168.199.135 10808</span><br></pre></td></tr></table></figure>
<p>其中以下参数需要根据实际情况自行配置：</p>
<ul>
<li><code>socks5</code> 是网络代理协议</li>
<li><code>192.168.199.135</code> 是代理服务器地址</li>
<li><code>10808</code> 是代理服务器监听端口</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>不加代理明显会超时, 加代理后会提示:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ proxychains4 wget https://www.google.com</span><br><span class="line">[proxychains] config file found: /etc/proxychains.conf</span><br><span class="line">[proxychains] preloading /usr/lib/libproxychains4.so</span><br><span class="line">[proxychains] DLL init: proxychains-ng 4.14</span><br><span class="line">--2020-10-10 13:44:49--  https://www.google.com/</span><br><span class="line">Resolving www.google.com (www.google.com)... 224.0.0.1</span><br><span class="line">Connecting to www.google.com (www.google.com)|224.0.0.1|:443... [proxychains] Strict chain  ...  192.168.199.135:10808  ...  www.google.com:443  ...  OK</span><br><span class="line">connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: unspecified [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line">index.html     [ &lt;=&gt;                                      ]  11.79K  --.-KB/s    <span class="keyword">in</span> 0.1s</span><br><span class="line"></span><br><span class="line">2020-10-10 13:44:50 (83.6 KB/s) - ‘index.html’ saved [12068]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具软件</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>善用佳软 - Markdown 工具之 Mermaid</title>
    <url>/post/2020/4689dd6d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>Mermaid</code> 是一个用于画流程图、状态图、时序图、甘特图的库，使用 <code>JS</code> 进行本地渲染，广泛集成于许多 Markdown 编辑器中。</p>
<p><code>Mermaid</code> 作为一个使用 <code>JS</code> 渲染的库，生成的不是一张图片，而是一段 <code>HTML</code> 代码，因此安全许多。</p>
<p>官网：<a href="https://mermaidjs.github.io/">https://mermaidjs.github.io/</a><br>Github 项目地址：<a href="https://github.com/knsv/mermaid">https://github.com/knsv/mermaid</a></p>
<a id="more"></a>
<h2 id="Mermaid-流程图"><a href="#Mermaid-流程图" class="headerlink" title="Mermaid 流程图"></a>Mermaid 流程图</h2><p>流程图，英文 <code>Flow Chart</code>，是使用图形表示算法思路是一种方法。在 <code>Hexo</code> 中提供了插件，使得我们可以利用 <code>Mermaid</code> 这个库来实现流程图，它的显示结果非常漂亮优雅。</p>
<p><code>Mermaid</code> 提供的流程图是一个简化版的，它主要由节点和连线组成，再以文字辅助，总共三种要素。</p>
<p>这里的三、四、五，其中三表示三种基本线型，四表示流程图四个方向，五表示五种节点形状。</p>
<h3 id="三种基本线型及扩展"><a href="#三种基本线型及扩展" class="headerlink" title="三种基本线型及扩展"></a>三种基本线型及扩展</h3><h4 id="三种基本线型及带箭头的基本线型"><a href="#三种基本线型及带箭头的基本线型" class="headerlink" title="三种基本线型及带箭头的基本线型"></a>三种基本线型及带箭头的基本线型</h4><p>节点之间通过连线来连接，一共有 3 种线的形状，虚线：<code>-.-</code>、实线：<code>–--</code>、粗实线:<code>===</code>。</p>
<p>在基本线型符号串的右边加上 <code>&gt;</code> 符号，去掉左边第 1 个符号，使其保持仍然是 3 个符号，就获得了带箭头的线型。虚线有点特殊，它的第一个符号可以不去掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 代码块类型 mermaid</span><br><span class="line">graph TB</span><br><span class="line">A1 -.- B1</span><br><span class="line">A2 --- B2</span><br><span class="line">A3 &#x3D;&#x3D;&#x3D; B3</span><br><span class="line">A4 .-&gt; B4</span><br><span class="line">A5 --&gt; B5</span><br><span class="line">A6 &#x3D;&#x3D;&gt; B6</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<pre class="mermaid">%% 代码块类型 mermaid
graph TB
A1 -.- B1
A2 --- B2
A3 === B3
A4 .-> B4
A5 --> B5
A6 ==> B6</pre>

<h4 id="在线段中间加上说明文字"><a href="#在线段中间加上说明文字" class="headerlink" title="在线段中间加上说明文字"></a>在线段中间加上说明文字</h4><p>上面 6 种连线，中间都可以加上说明文字。带文字连线的符号串是这样来的：</p>
<ul>
<li>在符号串的左边加上说明文字</li>
<li>再在说明文字的左边加上基本线型的符号串的前两个符号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 代码块类型 mermaid</span><br><span class="line">graph TB</span><br><span class="line">A1 -. 虚线文字 -.- B1</span><br><span class="line">A2 -. 虚线文字 .-&gt; B2</span><br><span class="line">A3 -- 实线文字 --- B3</span><br><span class="line">A4 -- 实线文字 --&gt; B4</span><br><span class="line">A5 &#x3D;&#x3D; 粗线文字 &#x3D;&#x3D;&#x3D; B5</span><br><span class="line">A6 &#x3D;&#x3D; 粗线文字 &#x3D;&#x3D;&gt; B6</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<pre class="mermaid">%% 代码块类型 mermaid
graph TB
A1 -. 虚线文字 -.- B1
A2 -. 虚线文字 .-> B2
A3 -- 实线文字 --- B3
A4 -- 实线文字 --> B4
A5 == 粗线文字 === B5
A6 == 粗线文字 ==> B6</pre>

<h3 id="四种图形走向"><a href="#四种图形走向" class="headerlink" title="四种图形走向"></a>四种图形走向</h3><p>所有节点之间的连线，带箭头的表示其具有方向性，一块 <code>Mermaid</code> 代码块内，所有节点连线方形是一致的。那么总共有如下四种，用相应的两个字符表示。</p>
<ul>
<li><code>TB</code>: 从上到下（也可以用 <code>TD</code>）</li>
<li><code>BT</code>: 从下到上</li>
<li><code>LR</code>: 从左到右</li>
<li><code>RL</code>: 从右到左</li>
</ul>
<p>其中 <code>T</code> 表示 <code>top</code>，<code>B</code> 表示 <code>bottom</code>，<code>L</code> 表示 <code>left</code>，<code>R</code> 表示 <code>right</code>。这里又有个特殊的，<code>TB</code> 也可用 <code>TD</code> 表示。</p>
<p>下面的图分别表示上面四种图形走向：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 代码块类型 mermaid</span><br><span class="line">graph LR</span><br><span class="line">A1 -. 虚线文字 .-&gt; B1</span><br></pre></td></tr></table></figure>
<p>如 <code>LR</code> 图形走向效果如下：</p>
<pre class="mermaid">%% 代码块类型 mermaid
graph LR
A1 -. 虚线文字 .-> B1</pre>

<h3 id="五种节点外观"><a href="#五种节点外观" class="headerlink" title="五种节点外观"></a>五种节点外观</h3><p><code>Mermaid</code> 只提供了 5 种节点的外观。一般就可以满足要求。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语法</th>
<th>形状</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>矩形</td>
<td>矩形示例</td>
</tr>
<tr>
<td>()</td>
<td>圆角矩形</td>
<td>圆角矩形示例</td>
</tr>
<tr>
<td>(())</td>
<td>圆</td>
<td>圆示例</td>
</tr>
<tr>
<td>{}</td>
<td>菱形</td>
<td>菱形示例</td>
</tr>
<tr>
<td>&gt;]</td>
<td>三角形矩形组合</td>
<td>三角矩形示例</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>为什么菱形不是 <code>&gt;</code>？ 因为这个符号要拿来表示箭头，分身乏术，只能用 <code>&#123;&#125;</code> 来表示。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 代码块类型 mermaid</span><br><span class="line">graph TB</span><br><span class="line">A1[矩形 A1]      -. 虚线文字 -.- B1[矩形 B1]</span><br><span class="line">A2(圆角矩形 A2) -. 虚线文字 .-&gt; B2(圆角矩形 B2)</span><br><span class="line">A3((圆 A3))     -- 实线文字 --- B3((圆 B3))</span><br><span class="line">A4&#123;菱形 A4&#125;     -- 实线文字 --&gt; B4&#123;菱形 B4&#125;</span><br><span class="line">A5 &gt;三角矩形 A5] &#x3D;&#x3D; 粗线文字 &#x3D;&#x3D;&#x3D; B5 &gt;三角矩形 B5]</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<pre class="mermaid">%% 代码块类型 mermaid
graph TB
A1[矩形 A1] -. 虚线文字 -.- B1[矩形 B1]
A2(圆角矩形 A2) -. 虚线文字 .-> B2(圆角矩形 B2)
A3((圆 A3)) -- 实线文字 --- B3((圆 B3))
A4{菱形 A4} -- 实线文字 --> B4{菱形 B4}
A5>三角矩形 A5] == 粗线文字 === B5>三角矩形 B5]</pre>

<h4 id="一种子图形"><a href="#一种子图形" class="headerlink" title="一种子图形"></a>一种子图形</h4><p><code>Mermaid</code> 还提供了子图形，可以被嵌入图形中。子图形以 <code>subgraph</code> 开始，以 <code>end</code> 结束。子图形必须提供标题，不能对图形方向作主。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 代码块类型 mermaid</span><br><span class="line">graph TB</span><br><span class="line">A --&gt; D</span><br><span class="line">A --&gt; F</span><br><span class="line">subgraph T2</span><br><span class="line">C --&gt; D</span><br><span class="line">C --&gt; subName1((sub))</span><br><span class="line">end</span><br><span class="line">subgraph T1</span><br><span class="line">A --- B</span><br><span class="line">end</span><br><span class="line">subgraph T3</span><br><span class="line">E -.- F</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<pre class="mermaid">%% 代码块类型 mermaid
graph TB
A --> D
A --> F
subgraph T2
C --> D
C --> subName1((sub))
end
subgraph T1
A --- B
end
subgraph T3
E -.- F
end</pre>

<h2 id="Mermaid-时序图"><a href="#Mermaid-时序图" class="headerlink" title="Mermaid 时序图"></a>Mermaid 时序图</h2><p>时序图用来表示几个交互对象之间传递消息，处理事务的时间顺序的过程。核心要素是参与者（或角色），消息传递的发起及接收者，角色处理自身任务。消息传递及角色任务在时间上先后排列。时序图上的时间不要求特别间却，只要体现先后顺序即可。</p>
<p>Mermaid 实现的时序图中，角色水平排列，从上向下表示时间发展的顺序。</p>
<h3 id="定义角色"><a href="#定义角色" class="headerlink" title="定义角色"></a>定义角色</h3><p>语法很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant 甲</span><br><span class="line">participant 乙</span><br></pre></td></tr></table></figure>
<p>其中 <code>participant</code> 表示定义参与者，<code>甲</code> 和 <code>乙</code> 是就是角色名，可以是字符串，不含空格。如果有需要，可以用 <code>as</code> 来增加角色的别名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant 成吉思汗 as 甲</span><br></pre></td></tr></table></figure>
<p>需要注意：</p>
<ul>
<li>定义参与者不是必须的，参与者按照出场先后顺序排列，如果要把某个角色排在前面，那么就一定要定义它。</li>
<li>预先定义的角色排列完毕之后。没有定义的统统按出场顺序跟在后面。</li>
<li>定义语句不一定要放在消息传递之前，在中间或者后面也是可以的。</li>
<li><code>Mermaid</code> 这里存在一个 bug。== 角色名后面一定不能有空格。空格和角色名一起被视作另外一个角色 ==</li>
</ul>
<h3 id="消息连线"><a href="#消息连线" class="headerlink" title="消息连线"></a>消息连线</h3><p>通过连线来表示角色传递消息的过程。消息连线有虚线和实线两种基本线型，另外有增加箭头或者终止符的变化。</p>
<ol>
<li>基本线型<ul>
<li>实线 <code>-&gt;</code></li>
<li>虚线 <code>--&gt;</code></li>
</ul>
</li>
<li>箭头连线<ul>
<li>实箭头线 <code>-&gt;&gt;</code></li>
<li>虚箭头线 <code>--&gt;&gt;</code></li>
</ul>
</li>
<li>带终止符的连线<ul>
<li>实终止符线 <code>-x</code></li>
<li>虚终止符线 <code>--x</code></li>
</ul>
</li>
</ol>
<p>下面我们让甲乙来演示一下综合效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 代码块类型为 mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">participant 甲</span><br><span class="line">participant 乙</span><br><span class="line">甲 -&gt; 乙 : 你还好吗？</span><br><span class="line">乙 --&gt; 甲 : 你看我这不挺好吗？</span><br><span class="line">甲 -&gt;&gt; 乙 : 来个箭头试试</span><br><span class="line">乙 --&gt;&gt; 甲 : 来就来，我也会</span><br><span class="line">甲 -x 乙 : 加个 x 试试？</span><br><span class="line">乙 --x 甲 : 试试就试试，谁怕谁？</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<pre class="mermaid">%% 代码块类型为 mermaid
sequenceDiagram
participant 甲
participant 乙
甲 -> 乙 : 你还好吗？
乙 --> 甲 : 你看我这不挺好吗？
甲 ->> 乙 : 来个箭头试试
乙 -->> 甲 : 来就来，我也会
甲 -x 乙 : 加个 x 试试？
乙 --x 甲 : 试试就试试，谁怕谁？</pre>

<h3 id="角色的内部任务"><a href="#角色的内部任务" class="headerlink" title="角色的内部任务"></a>角色的内部任务</h3><p>任务处理过程，角色本身不仅传递消息，自身还存在任务，需要告诉它开始处理及处理完自己的任务。</p>
<p>开始处理用语句：<code>activate</code> 角色；处理完毕用语句：<code>deactivate</code> 角色。</p>
<p>多数情况下，都是角色在接收到消息时才会启动或者结束自身任务，因此偷懒用了个快捷的办法，在消息连线后面加上 <code>+/-</code>，表示接收消息的角色这时候应该开始或者结束自身任务处理。</p>
<p>如果不是上面这种情况，是需要用 <code>activate</code> 和 <code>deactivate</code> 语句来启动和结束任务的。</p>
<p>另外，时序图里的角色不能处理多任务。</p>
<p>如果有多个启动和完成任务的指令，记住他们一定是从最内侧进行配对的，下面举例说明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 代码块类型为 mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">participant 甲</span><br><span class="line">participant 乙</span><br><span class="line">乙 --&gt; 甲: 甲启动任务 1</span><br><span class="line">甲 -&gt;&gt; 乙: 空白</span><br><span class="line">activate 甲</span><br><span class="line">甲 --&gt;&gt; 乙: 上一句让甲启动了任务 2。</span><br><span class="line">乙 --&gt;&gt; 甲: 甲结束了任务 1，只能匹配任务 2</span><br><span class="line">甲 -x 乙: 这里有个终止符</span><br><span class="line">deactivate 甲</span><br><span class="line">乙 --x 甲: 上一句甲结束了任务 2，只能匹配任务 1</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<pre class="mermaid">%% 代码块类型为 mermaid
sequenceDiagram
participant 甲
participant 乙
乙 --> 甲: 甲启动任务 1
甲 ->> 乙: 空白
activate 甲
甲 -->> 乙: 上一句让甲启动了任务 2。
乙 -->> 甲: 甲结束了任务 1，只能匹配任务 2
甲 -x 乙: 这里有个终止符
deactivate 甲
乙 --x 甲: 上一句甲结束了任务 2，只能匹配任务 1</pre>

<h3 id="给角色贴身便签"><a href="#给角色贴身便签" class="headerlink" title="给角色贴身便签"></a>给角色贴身便签</h3><p>给角色贴上便签 <code>note</code>，可以使其被更好地理解。便签的位置有角色的左边、右边或者上方，记住没有下方。</p>
<pre><code>Note left of | right of | over John,Alice: Text in note
</code></pre><p>上面的语法很好理解，Note 是固定词汇，<code>left of</code> | <code>right of</code> | <code>over</code> 是便签的位置，左、右或中，<code>John,Alice</code> 是被贴便签的角色，最后面的是便签内容。</p>
<blockquote>
<p>注意： <code>over</code> 不带 <code>of</code> 且可以同时为多个角色贴便签。</p>
</blockquote>
<p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 代码块类型为 mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">participant 甲</span><br><span class="line">participant 乙</span><br><span class="line">Note over 甲,乙 : 你们两都挺好的</span><br><span class="line">甲 --&gt;&gt; 乙 : 你好</span><br><span class="line">乙 -&gt;&gt; 甲 : 你也好</span><br><span class="line">Note over 乙 : 你们两都挺好的</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<pre class="mermaid">%% 代码块类型为 mermaid
sequenceDiagram
participant 甲
participant 乙
Note over 甲,乙 : 你们两都挺好的
甲 -->> 乙 : 你好
乙 ->> 甲 : 你也好
Note over 乙 : 你们两都挺好的</pre>

<h3 id="IF-ELSE-时序"><a href="#IF-ELSE-时序" class="headerlink" title="IF-ELSE 时序"></a>IF-ELSE 时序</h3><p>时序在处理的时候，肯定会遇上有条件执行的情况，它的语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alt 可选语句说明</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>其中的 <code>alt</code> 是 <code>alternative</code> 的缩写，即这有两组时序是二选一的，相当于 <code>if-else</code> 语句。</p>
<p>如果没有 <code>else</code>，那么用另外一个关键词 <code>opt</code>，他是 <code>optional</code> 的缩写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opt 条件说明</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 代码块类型为 mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">participant 甲</span><br><span class="line">participant 乙</span><br><span class="line">甲 -&gt;&gt; 乙 : 你好吗？</span><br><span class="line">alt 如果乙很好</span><br><span class="line">乙 --&gt;&gt; 甲 : 我很好</span><br><span class="line">else</span><br><span class="line">乙 --&gt;&gt; 甲 : 我不好</span><br><span class="line">end</span><br><span class="line">甲-&gt;&gt;乙 : 你有空吗？咱看电影去。</span><br><span class="line">opt 乙有空</span><br><span class="line">乙 --&gt;&gt; 甲 : 去吧</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<pre class="mermaid">%% 代码块类型为 mermaid
sequenceDiagram
participant 甲
participant 乙
甲 ->> 乙 : 你好吗？
alt 如果乙很好
乙 -->> 甲 : 我很好
else
乙 -->> 甲 : 我不好
end
甲->>乙 : 你有空吗？咱看电影去。
opt 乙有空
乙 -->> 甲 : 去吧
end</pre>

<h3 id="循环时序"><a href="#循环时序" class="headerlink" title="循环时序"></a>循环时序</h3><p>把几个语句用 <code>loop end</code> 语句圈起来，这就是循环时序。语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loop 循环语句说明</span><br><span class="line">... 语句</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 代码块类型为 mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">participant 甲</span><br><span class="line">participant 乙</span><br><span class="line">甲 -&gt;&gt; 乙 : 有人在吗</span><br><span class="line">乙 -&gt;&gt; 甲 : 在啊</span><br><span class="line">loop 这俩话唠</span><br><span class="line">甲 --&gt;&gt; 乙 : 你好</span><br><span class="line">乙 --&gt;&gt; 甲 : 你好</span><br><span class="line">end</span><br><span class="line">甲 -&gt;&gt; 乙 : 我不玩了，只会说你好</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>
<pre class="mermaid">%% 代码块类型为 mermaid
sequenceDiagram
participant 甲
participant 乙
甲 ->> 乙 : 有人在吗
乙 ->> 甲 : 在啊
loop 这俩话唠
甲 -->> 乙 : 你好
乙 -->> 甲 : 你好
end
甲 ->> 乙 : 我不玩了，只会说你好</pre>

<h2 id="Mermaid-甘特图"><a href="#Mermaid-甘特图" class="headerlink" title="Mermaid 甘特图"></a>Mermaid 甘特图</h2><p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 代码块类型为 mermaid</span><br><span class="line">gantt</span><br><span class="line">dateFormat  MM-DD</span><br><span class="line">title Shop项目交付计划</span><br><span class="line"></span><br><span class="line">section 里程碑 1</span><br><span class="line">数据库设计          :active,    p1, 08-15, 3d</span><br><span class="line">详细设计            :           p2, after p1, 2d</span><br><span class="line"></span><br><span class="line">section 里程碑 2</span><br><span class="line">后端开发            :           p3, 08-22, 10d</span><br><span class="line">前端开发            :           p4, 08-22, 8d</span><br><span class="line"></span><br><span class="line">section 里程碑 3</span><br><span class="line">功能测试            :           p6, after p3, 5d</span><br><span class="line">上线               :           p7, after p6, 2d</span><br><span class="line">交付               :           p8, after p7, 2d</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<pre class="mermaid">gantt
dateFormat  MM-DD
title Shop项目交付计划

section 里程碑 0.1
数据库设计          :active,    p1, 08-15, 3d
详细设计            :           p2, after p1, 2d

section 里程碑 0.2
后端开发            :           p3, 08-22, 10d
前端开发            :           p4, 08-22, 8d

section 里程碑 0.3
功能测试            :        p6, after p3, 5d
上线               :       p7, after p6, 2d
交付               :       p8, after p7, 2d</pre>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="http://www.guide2it.com/post/2019-03-10-1-make-flowcharts-with-mermaid-in-markdown/">Hexo+Mermaid (一)：记住三、四、五，玩转 Mermaid 流程图 | 走进 IT</a></li>
<li>[2] <a href="http://www.guide2it.com/post/2019-03-10-2-make-sequence-diagrams-with-mermaid-in-markdown/">Hexo+Mermaid (二)：六步玩转 Mermaid 时序图 | 走进 IT</a></li>
<li>[3] <a href="http://www.guide2it.com/post/2019-03-10-3-make-gantt-with-mermaid-in-markdown/">Hexo+Mermaid (三)：用 Mermaid 在 Hexo 中实现超简单的甘特图 | 走进 IT</a></li>
</ul>
]]></content>
      <categories>
        <category>工具软件</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>善用佳软 - Windows 自用软件</title>
    <url>/post/2018/63482222/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近可能要重装系统，整理一下电脑上装的软件，方便重装系统后安装各类软件</p>
<p>带*为必装软件，其余可根据需要进行安装</p>
<a id="more"></a>
<h2 id="开发软件"><a href="#开发软件" class="headerlink" title="开发软件"></a>开发软件</h2><div class="table-container">
<table>
<thead>
<tr>
<th>软件名称</th>
<th>建议版本</th>
<th>软件简介</th>
<th>授权方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>* <a href="https://code.visualstudio.com">VS Code</a></td>
<td>Lastest</td>
<td>微软出品的轻量级代码编辑器</td>
<td>免费 + <a href="https://github.com/Microsoft/vscode">开源</a></td>
</tr>
<tr>
<td>* <a href="https://www.git-scm.com">Git</a></td>
<td>Lastest</td>
<td>版本控制工具</td>
<td>免费 + <a href="https://github.com/git/git">开源</a></td>
</tr>
<tr>
<td>* <a href="https://winscp.net/eng/index.php">WinSCP</a></td>
<td>Lastest</td>
<td>跨平台文件传输工具</td>
<td>免费 + <a href="https://sourceforge.net/projects/winscp">开源</a></td>
</tr>
<tr>
<td>* <a href="https://www.vandyke.com">SecureCRT</a></td>
<td>8.3</td>
<td>远程连接工具</td>
<td>付费购买</td>
</tr>
<tr>
<td><a href="https://www.mathworks.com">MATLAB</a></td>
<td>Lastest</td>
<td>矩阵计算实验室</td>
<td>付费购买</td>
</tr>
<tr>
<td><a href="http://www.keil.com">Keil MDK</a></td>
<td>uvision5</td>
<td>ARM开发环境</td>
<td>付费购买</td>
</tr>
<tr>
<td>* <a href="https://visualstudio.microsoft.com/zh-hans">VS Community</a></td>
<td>Lastest</td>
<td>集成开发环境</td>
<td>免费</td>
</tr>
<tr>
<td><a href="http://www.ti.com.cn/tool/cn/ccstudio">Code Composer Studio</a></td>
<td>Reality</td>
<td>DSP/TI专用编译器</td>
<td>免费</td>
</tr>
<tr>
<td><a href="https://www.virtualbox.org">Virtual Box</a></td>
<td>Lastest</td>
<td>虚拟机软件</td>
<td>免费</td>
</tr>
<tr>
<td><a href="https://www.qt.io">QT</a></td>
<td>Reality</td>
<td>跨平台GUI开发环境</td>
<td>免费 + <a href="http://download.qt.io/archive/qt">开源</a></td>
</tr>
</tbody>
</table>
</div>
<h2 id="效率软件"><a href="#效率软件" class="headerlink" title="效率软件"></a>效率软件</h2><div class="table-container">
<table>
<thead>
<tr>
<th>软件名称</th>
<th>建议版本</th>
<th>软件简介</th>
<th>授权方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>* <a href="http://www.wox.one">WoX</a></td>
<td>Lastest</td>
<td>优秀的文件定位工具</td>
<td>免费 + <a href="https://github.com/Wox-launcher/Wox">开源</a></td>
</tr>
<tr>
<td>* <a href="http://www.voidtools.com/">Everything</a></td>
<td>Lastest</td>
<td>文件索引/搜索软件</td>
<td>免费</td>
</tr>
<tr>
<td>* <a href="https://cjkis.me/capslock+/">Capslock+</a></td>
<td>Lastest</td>
<td>键盘党都爱的高效利器</td>
<td>免费</td>
</tr>
<tr>
<td><a href="https://symless.com/synergy">Synergy</a></td>
<td>Lastest</td>
<td>键鼠共享软件</td>
<td>付费 + <a href="https://github.com/symless/synergy-core">开源</a></td>
</tr>
<tr>
<td>* <a href="https://notepad-plus-plus.org">NotePad++</a></td>
<td>Lastest</td>
<td>文本编辑软件</td>
<td>免费</td>
</tr>
<tr>
<td>* <a href="http://www.winrar.com.cn/">WinRAR</a></td>
<td>v5.50+</td>
<td>压缩/解压工具</td>
<td>免费 + 付费去广告</td>
</tr>
<tr>
<td>* <a href="https://products.office.com/zh-CN/">Microsoft Office 365</a></td>
<td>Lastest</td>
<td>办公套件</td>
<td>付费订阅</td>
</tr>
<tr>
<td>* Adobe Acrobat Pro</td>
<td>Lastest</td>
<td>pdf阅读/编辑软件</td>
<td>付费购买</td>
</tr>
<tr>
<td><a href="https://www.tug.org/texlive">TexLive</a> + <a href="http://www.texstudio.org">TeXstudio</a></td>
<td>Lastest</td>
<td>pdf写作软件</td>
<td>免费</td>
</tr>
<tr>
<td>* <a href="https://www.daemon-tools.cc/products/dtLite">DAEMON Tools Lite</a></td>
<td>Lastest</td>
<td>虚拟光驱工具</td>
<td>免费 + 付费Pro</td>
</tr>
<tr>
<td>* <a href="http://www.internetdownloadmanager.com/">Internet Download Manager</a></td>
<td>Lastest</td>
<td>下载工具</td>
<td>付费购买</td>
</tr>
<tr>
<td>Adobe PhotoShop</td>
<td>Lastest</td>
<td>图像处理工具</td>
<td>付费购买</td>
</tr>
<tr>
<td><a href="https://www.teamviewer.com/zhCN/">TeamViewer</a></td>
<td>Lastest</td>
<td>远程控制软件</td>
<td>个人免费</td>
</tr>
</tbody>
</table>
</div>
<h2 id="安全软件"><a href="#安全软件" class="headerlink" title="安全软件"></a>安全软件</h2><div class="table-container">
<table>
<thead>
<tr>
<th>软件名称</th>
<th>建议版本</th>
<th>软件简介</th>
<th>授权方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>* <a href="https://www.huorong.cn">火绒安全</a></td>
<td>Lastest</td>
<td>杀防一体安全软件</td>
<td>个人免费</td>
</tr>
<tr>
<td>* <a href="https://www.veracrypt.fr">VeraCrypt</a></td>
<td>Lastest</td>
<td>文件(夹)加密软件</td>
<td>免费 + <a href="https://github.com/veracrypt/VeraCrypt">开源</a></td>
</tr>
<tr>
<td>* <a href="https://keepass.info/">KeePass</a></td>
<td>Lastest</td>
<td>密码管理软件</td>
<td>免费 + <a href="https://sourceforge.net/projects/keepass">开源</a></td>
</tr>
<tr>
<td><a href="https://www.glarysoft.com/">Glary Utilities</a></td>
<td>Lastest</td>
<td>电脑管理</td>
<td>免费 + 付费Pro</td>
</tr>
</tbody>
</table>
</div>
<h2 id="娱乐软件"><a href="#娱乐软件" class="headerlink" title="娱乐软件"></a>娱乐软件</h2><div class="table-container">
<table>
<thead>
<tr>
<th>软件名称</th>
<th>建议版本</th>
<th>软件简介</th>
<th>授权方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>* <a href="https://music.163.com">网易云音乐</a></td>
<td>Lastest</td>
<td>国产良心音乐应用</td>
<td>免费 + 会员</td>
</tr>
<tr>
<td>* <a href="http://office.qq.com">TIM</a></td>
<td>Lastest</td>
<td>办公版QQ</td>
<td>免费</td>
</tr>
<tr>
<td>* <a href="https://store.steampowered.com">Steam</a></td>
<td>Lastest</td>
<td>数字游戏发行平台</td>
<td>免费 + 内售</td>
</tr>
<tr>
<td>爱奇艺(UWP)</td>
<td>Lastest</td>
<td><del>无广告</del>看爱奇艺视频</td>
<td>免费 + 会员</td>
</tr>
<tr>
<td><a href="http://app.iqiyi.com/pc/wnplayer/index.html">爱奇艺万能播放器</a></td>
<td>Lastest</td>
<td>爱奇艺良心出品</td>
<td>免费</td>
</tr>
</tbody>
</table>
</div>
<h2 id="其他软件"><a href="#其他软件" class="headerlink" title="其他软件"></a>其他软件</h2><div class="table-container">
<table>
<thead>
<tr>
<th>软件类别</th>
<th>软件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>浏览器</td>
<td>* Chrome</td>
</tr>
<tr>
<td>聊天</td>
<td>* <a href="http://weixin.qq.com">微信</a></td>
</tr>
<tr>
<td>下载</td>
<td>utorrent</td>
</tr>
<tr>
<td>影音</td>
<td>PotPlayer</td>
</tr>
<tr>
<td>办公</td>
<td>* MathType - * Visio</td>
</tr>
<tr>
<td>游戏</td>
<td><a href="https://wegame.com">WeGame</a></td>
</tr>
<tr>
<td>网络</td>
<td>Fiddler - Proxifier</td>
</tr>
<tr>
<td>博客</td>
<td>*Hexo(依赖Node.js和Git)</td>
</tr>
<tr>
<td>编程</td>
<td>Java SDK&amp;JRE - * Node.js - * Python - Vim - OpenCV</td>
</tr>
<tr>
<td>剪辑</td>
<td>Adobe Premiere - Adobe After Effects</td>
</tr>
<tr>
<td>解压刻录</td>
<td><a href="https://github.com/sparanoid/7z">7zip</a> - UltraISO</td>
</tr>
</tbody>
</table>
</div>
<h2 id="好孩子看不到"><a href="#好孩子看不到" class="headerlink" title="好孩子看不到"></a>好孩子看不到</h2><div class="table-container">
<table>
<thead>
<tr>
<th>软件名称</th>
<th>建议版本</th>
<th>软件简介</th>
<th>授权方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/shadowsocks/shadowsocks-windows">Shadowsocks</a></td>
<td>Lastest</td>
<td>无</td>
<td>免费 + 开源</td>
</tr>
<tr>
<td>ShadowsocksR</td>
<td>Lastest</td>
<td>无</td>
<td>免费 + 开源</td>
</tr>
<tr>
<td><a href="https://github.com/erguotou520/electron-ssr">electron-ssr</a></td>
<td>Lastest</td>
<td>替代ShadowsocksR的跨平台软件</td>
<td>免费 + 开源</td>
</tr>
<tr>
<td><a href="https://github.com/txthinking/brook">Brook</a></td>
<td>Lastest</td>
<td>无</td>
<td>免费 + 开源</td>
</tr>
<tr>
<td><a href="https://doub.io/dbrj-7/">Brook Tool</a></td>
<td>Lastest</td>
<td>无</td>
<td>免费</td>
</tr>
<tr>
<td><a href="https://github.com/nobody3u/V2RayGCon">V2rayGCon</a></td>
<td>Lastest</td>
<td>无</td>
<td>免费 + 开源</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>工具软件</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>善用佳软 - Vim 使用教程</title>
    <url>/post/2020/436448e4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vim 是从 vi 发展出来的一个文本编辑器，在程序员中被广泛使用。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。</p>
<a id="more"></a>
<h2 id="Vim-模式介绍"><a href="#Vim-模式介绍" class="headerlink" title="Vim 模式介绍"></a>Vim 模式介绍</h2><p>Vim 具有 6 种基本模式和 5 种派生模式，我们这里只简单介绍下 6 种基本模式：</p>
<ul>
<li>普通模式 (Normal mode)</li>
</ul>
<p>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是 Vim 启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</p>
<ul>
<li>插入模式 (Insert mode)</li>
</ul>
<p>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。</p>
<blockquote>
<p>在插入模式中，可以按 ESC 键回到普通模式。</p>
</blockquote>
<ul>
<li>可视模式 (Visual mode)</li>
</ul>
<blockquote>
<p>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim 的 “文本对象” 也能和移动命令一样用在这个模式中。</p>
</blockquote>
<ul>
<li>选择模式 (Select mode)</li>
</ul>
<blockquote>
<p>这个模式和无模式编辑器的行为比较相似（Windows 标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim 会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p>
</blockquote>
<ul>
<li>命令行模式 (Command line mode)</li>
</ul>
<blockquote>
<p>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（: 键），搜索（/ 和? 键）或者过滤命令（! 键）。在命令执行之后，Vim 返回到命令行模式之前的模式，通常是普通模式。</p>
</blockquote>
<ul>
<li>Ex 模式 (Ex mode)</li>
</ul>
<p>这和命令行模式比较相似，在使用 :visual 命令离开 Ex 模式前，可以一次执行多条命令。</p>
<blockquote>
<p>这其中我们常用到就是普通模式、插入模式和命令行模式，本课程也只涉及这三个常用模式的内容</p>
</blockquote>
<h2 id="三种常用模式的切换"><a href="#三种常用模式的切换" class="headerlink" title="三种常用模式的切换"></a>三种常用模式的切换</h2><p>vim 启动进入普通模式，处于插入模式或命令行模式时只需要按 Esc 或者 Ctrl+[（这在 vim 课程环境中不管用）即可进入普通模式。普通模式中按 i（插入）或 a（附加）键都可以进入插入模式，普通模式中按 : 进入命令行模式。命令行模式中输入 wq 回车后保存并退出 vim。</p>
<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="游标移动"><a href="#游标移动" class="headerlink" title="游标移动"></a>游标移动</h3><p>普通模式，在该模式下使用方向键或者 h，j，k，l 键可以移动游标。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>h</td>
<td>左</td>
</tr>
<tr>
<td>l</td>
<td>右（小写 L）</td>
</tr>
<tr>
<td>j</td>
<td>下</td>
</tr>
<tr>
<td>k</td>
<td>上</td>
</tr>
<tr>
<td>w</td>
<td>移动到下一个单词</td>
</tr>
<tr>
<td>b</td>
<td>移动到上一个单词</td>
</tr>
</tbody>
</table>
</div>
<h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h3><p>在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>在当前光标处进行编辑</td>
</tr>
<tr>
<td>I</td>
<td>在行首插入</td>
</tr>
<tr>
<td>A</td>
<td>在行末插入</td>
</tr>
<tr>
<td>a</td>
<td>在光标后插入编辑</td>
</tr>
<tr>
<td>o</td>
<td>在当前行后插入一个新行</td>
</tr>
<tr>
<td>O</td>
<td>在当前行前插入一个新行</td>
</tr>
<tr>
<td>cw</td>
<td>替换从光标所在位置后到一个单词结尾的字符</td>
</tr>
</tbody>
</table>
</div>
<h3 id="保存文档"><a href="#保存文档" class="headerlink" title="保存文档"></a>保存文档</h3><p>从普通模式输入 : 进入命令行模式，输入 w 回车，保存文档。输入 :w <filename> 可以将文档另存为其他文件名或存到其它路径下。</p>
<h3 id="退出-vim"><a href="#退出-vim" class="headerlink" title="退出 vim"></a>退出 vim</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:q!</td>
<td>强制退出，不保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:wq!</td>
<td>强制保存并退出</td>
</tr>
<tr>
<td>:w <filename></td>
<td>另存为</td>
</tr>
<tr>
<td>:saveas 文件路径</td>
<td>另存为</td>
</tr>
<tr>
<td>:x</td>
<td>保存并退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存并退出</td>
</tr>
</tbody>
</table>
</div>
<p>普通模式下按下 Shift+zz 即可保存退出 vim。</p>
<h3 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除游标所在的字符</td>
</tr>
<tr>
<td>X</td>
<td>删除游标所在前一个字符</td>
</tr>
<tr>
<td>Delete</td>
<td>同 x</td>
</tr>
<tr>
<td>dd</td>
<td>删除整行</td>
</tr>
<tr>
<td>dw</td>
<td>删除一个单词（不适用中文）</td>
</tr>
<tr>
<td>d$ 或 D</td>
<td>删除至行尾</td>
</tr>
<tr>
<td>d^</td>
<td>删除至行首</td>
</tr>
<tr>
<td>dG</td>
<td>删除到文档结尾处</td>
</tr>
<tr>
<td>d1G</td>
<td>删至文档首部</td>
</tr>
</tbody>
</table>
</div>
<p>除此之外，你还可以在命令之前加上数字，表示一次删除多行，如：2dd 表示一次删除 2 行。</p>
<h2 id="入门操作"><a href="#入门操作" class="headerlink" title="入门操作"></a>入门操作</h2><h3 id="游标的快速跳转"><a href="#游标的快速跳转" class="headerlink" title="游标的快速跳转"></a>游标的快速跳转</h3><h4 id="行间跳转"><a href="#行间跳转" class="headerlink" title="行间跳转"></a>行间跳转</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>nG(n Shift+g) | 游标移动到第 n 行 (如果默认没有显示行号，请先进入命令模式，输入 :set nu 以显示行号)<br>gg | 游标移动到到第一行<br>G(Shift+g) | 到最后一行</p>
<blockquote>
<p>小技巧：你在完成依次跳转后，可以使用 Ctrl+o 快速回到上一次 (跳转前) 光标所在位置。</p>
</blockquote>
<h4 id="行内跳转"><a href="#行内跳转" class="headerlink" title="行内跳转"></a>行内跳转</h4><p>普通模式下使用下列命令在行内按照单词为单位进行跳转：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>w</td>
<td>到下一个单词的开头</td>
</tr>
<tr>
<td>e</td>
<td>到当前单词的结尾</td>
</tr>
<tr>
<td>b</td>
<td>到前一个单词的开头</td>
</tr>
<tr>
<td>ge</td>
<td>到前一个单词的结尾</td>
</tr>
<tr>
<td>0 或 ^</td>
<td>到行头</td>
</tr>
<tr>
<td>$</td>
<td>到行尾</td>
</tr>
<tr>
<td>f &lt;字母&gt;</td>
<td>向后搜索 &lt; 字母 &gt; 并跳转到第一个匹配的位置 (非常实用)</td>
</tr>
<tr>
<td>F &lt;字母&gt;</td>
<td>向前搜索 &lt; 字母 &gt; 并跳转到第一个匹配的位置</td>
</tr>
<tr>
<td>t &lt;字母&gt;</td>
<td>向后搜索 &lt; 字母 &gt; 并跳转到第一个匹配位置之前的一个字母 (不常用)</td>
</tr>
<tr>
<td>T &lt;字母&gt;</td>
<td>向前搜索 &lt; 字母 &gt; 并跳转到第一个匹配位置之后的一个字母 (不常用)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="复制粘贴和剪切"><a href="#复制粘贴和剪切" class="headerlink" title="复制粘贴和剪切"></a>复制粘贴和剪切</h3><h4 id="复制及粘贴文本"><a href="#复制及粘贴文本" class="headerlink" title="复制及粘贴文本"></a>复制及粘贴文本</h4><p>普通模式中使用 y 复制：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>yy</td>
<td>复制游标所在的整行（3yy 表示复制 3 行）</td>
</tr>
<tr>
<td>y^</td>
<td>复制至行首，或 y0。不含光标所在处字符</td>
</tr>
<tr>
<td>y$</td>
<td>复制至行尾。含光标所在处字符</td>
</tr>
<tr>
<td>yw</td>
<td>复制一个单词</td>
</tr>
<tr>
<td>y2w</td>
<td>复制两个单词</td>
</tr>
<tr>
<td>yG</td>
<td>复制至文本末</td>
</tr>
<tr>
<td>y1G</td>
<td>复制至文本开头</td>
</tr>
</tbody>
</table>
</div>
<p>普通模式中使用 p 粘贴：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>粘贴至光标后（下）</td>
</tr>
<tr>
<td>P</td>
<td>粘贴至光标前（上）</td>
</tr>
</tbody>
</table>
</div>
<h4 id="剪切及粘贴"><a href="#剪切及粘贴" class="headerlink" title="剪切及粘贴"></a>剪切及粘贴</h4><p>其实前面讲得 dd 删除命令就是剪切，你每次 dd 删除文档内容后，便可以使用 p 来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行。</p>
<p>ddp，就这么简单，即实现了快速交换光标所在行与它下面的行。</p>
<h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="替换和撤销命令"><a href="#替换和撤销命令" class="headerlink" title="替换和撤销命令"></a>替换和撤销命令</h3><p>替换和撤销命令都是针对普通模式下的操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>r+&lt;待替换字母&gt;</td>
<td>将游标所在字母替换为指定字母</td>
</tr>
<tr>
<td>R</td>
<td>连续替换，直到按下 Esc</td>
</tr>
<tr>
<td>cc</td>
<td>替换整行，即删除游标所在行，并进入插入模式</td>
</tr>
<tr>
<td>cw</td>
<td>替换一个单词，即删除一个单词，并进入插入模式</td>
</tr>
<tr>
<td>C(大写)</td>
<td>替换游标以后至行末</td>
</tr>
<tr>
<td>~</td>
<td>反转游标所在字母大小写</td>
</tr>
<tr>
<td>u{n}</td>
<td>撤销一次或 n 次操作</td>
</tr>
<tr>
<td>U(大写)</td>
<td>撤销当前行的所有修改</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>redo，即撤销 undo 的操作</td>
</tr>
</tbody>
</table>
</div>
<h3 id="快速缩进"><a href="#快速缩进" class="headerlink" title="快速缩进"></a>快速缩进</h3><h4 id="调整缩进"><a href="#调整缩进" class="headerlink" title="调整缩进"></a>调整缩进</h4><ul>
<li>普通模式下输入 &gt;&gt; 整行将向右缩进（使用，用于格式化代码超爽）</li>
<li>普通模式下输入 &lt;&lt; 整行向左回退</li>
<li>普通模式下输入 : 进入命令行模式下对 <code>shiftwidth</code> 值进行设置可以控制缩进和回退的字符数<ul>
<li>获取目前的设定值 <code>:set shiftwidth?</code></li>
<li>设置缩进为 10 个字符 <code>:set shiftwidth=10</code></li>
</ul>
</li>
</ul>
<h4 id="调整文本位置"><a href="#调整文本位置" class="headerlink" title="调整文本位置"></a>调整文本位置</h4><ul>
<li>命令行模式下输入 :ce(center) 命令使本行内容居中：</li>
<li>命令行模式下输入 :ri(right) 命令使本行文本靠右：</li>
<li>命令行模式下输入 le(left) 命令使本行内容靠左：</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h4><p>普通模式下输入 / 然后键入需要查找的字符串，按回车后就会进行查找。? 与 / 功能相同，只不过 ? 是向上而 / 是向下查找。</p>
<p>进入查找之后，输入 n 和 N 可以继续查找。n 是查找下一个内容，N 查找上一个内容。</p>
<h4 id="高级查找"><a href="#高级查找" class="headerlink" title="高级查找"></a>高级查找</h4><ul>
<li>普通模式下输入 * 寻找游标所在处的单词</li>
<li>普通模式下输入 # 同上，但 # 是向前（上）找，* 则是向后（下）找</li>
<li>普通模式下输入 g* 同 *，但部分符合该单词即可</li>
<li>普通模式下输入 g# 同 #，但部分符合该单词即可</li>
</ul>
<p>以上查找 n，N 的继续查找命令依然可以用。</p>
<h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><h3 id="视窗操作"><a href="#视窗操作" class="headerlink" title="视窗操作"></a>视窗操作</h3><div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令行模式</td>
<td>:sp 1.txt</td>
<td>打开新的水平分屏视窗来编辑 1.txt</td>
</tr>
<tr>
<td>命令行模式</td>
<td>:vsp 2.txt</td>
<td>打开新的垂直分屏视窗来编辑 2.txt</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w s</td>
<td>将当前窗口分割成两个水平的窗口</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w v</td>
<td>将当前窗口分割成两个垂直的窗口</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w q</td>
<td>即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w o</td>
<td>打开一个视窗并且隐藏之前的所有视窗</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w j</td>
<td>移至下面视窗</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w k</td>
<td>移至上面视窗</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w h</td>
<td>移至左边视窗</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w l</td>
<td>移至右边视窗</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w J</td>
<td>将当前视窗移至下面</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w K</td>
<td>将当前视窗移至上面</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w H</td>
<td>将当前视窗移至左边</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w L</td>
<td>将当前视窗移至右边</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w -</td>
<td>减小视窗的高度</td>
</tr>
<tr>
<td>普通模式</td>
<td>Ctrl+w +</td>
<td>增加视窗的高度</td>
</tr>
</tbody>
</table>
</div>
<h3 id="文档加密"><a href="#文档加密" class="headerlink" title="文档加密"></a>文档加密</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建加密文档</span></span><br><span class="line">vim -x filename</span><br></pre></td></tr></table></figure>
<p>输入您的密码，确认密码，这样在下一次打开时，vim 就会要求你输入密码。</p>
<h3 id="在-vim-执行外部命令"><a href="#在-vim-执行外部命令" class="headerlink" title="在 vim 执行外部命令"></a>在 vim 执行外部命令</h3><p>在命令行模式中输入 ! 可以执行外部的 shell 命令，如：</p>
<ul>
<li>:!ls 用于显示当前目录的内容</li>
<li>:!rm filename 用于删除名为 filename 的文件</li>
<li>:w filename 可将当前 vim 中正在编辑的文件另存为 filename 文件</li>
</ul>
<h3 id="帮助系统"><a href="#帮助系统" class="headerlink" title="帮助系统"></a>帮助系统</h3><ul>
<li>普通模式下按 F1 打开 vim 自己预设的帮助文档</li>
<li>命令行模式下输入 :h shiftwidth 打开名为 shiftwidth 的帮助文件</li>
<li>命令行模式下输入 :ver 显示版本及参数</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://www.lanqiao.cn/courses/2">Vim 基础入门 - 蓝桥</a></li>
</ul>
]]></content>
      <categories>
        <category>工具软件</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>善用佳软 - 常用工具的一键安装脚本</title>
    <url>/post/2020/f284099/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.docker.com/ | sh</span><br><span class="line"><span class="comment"># 阿里云</span></span><br><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br><span class="line"><span class="comment"># DaoCloud</span></span><br><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="LNMP"><a href="#LNMP" class="headerlink" title="LNMP"></a>LNMP</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://soft.vpser.net/lnmp/lnmp1.6.tar.gz -cO lnmp1.6.tar.gz &amp;&amp; tar zxf lnmp1.6.tar.gz &amp;&amp; <span class="built_in">cd</span> lnmp1.6 &amp;&amp; ./install.sh lnmp</span><br><span class="line"><span class="comment"># 如需要安装 LNMPA 或 LAMP ，将 ./install.sh 后面的参数 lnmp 替换为 lnmpa 或 lamp 即可 如：</span></span><br><span class="line">wget http://soft.vpser.net/lnmp/lnmp1.6.tar.gz -cO lnmp1.6.tar.gz &amp;&amp; tar zxf lnmp1.6.tar.gz &amp;&amp; <span class="built_in">cd</span> lnmp1.6 &amp;&amp; ./install.sh lnmpa</span><br></pre></td></tr></table></figure>
<h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure>
<h2 id="Brook"><a href="#Brook" class="headerlink" title="Brook"></a>Brook</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/brook.sh &amp;&amp; chmod +x brook.sh &amp;&amp; bash brook.sh</span><br></pre></td></tr></table></figure>
<h2 id="V2ray"><a href="#V2ray" class="headerlink" title="V2ray"></a>V2ray</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Version 1</span></span><br><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/V2ray.Fun/master/install.sh &amp;&amp; bash install.sh</span><br><span class="line"><span class="comment"># Version 2</span></span><br><span class="line"><span class="built_in">source</span> &lt;(curl -sL https://multi.netlify.app/v2ray.sh) --zh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具软件</category>
      </categories>
      <tags>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据压缩技术 - Huffman 编码</title>
    <url>/post/2020/28999b3b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="霍夫曼（Huffman）算法的简介"><a href="#霍夫曼（Huffman）算法的简介" class="headerlink" title="霍夫曼（Huffman）算法的简介"></a>霍夫曼（Huffman）算法的简介</h2><p>Huffman 编码是 1952 年为压缩文本文件所设计的编码方法，也是目前消除视频信息冗余最常使用的方法之一；其对出现概率最大的符号赋以最短的码字，概率越小表示的码字越长，从而使表示每个符号的平均比特数最小。</p>
<a id="more"></a>
<h2 id="霍夫曼（Huffman）编码的步骤"><a href="#霍夫曼（Huffman）编码的步骤" class="headerlink" title="霍夫曼（Huffman）编码的步骤"></a>霍夫曼（Huffman）编码的步骤</h2><ol>
<li>把信源符号按概率大小顺序排列；（概率排序）</li>
<li>在分配码字长度时，首先将两个出现概率最小的两个符号的概率相加，合成一个概率；（合并）</li>
<li>把这个合成概率看作是一个新组合符号的概率，重复上述做法，直到最后只剩下两个符号的概率为止；（置换）</li>
<li>完成上述步骤后，再返回向前进行编码，每层有两个分支，分别赋予 0 和 1（大的赋 0 或小的赋 0 均可，但必须一致）。</li>
</ol>
<h2 id="霍夫曼（Huffman）编码的特点"><a href="#霍夫曼（Huffman）编码的特点" class="headerlink" title="霍夫曼（Huffman）编码的特点"></a>霍夫曼（Huffman）编码的特点</h2><ul>
<li>霍夫曼编码是瞬时惟一的可解块编码；<ul>
<li>瞬时：符号串中每个码字无需参考后继符号就可解码；</li>
<li>惟一可解码：任何符号串只能以一种方式解码；</li>
<li>块编码：每个信源符号都映射到一个编码符号的固定序列中；</li>
</ul>
</li>
<li>霍夫曼编码是惟一可译码。短的码不会成为更长码的起始部分；</li>
<li>霍夫曼编码的平均码长接近于熵；</li>
<li>与计算机的数据结构不匹配；</li>
<li>需要多次排序，耗费时间。</li>
</ul>
<p>注意：</p>
<ul>
<li>霍夫曼编码的算法是确定的，但编出的码并非是唯一的。</li>
<li>由于霍夫曼编码的依据是信源符号的概率分布，故其编码效率取决于信源的统计特性。</li>
</ul>
<h2 id="霍夫曼（Huffman）编码的局限性"><a href="#霍夫曼（Huffman）编码的局限性" class="headerlink" title="霍夫曼（Huffman）编码的局限性"></a>霍夫曼（Huffman）编码的局限性</h2><ul>
<li>只适用于离散信源，即信源符号个数为有限数；</li>
<li>编码时需要知道输入符号集的概率分布；</li>
<li>在进行 Huffman 编码压缩时，计算量大而复杂，尤其是译码复杂度较高；</li>
<li>由于码长不等，还存在一个输入与输出的速率匹配问题。</li>
</ul>
]]></content>
      <categories>
        <category>数据压缩技术</category>
      </categories>
      <tags>
        <tag>编码原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据压缩技术 - 游程编码</title>
    <url>/post/2020/cff0aa33/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="游程编码的概念"><a href="#游程编码的概念" class="headerlink" title="游程编码的概念"></a>游程编码的概念</h2><h3 id="游程编码的基本原理"><a href="#游程编码的基本原理" class="headerlink" title="游程编码的基本原理"></a>游程编码的基本原理</h3><p>将具有相同值的连续串用其串长和一个代表值来代替，该连续串就称为游程，串长称为游程长度。</p>
<h3 id="编码思想"><a href="#编码思想" class="headerlink" title="编码思想"></a>编码思想</h3><p>去除像素冗余：用游程的灰度和游程的长度代替游程本身。</p>
<a id="more"></a>
<h2 id="二元信源的游程编码"><a href="#二元信源的游程编码" class="headerlink" title="二元信源的游程编码"></a>二元信源的游程编码</h2><p>二元信源即只有 0 和 1 符号的信源</p>
<p>二元信源中 0 游程和 1 游程总是交替出现； 如规定某二元序列是从 0 开始, 第一个游程是 0 第二个是 1，第三个是 0 等等。</p>
<ul>
<li>0 游程：连续出现 0 符号的段 —&gt; 0 游程长度记作 L(0)</li>
<li>1 游程：连续出现 1 符号的段 —&gt; 0 游程长度记作 L(1)</li>
<li>游程序列：用自然数标记的游程长度，映射成交替出现的游程长度序列</li>
</ul>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200827215810.png" alt="二元序列游程编码"></p>
<h2 id="多元信源的游程编码"><a href="#多元信源的游程编码" class="headerlink" title="多元信源的游程编码"></a>多元信源的游程编码</h2><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200827215938.png" alt="多元序列游程编码"></p>
<ul>
<li>定长游程编码：编码的游程长度所用的二进制位数固定。</li>
<li>变长游程编码：不同范围的游程长度用不同编码位，需要增加标志位来表明所使用的二进制位数。</li>
</ul>
<p>变长游程编码举例：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200827220156.png" alt="变长游程编码举例"></p>
<p>但是增加的标志位可能抵消压缩编码带来的好处，所以多元序列进行游程编码的意义不大。</p>
<h2 id="游程编码优缺点分析"><a href="#游程编码优缺点分析" class="headerlink" title="游程编码优缺点分析"></a>游程编码优缺点分析</h2><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>游程编码仍然是变长编码，有其固定的缺点，需大量的缓冲和优质的信道。</li>
<li>编程长度可以从 1 一直到无限，这在码字的选择和码表的建立方面都有困难，实际应用是尚需采用某些措施来改进。</li>
<li>只适用于二元序列，对于多元信源，一般不能直接利用游程编码。</li>
<li>游程越长，出现的概率越小；游程长度趋于无穷时，其出现的概率也趋向于零。</li>
<li>按照霍夫曼编码的规则，概率越小，码长越长，但小概率的码字对平均码长的影响较小。</li>
<li>所以在实际应用时，对长游程一般采用截断处理的方法，将大于一定长度的长游程统一用等长码编码。</li>
</ul>
<h2 id="图像的游程编码"><a href="#图像的游程编码" class="headerlink" title="图像的游程编码"></a>图像的游程编码</h2><ul>
<li>对某些相同灰度级成片连续出现的图像，游程编码也是一种高效的编码方法。特别是对二值图像，效果尤为显著。</li>
<li>游程编码所能获得的压缩比主要取决于图像本身的特点。</li>
<li>若图像中具有相同颜色的图像块越大，图像块数目越少，则压缩比就越高，反之，压缩比就越小。</li>
</ul>
<p>图像游程编码举例：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200827220958.png" alt="游程编码二值图像"><br><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200827221023.png" alt="游程编码灰度图像"></p>
<p>从上例可看出，游程编码适合于对二值图像的编码，如果图像是由很多块颜色或灰度相同的大面积区域组成的，采用游程编码可以达到很大的压缩比。</p>
<p>通常，为了达到比较好的压缩效果，一般不单独使用游程编码，而是和其他编码方法结合使用。如：在 JPEG 中，就综合使用了游程编码以及哈夫曼编码。</p>
]]></content>
      <tags>
        <tag>数据压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>数据压缩技术 - 熵编码原理</title>
    <url>/post/2020/b179cf14/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="信息量的概念"><a href="#信息量的概念" class="headerlink" title="信息量的概念"></a>信息量的概念</h2><p>信息量：表示该符号所需要的位数。</p>
<p>考虑用 0 和 1 组成的二进制数码为含有 n 个符号的某条消息编码，假设符号 $a_{j}$ 在整条消息中重复出现的概率为 $P_{j}$ ，则该符号的信息量定义为：</p>
<script type="math/tex; mode=display">E_{n} = -log_{2}(P_{j})\qquad(0\le P_{j}\le1)</script><p>信息量表示为以 2 为底的对数，是正值。</p>
<a id="more"></a>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>输入信源字符串：<code>aabbaccbaa</code></p>
<p>a、b、c 出现的概率分别为 0.5、0.3 和 0.2，他们的信息量分别为：</p>
<script type="math/tex; mode=display">E_{a} = -\log_{2}0.5 = 1</script><script type="math/tex; mode=display">E_{b} = -\log_{2}0.3 = 1.737</script><script type="math/tex; mode=display">E_{c} = -\log_{2}0.2 = 2.322</script><p>总信息量也即表达整个字符串需要的位数：</p>
<script type="math/tex; mode=display">E = E_{a} \times 5 + E_{b} \times 3 + E_{c} \times 2 = 14.855(bit)</script><h3 id="等长编码"><a href="#等长编码" class="headerlink" title="等长编码"></a>等长编码</h3><p>输入信源字符串：<code>aabbaccbaa</code></p>
<p>使用等长编码编码该字符串：a-00, b-01, c-10</p>
<p>则该字符串可表示为：<code>&quot;00000101001010010000&quot;</code>，需要 20 位二进制数表示。</p>
<h2 id="熵编码的概念"><a href="#熵编码的概念" class="headerlink" title="熵编码的概念"></a>熵编码的概念</h2><p>数据压缩的基石是 Shannon 于 1948 年创立的信息论。<br>Shannon 第一定律（率失真定律）确定了在编码过程中不损失任何信息，即在无损编码条件下数据压缩的理论极限是信息的熵，并指出了如何建立最优数据压缩编码方法。<br>这类保存信息熵的编码方法统称为熵编码（Entropy coding）, 熵编码结果经解码后可无失真地恢复出原始信息。</p>
<p>假设信源符号集 $A\ {a_{1},a_{2},…,a_{j}}$，其中每个元素 $a_{j}$ 为信源符号。<br>其中信源产生符号 $a_{j}$ 这个事件的概率是 $P_{j}$，则对每个信源输出的平均信息量为：</p>
<script type="math/tex; mode=display">H(X)=-\sum_{j=1}^{m}p_{j}*\log_{2}p_{j}</script><script type="math/tex; mode=display">\sum_{j=1}^{m}p_{j}=1</script><p>$H(X)$ 为信源的平均信息量，或称为 “熵”（entropy）</p>
<h2 id="平均码长的概念"><a href="#平均码长的概念" class="headerlink" title="平均码长的概念"></a>平均码长的概念</h2><p>如果对字符 $a_{j 的}$ 编码长度为 $L_{j}$，则信号 L 的平均码长为：</p>
<script type="math/tex; mode=display">L_{avg} = \sum_{j=1}^{m}p_{j}*L_{j}</script><p>其中 m 为信号中所出现不同字符的个数。</p>
<h2 id="无失真编码定理"><a href="#无失真编码定理" class="headerlink" title="无失真编码定理"></a>无失真编码定理</h2><ul>
<li>平均码长 $L_{avg} \gg H(X)$：有冗余，不是最佳</li>
<li>平均码长 $L_{avg} \lt H(X)$：不可能</li>
<li>平均码长 $L_{avg} \approx H(X)$：最佳编码</li>
</ul>
<p>熵值是平均码长的下限。</p>
<p>编码的基本思想就是用较少的比特数表示出现概率较大的码源符号，用较多的比特数表示出现概率小的码源符号；</p>
<blockquote>
<p>常用编码方式：霍夫曼编码 (Huffman)：<a href="/post/2020/28999b3b/" title="数据压缩技术 - Huffman 编码">数据压缩技术 - Huffman 编码</a></p>
</blockquote>
<h2 id="编码效率的定义"><a href="#编码效率的定义" class="headerlink" title="编码效率的定义"></a>编码效率的定义</h2><p>熵 $H(x)$ 除以平均码长 $L_{avg}$ 即表示编码效率：</p>
<script type="math/tex; mode=display">H(X) = -\sum_{j=1}^{m}p_{j}*\log_{2}p_{j}</script><script type="math/tex; mode=display">\eta = \frac{H(X)}{L_{avg}}\qquad\eta\le 1</script>]]></content>
      <categories>
        <category>数据压缩技术</category>
      </categories>
      <tags>
        <tag>编码原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据压缩技术 - 算术编码</title>
    <url>/post/2020/814ee4c2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="算术编码的原理"><a href="#算术编码的原理" class="headerlink" title="算术编码的原理"></a>算术编码的原理</h2><p>算术编码是 1980 年代发展起来的一种熵编码方法。</p>
<p>基本原理是将被编码的数据序列表示成 0 和 1 之间的一个间隔 (也就是一个小数范围)，该间隔的位置与输入数据的概率分布有关。信息越长，编码表示的间隔就越小，因而表示这一间隔所需的二进制位数就越多 (由于间隔是用小数表示的)。</p>
<a id="more"></a>
<h2 id="算术编码的步骤"><a href="#算术编码的步骤" class="headerlink" title="算术编码的步骤"></a>算术编码的步骤</h2><p>算数编码是从整个符号序列出发，采用递推式连续编码的方法。解码时，根据该区间判断信源各个符号出现的顺序和类型。</p>
<p>下面以一个多符号的算术编码为例来分析算术编码的步骤：</p>
<p>例: 对一个简单的信号源进行观察，得到的统计模型如下：</p>
<ul>
<li>60% 的机会出现符号 $a_{1}$</li>
<li>20% 的机会出现符号 $a_{2}$</li>
<li>10% 的机会出现符号 $a_{3}$</li>
<li>10% 的机会出现符号 数据结束符 $a_{4}$ (出现这个符号的意思是该信号源’内部中止’，在进行数据压缩时这样的情况是很常见的。当第一次也是唯一的一次看到这个符号时，解码器就知道整个信号流都被解码完成了)。</li>
</ul>
<p>解：</p>
<ol>
<li>首先定义算法空间为 [0 1]。</li>
<li><p>确定各个字符的区间分配，建立码点，码点要满足如下两条规则：</p>
<ul>
<li>每一个码点值是它前面所出现的概率之和；（第一个码点值是 0，因为它之前没有码字；第一个符号 $a_{1}$ 出现的概率为 0.6，故第二个码点值是 0.6，依次类推。）</li>
<li><p>将每一个码点值作为右端点，每个子分过程中所得区间的宽度对应于该符号的概率。</p>
<p>对于前面提出的 4 符号模型：</p>
</li>
<li>$a_{1}$ 对应的区间是 [0, 0.6)</li>
<li>$a_{2}$ 对应的区间是 [0.6, 0.8)</li>
<li>$a_{3}$ 对应的区间是 [0.8, 0.9)</li>
<li>数据结束符 $a_{4}$ 对应的区间是 [0.9, 1)</li>
</ul>
</li>
<li><p>对输入的每个信源符号，重复如下步骤：</p>
<ul>
<li>将第一个信源符号 $a_{1}$ 出现的概率空间 [0 0.6) 扩展为新的算法子空间，将当前区间分割为长度正比于信源集内各个符号概率的区间；</li>
<li>接下来确定第二个符号是 $a_{3}$ 的子区间，即序列 $a_{1},a_{3}$ 的子区间：</li>
</ul>
</li>
</ol>
<p>比如要编码序列 $a_{1},a_{3},a_{4}$：</p>
<ol>
<li>读入 $a_{1}$，结果区间为 [0, 0.6)</li>
<li>读入 $a_{3}$，结果区间为 [0 + 0.6 <em> 0.8, 0 + 0.6 </em> 0.9) = [0.48, 0.54)</li>
<li>读入 $a_{4}$，结果区间为 [0.48 + 0.06 <em> 0.9, 0.48 + 0.06 </em> 1) = [0.534, 0.54)</li>
</ol>
<p>当所有的符号都编码完毕，最终得到的结果区间即唯一的确定了已编码的符号序列。任何人使用该区间和使用的模型参数即可以解码重建得到该符号序列。</p>
<p>实际上我们并不需要传输最后的结果区间 [0.534, 0.54)，实际上，我们只需要传输该区间中的一个小数（比如 0.535）即可。在实用中，只要传输足够的该小数足够的位数（不论几进制），以保证以这些位数开头的所有小数都位于结果区间就可以了。</p>
<h2 id="算术解码的步骤"><a href="#算术解码的步骤" class="headerlink" title="算术解码的步骤"></a>算术解码的步骤</h2><p>例: 下面对使用前面提到的 4 符号模型进行编码的一段信息进行解码。编码的结果是 0.538（为了容易理解，这里使用十进制而不是二进制；我们也假设我们得到的结果的位数恰好够我们解码。下面会讨论这两个问题）。</p>
<p>像编码器所作的那样我们从区间 [0,1) 开始，使用相同的模型，我们将它分成编码器所必需的四个子区间。分数 0.538 落在 $a_{1}$ 坐在的子区间 [0,0.6)；这向我们提示编码器所读的第一个符号必然是 $a_{1}$，这样我们就可以将它作为消息的第一个符号记下来。</p>
<p>然后我们将区间 [0,0.6) 分成子区间：</p>
<ul>
<li>$a_{1}$ 的区间是 [0, 0.36) — [0, 0.6) 的 60%</li>
<li>$a_{2}$ 的区间是 [0.36, 0.48) — [0, 0.6) 的 20%</li>
<li>$a_{3}$ 的区间是 [0.48, 0.54) — [0, 0.6) 的 10%</li>
<li>数据结束符 $a_{4}$ 的区间是 [0.54, 0.6). — [0, 0.6) 的 10%</li>
</ul>
<p>0.538 在 [0.48, 0.54) 区间；所以消息的第二个符号一定是 $a_{3}$。</p>
<p>我们再一次将当前区间划分成子区间：</p>
<ul>
<li>$a_{1}$ 的区间是 [0.48, 0.516)</li>
<li>$a_{2}$ 的区间是 [0.516, 0.528)</li>
<li>$a_{3}$ 的区间是 [0.528, 0.534)</li>
<li>数据结束符 $a_{4}$ 的区间是 [0.534, 0.540)</li>
</ul>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200827184355.jpg" alt="算术编码的单位区间上的码点"></p>
<p>0.538 落在符号数据结束符 $a_{4}$ 的区间；所以，这一定是下一个符号。由于它也是内部的结束符号，这也就意味着编码已经结束。（如果数据流没有内部结束，我们需要从其它的途径知道数据流在何处结束，否则我们将永远将解码进行下去，错误地将不属于实际编码生成的数据读进来。）</p>
<p>同样的消息能够使用同样短的分数来编码实现如 0.534、0.535、0.536、0.537 或者是 0.539，这表明使用十进制而不是二进制会带来效率的降低。这是正确的是因为三位十进制数据能够表达的信息内容大约是 9.966 位；我们也能够将同样的信息使用二进制分数表示为 0.10001010（等同于 0.5390625），它仅需 8 位。这稍稍大于信息内容本身或者消息的信息熵，大概是概率为 0.6% 的 7.361 位信息熵。（注意最后一个 0 必须在二进制分数中表示，否则消息将会变得不确定起来。）</p>
<h2 id="算术编码的分析"><a href="#算术编码的分析" class="headerlink" title="算术编码的分析"></a>算术编码的分析</h2><p>算术编码是一种从整个符号系列出发，采用递推形式连续编码的方法。在算术编码中，字母表中的符号和码字间不再存在一一对应关系，一个算术码字要赋给整个信源符号序列（即不是一次编一个号），而码字本身确定 0 和 1 之间的一个实数区间。</p>
<p>不论是否是二元信源，也不论数据的概率分布如何，其平均码长均能逼近信源的熵。</p>
<p>算术编码和霍夫曼编码的区别就在于：在算术编码中，输入序列（即被赋给单个码字的符号块）的长度，是可变的，可以说，算术编码是将可变长码字赋给可变长符号块</p>
<p>正是由于算术编码不需要为定长符号块分配整数长的码字，理论上能达到无损编码定理所规定的最低限。</p>
<p>在编码过程中，尽管在计算时有乘法运算，但可以通过移位实现，即通过加法和移位实现算术运算。在解码时，要除以符号区间概率，也可以通过移位实现，即通过减法和移位实现算术解码。这正是把这种编码方法称为算术码的原因。</p>
<p>算术编码从全序列出发，采用递推形式的连续编码，它不是将单个的信源符号映射成一个码字，而是将整个符号序列映射为实数轴上 [0,1）区间内的一个小区间，其长度等于该序列的概率。</p>
<p>随着输入符号越来越多，子区间分割越来越精细，因此表示其左端点的数值的有效位数也越来越多。</p>
<p>如果等整个符号序列输入完毕后再将最终得到的左端点输出，将遇到两个问题：第一，当符号序列很长时，将不能实时编解码；第二，有效位太长的数难以表示。</p>
<p>为了解决这个问题，通常采用两个有限精度的移位寄存器存放码字的最新部分，随着序列中符号的不断输入，不断地将其中的高位移出到信道上，以实现实时编解码。</p>
<h2 id="算术编码的效率"><a href="#算术编码的效率" class="headerlink" title="算术编码的效率"></a>算术编码的效率</h2><p>算术编码的最大优点之一在于它具有自适应性和高编码效率。</p>
<p>算术编码的模式选择直接影响编码效率。其模式有固定模式和自适应模式两种：</p>
<ul>
<li>固定模式是基于概率分布模型进行编码。</li>
<li>自适应模式中，其各符号的初始概率都相同，但会随着符号顺序的出现而改变各符号的概率。</li>
</ul>
<p>在无法进行信源概率模型统计的条件下，非常适于使用自适应模式的算术编码。</p>
<p>在信道符号概率比较均匀的情况下，算术编码的编码效率高于 Huffman 编码。但在实现上，比 Huffman 编码的计算过程复杂。</p>
<p>算术码也是变长码，编码过程中的移位和输出都不均匀，需要有缓冲存储器。</p>
<p>在误差扩散方面，也比分组码更严重。在分组码中，由于误码而破坏分组，过一段时间后常能自动恢复；但在算术码中，却往往会一直延续下去，因为它是从全序列出发来编码的。因而算术码流的传输也要求高质量的信道，或采用检错反馈重发的方式。</p>
]]></content>
      <categories>
        <category>数据压缩技术</category>
      </categories>
      <tags>
        <tag>编码原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 二叉搜索树</title>
    <url>/post/2020/42349ee0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二叉搜索树的特点"><a href="#二叉搜索树的特点" class="headerlink" title="二叉搜索树的特点"></a>二叉搜索树的特点</h2><p>所谓二叉搜索树（Binary Search Tree），又叫二叉排序树，简单而言就是左子树上所有节点的值均小于根节点的值，而右子树上所有节点的值均大于根节点的值，左小右大，并不是乱序，因此又得名二叉排序树。</p>
<p>二叉搜索树要么是空二叉树，要么具有如下特点：</p>
<ul>
<li>二叉搜索树中，如果其根节点有左子树，那么左子树上所有节点的值都小于根节点的值；</li>
<li>二叉搜索树中，如果其根节点有右子树，那么右子树上所有节点的值都大小根节点的值；</li>
<li>二叉搜索树的左右子树也要求都是二叉搜索树；</li>
</ul>
<p>有了二叉搜索树，当你要查找一个值，就不需要遍历整个序列或者说遍历整棵树了，可以根据当前遍历到的节点的值来确定搜索方向，这就好比你要去日本，假设你没有见过世界地图，你不知道该往哪个方向走，只能满地球找一遍才能保证一定能够到达日本；而如果你见过世界地图，你知道日本在中国的东边，你就不会往西走、往南走、往北走。这种思维在搜索中被叫做 “剪枝”，把不必要的分枝剪掉可以提高搜索效率。在二叉搜索树中查找值，每次都会把搜索范围缩小，与二分搜索的思维类似。</p>
<a id="more"></a>
<h3 id="二叉搜索树的节点定义"><a href="#二叉搜索树的节点定义" class="headerlink" title="二叉搜索树的节点定义"></a>二叉搜索树的节点定义</h3><p>二叉搜索树的遍历与二叉树的节点定义一致。</p>
<blockquote>
<p>详见：<a href="/post/2020/1c1a3b62/" title="数据结构与算法 - 二叉树的遍历">数据结构与算法 - 二叉树的遍历</a></p>
</blockquote>
<h2 id="二叉搜索树的遍历节点"><a href="#二叉搜索树的遍历节点" class="headerlink" title="二叉搜索树的遍历节点"></a>二叉搜索树的遍历节点</h2><p>二叉搜索树的遍历与二叉树的遍历方法一致，有三种方法：</p>
<ul>
<li>递归法</li>
<li>栈迭代法</li>
<li>MORRIS 迭代法</li>
</ul>
<blockquote>
<p>详见：<a href="/post/2020/1c1a3b62/" title="数据结构与算法 - 二叉树的遍历">数据结构与算法 - 二叉树的遍历</a></p>
</blockquote>
<p>需要注意的是，由于二叉搜索树的特性，在中序遍历二叉搜索树时，节点值会保持递增。</p>
<h2 id="二叉搜索树的查找节点"><a href="#二叉搜索树的查找节点" class="headerlink" title="二叉搜索树的查找节点"></a>二叉搜索树的查找节点</h2><p>二叉搜索树中查找某关键字时，查找过程类似于次优二叉树，在二叉搜索树不为空树的前提下，首先将被查找值同树的根节点进行比较，会有 3 种不同的结果：</p>
<ul>
<li>如果相等，查找成功；</li>
<li>如果比较结果为根节点的关键字值较大，则说明该关键字可能存在其左子树中；</li>
<li>如果比较结果为根节点的关键字值较小，则说明该关键字可能存在其右子树中；</li>
</ul>
<p>如下图所示的二叉搜索树：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200809195623.png" alt="二叉搜索树"></p>
<p>要想查找到 8，则是先到达根节点，其值为 5，8 比 5 大因此继续往右子树上找，到达 9，8 比 9 小因此往左子树上找，最终找到 8；</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200809201256.gif" alt="二叉搜索树中搜索节点 8"></p>
<p>要想查找 4，则是先到达根节点其值为 5，4 比 5 小因此往左子树上找，到达 1，4 比 1 大因此往右子树上找，到达 3，4 比 3 大因此往右子树上找，而值为 3 的节点的右子树是空的，因此该搜索二叉树中不存在值为 4 的节点。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200809201606.gif" alt="二叉搜索树中搜索节点 4"></p>
<h2 id="二叉搜索树的插入节点"><a href="#二叉搜索树的插入节点" class="headerlink" title="二叉搜索树的插入节点"></a>二叉搜索树的插入节点</h2><p>二叉搜索树本身是动态查找表的一种表示形式，有时会在查找过程中插入或者删除表中元素，当因为查找失败而需要插入数据元素时，该数据元素的插入位置一定位于二叉搜索树的叶子节点，并且一定是查找失败时访问的最后一个节点的左孩子或者右孩子。</p>
<p>例如，在上文的二叉搜索树中做查找 4 的操作，当查找到值 3 所在的叶子节点时，判断出表中没有该值，此时值 4 的插入位置为值 3 的右孩子。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200809202357.gif" alt="二叉搜索树中插入节点 4"></p>
<h2 id="二叉搜索树的删除节点"><a href="#二叉搜索树的删除节点" class="headerlink" title="二叉搜索树的删除节点"></a>二叉搜索树的删除节点</h2><p>在查找过程中，如果在使用二叉排序树表示的动态查找表中删除某个数据元素时，需要在成功删除该节点的同时，依旧使这棵树为二叉排序树。</p>
<p>假设要删除的为节点 p，则对于二叉排序树来说，需要根据节点 p 所在不同的位置作不同的操作，有以下 3 种可能：</p>
<ol>
<li><p>节点 p 为叶子节点，此时只需要删除该节点，并修改其父节点的指针即可；</p>
<p> 以上文的二叉搜索树中做删除节点 4 的操作为例：<br> <img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200809202818.gif" alt="二叉搜索树中删除节点 4"></p>
</li>
<li><p>节点 p 只有左子树或者只有右子树</p>
<ul>
<li>如果 p 是其父节点的左孩子，则直接将 p 节点的左子树或右子树作为其父节点的左子树；</li>
<li><p>如果 p 是其父节点的右孩子，则直接将 p 节点的左子树或右子树作为其父节点的右子树；</p>
<p>以上文的二叉搜索树中做删除节点 1 的操作为例：<br><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200809203119.gif" alt="二叉搜索树中删除节点 1"></p>
</li>
</ul>
</li>
<li><p>节点 p 左右子树都有，此时有两种处理方式：</p>
<ol>
<li>令节点 p 的左子树为其父节点的左子树；节点 p 的右子树为其自身直接前驱节点的右子树；</li>
<li>用节点 p 的直接前驱（或直接后继）来代替节点 p，同时在二叉排序树中对其直接前驱（或直接后继）做删除操作。<br>以上文的二叉搜索树中做删除节点 9 的操作为例，使用直接后继代替了节点 9：<br><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200809203538.gif" alt="二叉搜索树中删除节点 9"></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 二叉树的遍历</title>
    <url>/post/2020/1c1a3b62/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二叉树的节点"><a href="#二叉树的节点" class="headerlink" title="二叉树的节点"></a>二叉树的节点</h2><h3 id="二叉树的节点定义"><a href="#二叉树的节点定义" class="headerlink" title="二叉树的节点定义"></a>二叉树的节点定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T value;            <span class="comment">// 关键字 (键值)</span></span><br><span class="line">        BSTNode *left;      <span class="comment">// 左孩子</span></span><br><span class="line">        BSTNode *right;     <span class="comment">// 右孩子</span></span><br><span class="line"></span><br><span class="line">        BSTNode(T v, BTNode *l = <span class="literal">nullptr</span>, BTNode *r = <span class="literal">nullptr</span>):</span><br><span class="line">            value(v),left(l),right(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的遍历，有三种方法：</p>
<ul>
<li>递归法</li>
<li>栈迭代法</li>
<li>MORRIS 迭代法</li>
</ul>
<p>下面我们分别分析下三种方法：</p>
<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>三种方式中，递归法最好理解，具体实现如下：</p>
<h4 id="前序遍历（递归法）"><a href="#前序遍历（递归法）" class="headerlink" title="前序遍历（递归法）"></a>前序遍历（递归法）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:BTPreOrder(BSTNode&lt;T&gt;&amp; node) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; node-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    BTPreOrder(node-&gt;left);</span><br><span class="line">    BTPreOrder(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历（递归法）"><a href="#中序遍历（递归法）" class="headerlink" title="中序遍历（递归法）"></a>中序遍历（递归法）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:BTPMidOrder(BSTNode&lt;T&gt;&amp; node) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    BTPMidOrder(node-&gt;left);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; node-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    BTPMidOrder(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历（递归法）"><a href="#后序遍历（递归法）" class="headerlink" title="后序遍历（递归法）"></a>后序遍历（递归法）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:BTPostOrder(BSTNode&lt;T&gt;&amp; node) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    BTPostOrder(node-&gt;left);</span><br><span class="line">    BTPostOrder(node-&gt;right);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; node-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈迭代法"><a href="#栈迭代法" class="headerlink" title="栈迭代法"></a>栈迭代法</h3><h4 id="前序遍历（栈迭代法）"><a href="#前序遍历（栈迭代法）" class="headerlink" title="前序遍历（栈迭代法）"></a>前序遍历（栈迭代法）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:BTPreOrder(BSTNode&lt;T&gt;&amp; node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">    BSTNode&lt;T&gt;* node = root;</span><br><span class="line">    <span class="keyword">while</span> (node || !nodeStack.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            nodeStack.push(node);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; node-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node = nodeStack.top();</span><br><span class="line">            nodeStack.pop();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历（栈迭代法）"><a href="#中序遍历（栈迭代法）" class="headerlink" title="中序遍历（栈迭代法）"></a>中序遍历（栈迭代法）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:BTMidOrder(BSTNode&lt;T&gt;&amp; node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">    BSTNode&lt;T&gt;* node = root;</span><br><span class="line">    <span class="keyword">while</span> (node || !nodeStack.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            nodeStack.push(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node = nodeStack.top();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; node-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">            nodeStack.pop();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MORRIS-迭代法"><a href="#MORRIS-迭代法" class="headerlink" title="MORRIS 迭代法"></a>MORRIS 迭代法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRO_ORDER</span></span><br><span class="line">BSTree&lt;T&gt;* BSTree&lt;T&gt;::rightReverse(BSTree&lt;T&gt;* root) &#123;</span><br><span class="line">    BSTree&lt;T&gt;* head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        BSTree&lt;T&gt;* next = root-&gt;right;</span><br><span class="line">        root-&gt;right = head;</span><br><span class="line">        head = root;</span><br><span class="line">        root = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::printEdge (BSTree&lt;T&gt;* root) &#123;</span><br><span class="line">    root = rightReverse(root);</span><br><span class="line">    BSTree&lt;T&gt;* head = root;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        result.push_back(head-&gt;val);</span><br><span class="line">        head = head-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    root = rightReverse(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::BSTOrder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    BSTNode&lt;T&gt;* node = root;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            <span class="comment">/* 如果存在左子树，则需要设置索引 */</span></span><br><span class="line">            BSTNode&lt;T&gt;* index = node-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(index-&gt;right &amp;&amp; index-&gt;right != node)</span><br><span class="line">            &#123;</span><br><span class="line">                index = index-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!index-&gt;right) &#123;</span><br><span class="line">                <span class="comment">/* 首次寻找到索引，设置索引，继续遍历左子树 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRE_ORDER</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;node-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                index-&gt;right = node;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* 非首次寻找到索引，说明左子树遍历完成，根据索引去遍历右子树 */</span></span><br><span class="line">#ifdef MID_ORDER</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;node-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">                <span class="comment">/* 恢复索引 */</span></span><br><span class="line">                index-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRO_ORDER</span></span><br><span class="line">                printEdge(root);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 没有左子树 遍历右子树 */</span></span><br><span class="line">#ifndef PRO_ORDER</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;node-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRO_ORDER</span></span><br><span class="line">        printEdge(root);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 动态规划（前缀和）</title>
    <url>/post/2020/9158b835/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note success"><h2 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h2><ul>
<li>作者：力扣 (LeetCode)</li>
<li>链接：<a href="https://leetcode-cn.com/leetbook/read/dynamic-programming-1-plus/">https://leetcode-cn.com/leetbook/read/dynamic-programming-1-plus/</a></li>
<li>来源：力扣（LeetCode）</li>
<li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
</div>
<a id="more"></a>
<p>前缀和是一种查询数组中任意区间的元素的和的数据结构，这里数组给定之后就不变了。针对这个不变的数组，前缀和用于多次查询区间 <code>[i, j]</code> 上元素的和。</p>
<p>对于动态规划而言，前缀和的意义主要有两点：</p>
<ol>
<li>一维和二维前缀和的推导，分别用到了单串和矩阵中最经典的状态设计以及状态转移；</li>
<li>在一些更复杂的动态规划问题中，状态转移的时候需要依赖区间和，因为状态转移是非常频繁的操作，因此必须高效地求区间和才能使得状态转移的时间复杂度可接受，此时就必须用到前缀和了。</li>
</ol>
<p>除此之外，一些问题需要前缀和与其它数据结构配合来解决，也有两类：</p>
<ol>
<li>先预处理出前缀和数组，这一步是动态规划，然后在前缀和数组上用其它数据结构解决；</li>
<li>还是按照动态规划的方式求前缀和，也需要额外的数据结构维护前缀和，但不是预处理好前缀和数组之后再用数据结构计算，而是每求出一个前缀和，就更新一次数据结构并维护答案。</li>
</ol>
<p>前缀和的推导和计算隐含着动态规划的基本思想，同时它的状态设计是线性动态规划中比较简单的那一类。与线性动态规划一样，前缀和也有一维和二维两种场景。</p>
<p>虽然前缀和本身很简单，但需要用到它解决的问题非常多，与其它数据结构配合的变化也很多，因此需要从线性动态规划中剥离出来单独学习。</p>
<h2 id="前缀和简介"><a href="#前缀和简介" class="headerlink" title="前缀和简介"></a>前缀和简介</h2><p>考虑以下问题：</p>
<p>给定长度 <code>n</code> 的序列 <code>a</code>：$a_{0}, a_{1}, …, a_{n-1}$，给每个前缀求一次和，$S_{0} = 0$, $S_{i}=\sum_{j=0}^{i-1}a_{j}$。这些前缀和维护在一个长度 $n + 1$ 数组 <code>S</code> 里, 称为前缀和数组。</p>
<p>有两类在数组 <code>a</code> 上的求和需求</p>
<ul>
<li>前缀和：求 <code>a[0..i]</code> 的和</li>
<li>区间和：求区间 <code>a[L, R]</code> 的和</li>
</ul>
<p>对于前缀和，<code>S[i + 1]</code> 刚好就是答案，因为这就是前缀和的定义：$S_{i + 1}=\sum_{j=0}^{i}a_{j}$。</p>
<p>对于区间和，解决此问题最直观的方法是枚举 <code>[L, R]</code> 上的所有元素求和：$sum(L, R) = \sum_{idx = L}^{R}nums[idx]$。</p>
<p>这种方法虽然直观，但是不足是查询一次需要 <code>O(N)</code> 时间，并且每来一个新的查询，就要重新枚举元素求和。通过简单的画图推导可以得到答案为 <code>S[R + 1] - S[L]S[R+1]−S[L]</code></p>
<p>如果查询次数很多，当新查询来时，此前的查询计算的中间结果很多是可以直接用的，新的查询不必重新枚举，例如 此前查询过 <code>sum(5, 10)</code>，现在来了新查询 <code>sum(4, 8)</code> 在计算新查询时，<code>5 ~ 8</code> 这一段在计算此前的查询 <code>sum(5, 10)</code> 的时候已经计算过了，新查询的计算过程可以写成 <code>nums[4] + sum(5, 8)</code>，而不用全部枚举。</p>
<p>如果已经有了 前缀和数组，那么通过简单的画图推导可以知道，两个前缀和 <code>S[R+1]</code> 和 <code>S[L]</code> 的差刚好就是 <code>[L, R]</code> 上的区间和。已有前缀和数组之后，这一步操作就是 <code>O(1)</code> 的。</p>
<p>现将前缀和数组预处理出来，然后在每次查询中直接通过前缀和数组来计算而不是通过原数组，这是一种缓存中间结果的思想，如果把这一思想执行彻底，可以将所有可能的问题 <code>sum(i, j)</code> 其中 <code>0 &lt;= i &lt;= j &lt;= n-1</code>，将计算它们所需的所有中间结果先算一次缓存下来。这里提到的是缓存所有所需的中间结果，而不是子问题的中间结果，因为计算 <code>sum(i, j)</code> 需要的中间结果是前 <code>i-1</code> 个数的和 <code>sum(0,i)</code> 和前 <code>j</code> 个数的和 <code>sum(0, j+1)</code>。最终 <code>sum(i, j) = sum(0, j+1) - sum(0, i)</code> 这对于所有的区间查询都是适用的。</p>
<p>以上将中间结果缓存思路与动态规划中缓存子问题的解的思路是一致的。</p>
<p>定义 <code>sums[k]</code> 为 <code>[0..k-1]</code> 的和，其中 <code>sums[0]</code> 表示数组中没有数字被选中，<code>sums[1]</code> 表示之选中第一个数 <code>nums[0]</code>。 预先计算 <code>0 ~ k (0 &lt;= k &lt;= n-1)</code> 的和，这一系列的和都是从 <code>0</code> 开始的，因此称为前缀和。公式如下：</p>
<ol>
<li><code>k = 0</code> : $sum(0,0)=0$</li>
<li><code>1 &lt;= k &lt;= n-i</code> : $sum(0,k) = \sum_{i=0}^{k-1}nums[i]$</li>
</ol>
<p>此后的区间查询都可以利用公式 <code>sum(i, j) = sums(0, j + 1) - sum(0, i)</code></p>
<p>在上一章中，我们把线性动态规划中几种主流问题及其对应的 dp 状态设计做了总结。其中最基础的一种是单串 <code>dp[i]</code>，并且只与子问题 <code>i - 1</code> 有关，即 <code>dp[i] = f(dp[i-1])</code>。前缀和就是这种情况，<code>sums[i]</code> 只与 <code>sums[i-1]</code> 有关。推导前缀和数组的过程是 <code>O(N)</code> 的，如果区间和的查询次数达到了 <code>O(N)</code> 那么计算区间和的时间复杂度是摊销 <code>O(1)</code> 的。</p>
<p>以上就是前缀和的基础介绍了，其中比较关键的有两点</p>
<ol>
<li>预处理前缀和的过程是最简单且最经典的单串动态规划问题。</li>
<li>先将所有位置的前缀和预处理出来，然后再处理区间和的查询，这是一种先缓存中间结果再处理查询的思路，因为这些中间结果在查询时需要反复用到，缓存之后就不用反复计算了，因此花时间预处理这些信息是有效的。</li>
</ol>
<p>前缀和除了求区间和之外，还有一些其它的应用：</p>
<ol>
<li><p>在用 dp 的方式推 <code>sums[i]</code> 的时候，有时求完 <code>sums[i]</code> 需要查询以前算过的结果计算某种指标，需要用其它数据结构将前面的计算结果维护起来，例如哈希表等等，在求每个位置的前缀和的过程中，查询数据结构并更新答案，这是前缀和的一大类问题，变化比较多，力扣上这类题也有很多，在本章最后一节中汇总了一些题目，在下一节也选择了典型题目做讲解。</p>
</li>
<li><p>前缀和的逆运算是差分，对原序列求出其差分序列，然后在对得到的差分序列求其前缀和序列，可以得到原序列，这在处理一些区间修改的问题时很有用，参考后面小节的题目讲解。</p>
</li>
<li><p>前缀和还可以推广到二维上，并用于快速求矩形和，二维前缀和的计算过程是最经典的矩阵上的线性动态规划，参考后面一节的题目和讲解。</p>
</li>
</ol>
<h2 id="求区间和"><a href="#求区间和" class="headerlink" title="求区间和"></a>求区间和</h2><p>利用前缀和求区间和的思想，已经求前缀和的过程在上一节中已经重点介绍，这里主要回顾一下前缀和中的动态规划思想，如下：</p>
<ul>
<li>状态定义：<code>sums[i] := [0..i-1]</code> 的和</li>
<li>状态转移：<code>sums[i] = a[i - 1] + sums[i - 1]</code></li>
<li>初始化：<code>sums[0] = 0</code></li>
</ul>
<p>这是最简单的单串线性动态规划，其思想在上一章重点介绍。求解该动态规划问题后得到数组 <code>sums</code> 。然后区间和问题就变成了两个前缀和的差的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeRum</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sums[R + <span class="number">1</span>] - sums[L];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求区间和相关练习题"><a href="#求区间和相关练习题" class="headerlink" title="求区间和相关练习题"></a>求区间和相关练习题</h3><ul>
<li>实现前缀和问题<ul>
<li>区域和检索 - 数组不可变</li>
<li>二维区域和检索 - 矩阵不可变</li>
</ul>
</li>
</ul>
<h2 id="数据结构维护前缀和"><a href="#数据结构维护前缀和" class="headerlink" title="数据结构维护前缀和"></a>数据结构维护前缀和</h2><p>在上一节中提到，在用 <code>dp</code> 的方式推 <code>sums[i]</code> 的时候，有时求完 <code>sums[i]</code> 需要查询以前算过的结果计算某种指标，需要用其它数据结构将前面的计算结果维护起来，以便高效查询。以下几个问题就是以上思路的直接应用。</p>
<p>将前缀和维护在数据结构中，以便于后续的 多次 查询，最常见的是维护在哈希表中。</p>
<p>力扣上这种题目非常多，更多题目详见本章后续节。下面考虑几个经典问题：</p>
<p>第一问：$a_{0}, a_{1}, …, a_{n-1}$ 上有没有一个区间，其和为 <code>target</code>。<br>计算前缀和数组 <code>sums[i]</code> 。当扫描到 i 时，$a_{0}, a_{1}, …, a_{i-1}$ 的前缀和都已经求过了，在计算的过程中将前缀和维护在数据结构中，以便于后续的多次查询，本题在之后要查询前缀和的值是否存在，因此维护在 <code>unordered_set</code> 里。</p>
<p>求完当前值 <code>a[i]</code> 对应的前缀和 <code>S[i+1]</code>, 在插入到 <code>unordered_set</code> 之前先问：<code>S[i+1] - target</code> 在 <code>unordered_set</code> 中是否出现：</p>
<ul>
<li>如果出现，说明存在以 i 结尾的某个区间，和为 <code>target</code>, 则找到答案。</li>
<li>如果不出现，则没有以 i 结尾的区间，和为 <code>target</code>，继续枚举 <code>i + 1</code>。</li>
</ul>
<p>上面的问题还可以有变种：</p>
<p>第二问：$a_{0}, a_{1}, …, a_{n-1}$ 上有多少个区间，其和为 <code>target</code>。</p>
<p>按照第一问的思路，把 <code>unordered_set</code> 改成 <code>unordered_map</code> 就可以</p>
<blockquote>
<p>参考题目：560. 和为 K 的子数组</p>
</blockquote>
<p>第三问：$a_{0}, a_{1}, …, a_{n-1}$ 上有没有一个区间，其和大于或小于 <code>target</code>。</p>
<p>整体思路与第一问相同，但是维护前缀和的数据结构需要从哈希表变为线段树</p>
<blockquote>
<p>参考题目：327. 区间和的个数</p>
</blockquote>
<p>第四问: 一棵树上有没有某个路径，其和为 <code>target</code>。</p>
<p>这是第一问的树形版本，<code>dfs</code>（前序遍历）时，栈里存的是当前节点到根的链，这条链上的和可以作为前缀和维护在 <code>unordered_map</code> 里。从左子树跳到右子树的时候，左子树的所有节点对应的前缀和要先从 <code>unordered_map</code> 中删掉。</p>
<blockquote>
<p>参考题目： 437. 路径总和 III</p>
</blockquote>
<h3 id="数据结构维护前缀和相关练习题"><a href="#数据结构维护前缀和相关练习题" class="headerlink" title="数据结构维护前缀和相关练习题"></a>数据结构维护前缀和相关练习题</h3><ul>
<li>HashMap 维护 (1)，键是前缀和（状态）的值，值为第一次出现时的索引<ul>
<li>和等于 k 的最长子数组长度</li>
<li>连续数组</li>
<li>每个元音包含偶数次的最长子字符串 —— 前缀状态为 a,e,i,o,u 的个数的奇偶</li>
</ul>
</li>
<li>HashMap 维护 (2)，键是前缀和（前缀状态）的值，值为出现次数<ul>
<li>和为 K 的子数组</li>
<li>统计优美子数组 —— 前缀状态为奇数的个数</li>
</ul>
</li>
<li>HashMap 维护 (3)，键是前缀和模 K 的余数（可以理解为前缀状态，状态为前缀和模 K）<ul>
<li>连续的子数组和 —— 值为第一次出现时的索引</li>
<li>和可被 K 整除的子数组 —— 值为出现次</li>
</ul>
</li>
<li>前缀和（积）与后缀和（积）均需要<ul>
<li>除自身以外数组的乘积</li>
<li>寻找数组的中心索引</li>
<li>找两个和为目标值且不重叠的子数组 —— 前缀和后缀和分别推一次，推的时候保存信息（DP），枚举分割点</li>
</ul>
</li>
<li>二维前缀和<ul>
<li>元素和为目标值的子矩阵数量</li>
<li>矩阵区域和</li>
<li>最大子矩阵 —— 思路类似一维的最大子数组和</li>
<li>矩形区域不超过 K 的最大数值和 —— 在上一题基础上加了一个 K</li>
</ul>
</li>
</ul>
<h2 id="运算推广"><a href="#运算推广" class="headerlink" title="运算推广"></a>运算推广</h2><p>前缀和求的是数组 a 的前缀 [0..i-1] 的和，也就是对这些元素做加法结果，实际上对前缀 [0..i-1]，我们还可以做很多其它运算得到相应结果。<br>如果利用前缀上的某种运算的结果，可以像前缀和一样快速得到区间 [L, R] 上同样运算的结果，那么前缀和就成功推广了。</p>
<p>事实上这种运算是存在的，例如异或运算，对应每个前缀 [0..i-1] ，我们都可以求得一个异或值，称为前缀异或，而对于区间 [L, R]。我们可以用 [0..R] 的前缀异或减去 [0..L-1] 的前缀异或就可以得到区间上的异或值，这个逻辑与前缀和完全相同。这依赖于异或运算的性质。</p>
<p>如果想将某种运算应用到前缀元素上，并且利用前缀的结果快速计算区间结果，需要该运算满足 区间减法：区间 A = [i, j]，区间 B = [i, k] 区间 C = [k+1, j]，那么有了大区间 A 上的结果 a 和其中一个小区间 B 上的结果 b, 要能够算出另一个小区间 C 上的结果 c 。</p>
<p>例如：</p>
<ul>
<li>异或：$a = b \oplus c =&gt; c = b \oplus a$</li>
<li>乘法或模下乘法：$a = b \times c =&gt; c = a / b$</li>
</ul>
<h3 id="运算推广相关练习题"><a href="#运算推广相关练习题" class="headerlink" title="运算推广相关练习题"></a>运算推广相关练习题</h3><ul>
<li>前缀和<br>乘积最大子数组<br>乘积小于 K 的子数组<br>最后 K 个数的乘积 —— 若乘法的前缀积会溢出，可以用对数的前缀和防溢出，但是结果转回整数需要用四舍五入而不是下取整</li>
<li>前缀异或<br>子数组异或查询<br>形成两个异或相等数组的三元组数目 —— 哈希表维护前缀异或结果，类似 「560. 和为 K 的子数组」</li>
</ul>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>前缀和序列 $S_{0}, S_{1}, …, S_{n}$ 的差分序列 $a_{0}, a_{1}, …, a_{n-1}$ 就等于原序列，其中 $a_{i} = S_{i+1} - S_{i}$ 原序列 $a_{0}, a_{1}, …, a_{n-1}$ 的差分序列为 $b_{0}, b_{1}, …, b_{n-1}$，其中 $b_{0} = a_{0} - 0$, $b_{i} = a_{i} - a_{i-1}$ 则对差分序列求前缀和序列，就得到原序列。</p>
<p>差分序列的好处是如果要对原序列的一个区间 <code>[l, r]</code> 上所有值加 <code>val</code>，原序列上要操作 <code>r-l+1</code> 次 <code>(a[l .. r] + val)</code>，在差分序列上只需要操作 <code>2</code> 次 <code>(b[l] + val, b[r+1] - val)</code>。如果这种区间操作需要很多次，最后的查询只有一次的话，就非常适合在差分序列上操作。</p>
<h3 id="差分相关练习题"><a href="#差分相关练习题" class="headerlink" title="差分相关练习题"></a>差分相关练习题</h3><p>区间加法 —— 用差分维护区间加法模板</p>
<h2 id="推荐阅读顺序"><a href="#推荐阅读顺序" class="headerlink" title="推荐阅读顺序"></a>推荐阅读顺序</h2><ol>
<li><a href="/post/2020/aecf6ec6/" title="数据结构与算法 - 动态规划（简介）">数据结构与算法 - 动态规划（简介）</a></li>
<li><a href="/post/2020/610682be/" title="数据结构与算法 - 动态规划（线性动态规划）">数据结构与算法 - 动态规划（线性动态规划）</a></li>
<li><a href="/post/2020/9158b835/" title="数据结构与算法 - 动态规划（前缀和）">数据结构与算法 - 动态规划（前缀和）</a></li>
<li><a href="/post/2020/cb02a3b0/" title="数据结构与算法 - 动态规划（区间动态规划）">数据结构与算法 - 动态规划（区间动态规划）</a></li>
<li><a href="/post/2020/2cea0e37/" title="数据结构与算法 - 动态规划（背包问题）">数据结构与算法 - 动态规划（背包问题）</a></li>
<li><a href="/post/2020/2a7541d6/" title="数据结构与算法 - 动态规划（状态压缩）">数据结构与算法 - 动态规划（状态压缩）</a></li>
<li><a href="/post/2020/8ed94cfd/" title="数据结构与算法 - 动态规划（计数问题）">数据结构与算法 - 动态规划（计数问题）</a></li>
<li><a href="/post/2020/41da3a83/" title="数据结构与算法 - 矩阵快速幂">数据结构与算法 - 矩阵快速幂</a></li>
<li><a href="/post/2020/16341583/" title="数据结构与算法 - 动态规划（数位动态规划）">数据结构与算法 - 动态规划（数位动态规划）</a>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 动态规划（区间动态规划）</title>
    <url>/post/2020/cb02a3b0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note success"><h2 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h2><ul>
<li>作者：力扣 (LeetCode)</li>
<li>链接：<a href="https://leetcode-cn.com/leetbook/read/dynamic-programming-1-plus/">https://leetcode-cn.com/leetbook/read/dynamic-programming-1-plus/</a></li>
<li>来源：力扣（LeetCode）</li>
<li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
</div>
<a id="more"></a>
<p>在输入为长度为 n 的数组时，子问题用区间 <code>[i..j]</code> 表示。</p>
<p>状态的定义和转移都与区间有关，称为区间动态规划</p>
<h2 id="区间动态规划简介"><a href="#区间动态规划简介" class="headerlink" title="区间动态规划简介"></a>区间动态规划简介</h2><p>区间 DP 是状态的定义和转移都与区间有关，其中区间用两个端点表示。</p>
<p>状态定义 dp[i][j] = [i..j] 上原问题的解。i 变大，j 变小都可以得到更小规模的子问题。</p>
<p>对于单串上的问题，我们可以对比一下线性动态规划和区间动态规划。线性动态规划, 一般是定义 dp[i]， 表示考虑到前 i 个元素，原问题的解，i 变小即得到更小规模的子问题，推导状态时候是从前往后，即 i 从小到大推的。区间动态规划，一般是定义 dp[i][j]，表示考虑 [i..j] 范围内的元素，原问题的解增加 i，减小 j 都可以得到更小规模的子问题。推导状态一般是按照区间长度从短到长推的。</p>
<p>区间动态规划的状态设计，状态转移都与线性动态规划有明显区别，但是由于这两种方法都经常用在单串问题上，拿到一个单串的问题时，往往不能快速地判断到底是用线性动态规划还是区间动态规划，这也是区间动态规划的难点之一。</p>
<p>状态转移，推导状态 dp[i][j] 时，有两种常见情况</p>
<h3 id="dp-i-j-仅与常数个更小规模子问题有关"><a href="#dp-i-j-仅与常数个更小规模子问题有关" class="headerlink" title="dp[i][j] 仅与常数个更小规模子问题有关"></a>dp[i][j] 仅与常数个更小规模子问题有关</h3><p>一般是与 dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1] 有关。</p>
<p>dp[i][j] = f(dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1])</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201002230946.png" alt="dp[i][j] 仅与常数个更小规模子问题有关"></p>
<p>代码常见写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> len = <span class="number">1.</span>.n</span><br><span class="line">    <span class="keyword">for</span> i = i..len</span><br><span class="line">        j = i + len - <span class="number">1</span></span><br><span class="line">        dp[i][j] = <span class="built_in">max</span>(dp[i][j], f(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>], dp[i+<span class="number">1</span>][j<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure>
<p>时间复杂度和空间复杂度均为 $O(n^{2})$</p>
<h3 id="dp-i-j-与-O-n-个更小规模子问题有关"><a href="#dp-i-j-与-O-n-个更小规模子问题有关" class="headerlink" title="dp[i][j] 与 O(n) 个更小规模子问题有关"></a>dp[i][j] 与 O(n) 个更小规模子问题有关</h3><p>一般是枚举 [i,j] 的分割点，将区间分为 [i,k] 和 [k+1,j]，对每个 k 分别求解（下面公式的 f），再汇总（下面公式的 g）。</p>
<pre><code>dp[i][j] = g(f(dp[i][k], dp[k + 1][j])) 其中 k = i .. j-1。
</code></pre><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201002231126.png" alt="dp[i][j] 与 O(n) 个更小规模子问题有关"></p>
<p>代码常见写法, 以下代码以 f 为 max 为例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> len = <span class="number">1.</span>.n</span><br><span class="line">    <span class="keyword">for</span> i = i..len</span><br><span class="line">        j = i + len - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k = i..j</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], f(dp[i][k], dp[k][j]))</span><br></pre></td></tr></table></figure>
<p>时间复杂度可以达到 $O(n^3)$，空间复杂度还是 $O(n^2)$</p>
<h2 id="区间动态规划经典问题"><a href="#区间动态规划经典问题" class="headerlink" title="区间动态规划经典问题"></a>区间动态规划经典问题</h2><h3 id="大规模问题与常数个小规模问题有关"><a href="#大规模问题与常数个小规模问题有关" class="headerlink" title="大规模问题与常数个小规模问题有关"></a>大规模问题与常数个小规模问题有关</h3><p>最常见的形式如下：</p>
<p>推导 dp[i][j] 时，需要用到 dp[i][j-1], dp[i+1][j], dp[i+1][j-1] 三个子问题</p>
<ul>
<li>最长回文子序列</li>
</ul>
<blockquote>
<p>考虑一个字符串 s 的所有子序列, 这些子序列中最长的回文子序列长度是多少</p>
</blockquote>
<p>这个问题如果用线性动态规划的经典思路，状态如下：</p>
<pre><code>dp[i] := 考虑 [0..i] , 原问题的答案
</code></pre><p>但是此后我们就遇到了困难，会发现这个状态有些难以转移</p>
<p>而如果考虑区间动态规划，状态如下：</p>
<pre><code>dp[i][j] := 区间 [i..j] 上, 原问题的答案
</code></pre><p>转移的时候，考虑 <code>dp[i][j-1]</code>, <code>dp[i+1][j]</code>, <code>dp[i+1][j-1]</code> 这三个子问题，这是考虑把边界去掉的模式，回文的特点恰好时候这种模式，</p>
<p>根据两个边界的元素关系可以得到转移方程如下：</p>
<pre><code>dp[i][j] = dp[i + 1][j - 1] + 2;                if (s[i] == s[j])
dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);     if (s[i] != s[j])
</code></pre><p>回文是用区间动态规划解决的常见问题，有很多变种，下一节中列出的练习题有很多类似的。</p>
<h3 id="大规模问题与-O-n-个小规模问题有关"><a href="#大规模问题与-O-n-个小规模问题有关" class="headerlink" title="大规模问题与 O(n) 个小规模问题有关"></a>大规模问题与 <code>O(n)</code> 个小规模问题有关</h3><p>推导 <code>dp[i][j]</code> 时，需要 <code>[i..j]</code> 的所有子区间信息，其中子区间的其中一个端点与原区间重合，共 <code>O(n)</code> 个子区间</p>
<p>最常见的形式</p>
<pre><code>dp[i][j] = g(f(dp[i][k], dp[k][j])) 其中 k = i+1 .. j-1。
</code></pre><p>其中 <code>g</code> 常见的有 <code>max</code>/<code>min</code>，例如 <code>664</code> 就是 <code>min</code></p>
<p>下面就以 <code>664</code> 题讲解这种模式的思考方式</p>
<p>==【奇怪的打印机】==</p>
<blockquote>
<p>有台奇怪的打印机有以下两个特殊要求：<br>打印机每次只能打印同一个字符序列。<br>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。<br>给定一个只包含小写英文字母的字符串 s，你的任务是计算这个打印机打印它需要的最少次数。</p>
</blockquote>
<p>首先区间动态规划的状态定义与前面一样，还是经典的定义方式，状态定义模式化这也是区间动态规划的一个特点。</p>
<pre><code>dp[i][j] := 打印出 [i..j] 上的字符需要的最少次数
</code></pre><p>在转移时，枚举中间的切分位置 <code>k</code>，考虑 <code>i</code> 边界以及中间枚举的切分位置 <code>k</code> 转移时的情况</p>
<p><code>i</code> 要自己涂一次，则 <code>dp[i][j] = 1 + dp[i + 1][j]</code></p>
<p>其中第一项 <code>1</code> 表示 <code>i</code> 位置单独花费一次次数 <code>i</code> 与中间的某个切分位置 <code>k</code> 一起打印 (条件是 <code>s[i] = s[k]</code>)，则 <code>dp[i][j] = dp[i+1][k] + dp[k+1][j]</code></p>
<p>其中第一项 <code>dp[i+1][k]</code> 表示 <code>i</code> 位置跟着 <code>k</code> 一起转移了，不在单独考虑 <code>i</code> 花费的次数了</p>
<p>综合以上分析可以写出状态转移方程如下：</p>
<pre><code>dp[i][j] = dp[i + 1][j] + 1;
dp[i][j] = min(dp[i][j], dp[i + 1][k] + dp[k + 1][j]); 其中 i &lt; k &lt;= j 且 s[i] == s[k]
</code></pre><h3 id="区间动态规划回文相关问题"><a href="#区间动态规划回文相关问题" class="headerlink" title="区间动态规划回文相关问题"></a>区间动态规划回文相关问题</h3><ul>
<li>最长回文子串</li>
<li>回文子串</li>
<li>最长回文子序列</li>
<li>段式回文</li>
<li>统计不同回文子字符串</li>
<li>让字符串成为回文串的最少插入次数 —— 最长回文子序列</li>
</ul>
<h3 id="区间动态规划其它问题"><a href="#区间动态规划其它问题" class="headerlink" title="区间动态规划其它问题"></a>区间动态规划其它问题</h3><ul>
<li>戳气球</li>
<li>移除盒子 —— 戳气球升级版，[i][j] 基础上加了一维 k 状态，k 是 j 右侧与 j 相同的元素个数, 记忆化</li>
<li>多边形三角剖分的最低得分</li>
<li>奇怪的打印机</li>
<li>合并石头的最低成本</li>
<li>预测赢家</li>
<li>编码最短长度的字符串</li>
</ul>
<h2 id="区间动态规总结"><a href="#区间动态规总结" class="headerlink" title="区间动态规总结"></a>区间动态规总结</h2><p>区间动态规划一般用在单串问题上，以区间 [i, j] 为单位思考状态的设计和转移。它与线性动态规划在状态设计和状态转移上都有明显的不同，但由于这两个方法都经常用在单串问题上，导致我们拿到一个单串的问题时，经常不能快速反映出应该用哪种方法。这是区间动态规划的难点之一，但是这个难点也是好解决的，就是做一定数量的练习题，因为区间动态规划的题目比线性动态规划少很多，并且区间动态规划的状态设计和转移都比较朴素，变化也比线性动态规划少很多，所以通过不多的题目数量就可以把区间动态规划常见的方法和变化看个大概了。</p>
<h2 id="推荐阅读顺序"><a href="#推荐阅读顺序" class="headerlink" title="推荐阅读顺序"></a>推荐阅读顺序</h2><ol>
<li><a href="/post/2020/aecf6ec6/" title="数据结构与算法 - 动态规划（简介）">数据结构与算法 - 动态规划（简介）</a></li>
<li><a href="/post/2020/610682be/" title="数据结构与算法 - 动态规划（线性动态规划）">数据结构与算法 - 动态规划（线性动态规划）</a></li>
<li><a href="/post/2020/9158b835/" title="数据结构与算法 - 动态规划（前缀和）">数据结构与算法 - 动态规划（前缀和）</a></li>
<li><a href="/post/2020/cb02a3b0/" title="数据结构与算法 - 动态规划（区间动态规划）">数据结构与算法 - 动态规划（区间动态规划）</a></li>
<li><a href="/post/2020/2cea0e37/" title="数据结构与算法 - 动态规划（背包问题）">数据结构与算法 - 动态规划（背包问题）</a></li>
<li><a href="/post/2020/2a7541d6/" title="数据结构与算法 - 动态规划（状态压缩）">数据结构与算法 - 动态规划（状态压缩）</a></li>
<li><a href="/post/2020/8ed94cfd/" title="数据结构与算法 - 动态规划（计数问题）">数据结构与算法 - 动态规划（计数问题）</a></li>
<li><a href="/post/2020/41da3a83/" title="数据结构与算法 - 矩阵快速幂">数据结构与算法 - 矩阵快速幂</a></li>
<li><a href="/post/2020/16341583/" title="数据结构与算法 - 动态规划（数位动态规划）">数据结构与算法 - 动态规划（数位动态规划）</a>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 动态规划（数位动态规划）</title>
    <url>/post/2020/16341583/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note success"><h2 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h2><ul>
<li>作者：力扣 (LeetCode)</li>
<li>链接：<a href="https://leetcode-cn.com/leetbook/read/dynamic-programming-2-plus/">https://leetcode-cn.com/leetbook/read/dynamic-programming-2-plus/</a></li>
<li>来源：力扣（LeetCode）</li>
<li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
</div>
<a id="more"></a>
<p>数位 DP 在基础的动态规划问题当中算是比较难的一类，因为数位 DP 的状态的物理意义不太好理解。其它的动态规划，比如区间 DP 状态的物理意义就是区间，状态压缩 DP 中状态的物理意义就是集合，这都比较好理解。</p>
<p>但是数位 DP 比其它 DP 好的一面是数位 DP 的思维相对比较固定。 一个是解决的问题模式比较固定，一个是状态设计也比较固定，因此可以通过一些常见问题把数位 DP 的套路了解个大概。</p>
<p>力扣上有几道数位 DP 的题目，通过这些题目我们可以大致了解数位 DP 的思考过程和做法。</p>
<h2 id="数位动态规划简介"><a href="#数位动态规划简介" class="headerlink" title="数位动态规划简介"></a>数位动态规划简介</h2><p>数位 DP 主要解决的问题: 在一段区间 [L, R] 上：</p>
<p>满足某些条件的数字个数<br>将 $x \in [L, R]$ 代到一个函数 $f(x)$ 中，一个数字 $x$ 的 $f(x)$ 值为一次贡献的量，求总的贡献</p>
<p>时间复杂度一般是 $log_{10}L$</p>
<p>以一个最简单的例子说明数位 DP 的思考过程：[L, R] 上的整数会共有多少个</p>
<p>首先对于区间 [L, R] 上的问题，首先变成解决前缀 [0, N] 的问题，[0, N] 上的问题解决后，求一次 [0, R] 和 [0, L- 1] 就可以得到原问题的解了。</p>
<p>例如 N = 2357</p>
<p>首先位数的范围是 3 ~ 0，第 3 位为 2，第 2 位为 3，第 1 位为 5，第 0 位为 7。在枚举某个位可能的数字的时候，必须要高位的数字已经确定了，才能只当当前位的枚举范围。</p>
<p>比如当前为是第 2 位，如果它的高位第 3 位是 0、1，则当前第 2 位的选择范围是 0 ~ 9 ；而当第 3 位为 2，第 2 为的选择范围就变成 0 ~ 3 。</p>
<p>分类：高位的数字可以分成两类，如果没有顶到上界（例如第 3 位为 2），则枚举范围就是 0 ~ 9，即不限制，而如果高位顶到了上界（例如第 3 位为 2）当前位的范围就会被限制。</p>
<p>如果当前为枚举的数字因高位顶到了上界而被限制，则当前位的数字枚举也要分类：顶到上界，未顶到上界，这两种对低位的枚举影响不一样</p>
<ul>
<li>当高位未顶到上界（可能是未被限制，也可能是被限制了但是选的数未顶到上界），则低位的数字无限制，可选 0 ~ 9</li>
<li>当高位顶到了上界，则低位的数字 被限制 且要分类：顶到上界和未顶到上界</li>
</ul>
<p>可以看出各个位上未被限制的情况被反复的复用，这是用数位 DP 可以提高效率的地方。而顶到上界的情况，只出现一次</p>
<h3 id="DP-状态设计"><a href="#DP-状态设计" class="headerlink" title="DP 状态设计"></a>DP 状态设计</h3><p>dp[pos][lim] ，pos 为当前的数位 N-1 ~ 0 ，lim 表示是否顶到上界，对于 -1 的地方，pos 到 -1 的时候可以 return 1，使得个位的枚举有效。</p>
<h3 id="DP-状态转移"><a href="#DP-状态转移" class="headerlink" title="DP 状态转移"></a>DP 状态转移</h3><pre><code>dp[pos][lim]:
dp[pos][0] = 10 * dp[pos - 1][0]
dp[pos][1] = digits[i] * dp[pos - 1][0] + dp[pos - 1][1]
</code></pre><p>因为顶到上界的时候只需要计算一次，所有 lim 可以不放到 dp 数组里记忆化：将 dp 数组改为 1 维，但是在 dfs 的时候带着 lim 这个参数。</p>
<p>有的时候一串前导 0 需要特别处理。此时可以在 dfs 加一个状态 zero，见后面的例题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>一般数位 DP 的状态必有的维度有 pos、lim</li>
<li>前导零会对结果产生影响时，加一维 zero</li>
<li>可能需要带上前缀的某种状态 state，此状态可能影响当前位的枚举，也可能影响当前位枚举的值对答案的贡献</li>
</ul>
<h2 id="数位动态规划经典问题"><a href="#数位动态规划经典问题" class="headerlink" title="数位动态规划经典问题"></a>数位动态规划经典问题</h2><p>==902. 最大为 N 的数字组合 ==</p>
<p>这道题也是问 [1, N] 上的数字有多少个，只是每一位只能用给定的数字。因此在上面推导过程的基础上，在转移的时候，限制枚举的数字种类即可。</p>
<p>以下为不带前导零状态的数位 dp 模板。</p>
<pre><code>num_set: 可选数字集合
digits[i]: 第 i 位的上界, 在第 i 位若被限制, 则需要取 digits[i]
getdp(...) : dfs
</code></pre><p>以下为用记忆化搜索进行状态转移的过程，是数位 DP 的代码模板。</p>
<p>其中 pos 表示当前的数位，lim 表示当前是否顶到了上界</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdp</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits, <span class="keyword">const</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&amp; num_set, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][lim] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[pos][lim];</span><br><span class="line">    dp[pos][lim] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> up = lim ? digits[pos] : <span class="number">9</span>; <span class="comment">// 当前要枚举到的上界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: num_set) <span class="comment">// 枚举当前位所有可能数字</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt; up)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        dp[pos][lim] += getdp(pos - <span class="number">1</span>, lim &amp;&amp; i == up, digits, num_set, dp); <span class="comment">// 本位被限制且选顶到上界的数字, 下一位才被限制</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[pos][lim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前导零的分析"><a href="#前导零的分析" class="headerlink" title="前导零的分析"></a>前导零的分析</h3><p>增加 zero 状态, 表示高位是否是前导零。</p>
<ul>
<li>如果高位选了前导零，则当前位无限制，且还可以选前导零。</li>
<li>如果高位没有选前导零且未顶到上界，则当前位在可选数字集合的范围内无限制。</li>
<li>如果高位顶到了上界，则当前位的选择被限制。</li>
</ul>
<h3 id="数位动态规划练习题"><a href="#数位动态规划练习题" class="headerlink" title="数位动态规划练习题"></a>数位动态规划练习题</h3><ol>
<li>满足某些条件的数字个数<ul>
<li>最大为 N 的数字组合</li>
<li>中心对称数 III</li>
<li>计算各个位数不同的数字个数</li>
<li>不含连续 1 的非负整数</li>
<li>至少有 1 位重复的数字</li>
<li>易混淆数 II</li>
</ul>
</li>
<li>将 $x \in [L, R]$ 代到一个函数 $f(x)$ 中, 一个数字 $x$ 的 $f(x)$ 值为一次贡献的量, 求总的贡献<ul>
<li>数字 1 的个数</li>
<li>范围内的数字计数</li>
<li>2 出现的次数</li>
</ul>
</li>
</ol>
<h2 id="推荐阅读顺序"><a href="#推荐阅读顺序" class="headerlink" title="推荐阅读顺序"></a>推荐阅读顺序</h2><ol>
<li><a href="/post/2020/aecf6ec6/" title="数据结构与算法 - 动态规划（简介）">数据结构与算法 - 动态规划（简介）</a></li>
<li><a href="/post/2020/610682be/" title="数据结构与算法 - 动态规划（线性动态规划）">数据结构与算法 - 动态规划（线性动态规划）</a></li>
<li><a href="/post/2020/9158b835/" title="数据结构与算法 - 动态规划（前缀和）">数据结构与算法 - 动态规划（前缀和）</a></li>
<li><a href="/post/2020/cb02a3b0/" title="数据结构与算法 - 动态规划（区间动态规划）">数据结构与算法 - 动态规划（区间动态规划）</a></li>
<li><a href="/post/2020/2cea0e37/" title="数据结构与算法 - 动态规划（背包问题）">数据结构与算法 - 动态规划（背包问题）</a></li>
<li><a href="/post/2020/2a7541d6/" title="数据结构与算法 - 动态规划（状态压缩）">数据结构与算法 - 动态规划（状态压缩）</a></li>
<li><a href="/post/2020/8ed94cfd/" title="数据结构与算法 - 动态规划（计数问题）">数据结构与算法 - 动态规划（计数问题）</a></li>
<li><a href="/post/2020/41da3a83/" title="数据结构与算法 - 矩阵快速幂">数据结构与算法 - 矩阵快速幂</a></li>
<li><a href="/post/2020/16341583/" title="数据结构与算法 - 动态规划（数位动态规划）">数据结构与算法 - 动态规划（数位动态规划）</a>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 动态规划（状态压缩）</title>
    <url>/post/2020/2a7541d6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note success"><h2 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h2><ul>
<li>作者：力扣 (LeetCode)</li>
<li>链接：<a href="https://leetcode-cn.com/leetbook/read/dynamic-programming-2-plus/">https://leetcode-cn.com/leetbook/read/dynamic-programming-2-plus/</a></li>
<li>来源：力扣（LeetCode）</li>
<li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
</div>
<a id="more"></a>
<h2 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h2><p>状态压缩动态规划，是利用计算机 二进制 的性质来描述状态的一种动态规划方式。</p>
<p>例如：有一个大小为 n*n 的格子，我们可以在任意处放置物品，现在来描述一下某一行的某种状态：</p>
<p>设 n = 9；</p>
<p>有 9 位二进制数 101011011，每一位表示该格子是否被放置物品，1 表示放置了，0 表示没放置，这样一种状态就被我们表示出来了：</p>
<pre><code>列 数   1   2   3   4   5   6   7   8   9
二进制  1   0   1   0   1   1   0   1   1
是否用  √   ×   √   ×   √   √   ×   √   √
</code></pre><p>对于一行的状态，一共有 <code>1 &lt;&lt; n</code> 种。</p>
<p>现在我们得到了表示状态的方法，这里状态为集合中的各个元素选择情况，用二进制枚举了全部的状态，共 $2^{n}$。</p>
<p>状压其实是一种很暴力的算法，因为他需要遍历每个状态，所以将会出现 $2^{n}$ 个状态数量，n 一般需要小于等于 20 才可以考虑。</p>
<p>不过有时可以先排除不合法的方案，使一行的总方案数大大减少从而使得用二进制枚举所有状态成为可能。</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>状态压缩动态规划中，状态是集合，对状态进行操作或访问也就是要对集合进行操作和访问。</p>
<p>为了更好的理解状压 dp，首先介绍位运算相关的知识。</p>
<p>与位运算相关的运算符共有 6 种，&amp;，|，^，~，&gt;&gt;，&lt;&lt;</p>
<ol>
<li>&amp; 符号，x &amp; y ，会将两个十进制数在二进制下进行与运算，然后返回其十进制下的值。</li>
<li>| 符号，x | y ，会将两个十进制数在二进制下进行或运算，然后返回其十进制下的值。</li>
<li>^ 符号，x ^ y ，会将两个十进制数在二进制下进行异或运算，然后返回其十进制下的值。</li>
<li>&lt;&lt; 符号，x &lt;&lt; y 左移操作，将 x 在二进制下的每一位向左移动 y 位，最右边用 0 填充。</li>
<li>>&gt; 符号，x &gt;&gt; y 右移操作，将 x 在二进制下的每一位向右移动 y 位，最左边用 0 填充。</li>
<li>~ 符号，~x ，按位取反操作，将 x 在二进制下的每一位取反，返回其十进制下的值</li>
</ol>
<p>用位运算可以表示集合的常见操作，如下，其中 A,B 表示两个集合，c 表示某个元素。</p>
<ul>
<li>c 插入 A ：A |= (1 &lt;&lt; c)</li>
<li>A 删除 c ：A &amp;= ~(1 &lt;&lt; c)</li>
<li>A 置空 ：A = 0</li>
<li>并集 ：A | B</li>
<li>交集 ：A &amp; B</li>
<li>全集 ：(1 &lt;&lt; n) - 1</li>
<li>补集 ：((1 &lt;&lt; n) - 1) ^ A</li>
<li>子集 ：(A &amp; B) == B</li>
<li>判断是否是 2 的幂 ：A &amp; (A - 1) == 0</li>
<li>最低位的 1 变为 0 ：n &amp;= (n - 1)</li>
<li>最低位的 1：A &amp; (-A)，最低位的 1 一般记为 lowbit(A)，表示 A 的二进制表达式中最低位的 1 所对应的值。</li>
<li><p>最高位的 1：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p = lowbit(A)</span><br><span class="line"><span class="keyword">while</span>(p != A)</span><br><span class="line">&#123;</span><br><span class="line">    A -= p;</span><br><span class="line">    p = lowbit(A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举 A 的子集：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(subset = (A - <span class="number">1</span>) &amp; A; subset != A; subset = (subset - <span class="number">1</span>) &amp; A)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举全集的子集：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h2><p>旅行商问题是状态压缩动态规划的经典问题，它的问题描述如下：</p>
<blockquote>
<p>一个商人想要旅行各地并进行贸易。各地之间有若干条单向的通道相连，商人从一个地方出发，想要用最短的路程把所有地区环游一遍，请问环游需要的最短路程是多少？</p>
</blockquote>
<p>如果在极端情况下也就是所有点之间都有连线的时候，对于每一个点来说，它可以选择的下一个位置一共有 <code>n-1</code> 种。那么一共可以选择的路线总共有 <code>n!</code> 种。</p>
<h2 id="状态压缩的做法"><a href="#状态压缩的做法" class="headerlink" title="状态压缩的做法"></a>状态压缩的做法</h2><p>要用动态规划的思路来解决这个问题，就要考虑状态定义和状态转移。</p>
<p>利用二进制可以用一个整数来表示一个集合的状态，我们很容易会把这个状态当成是动态规划当中的状态，但在这里是不全面的。单纯集合之间的转移没有限制条件，比如有 5 个球，已经拿了 1 号球和 2 号球，后面只要是剩下的球都可以拿，但是对于旅行商问题，有 5 个地方，我们已经去过了 1 和 2 两个地方，我们当前在位置 1，我们只能选与 1 相邻的地方来更新状态，也就是说状态转移是有限制的。</p>
<p>为了保证地点之间的移动顺序正确，我们还需要加上一维，也就是当前所处的位置。所以真正的状态是我们之前遍历过的位置的状态，加上当前所处的地点，这两者的结合。</p>
<pre><code>状态定义
dp[s][i] := 已经选过 s 这些点，最后一个点是 i

状态转移
dp[s][i] = dp[s | (1 &lt;&lt; j)][j] + w[i][j]; 从 i 点转移到 j 点，这里 j 可能已经在 s 中了
</code></pre><p>状态压缩动态规划的变化不多，以上 TSP 问题的分析过程和做法基本就是状态压缩动态规划的分析过程和做法了。</p>
<p>状态压缩动态规划主要的难点是想到用状态压缩动态规划做，下一节有 12 道练习题，通过这些题的练习，我们可以大致了解状态压缩动态规划的常见问题和问法。</p>
<h2 id="状态压缩动态规划练习题"><a href="#状态压缩动态规划练习题" class="headerlink" title="状态压缩动态规划练习题"></a>状态压缩动态规划练习题</h2><p>以下 12 道题是力扣上的状态压缩的习题，涵盖了状态压缩动态规划的常见套路。</p>
<ul>
<li>安卓系统手势解锁</li>
<li>我能赢吗</li>
<li>不同路径 III —— 状态压缩 DP + 记忆化</li>
<li>划分为 k 个相等的子集 —— 状态压缩 DP + 记忆化</li>
<li>访问所有节点的最短路径 —— Floyd + 状态压缩 DP 求最短哈密顿路</li>
<li>最短超级串 —— 状态压缩 DP + DP 过程记录路径</li>
<li>优美的排列</li>
<li>骑士拨号器</li>
<li>参加考试的最大学生数</li>
<li>大礼包</li>
<li>贴纸拼词</li>
<li>按位与为零的三元组</li>
</ul>
<h2 id="推荐阅读顺序"><a href="#推荐阅读顺序" class="headerlink" title="推荐阅读顺序"></a>推荐阅读顺序</h2><ol>
<li><a href="/post/2020/aecf6ec6/" title="数据结构与算法 - 动态规划（简介）">数据结构与算法 - 动态规划（简介）</a></li>
<li><a href="/post/2020/610682be/" title="数据结构与算法 - 动态规划（线性动态规划）">数据结构与算法 - 动态规划（线性动态规划）</a></li>
<li><a href="/post/2020/9158b835/" title="数据结构与算法 - 动态规划（前缀和）">数据结构与算法 - 动态规划（前缀和）</a></li>
<li><a href="/post/2020/cb02a3b0/" title="数据结构与算法 - 动态规划（区间动态规划）">数据结构与算法 - 动态规划（区间动态规划）</a></li>
<li><a href="/post/2020/2cea0e37/" title="数据结构与算法 - 动态规划（背包问题）">数据结构与算法 - 动态规划（背包问题）</a></li>
<li><a href="/post/2020/2a7541d6/" title="数据结构与算法 - 动态规划（状态压缩）">数据结构与算法 - 动态规划（状态压缩）</a></li>
<li><a href="/post/2020/8ed94cfd/" title="数据结构与算法 - 动态规划（计数问题）">数据结构与算法 - 动态规划（计数问题）</a></li>
<li><a href="/post/2020/41da3a83/" title="数据结构与算法 - 矩阵快速幂">数据结构与算法 - 矩阵快速幂</a></li>
<li><a href="/post/2020/16341583/" title="数据结构与算法 - 动态规划（数位动态规划）">数据结构与算法 - 动态规划（数位动态规划）</a>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 动态规划（线性动态规划）</title>
    <url>/post/2020/610682be/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note success"><h2 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h2><ul>
<li>作者：力扣 (LeetCode)</li>
<li>链接：<a href="https://leetcode-cn.com/leetbook/read/dynamic-programming-1-plus/">https://leetcode-cn.com/leetbook/read/dynamic-programming-1-plus/</a></li>
<li>来源：力扣（LeetCode）</li>
<li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
</div>
<a id="more"></a>
<p>这一章将会介绍线性动态规划的相关概念和经典问题，并给出一些练习题供大家演练。</p>
<p>用动态规划解决问题的过程有以下几个关键点：状态定义，状态的转移，初始化和边界条件。</p>
<p>状态定义 就是定义子问题，如何表示目标规模的问题和更小规模的问题。例如常见的方法：定义状态 <code>dp[n]</code>，表示规模为 <code>n</code> 的问题的解，<code>dp[n - 1]</code> 就表示规模为 <code>n - 1</code> 的子问题的解。在实战中 <code>dp[n]</code> 的具体含义需要首先整理清楚再往下做。</p>
<p>状态转移 就是子问题之间的关系，例如定义好状态 <code>dp[n]</code>，此时子问题是 <code>dp[n-1]</code> 等，并且大规模的问题的解依赖小规模问题的解，此时需要知道怎样通过小规模问题的解推出大规模问题的解。这一步就是列状态转移方程的过程。一般的状态转移方程可以写成如下形式</p>
<pre><code>dp[n] = f(dp[i]) 其中 i &lt; n
</code></pre><p>按照状态定义和状态转移的常见形式，可以对动态规划进行分类，可以参考上一章的内容。</p>
<p>其中线性动态规划的主要特点是状态的推导是按照问题规模 <code>i</code> 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。</p>
<p>这里问题规模为 <code>i</code> 的含义是考虑前 <code>i</code> 个元素 <code>[0..i]</code> 时问题的解。</p>
<h2 id="线性动态规划简介"><a href="#线性动态规划简介" class="headerlink" title="线性动态规划简介"></a>线性动态规划简介</h2><p>线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。</p>
<p>这里问题规模为 <code>i</code> 的含义是考虑前 <code>i</code> 个元素 <code>[0..i]</code> 时问题的解。</p>
<p>状态定义：</p>
<pre><code>dp[n] := [0..n] 上问题的解
</code></pre><p>状态转移：</p>
<pre><code>dp[n] = f(dp[n-1], ..., dp[0])
</code></pre><p>从以上状态定义和状态转移可以看出，大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量 <code>i</code> 表示，<code>i</code> 的大小表示了问题规模的大小，因此从小到大推 <code>i</code> 直至推到 <code>n</code>，就得到了大规模问题的解，这就是线性动态规划的过程。</p>
<p>按照问题的输入格式，线性动态规划解决的问题主要是单串，双串，矩阵上的问题，因为在单串，双串，矩阵上问题规模可以完全用位置表示，并且位置的大小就是问题规模的大小。因此从前往后推位置就相当于从小到大推问题规模。</p>
<p>线性动态规划是动态规划中最基本的一类。问题的形式、dp 状态和方程的设计、以及与其它算法的结合上面变化很多。按照 dp 方程中各个维度的含义，可以大致总结出几个主流的问题类型，见后面的小节。除此之外还有很多没有总结进来的变种问题，小众问题，和困难问题，这些问题的解法更多地需要结合自己的做题经验去积累，除此之外，常见的，主流的问题和解法都可以总结成下面的四个小类别。</p>
<h2 id="单串"><a href="#单串" class="headerlink" title="单串"></a>单串</h2><p>单串 dp[i] 线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 <code>dp[i] := 考虑 [0..i]</code> 上，原问题的解，其中 <code>i</code> 位置的处理，根据不同的问题，主要有两种方式：</p>
<ul>
<li>第一种是 <code>i</code> 位置必须取，此时状态可以进一步描述为 <code>dp[i] := 考虑 [0..i]</code> 上，且取 <code>i</code>，原问题的解；</li>
<li>第二种是 <code>i</code> 位置可以取可以不取</li>
</ul>
<p>大部分的问题，对 <code>i</code> 位置的处理是第一种方式，例如力扣：</p>
<ul>
<li>70 爬楼梯问题</li>
<li>801 使序列递增的最小交换次数</li>
<li>790 多米诺和托米诺平铺</li>
<li>746 使用最小花费爬楼梯</li>
</ul>
<p>线性动态规划中单串 <code>dp[i]</code> 的问题，状态的推导方向以及推导公式如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201002211131.png" alt="单串状态的推导方向以及推导公式"></p>
<h3 id="依赖比-i-小的-O-1-个子问题"><a href="#依赖比-i-小的-O-1-个子问题" class="headerlink" title="依赖比 i 小的 O(1) 个子问题"></a>依赖比 i 小的 O(1) 个子问题</h3><p><code>dp[n]</code> 只与常数个小规模子问题有关，状态的推导过程 <code>dp[i] = f(dp[i - 1], dp[i - 2], ...)</code>。时间复杂度 <code>O(n)</code>，空间复杂度 <code>O(n)</code> 可以优化为 <code>O(1)</code>，例如上面提到的 70, 801, 790, 746 都属于这类。</p>
<p>如图所示，虽然绿色部分的 <code>dp[i-1], dp[i-2], ..., dp[0]</code> 均已经计算过，但计算橙色的当前状态时，仅用到 <code>dp[i-1]</code>，这属于比 <code>i</code> 小的 <code>O(1)</code> 个子问题。</p>
<p>例如，当 <code>f(dp[i-1], ...) = dp[i-1] + nums[i]</code> 时，当前状态 <code>dp[i]</code> 仅与 <code>dp[i-1]</code> 有关。这个例子是一种数据结构前缀和的状态计算方式，关于前缀和的详细内容请参考下一章。</p>
<h3 id="依赖比-i-小的-O-n-个子问题"><a href="#依赖比-i-小的-O-n-个子问题" class="headerlink" title="依赖比 i 小的 O(n) 个子问题"></a>依赖比 i 小的 O(n) 个子问题</h3><p><code>dp[n]</code> 与此前的更小规模的所有子问题 <code>dp[n - 1], dp[n - 2], ..., dp[1]</code> 都可能有关系。</p>
<p>状态推导过程如下：</p>
<pre><code>dp[i] = f(dp[i - 1], dp[i - 2], ..., dp[0])
</code></pre><p>依然如图所示，计算橙色的当前状态 <code>dp[i]</code> 时，绿色的此前计算过的状态 <code>dp[i-1], ..., dp[0]</code> 均有可能用到，在计算 <code>dp[i]</code> 时需要将它们遍历一遍完成计算。</p>
<p>其中 <code>f</code> 常见的有 <code>max</code>/<code>min</code>，可能还会对 <code>i-1,i-2,...,0</code> 有一些筛选条件，但推导 <code>dp[n]</code> 时依然是 <code>O(n)</code> 级的子问题数量。</p>
<p>例如：</p>
<ul>
<li>139 单词拆分</li>
<li>818 赛车</li>
</ul>
<p>以 <code>min</code> 函数为例，这种形式的问题的代码常见写法如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, ..., n</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>, ..., i<span class="number">-1</span></span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i], f(dp[j])</span><br></pre></td></tr></table></figure>
<p>时间复杂度 $O(n^{2})$，空间复杂度 <code>O(n)</code></p>
<h3 id="单串相关练习题"><a href="#单串相关练习题" class="headerlink" title="单串相关练习题"></a>单串相关练习题</h3><ul>
<li>最经典单串 LIS 系列<ul>
<li>最长递增子序列</li>
<li>最长递增子序列的个数</li>
<li>俄罗斯套娃信封问题</li>
</ul>
</li>
<li>最大子数组和系列<ul>
<li>最大子序和</li>
<li>乘积最大子数组</li>
<li>环形子数组的最大和 —— 环形数组的处理</li>
<li>面试题 17.24 最大子矩阵 —— 思路类似一维的最大子数组和</li>
<li>矩形区域不超过 K 的最大数值和 —— 在上一题基础上加了一个 K</li>
</ul>
</li>
<li>打家劫舍系列<ul>
<li>打家劫舍</li>
<li>打家劫舍 II</li>
<li>删除与获得点数</li>
<li>3n 块披萨</li>
</ul>
</li>
<li>变形：需要两个位置的情况<ul>
<li>最长的斐波那契子序列的长度</li>
<li>最长等差数列</li>
</ul>
</li>
<li>与其它算法配合<ul>
<li>形成字符串的最短路径 —— DP + 二分，贪心</li>
<li>最大整除子集 —— 先对数组排序</li>
</ul>
</li>
<li>其它单串 dp[i] 问题<ul>
<li>最长有效括号</li>
<li>等差数列划分</li>
<li>解码方法</li>
<li>分割回文串 II</li>
<li>比特位计数</li>
<li>使序列递增的最小交换次数</li>
<li>最低加油次数</li>
<li>两个字符串的删除操作</li>
</ul>
</li>
</ul>
<h2 id="带维度单串"><a href="#带维度单串" class="headerlink" title="带维度单串"></a>带维度单串</h2><p>单串的问题，子问题仅与位置 <code>i</code> 有关时，就形成单串 <code>dp[i]</code> 的问题。在此基础上，如果子问题还与某种指标 <code>k</code> 有关，<code>k</code> 的物理意义比较常见的有长度，个数，次数，颜色等，则是另一大类问题，状态通常写成 <code>dp[i][k]</code>。其中 <code>k</code> 上可能有二分，贪心等算法.</p>
<p>当 <code>i</code> 变小时，形成小规模子问题，当 <code>k</code> 变小时，也形成小规模子问题，因此推导 <code>dp[i][k]</code> 时，<code>i</code> 和 <code>k</code> 两个维度分别是一个独立的单串 dp[i] 问题。推导 <code>k</code> 时，<code>k</code> 可能与 <code>k - 1,...,1</code> 中的所有小规模问题有关，也可能只与其中常数个有关，参考单串 <code>dp[i]</code> 问题中的两种情况。</p>
<p>例如 256. 粉刷房子 ，其中 <code>k</code> 这一维度的物理意义是颜色推导 <code>k</code> 时，<code>k</code> 与 <code>k - 1,...,1</code> 中的所有小规模问题有关，则 <code>k</code> 这一维度的时间复杂度为 $O(K^{2})$</p>
<p>单串 <code>dp[i][k]</code> 的问题，推导状态时可以先枚举 <code>k</code>，再枚举 <code>i</code>，对于固定的 <code>k</code>，求 <code>dp[i][k]</code> 相当于就是在求一个单串 <code>dp[i]</code> 的问题，但是计算 <code>dp[i][k]</code> 时可能会需要 <code>k-1</code> 时的状态。具体的转移需要根据题目条件确定。参考 813。</p>
<p>矩阵上的 <code>dp[i][j]</code> 这类问题中也有可能会多出 <code>k</code> 这个维度，状态的定义就是 <code>dp[i][j][k]</code>，例如</p>
<ul>
<li>576 出界的路径数</li>
<li>688 “马” 在棋盘上的概率</li>
</ul>
<h3 id="带维度经典问题"><a href="#带维度经典问题" class="headerlink" title="带维度经典问题"></a>带维度经典问题</h3><p>以下将涉及到的知识点对应的典型问题进行讲解，题目和解法具有代表性，可以从一个问题推广到一类问题。</p>
<p>==【813. 最大平均值和的分组】==</p>
<blockquote>
<p>我们将给定的数组 A 分成 K 个相邻的非空子数组 ，我们的分数由每个子数组内的平均值的总和构成。计算我们所能得到的最大分数是多少。<br>注意我们必须使用 A 数组中的每一个数进行分组，并且分数不一定需要是整数。</p>
</blockquote>
<p>输入是单串，但是有一个额外的次数的指标 k。在这种情况下，第一步是考虑单串 <code>dp[i]</code> 的子问题拆分方式：枚举子数组的起点来拆分子问题。</p>
<p>设计状态 <code>dp[i] := [i..n-1]</code> 上原问题的解，即 <code>[i..n-1]</code> 上分成 <code>K</code> 个相邻的非空子数组可得的最大分数</p>
<p>第二步是将额外的指标 <code>K</code> 作为一个维度加到状态里　<code>dp[i][k] := [i..n-1]</code> 上原问题的解，即 <code>[i..n-1]</code> 上分成 <code>k</code> 个相邻的非空子数组可得的最大分数</p>
<p>在推导状态时，先枚举 <code>k</code>，对于固定的 <code>k</code>，枚举 <code>i</code> ，枚举 <code>i</code> 时，相当于是在推导一个单串 <code>dp[i]</code> 的问题，但是计算 <code>dp[i][k]</code> 时需要用到 <code>k-1</code> 时的状态，这个区别在 2-1-4 中也有讨论。</p>
<p>由于 <code>i</code> 枚举的是起点，因此 <code>i</code> 越小的时候，子问题规模越大，需要从 <code>n-1</code> 到 <code>0</code> 枚举。</p>
<p>上面提到，固定 <code>k</code> 时，枚举 <code>i</code> ，相当于是在推导一个单串 <code>dp[i]</code> 的问题，这个问题在计算 <code>i</code> 的时候，需要此前已经计算的所有状态，即 <code>i+1, i+2, ..., n-1</code>。这相当于 2-1-1 中的第二种情况，但区别是这里有 <code>k</code> 这一个额外指标影响状态的推导。</p>
<p>对于区间 <code>[i..n-1]</code>，若分出了区间 <code>[i,j-1]</code>, 则在区间 <code>[j..n-1]</code> 上分 <code>k - 1</code> 个区间，就可以将 <code>[i..n-1]</code> 分成 <code>k</code> 个区间。而 <code>[i+1, .., n-1]</code> 均有可能是这个 <code>j</code>。因此枚举这些 <code>j</code> ，将 <code>[j, n-1]</code> 上分 <code>k-1</code> 份的结果 <code>dp[j][k-1]</code> 加上 <code>[i..j-1]</code> 上的平均追 <code>avg(i, j-1)</code> 就得到了当前待计算状态 <code>dp[i][k]</code>。</p>
<p>结合题目条件，这个单串 <code>dp[i][k]</code> 的问题，状态的推导方向，以及推导公式如下:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201002212440.png" alt="带维度单串状态的推导方向以及推导公式"></p>
<p>按照以上的分析，状态的转移方程可以写出来，如下：</p>
<script type="math/tex; mode=display">dp[i][k] = min_{j} dp[j][k-1] + avg(i, j-1)\ 其中 j 取 [i+1,..,n−1] 取较小值</script><p>其中 $avg(i, j)$，是求子串 (i, j) 上的平均值，其中中间的一步求 $sum(i, j)$ 可以用前缀和实现。前缀和的内容参考下一章。</p>
<h3 id="带维度单串相关练习题"><a href="#带维度单串相关练习题" class="headerlink" title="带维度单串相关练习题"></a>带维度单串相关练习题</h3><ul>
<li>带维度单串 dp[i][k]<ul>
<li>最大平均值和的分组 —— k 是个数</li>
<li>鸡蛋掉落 —— k 是次数，k 上有二分</li>
<li>粉刷房子 —— k 是颜色</li>
<li>粉刷房子 II —— k 是颜色</li>
<li>奇偶跳 —— k 表示当前的奇偶状态</li>
<li>青蛙过河 —— k 表示上一步的跳的步数</li>
<li>安排邮筒 —— k 是个数，前缀和维护状态转移时的查询</li>
<li>抛掷硬币 —— k 是个数</li>
<li>分割数组的最大值 —— k 是份数</li>
<li>给房子涂色 III —— 有两个指标 k 颜色；t 街区数</li>
</ul>
</li>
<li>股票系列<ul>
<li>买卖股票的最佳时机</li>
<li>买卖股票的最佳时机 II</li>
<li>买卖股票的最佳时机 III</li>
<li>买卖股票的最佳时机 IV</li>
<li>最佳买卖股票时机含冷冻期</li>
<li>买卖股票的最佳时机含手续费</li>
</ul>
</li>
</ul>
<h2 id="双串"><a href="#双串" class="headerlink" title="双串"></a>双串</h2><p>有两个输入从串，长度分别为 m, n，此时子问题需要用 i, j 两个变量表示，分别代表第一个串和第二个串考虑的位置 dp[i][j]:= 第一串考虑 [0..i]，第二串考虑 [0..j] 时，原问题的解</p>
<p>较大规模的子问题只与常数个较小规模的子问题有关，其中较小规模可能是 i 更小，或者是 j 更小，也可以是 i，j 同时变小。</p>
<p>其中一种最常见的状态转移形式：推导 dp[i][j] 时，dp[i][j] 仅与 dp[i-1][j], dp[i][j-1], dp[i-1][j-1]，例如</p>
<ul>
<li>72 编辑距离</li>
<li>712 两个字符串的最小 ASCII 删除和</li>
</ul>
<p>线性动态规划中双串 dp[i][j] 的问题，状态的推导方向以及推导公式如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201002222141.png" alt="双串状态的推导方向以及推导公式"></p>
<p>如图所示，绿色部分的 dp[i-1 ~ 0][j-1 ~ 0] 均已经计算过，但计算橙色的当前状态时，仅用到 dp[i-1][j], dp[i][j-1], dp[i-1][j-1]，即比 i, j 小的 O(1)O(1) 个子问题。</p>
<p>这种形式的线性 DP 的代码常见写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1.</span>.m</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1.</span>.n</span><br><span class="line">        dp[i][j] = f(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(mn)，空间复杂度 O(mn)</p>
<p>以上是 O(1) 转移的情况，即计算 dp[i][j] 时，虽然绿色部分的子问题均已经计算完，但只需要用到 dp[i-1][j], dp[i][j-1], dp[i-1][j-1]。也可能出现更高复杂度的转移，类似单串中依赖比 i 小的 O(n) 个子问题的况。</p>
<h3 id="双串相关练习题"><a href="#双串相关练习题" class="headerlink" title="双串相关练习题"></a>双串相关练习题</h3><ul>
<li>最经典双串 LCS 系列<ul>
<li>最长公共子序列</li>
<li>两个字符串的最小 ASCII 删除和 —— LCS，len 和 ascii 各一个 dp</li>
<li>最长重复子数组 —— 最长公共子串，注意与最长公共子序列的区别</li>
</ul>
</li>
<li>字符串匹配系列<ul>
<li>编辑距离</li>
<li>通配符匹配</li>
<li>正则表达式匹配</li>
</ul>
</li>
<li>其它双串 dp[i][j] 问题<ul>
<li>交错字符串</li>
<li>不同的子序列</li>
</ul>
</li>
<li>带维度双串 dp[i][j][k]<ul>
<li>扰乱字符串</li>
</ul>
</li>
</ul>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>输入是一个矩阵，宽和高分别为 m, n，用两个维度表示问题规模 dp[i][j]:= 第一维度考虑 [0..i], 第二维度考虑 [0..j]，原问题的解</p>
<p>这样的状态定义，i 减小，j 减小均可以得到小规模子问题，两个维度均从小到大按顺序推，单独看各自维度，均是一个类似 上 的单串 dp[i] 问题，同样有单串中的两种情况，即转移时要考虑 O(1) 个小规模子问题，和转移时要考虑 O(n) 个子问题。</p>
<p>两个维度均只需考虑 O(1)O(1) 个子问题是最简单的情况，一般 dp[i][j] 就只与 dp[i-1][j], dp[i][j-1], dp[i-1][j-1] 有关，例如 64，但是也有可能出现需要其它位置的状态的情况，需要结合题目分析，这里分析的计算 dp[i][j] 需要哪些状态，决定了状态推导的方向。</p>
<p>线性动态规划中矩阵 dp[i][j] 的问题，状态的推导方向以及推导公式与双串 dp[i][j] 相同，但是物理意义不一样，且求 dp[i][j] 时所需的子问题的变化相对更多。</p>
<h3 id="矩阵相关练习题"><a href="#矩阵相关练习题" class="headerlink" title="矩阵相关练习题"></a>矩阵相关练习题</h3><ul>
<li>矩阵 dp[i][j]<ul>
<li>三角形最小路径和</li>
<li>最小路径和</li>
<li>地下城游戏</li>
<li>下降路径最小和</li>
<li>最大正方形</li>
<li>下降路径最小和 II</li>
</ul>
</li>
<li>矩阵 dp[i][j][k]<ul>
<li>最大矩形</li>
<li>矩形区域不超过 K 的最大数值和 —— k 为宽度</li>
<li>最大子矩阵 —— 思路类似一维的最大子数组和</li>
<li>切披萨的方案数 —— 需要二维前缀和判断两个状态之间能否转移</li>
</ul>
</li>
</ul>
<h2 id="线性动态规划总结"><a href="#线性动态规划总结" class="headerlink" title="线性动态规划总结"></a>线性动态规划总结</h2><p>线性动态规划是动态规划中最基础的一类，它的状态一般物理意义很明确，易于分析。在初学动态规划时，通过线性动态规划的大量练习，可以不断加深动态规划的概念理解，例如动态规划中最重要的三个概念：最有子结构，重复子问题，无后效性。下面对动态规划的三个基本概念做个简要回顾，在线性动态规划的题目练习中可以不断地加深理解，之后再学习其它的动态规划类型就会容易很多。</p>
<p>最优子结构：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构。<br>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。<br>重复子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）<br>线性动态规划是动态规划中变化最多的一类。</p>
<p>首先线性动态规划针对的问题是最常见的数组，字符串，矩阵等，这三种数据结构本身就是线性的，因此出现这些类型的输入的时候，如果要用到动态规划，首先考虑线性动态规划就很合理了，因此很多问题不论最后正解是不是线性动态规划，都会首先想一下线性动态规划是否可行。</p>
<p>其次由于大部分问题的数据都是以这三种形式给出的，因此题目的变化会非常多，很多常见的输入形式以及问题都非常经典，都存在经典的状态设计。因此不考虑一些比较 Trick 的解法，仅仅是经典问题的经典状态设计，就比其它种类的动态规划问题多很多了。</p>
<p>例如单个数组或字符串上设计一维状态，两个数组或字符串上设计两维状态，以及矩阵上设计两维状态等等，同时以上三种情况的状态设计都有可能再加上额外的指标的状态，就是前面例题中的 k，这里面变化就很多了，比如有的题目在 k 这一维上要使用二分，贪心的策略，有的题目需要 DP 状态与数据结构配合来解决问题。</p>
<p>除此之外还有一类问题没有显式的数组，字符串，但是在求解的时候依然满足前面提到的动态规划三条基本概念，可以用动态规划求解，这种问题通常也是线性动态规划。如此多的变化仅仅本小节例举的题目是远远不够的，下一小节是线性动态规划的练习题，涉及到对线性动态规划的更多的变化。</p>
<h2 id="推荐阅读顺序"><a href="#推荐阅读顺序" class="headerlink" title="推荐阅读顺序"></a>推荐阅读顺序</h2><ol>
<li><a href="/post/2020/aecf6ec6/" title="数据结构与算法 - 动态规划（简介）">数据结构与算法 - 动态规划（简介）</a></li>
<li><a href="/post/2020/610682be/" title="数据结构与算法 - 动态规划（线性动态规划）">数据结构与算法 - 动态规划（线性动态规划）</a></li>
<li><a href="/post/2020/9158b835/" title="数据结构与算法 - 动态规划（前缀和）">数据结构与算法 - 动态规划（前缀和）</a></li>
<li><a href="/post/2020/cb02a3b0/" title="数据结构与算法 - 动态规划（区间动态规划）">数据结构与算法 - 动态规划（区间动态规划）</a></li>
<li><a href="/post/2020/2cea0e37/" title="数据结构与算法 - 动态规划（背包问题）">数据结构与算法 - 动态规划（背包问题）</a></li>
<li><a href="/post/2020/2a7541d6/" title="数据结构与算法 - 动态规划（状态压缩）">数据结构与算法 - 动态规划（状态压缩）</a></li>
<li><a href="/post/2020/8ed94cfd/" title="数据结构与算法 - 动态规划（计数问题）">数据结构与算法 - 动态规划（计数问题）</a></li>
<li><a href="/post/2020/41da3a83/" title="数据结构与算法 - 矩阵快速幂">数据结构与算法 - 矩阵快速幂</a></li>
<li><a href="/post/2020/16341583/" title="数据结构与算法 - 动态规划（数位动态规划）">数据结构与算法 - 动态规划（数位动态规划）</a>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 动态规划（背包问题）</title>
    <url>/post/2020/2cea0e37/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note success"><h2 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h2><ul>
<li>作者：力扣 (LeetCode)</li>
<li>链接：<a href="https://leetcode-cn.com/leetbook/read/dynamic-programming-2-plus/">https://leetcode-cn.com/leetbook/read/dynamic-programming-2-plus/</a></li>
<li>来源：力扣（LeetCode）</li>
<li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
</div>
<a id="more"></a>
<p>背包问题（Knapsack problem）是一种组合优化的 NP 完全问题。</p>
<p>背包问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。</p>
<p>有 n 种物品，物品 j 的体积为 $v_{j}$, 价值为 $w_{i}$, 有一个体积限制 V。如何选择物品使得总体积不超过 V，并使得总价值最大。<br>这是背包问题最基础的描述，再往下细分还可以把背包问题分成几大类，其中比较基础的是 3 种：01 背包，完全背包，多重背包。</p>
<h2 id="背包动态规划简介"><a href="#背包动态规划简介" class="headerlink" title="背包动态规划简介"></a>背包动态规划简介</h2><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="背包的问题描述"><a href="#背包的问题描述" class="headerlink" title="背包的问题描述"></a>背包的问题描述</h4><p>有 <code>n</code> 种物品，物品 <code>j</code> 的体积为 $v_{j}$，价值为 $w_{i}$，有一个体积限制 V。每种物品只有 1 个，只有选或者不选，而没有选几个的问题，此问题称为 ==背包问题==。</p>
<p>一个朴素的想法是，只考虑价值尽量大，状态设计是单串线性 DP 中最经典的状态设计，如下：</p>
<pre><code>dp[i] = dp[i] 已经考虑前 i 个物品可以取得的最大价值
</code></pre><p>由于只考虑价值，则当前物品应该尽量多拿，但是这是错的，因为后面可能有的物品虽然体积大，但是它的价值也很大，由于考虑每个物品时都尽可能多选，轮到后面的物品的时候可能就没有空间了。</p>
<p>因此只用价值做状态是不行的，考虑如下的状态设计：</p>
<pre><code>dp[i][j] := 已经考虑了 [0..i-1]  前 i 个物品，占用了 j 空间，所能取得的最大价值。
</code></pre><p>转移方式有两种，一种是放入，一种是不放入。如果放，则前 i - 1 个只能占 j - v[i] 空间，如果不放，则前 i - 1 个物品还是占了 j 空间。</p>
<pre><code>dp[i][j] = dp[i - 1][j] 当前物品不选
           dp[i - 1][j - v[i]] + w[i] 当前物品选，j - v[i] 要大于等于 0
</code></pre><p>初始化时将所有状态置为 0 即可。这就是 01 背包问题。状态设计和状态转移。一共 $N \times V$ 种状态, 状态的转移 O(1) 可以完成，因此时间复杂度，空间复杂度都是 O(NV)。</p>
<h3 id="衍生问题：背包必须放满"><a href="#衍生问题：背包必须放满" class="headerlink" title="衍生问题：背包必须放满"></a>衍生问题：背包必须放满</h3><p>回顾背包的基本解法的状态转移方程，如下：</p>
<p>dp[i][j] = dp[i - 1][j] 当前物品不选<br>           dp[i - 1][j - v[i]] + w[i] 当前物品选，j - v[i] 要大于等于 0</p>
<p>空间复杂度为 O(NV)，状态转移中 i 这一维只跟 i - 1 有关系，因此 i 这一维用滚动数组至少可以将 N 行优化为 2 行。这本来是动态规划的基本操作，在线性动态规划中很常见。这里特别提空间优化是因为 01 背包的 i 这一维用 1 行就可以解决。</p>
<p>假设状态只有一行，即 dp[j] := 占用了 j 空间的情况下可以取到的最大价值, 在推第 i 行的时候，dp 数组中存的是第 i - 1 行的信息。</p>
<p>看状态的两个转移方向，第一个是 dp[i - 1][j]，这刚好就是当前 dp 数组在 j 位置保存的数据，因此不用动，比较麻烦的是另一个，就是 dp[i - 1][j - v[i]] + w[i]。这里要用到第 i - 1 行的 dp[j - v[i]]，但是如果按照正常的 j 从 0 到 V 推的话，计算 dp[j] 的时候，dp[j - v[i]] 保存的已经是第 i 行信息了。</p>
<p>因此这里需要转换一下，从大往小推，推到 dp[j] 时，dp[j+1], dp[j+2],…,dp[V] 都已经是第 i 行的信息了，但是它们对 dp[j] 的计算没有影响，有影响的 dp[j-v[i]] 此时还是第 i - 1 行的信息，可以满足转移方程 dp[i - 1][j - v[i]] + w[i] 的需要。因此当空间这一维的状态从大往小推的时候，i 这一维状态可以优化到一维。</p>
<p>这就是背包的终极形态了。</p>
<pre><code>dp[j] = max(dp[j], dp[j - v[i]] + w[i]) // j 从大往小推
</code></pre><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>完全背包的问题描述：</p>
<p>有 n 种物品，物品 j 的体积为 $v_{j}$，价值为 $w_{i}$，有一个体积限制 V。每种物品有无限个，此问题称为完全背包问题。</p>
<p>但是由于有体积限制，因此实际取的数量也是有限制的。每个物品其实最多只能取 $V / v[i]$ 个。</p>
<p>一个朴素的思路是将完全背包强行变成 01 背包：对每个物品 i，都可以求出一个 $V / v[i]$ ，然后就 将物品展开 ，即视为有 $V / v[i]$ 个同样的物品，每个物品有选和不选两种选择。</p>
<p>再套用背包的解法可以解决完全背包。如下：</p>
<pre><code>dp[j] = max(dp[j], dp[j - v[i]] + w[i]) // j 从大往小推
</code></pre><p>但是这种办法复杂度太高了，需要优化。优化的方法非常巧妙，现在我们不把每个物品展开来考虑这个问题。</p>
<p>首先状态表示与背包相同：</p>
<pre><code>dp[i][j] := 已经考虑了 [0..i-1]  前 i 个物品，占用了 j 空间，所能取得的最大价值。
</code></pre><p>考虑的状态转移，对于当前物品 i ，也是有两种情况：选和不选。</p>
<ul>
<li>如果选，在 01 背包中 前 i - 1 个只能占 j - v[i] 空间，而在完全背包中因为 i 有无限多个，因此选了 i 之后是 前 i 个物品只能占 j - v[i] 空间。</li>
<li><p>如果不选，则前 i - 1 个物品还是占了 j 空间，这与 01 背包一样。状态转移方程如下，注意唯一的区别就是第 2 行的 dp[i - 1] 变成了 dp[i]。</p>
<pre><code>  dp[i][j] = dp[i - 1][j] 当前物品不选
             dp[i][j - v[i]] + w[i] 当前物品选，j - v[i] 要大于等于 0
</code></pre></li>
</ul>
<p>考虑空间优化后的状态转移方程如下：在 01 背包中，由于推第 i 行的 dp[j] 时需要第 i - 1 行的 dp[j-v[i]] ，因此忌讳在推导 dp[j] 时，dp[j-v[i]] 已经更新过了, 这是 01 背包不希望发生的事，解决的办法就是 j 从大往小推。</p>
<p>而上述 01 背包不希望发生的事正是完全背包希望发生的，即推导第 i 行的 dp[j] 时，用到第 i 行的 dp[j -v[i]] 。而这仅需要把 01 背包中的从大往小推 j 改为从小往大推 j 即可实现。这就是完全背包的优化巧妙的地方。</p>
<pre><code>dp[j] = max(dp[j], dp[j - v[i]] + w[i])
</code></pre><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><p>多重背包问题是这样描述的：</p>
<p>有 n 种物品，物品 j 的体积为 $v_{j}$ ，价值为 $w_{i}$，有一个体积限制 V 。每种物品还有一个 $c_{i}$，表示每种物品的个数，此问题称为多重背包问题。</p>
<h4 id="思路-1-：将物品展开，全拆成-01"><a href="#思路-1-：将物品展开，全拆成-01" class="headerlink" title="思路 1 ：将物品展开，全拆成 01"></a>思路 1 ：将物品展开，全拆成 01</h4><p>这与完全背包的朴素思路一致。与完全背包的情况一样，这种方法是正确的，但是时间复杂度较高。</p>
<p>多重背包的朴素算法与完全背包的朴素算法没有区别，而多重背包的优化相对较难，并且力扣上面没有多重背包的题目。下面仅对多重背包的优化做简单的介绍。</p>
<h4 id="思路-2-：2-进制分解"><a href="#思路-2-：2-进制分解" class="headerlink" title="思路 2 ：2 进制分解"></a>思路 2 ：2 进制分解</h4><p>这是对思路 1 的优化。</p>
<p>有这样一个事实：任意一个数 <code>n</code>，它一定可以用 1,2,4,8,…,$2^{k}$，以及 $2^{k}$ 到 $2^{k+1}$ 之间的某个数表示。例如 <code>13</code> 以内的所有数都可以用 <code>1,2,4,6</code> 表示。</p>
<p>所以对于物品 i, 数量限制是 $c_{i}$, 可以将其分成若干物品，它们的价值和体积为：$(w_{i},v_{i})$，$(2w_{i}, 2v_{i})$,…</p>
<p>然后对这些物品做 01 背包。这样 01 背包的物品数就比思路 1 少很多了。这可以理解为类似于倍增法的思想。倍增法超出了力扣的范围，感兴趣的话可以找相关的资料学习。</p>
<p>以上就是背包动态规划的基本内容。背包动态规划在力扣上题目不多，下一节整理了 8 道背包动态规划的练习题，通过这些题可以大致了解背包问题的一些经典问题和常见的问法。</p>
<h2 id="背包动态规划问题分析步骤"><a href="#背包动态规划问题分析步骤" class="headerlink" title="背包动态规划问题分析步骤"></a>背包动态规划问题分析步骤</h2><p>上一小节介绍了三种最基本的背包问题：01 背包，完全背包，多重背包。包括问题描述，状态设计以及状态转移方程。</p>
<p>实际问题会把背包问题做各种包装，而不会把问题描述的这么直白，背包的问题常见的有三种，第一个是求最值，这是背包的原始问题，第二个是体积要取到背包容量的最值，第三个是求方案数，即组合问题。</p>
<p>背包问题的分析步骤：</p>
<ol>
<li>分析是否为背包问题。</li>
<li>是背包问题三种问法中的哪一种。</li>
<li>是 0-1 背包问题还是完全背包问题。也就是题目给的 nums 数组中的元素是否可以重复使用。</li>
<li>如果是组合问题，即求方案数，是否需要考虑元素之间的顺序。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法，需要注意。</li>
</ol>
<h3 id="背包动态规划相关练习题"><a href="#背包动态规划相关练习题" class="headerlink" title="背包动态规划相关练习题"></a>背包动态规划相关练习题</h3><h4 id="最值问题"><a href="#最值问题" class="headerlink" title="最值问题"></a>最值问题</h4><p>下面这三道题是背包问题最原始的问法，即求最大价值。</p>
<p>其中第三题比较特殊，没有价值，但是要求背包的剩余容量最小，以下是传统的背包做法和使得背包剩余容量最小的做法的对比。差别非常细微。</p>
<p>传统做法：</p>
<ul>
<li>dp[i][j] := 考虑前 i 件物品，且背包容量为 j 时所能获得的最大价值</li>
<li><p>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]); 第一项是不选 i, 第二项是选 i(j - v[i] &gt;= 0)<br>使得背包容量剩余最小的做法：</p>
</li>
<li><p>dp[i][j] := 考虑前 i 件物品, 背包容量为 j 时，能取到的最大体积</p>
</li>
<li>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + v[i]); 第一项是不选 i, 第二项是选 i(j - v[i] &gt;= 0)</li>
</ul>
<p>练习题目：</p>
<ul>
<li>零钱兑换（完全背包）</li>
<li>一和零（二维费用背包）</li>
<li>最后一块石头的重量 II —— 转换为背包问题，使得背包剩余容量最小</li>
</ul>
<h4 id="恰好取到背包容量"><a href="#恰好取到背包容量" class="headerlink" title="恰好取到背包容量"></a>恰好取到背包容量</h4><ul>
<li>分割等和子集（背包问题 - 要求恰好取到背包容量）</li>
</ul>
<h4 id="组合问题（求方案数）"><a href="#组合问题（求方案数）" class="headerlink" title="组合问题（求方案数）"></a>组合问题（求方案数）</h4><p>这四道题是背包问题求方案数的题目，涉及到 01 背包，完全背包的方案数问题。以及考虑顺序和不考虑顺序的情况。</p>
<ul>
<li>组合总和 Ⅳ —— 顺序不同的序列被视作不同的组合</li>
<li>目标和 —— 背包问题 - 求方案数</li>
<li>零钱兑换 II —— 完全背包 - 求方案数</li>
<li>盈利计划 —— 背包问题 - 求方案数总价值有要求：有下限</li>
</ul>
<h2 id="推荐阅读顺序"><a href="#推荐阅读顺序" class="headerlink" title="推荐阅读顺序"></a>推荐阅读顺序</h2><ol>
<li><a href="/post/2020/aecf6ec6/" title="数据结构与算法 - 动态规划（简介）">数据结构与算法 - 动态规划（简介）</a></li>
<li><a href="/post/2020/610682be/" title="数据结构与算法 - 动态规划（线性动态规划）">数据结构与算法 - 动态规划（线性动态规划）</a></li>
<li><a href="/post/2020/9158b835/" title="数据结构与算法 - 动态规划（前缀和）">数据结构与算法 - 动态规划（前缀和）</a></li>
<li><a href="/post/2020/cb02a3b0/" title="数据结构与算法 - 动态规划（区间动态规划）">数据结构与算法 - 动态规划（区间动态规划）</a></li>
<li><a href="/post/2020/2cea0e37/" title="数据结构与算法 - 动态规划（背包问题）">数据结构与算法 - 动态规划（背包问题）</a></li>
<li><a href="/post/2020/2a7541d6/" title="数据结构与算法 - 动态规划（状态压缩）">数据结构与算法 - 动态规划（状态压缩）</a></li>
<li><a href="/post/2020/8ed94cfd/" title="数据结构与算法 - 动态规划（计数问题）">数据结构与算法 - 动态规划（计数问题）</a></li>
<li><a href="/post/2020/41da3a83/" title="数据结构与算法 - 矩阵快速幂">数据结构与算法 - 矩阵快速幂</a></li>
<li><a href="/post/2020/16341583/" title="数据结构与算法 - 动态规划（数位动态规划）">数据结构与算法 - 动态规划（数位动态规划）</a>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 动态规划（简介）</title>
    <url>/post/2020/aecf6ec6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note success"><h2 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h2><ul>
<li>作者：力扣 (LeetCode)</li>
<li>链接：<a href="https://leetcode-cn.com/leetbook/read/dynamic-programming-1-plus/">https://leetcode-cn.com/leetbook/read/dynamic-programming-1-plus/</a></li>
<li>来源：力扣（LeetCode）</li>
<li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
</div>
<a id="more"></a>
<h2 id="动态规划与其它算法的关系"><a href="#动态规划与其它算法的关系" class="headerlink" title="动态规划与其它算法的关系"></a>动态规划与其它算法的关系</h2><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>解决分治问题的时候，思路就是想办法把问题的规模减小，有时候减小一个，有时候减小一半，然后将每个小问题的解以及当前的情况组合起来得出最终的结果。</p>
<p>例如归并排序和快速排序，归并排序将要排序的数组平均地分成两半，快速排序将数组随机地分成两半。<br>然后不断地对它们递归地进行处理。</p>
<p>这里存在有最优的子结构，即原数组的排序结果是在子数组排序的结果上组合出来的，但是不存在重复子问题，因为不断地对待排序的数组进行对半分的时候，两半边的数据并不重叠，分别解决左半边和右半边的两个子问题的时候，没有子问题重复出现，这是动态规划和分治的区别。</p>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>关于最优子结构</p>
<p>贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录</p>
<p>动态规划：全局最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解，因此需要记录之前的所有的局部最优解</p>
<p>关于子问题最优解组合成原问题最优解的组合方式</p>
<p>贪心：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可，这里的最优是贪心意义上的最优。此时不需要知道一个节点的所有子树情况，于是构不成一棵完整的树</p>
<p>动态规划：动态规划需要对每一个子树求最优解，直至下面的每一个叶子的值，最后得到一棵完整的树，在所有子树都得到最优解后，将他们组合成答案</p>
<p>结果正确性</p>
<p>贪心不能保证求得的最后解是最佳的，复杂度低</p>
<p>动态规划本质是穷举法，可以保证结果是最佳的，复杂度高</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>分治</th>
<th>动态规划</th>
<th>贪心</th>
</tr>
</thead>
<tbody>
<tr>
<td>适用类型</td>
<td>通用</td>
<td>优化</td>
<td>优化</td>
</tr>
<tr>
<td>子问题</td>
<td>每个都不同</td>
<td>有很多重复</td>
<td>只有一个</td>
</tr>
<tr>
<td>最优子结构</td>
<td>没有要求</td>
<td>必须满足</td>
<td>必须满足</td>
</tr>
<tr>
<td>子问题数</td>
<td>全部都要解</td>
<td>全部都要解</td>
<td>只解一个</td>
</tr>
</tbody>
</table>
</div>
<h2 id="推荐阅读顺序"><a href="#推荐阅读顺序" class="headerlink" title="推荐阅读顺序"></a>推荐阅读顺序</h2><ol>
<li><a href="/post/2020/aecf6ec6/" title="数据结构与算法 - 动态规划（简介）">数据结构与算法 - 动态规划（简介）</a></li>
<li><a href="/post/2020/610682be/" title="数据结构与算法 - 动态规划（线性动态规划）">数据结构与算法 - 动态规划（线性动态规划）</a></li>
<li><a href="/post/2020/9158b835/" title="数据结构与算法 - 动态规划（前缀和）">数据结构与算法 - 动态规划（前缀和）</a></li>
<li><a href="/post/2020/cb02a3b0/" title="数据结构与算法 - 动态规划（区间动态规划）">数据结构与算法 - 动态规划（区间动态规划）</a></li>
<li><a href="/post/2020/2cea0e37/" title="数据结构与算法 - 动态规划（背包问题）">数据结构与算法 - 动态规划（背包问题）</a></li>
<li><a href="/post/2020/2a7541d6/" title="数据结构与算法 - 动态规划（状态压缩）">数据结构与算法 - 动态规划（状态压缩）</a></li>
<li><a href="/post/2020/8ed94cfd/" title="数据结构与算法 - 动态规划（计数问题）">数据结构与算法 - 动态规划（计数问题）</a></li>
<li><a href="/post/2020/41da3a83/" title="数据结构与算法 - 矩阵快速幂">数据结构与算法 - 矩阵快速幂</a></li>
<li><a href="/post/2020/16341583/" title="数据结构与算法 - 动态规划（数位动态规划）">数据结构与算法 - 动态规划（数位动态规划）</a>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 动态规划（计数问题）</title>
    <url>/post/2020/8ed94cfd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note success"><h2 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h2><ul>
<li>作者：力扣 (LeetCode)</li>
<li>链接：<a href="https://leetcode-cn.com/leetbook/read/dynamic-programming-2-plus/">https://leetcode-cn.com/leetbook/read/dynamic-programming-2-plus/</a></li>
<li>来源：力扣（LeetCode）</li>
<li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
</div>
<a id="more"></a>
<p>计数是组合数学的重要内容。不考虑用母函数等手段求解析解的话，计数问题一般有两种做法：</p>
<ol>
<li>找到组合数公式，然后用 DP 的方式或者用含阶乘的公式求组合数<br>2。 找到递归关系，然后以 DP 的方式求这个递推关系，如果是线性递推关系，可以用矩阵快速幂加速</li>
</ol>
<p>以卡特兰数为例，</p>
<ol>
<li>组合数公式：$C_{n} = \dbinom{2n}{n} - \dbinom{2n}{n - 1} = \frac{1}{n + 1}\dbinom{2n}{n} = \prod_{k=2}^{n}\frac{n + k}{k}$</li>
<li>递推式: $C_{n} = \sum_{i=0}^{N-1}C_{i}C_{n-i-1}$</li>
</ol>
<p>在实际问题中，绝大多数都是用方法 2 来做，首先是因为递推关系相对好找一些，另外即使找到了组合数公式，依然要面临求组合数的问题。</p>
<p>在找递推关系时，有时需要手算若干例子找规律，然后猜想递推关系再验证。</p>
<p>下一小节我们用两道例题看一下这两种方法的思考过程。</p>
<h2 id="计数问题经典问题"><a href="#计数问题经典问题" class="headerlink" title="计数问题经典问题"></a>计数问题经典问题</h2><h3 id="计数问题组合数法的思考过程"><a href="#计数问题组合数法的思考过程" class="headerlink" title="计数问题组合数法的思考过程"></a>计数问题组合数法的思考过程</h3><p>==62. 不同路径 ==</p>
<p>本题更好想的做法是用动态规划来做，对于位置 (i,j)，它可能从上面或左面转移而来，因此状态设计和状态转移可以写成如下形式：</p>
<pre><code>dp[i][j] := 从 (0,0) 到 (i,j) 的方法数
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
</code></pre><p>按照计数问题的思路，我们可以这样想：从 (0,0) 走到 (m, n) 一共需要走 m + n - 2 步，其中 m - 1 步是向下走的，n - 1 步是向右走的。因此问题转化为从 m + n - 2 中选 m - 1 个，共有多少选法。</p>
<p>这个问题的组合数公式比较好写，如下：</p>
<script type="math/tex; mode=display">\dbinom{m + n - 2}{m - 1}</script><p>我们可以用递推的方式求这个组合数，参考杨辉三角。</p>
<h3 id="计数问题递推关系法的思考过程"><a href="#计数问题递推关系法的思考过程" class="headerlink" title="计数问题递推关系法的思考过程"></a>计数问题递推关系法的思考过程</h3><p>==276. 栅栏涂色 ==</p>
<p>很多问题用动态规划的思考方式思考时，可能会发现状态不是很好设计，或者不是很好转移，组合数公式也不好想，此时需要手算一些例子，看看能不能找到一些规律，找到突破口进而得到递推公式。</p>
<p>本题是典型的一例。</p>
<p>本题是问：k 种颜色，n 个栅栏，最多连续 2 个颜色相同，问有多少涂色的方案。</p>
<p>Step 1：手算若干例子，记 dp[i]:=i 个栅栏的方案数 ：</p>
<pre><code>// n &gt; 0, k &gt; 0
n == 1: dp[n] = k
n == 2: dp[n] = k * k
n == 3: dp[n] = k * k * k - k
n == 4: dp[n] = k * (k * k * k - k) - k * k
</code></pre><p>Step 2：通过上述手算例子，可以猜想如下递推公式：</p>
<pre><code>f[i] = k*f[i - 1] - f[i - 2]
</code></pre><p>如果要证明，可以考虑数学归纳法。</p>
<p>Step 3：将递推关系视为动态规划的状态转移，求解问题。</p>
<p>如果递推关系是线性的，可以用矩阵快速幂加速，这是下一章的内容。下一小节中有 16 道计数问题的练习题，练习这些题目时重点体会寻找递推关系的过程。</p>
<h3 id="计数问题相关练习题"><a href="#计数问题相关练习题" class="headerlink" title="计数问题相关练习题"></a>计数问题相关练习题</h3><ul>
<li>路径问题<ul>
<li>不同路径</li>
<li>不同路径 II</li>
</ul>
</li>
<li>卡特兰数<ul>
<li>不同的二叉搜索树 —— 卡特兰数</li>
<li>不相交的握手 —— 卢卡斯定理求大组合数</li>
</ul>
</li>
<li>铺砖问题<ul>
<li>多米诺和托米诺平铺</li>
</ul>
</li>
<li>斐波那契<ul>
<li>爬楼梯</li>
<li>使用最小花费爬楼梯</li>
<li>斐波那契数</li>
<li>第 N 个泰波那契数</li>
</ul>
</li>
<li>隐晦的递推关系<ul>
<li>骑士拨号器</li>
<li>屏幕可显示句子的数量 —— 可以通过模拟找循环节</li>
<li>N 天后的牢房 —— 可以通过模拟找循环节</li>
<li>栅栏涂色</li>
<li>掷骰子的 N 种方法</li>
<li>学生出勤记录 II</li>
<li>不同的子序列 II —— 找规律</li>
</ul>
</li>
</ul>
<h2 id="推荐阅读顺序"><a href="#推荐阅读顺序" class="headerlink" title="推荐阅读顺序"></a>推荐阅读顺序</h2><ol>
<li><a href="/post/2020/aecf6ec6/" title="数据结构与算法 - 动态规划（简介）">数据结构与算法 - 动态规划（简介）</a></li>
<li><a href="/post/2020/610682be/" title="数据结构与算法 - 动态规划（线性动态规划）">数据结构与算法 - 动态规划（线性动态规划）</a></li>
<li><a href="/post/2020/9158b835/" title="数据结构与算法 - 动态规划（前缀和）">数据结构与算法 - 动态规划（前缀和）</a></li>
<li><a href="/post/2020/cb02a3b0/" title="数据结构与算法 - 动态规划（区间动态规划）">数据结构与算法 - 动态规划（区间动态规划）</a></li>
<li><a href="/post/2020/2cea0e37/" title="数据结构与算法 - 动态规划（背包问题）">数据结构与算法 - 动态规划（背包问题）</a></li>
<li><a href="/post/2020/2a7541d6/" title="数据结构与算法 - 动态规划（状态压缩）">数据结构与算法 - 动态规划（状态压缩）</a></li>
<li><a href="/post/2020/8ed94cfd/" title="数据结构与算法 - 动态规划（计数问题）">数据结构与算法 - 动态规划（计数问题）</a></li>
<li><a href="/post/2020/41da3a83/" title="数据结构与算法 - 矩阵快速幂">数据结构与算法 - 矩阵快速幂</a></li>
<li><a href="/post/2020/16341583/" title="数据结构与算法 - 动态规划（数位动态规划）">数据结构与算法 - 动态规划（数位动态规划）</a>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 双指针法的应用</title>
    <url>/post/2020/923b6032/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="应用1：寻找和为target的两个数"><a href="#应用1：寻找和为target的两个数" class="headerlink" title="应用1：寻找和为target的两个数"></a>应用1：寻找和为target的两个数</h2><h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h3><blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p>
</blockquote>
<h2 id="应用2：判断链表是否有环"><a href="#应用2：判断链表是否有环" class="headerlink" title="应用2：判断链表是否有环"></a>应用2：判断链表是否有环</h2><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p>
</blockquote>
<h3 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h3><blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></p>
</blockquote>
<h2 id="应用3：荷兰国旗问题"><a href="#应用3：荷兰国旗问题" class="headerlink" title="应用3：荷兰国旗问题"></a>应用3：荷兰国旗问题</h2><h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h3><blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/sort-colors/">https://leetcode-cn.com/problems/sort-colors/</a></p>
</blockquote>
<h2 id="应用4：三数之和"><a href="#应用4：三数之和" class="headerlink" title="应用4：三数之和"></a>应用4：三数之和</h2><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p>
</blockquote>
<h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h3><blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/3sum-closest/">https://leetcode-cn.com/problems/3sum-closest/</a></p>
</blockquote>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>「滑动窗口」是一类使用「双指针」技巧，通过两个变量在数组上同向交替移动解决问题的算法。这一类问题的思考路径通常是：先思考暴力解法，分析暴力解法的缺点（一般而言暴力解法的缺点是重复计算），然后 结合问题的特点，使用「双指针」技巧对暴力解法进行剪枝。因此，思考算法设计的合理性是更关键的，这一点适用于所有算法问题。</p>
<ul>
<li>「力扣」第 1004 题：最大连续 1 的个数 III；</li>
<li>「力扣」第 1208 题：尽可能使字符串相等；</li>
<li>「力扣」第 1493 题：删掉一个元素以后全为 1 的最长子数组。</li>
<li>「力扣」第 3 题：无重复字符的最长子串；</li>
<li>「力扣」第 209 题：长度最小的子数组；</li>
<li>「力扣」第 76 题：最小覆盖子串；</li>
<li>「力扣」第 438 题：找到字符串中所有字母异位词；</li>
<li>「力扣」第 567 题：字符串的排列。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 字符串匹配</title>
    <url>/post/2020/4641b2f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-题目介绍"><a href="#1-题目介绍" class="headerlink" title="1. 题目介绍"></a>1. 题目介绍</h2><blockquote>
<p>详见: <a href="https://leetcode-cn.com/problems/implement-strstr/">https://leetcode-cn.com/problems/implement-strstr/</a></p>
</blockquote>
<h2 id="2-解题方法-1-暴力解法"><a href="#2-解题方法-1-暴力解法" class="headerlink" title="2. 解题方法 1 - 暴力解法"></a>2. 解题方法 1 - 暴力解法</h2><h3 id="2-1-算法实现"><a href="#2-1-算法实现" class="headerlink" title="2.1 算法实现"></a>2.1 算法实现</h3><p>暴力算法比较容易理解:</p>
<ol>
<li>首先将主串和子串头部对齐</li>
<li>按位遍历比较子串和主串是否一致</li>
<li>如果不一致, 则将子串向后移动一位, 重新遍历</li>
</ol>
<a id="more"></a>
<p>图示如下 <sup>[1]</sup>:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200517224911.gif" alt="暴力算法"></p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> haylength = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> nedlength = needle.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= haylength - nedlength; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; nedlength; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(haystack[i+j] != needle[j]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == nedlength) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-算法分析"><a href="#2-2-算法分析" class="headerlink" title="2.2 算法分析"></a>2.2 算法分析</h3><p>假设主串长度为 N, 子串长度为 M, 则</p>
<p>时间复杂度：最坏时间复杂度为 O((N - M)M)，最优时间复杂度为 O(M)</p>
<p>空间复杂度：O(1)</p>
<h2 id="3-解题方法-2-KMP-算法"><a href="#3-解题方法-2-KMP-算法" class="headerlink" title="3. 解题方法 2 - KMP 算法"></a>3. 解题方法 2 - KMP 算法</h2><h3 id="3-1-KMP-算法背景"><a href="#3-1-KMP-算法背景" class="headerlink" title="3.1 KMP 算法背景"></a>3.1 KMP 算法背景</h3><p> Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个 <strong>文本串 S</strong> 内查找一个 <strong>模式串 P</strong> 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法。<sup>[2]</sup></p>
<h3 id="3-2-KMP-算法实现"><a href="#3-2-KMP-算法实现" class="headerlink" title="3.2 KMP 算法实现"></a>3.2 KMP 算法实现</h3><h4 id="KMP-算法思想"><a href="#KMP-算法思想" class="headerlink" title="KMP 算法思想"></a>KMP 算法思想</h4><p>KMP 算法对暴力算法进行了改进, 在遍历文本串和模式串时, 如如果发现不一致的位, KMP 算法不会像暴力算法一样只将模式串向后移动 1 位, 而是会跳过一些不可能的位置, 直接将模式串后移 K 位</p>
<ol>
<li>首先将文本串和模式串头部对齐</li>
<li>按位遍历比较模式串和文本串是否一致</li>
<li>如果不一致, 则将模式串向后 K 位, 并从文本串的位置继续遍历</li>
</ol>
<p>图示如下:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200517232528.gif" alt="KMP 算法"></p>
<p>从图中可知, KMP 算法可以避免指向文本串的指针的回溯, 从而提高寻找子串的效率</p>
<p>而需要跳过多少个字符呢? (也就是如何的到 K 的值呢?) 这就是 KMP 算法的精髓所在了, 在 KMP 算法中, K 值被称为 next 数组, 是一个只和模式串有关的数组, 下面我们就来分析下 next 数组的求法</p>
<h4 id="如何求得-K-next-数组的求法"><a href="#如何求得-K-next-数组的求法" class="headerlink" title="如何求得 K (next 数组的求法)"></a>如何求得 K (next 数组的求法)</h4><p>next 数组的值是代表着字符串的前缀与后缀相同的最大长度 <sup>[?]</sup>, <strong>前缀</strong> 指除了最后一个字符以外，一个字符串的全部头部组合；<strong>后缀</strong> 指除了第一个字符以外，一个字符串的全部尾部组合。</p>
<blockquote>
<p>[?] 大多数博文都是这个么写的, 但没有找到详细的证明</p>
</blockquote>
<p>以模式串 <strong>AB</strong>B<strong>AB</strong> 为例 前缀与后缀相同的最大长度为 2, 即 该模式串的 next 数组的值为 2.</p>
<p>以模式串为 array:ABBABAABB 为例, n 为字符串的下标</p>
<p>初始值:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>A</th>
<th>B</th>
<th>B</th>
<th>A</th>
<th>B</th>
<th>A</th>
<th>A</th>
<th>B</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>next</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
</div>
<p>下标 0: <a href="#Case1">情况 1</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>A</th>
<th>B</th>
<th>B</th>
<th>A</th>
<th>B</th>
<th>A</th>
<th>A</th>
<th>B</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>next</td>
<td>0</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
</div>
<p>下标 1: <a href="#Case3">情况 3</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>A</th>
<th>B</th>
<th>B</th>
<th>A</th>
<th>B</th>
<th>A</th>
<th>A</th>
<th>B</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>next</td>
<td>0</td>
<td>0</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
</div>
<p>下标 2: <a href="#Case3">情况 3</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>A</th>
<th>B</th>
<th>B</th>
<th>A</th>
<th>B</th>
<th>A</th>
<th>A</th>
<th>B</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>next</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
</div>
<p>下标 3: <a href="#Case2">情况 2</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>A</th>
<th>B</th>
<th>B</th>
<th>A</th>
<th>B</th>
<th>A</th>
<th>A</th>
<th>B</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>next</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
</div>
<p>下标 4: <a href="#Case2">情况 2</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>A</th>
<th>B</th>
<th>B</th>
<th>A</th>
<th>B</th>
<th>A</th>
<th>A</th>
<th>B</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>next</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
</div>
<p>下标 5: <a href="#Case3">情况 3</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>A</th>
<th>B</th>
<th>B</th>
<th>A</th>
<th>B</th>
<th>A</th>
<th>A</th>
<th>B</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>next</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
</div>
<p>下标 6: <a href="#Case3">情况 3</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>A</th>
<th>B</th>
<th>B</th>
<th>A</th>
<th>B</th>
<th>A</th>
<th>A</th>
<th>B</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>next</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
</div>
<p>下标 7: <a href="#Case2">情况 2</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>A</th>
<th>B</th>
<th>B</th>
<th>A</th>
<th>B</th>
<th>A</th>
<th>A</th>
<th>B</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>next</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>?</td>
</tr>
</tbody>
</table>
</div>
<p>下标 8: <a href="#Case2">情况 2</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>A</th>
<th>B</th>
<th>B</th>
<th>A</th>
<th>B</th>
<th>A</th>
<th>A</th>
<th>B</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>next</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p>最后将 next 数组向右移动一格, 并将起始位置 - 1 (方便程序编写, 建议结合代码理解为什么要进行这一步操作)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>A</th>
<th>B</th>
<th>B</th>
<th>A</th>
<th>B</th>
<th>A</th>
<th>A</th>
<th>B</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Case1"> 情况 1 </h5>

<ul>
<li>n == 0</li>
</ul>
<p>如果模式串的首位即与不匹配, 即无前缀和后缀, 则认为前缀和后缀相同的最大长度为 0, 即 next[0] = 0</p>
<h5 id="Case2"> 情况 2 </h5>

<ul>
<li><code>array[n] == array[next(n-1)]</code></li>
</ul>
<p>由 next 数组定义得: <code>array[0 ~ next(n-1)-1] ≡ array[n-next(n-1) ~ n-1]</code></p>
<p>∴ <code>array[next(n-1)] == array[n]</code></p>
<p>∴ <code>array[0 ~ next(n-1)] ≡ array[n-next(n-1) ~ n]</code></p>
<p>∴ <code>next[n] = next(n-1) + 1</code></p>
<h5 id="Case3"> 情况 3<sup>[?]</sup> </h5>

<blockquote>
<p>[?] 证明不是很严谨, 未找到严谨的证明方法</p>
</blockquote>
<ul>
<li><code>array[n] != array[next(n-1)]</code></li>
</ul>
<p>定义: <code>k = next(n-1)</code></p>
<p>由 next 数组定义得:</p>
<p><code>array[0 ~ k-1] ≡ array[n-k ~ n-1]</code></p>
<p><code>array[0 ~ next(k-1)-1] ≡ array[k-next(k-1) ~ k-1]</code></p>
<p>∴ <code>array[0 ~ next(k-1)-1] ≡ array[n-k+(k-next(k-1)) ~ n-1]</code></p>
<p>∴ <code>array[0 ~ next(k-1)-1] ≡ array[n-next(k-1) ~ n-1]</code></p>
<p>如果: <code>array[next(k-1)] == array[n]</code></p>
<p>则: <code>array[0 ~ next(k-1)] ≡ array[n-next(k-1) ~ n]</code></p>
<p>∴ <code>next[n] = next(k-1)</code></p>
<p>如果: <code>array[next(k-1)] != array[n]</code></p>
<p>//TODO</p>
<h4 id="KMP-算法完整实现"><a href="#KMP-算法完整实现" class="headerlink" title="KMP 算法完整实现"></a>KMP 算法完整实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> haylength = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> nedlength = needle.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 特殊情况处理 */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == nedlength) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == haylength) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 计算 next 数组 */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">        next.resize(nedlength);</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nedlength - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || needle[i] == needle[j]) next[++i] = ++j;</span><br><span class="line">            <span class="keyword">else</span> j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* KMP 算法 */</span></span><br><span class="line">        <span class="keyword">while</span>((i &lt; haylength) &amp;&amp; (j &lt; nedlength))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || haystack[i] == needle[j]) &#123; i++; j++; &#125;</span><br><span class="line">            <span class="keyword">else</span> j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == nedlength) <span class="keyword">return</span> i - j;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-KMP-算法分析"><a href="#3-3-KMP-算法分析" class="headerlink" title="3.3 KMP 算法分析"></a>3.3 KMP 算法分析</h3><p>假设主串长度为 N, 子串长度为 M, 则</p>
<p>时间复杂度：最坏时间复杂度为 O(N + M)，最优时间复杂度为 O(M)</p>
<p>空间复杂度：O(N)</p>
<h2 id="4-解题方法-3-Rabin-Karp-算法"><a href="#4-解题方法-3-Rabin-Karp-算法" class="headerlink" title="4. 解题方法 3 - Rabin Karp 算法"></a>4. 解题方法 3 - Rabin Karp 算法</h2><h3 id="4-1-abin-Karp-算法背景"><a href="#4-1-abin-Karp-算法背景" class="headerlink" title="4.1 abin Karp 算法背景"></a>4.1 abin Karp 算法背景</h3><p>Michael O. Rabin 和 Richard M. Karp 在 1987 年提出一个想法，即可以对模式串进行哈希运算并将其哈希值与文本中子串的哈希值进行比对。总的来说这一想法非常浅显，唯一的问题在于我们需要找到一个哈希函数 ，它需要能够对不同的字符串返回不同的哈希值。例如，该哈希函数可能会对每个字符的 ASCII 码进行算，但同时我们也需要仔细考虑对多语种文本的支持。</p>
<h3 id="4-2-abin-Karp-算法实现"><a href="#4-2-abin-Karp-算法实现" class="headerlink" title="4.2 abin Karp 算法实现"></a>4.2 abin Karp 算法实现</h3><h4 id="abin-Karp-算法思想"><a href="#abin-Karp-算法思想" class="headerlink" title="abin Karp 算法思想"></a>abin Karp 算法思想</h4><p>Rabin Karp 算法也是对暴力算法的改进, 在比较文本串和模式串时, 暴力算法需要比较 O(M)* 次, 如果采用哈希运算的话, 就可以把比较降低为 O(1) 次:</p>
<blockquote>
<ul>
<li>假设文本串的长度为 N, 模式串的长度为 M</li>
</ul>
</blockquote>
<ol>
<li>计算模式串的 Hash 值 - O(M)</li>
<li>计算文本串中第一个个与模式串长度一致的子串的 Hash 值 -  O(m)</li>
<li>如果两个 Hash 值不一致, 则将计算文本串的下一个子串 Hash 值 - O(1), 并再次进行比较…</li>
<li>如果两个 Hash 值一致, 则将两个子串进行一次完整比较, 确认两个字符串完全一致</li>
</ol>
<h4 id="Hash-算法的选择"><a href="#Hash-算法的选择" class="headerlink" title="Hash 算法的选择"></a>Hash 算法的选择</h4><ul>
<li>由于需要在 O(1) 的事件复杂度内计算出 两个相邻子串的 Hash 值, 故基本不能使用各语言标准库中自带的 Hash 函数, 需要自己设计一个可以递推的 Hash 函数</li>
</ul>
<h5 id="常见的-Hash-算法-取模"><a href="#常见的-Hash-算法-取模" class="headerlink" title="常见的 Hash 算法 - 取模"></a>常见的 Hash 算法 - 取模</h5><p>比如一个字符串 ABCDE, 他的 Hash 值为:</p>
<p><code>Hash(ABCDE) = ( A * 31^4 + B * 31^3 + C * 31^2 + D * 31^1 + E ) % 100000</code></p>
<h4 id="abin-Karp-算法完整实现"><a href="#abin-Karp-算法完整实现" class="headerlink" title="abin Karp 算法完整实现"></a>abin Karp 算法完整实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> BASE = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">int</span> DIFF = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> haylength = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> nedlength = needle.length();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == nedlength) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == haylength) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nedhash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a : needle)</span><br><span class="line">        &#123;</span><br><span class="line">            nedhash = (nedhash * <span class="number">31</span> + a) % BASE;</span><br><span class="line">            DIFF = (DIFF * <span class="number">31</span>) % BASE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> hayhash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nedlength; i++)</span><br><span class="line">            hayhash = (hayhash * <span class="number">31</span> + haystack[i]) % BASE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= haylength - nedlength; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> != i)</span><br><span class="line">            &#123;</span><br><span class="line">                hayhash = (hayhash * <span class="number">31</span> + haystack[i + nedlength - <span class="number">1</span>]) % BASE;</span><br><span class="line">                hayhash = hayhash - (DIFF * haystack[i - <span class="number">1</span>])  % BASE;</span><br><span class="line">                <span class="keyword">if</span>(hayhash &lt; <span class="number">0</span>) hayhash += BASE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 两个 Hash 值一致, 则将两个子串进行一次完整比较 */</span></span><br><span class="line">            <span class="keyword">if</span>(hayhash == nedhash)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; nedlength; j++)</span><br><span class="line">                    <span class="keyword">if</span>(haystack[i + j] != needle[j]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(j == nedlength) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-abin-Karp-算法分析"><a href="#4-3-abin-Karp-算法分析" class="headerlink" title="4.3 abin Karp 算法分析"></a>4.3 abin Karp 算法分析</h3><p>假设主串长度为 N, 子串长度为 M, 则</p>
<p>时间复杂度：最坏时间复杂度为 O((N - M)M)，最优时间复杂度为 O(M)</p>
<p>空间复杂度：O(1)</p>
<h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h2><ul>
<li>[1] <a href="https://www.bilibili.com/video/BV1jb411V78H?from=search&amp;seid=6940275233034003274">天勤公开课 KMP 算法易懂版 哔哩哔哩</a></li>
<li>[2] <a href="https://www.cnblogs.com/zhangtianq/p/5839909.html">从头到尾彻底理解 KMP Chris_z 博客园</a></li>
<li>[3] <a href="https://www.ituring.com.cn/article/1759">图说 Rabin-Karp 字符串查找算法</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 拓扑排序</title>
    <url>/post/2021/fd828132/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>「先穿袜子，再穿鞋子」 —- 这就是一种拓扑排序</p>
<a id="more"></a>
<p>首先声明：拓扑排序并不是通常意义上的【排序】算法</p>
<h2 id="拓扑排序简介"><a href="#拓扑排序简介" class="headerlink" title="拓扑排序简介"></a>拓扑排序简介</h2><p>给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：</p>
<pre><code>对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面。
</code></pre><p>那么称该排列是图 G 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：</p>
<ol>
<li><p>如果图 G 中存在环，那么图 G 不存在拓扑排序（即只有「有向无环图」存在拓扑排序）</p>
</li>
<li><p>如果图 G 是有向无环图，那么它的拓扑排序可能不止一种</p>
</li>
</ol>
<p>在很多应用中， 有向无回路图用于说明事件发生的先后次序， 下图给出了一个实例，说明 Bumstead 教授早晨穿衣的过程。他必须先穿好某些衣服， 才能再穿其他衣服（如先穿袜子后才能穿鞋） ， 其他的一些衣服前可以按任意次序穿戴（如袜子和裤子）</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210112230616.png" alt="Bumstead 教授早晨穿衣的过程"></p>
<pre><code>图 a 为 Bumstead 教授对他所穿的衣服进行了拓扑排序
每一条有向边 (u,v) 都意味若必须先穿衣服 u 再穿衣服 v
深度优先搜索中的发现和完成时间都在每个顶点的旁边示出
图 b 为 经过拓扑排序后的同一图形
图中的各个顶点按照完成时间的递降顺序从左向右排列，注意所有的有向边都是从左指向右的
</code></pre><h2 id="拓扑排序的实现"><a href="#拓扑排序的实现" class="headerlink" title="拓扑排序的实现"></a>拓扑排序的实现</h2><p>为了说明如何得到一个有向无环图的拓扑排序，我们首先需要了解有向图节点的入度（indegree）和出度（outdegree）的概念：</p>
<ul>
<li>入度：设有向图中有一节点 $v$，其入度即为当前所有从其他节点出发，终点为 $v$ 的的边的数目。也就是所有指向 $v$ 的有向边的数目。</li>
<li>出度：设有向图中有一节点 $v$，其出度即为当前所有起点为 $v$，指向其他节点的边的数目。也就是所有由 $v$ 发出的边的数目。</li>
</ul>
<p>在了解了入度和出度的概念之后，再根据拓扑排序的定义，我们自然就能够得出结论：要想完成拓扑排序，我们每次都应当从入度为 0 的节点开始遍历。因为只有入度为 0 的节点才能够成为拓扑排序的起点。否则根据拓扑排序的定义，只要一个节点 $v$ 的入度不为 0，则至少有一条边起始于其他节点而指向 $v$，那么这条边的起点在拓扑排序的顺序中应当位于 $v$ 之前，则 $v$ 不能成为当前遍历的起点。</p>
<p>由此我们可以进一步得出一个改进的深度优先遍历或广度优先遍历算法来完成拓扑排序。</p>
<h3 id="广度优先算法实现拓扑排序"><a href="#广度优先算法实现拓扑排序" class="headerlink" title="广度优先算法实现拓扑排序"></a>广度优先算法实现拓扑排序</h3><p>广度优先算法实现拓扑排序需要多保存每一个节点对应的入度（普通遍历算法只需要保存节点之间的关系），并在遍历的每一层选取入度为 0 的节点开始遍历（普通遍历算法则可以从该吃呢个任意一个节点开始遍历）。这个算法描述如下：</p>
<ol>
<li>保存每一个节点与其他节点之间的关系，可以使用邻接表或者哈希表</li>
<li>计算并保存每一个节点的入度，可以使用数组</li>
<li>遍历选取入度为 0 的节点，并将该节点加入队列</li>
<li>取队列中的节点，加入排序结果列表，并将该节点的子节点的入度减 1</li>
<li>重复步骤 5，直到队列为空</li>
<li>如果排序结果列表和节点总数相同，代表遍历完了所有节点，否则说明有节点没有遍历到<ul>
<li>如果遍历完所有的节点，则排序结果列表即为当前图的拓扑排序</li>
<li>如果无法遍历完所有的节点，则意味着当前图不是有向无环图，不存在拓扑排序</li>
</ul>
</li>
</ol>
<h2 id="拓扑排序题目解析"><a href="#拓扑排序题目解析" class="headerlink" title="拓扑排序题目解析"></a>拓扑排序题目解析</h2><h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h3><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul>
<li>「力扣」第 207 题：课程表（中等）</li>
<li>「力扣」第 210 题：课程表 II（中等）</li>
<li>「力扣」第 301 题：最小高度树（中等）</li>
<li>「力扣」第 802 题：找到最终的安全状态（中等）</li>
<li>「力扣」第 1203 题：项目管理（困难）</li>
<li>「力扣」第 630 题：课程表 III（困难）</li>
<li>「力扣」第 329 题：矩阵中的最长递增路径（困难）</li>
<li>「力扣」第 1245 题：树的直径（中等）</li>
<li>「力扣」第 444 题：序列重建（中等）</li>
<li>「力扣」第 1136 题：平行课程（困难）</li>
<li>「力扣」第 269 题：火星词典（困难）</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/">课程表 - 课程表 - 力扣（LeetCode）</a></li>
<li>[2] <a href="https://www.jianshu.com/p/3347f54a3187">深入理解拓扑排序（Topological sort) - 简书</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 排序算法</title>
    <url>/post/2020/759c397f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200525214900.png" alt="各种排序算法的时间复杂度"></p>
<a id="more"></a>
<h2 id="时间复杂度O-n2"><a href="#时间复杂度O-n2" class="headerlink" title="时间复杂度O(n2)"></a>时间复杂度O(n<sup>2</sup>)</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210216200055.png" alt="插入排序"></p>
<h2 id="时间复杂度O-nlogn"><a href="#时间复杂度O-nlogn" class="headerlink" title="时间复杂度O(nlogn)"></a>时间复杂度O(nlog<sub>n</sub>)</h2><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h2 id="时间复杂度O-n"><a href="#时间复杂度O-n" class="headerlink" title="时间复杂度O(n)"></a>时间复杂度O(n)</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h2 id="时间复杂度O-amp"><a href="#时间复杂度O-amp" class="headerlink" title="时间复杂度O(!@#$%^&amp;*)"></a>时间复杂度O(!@#$%^&amp;*)</h2><h3 id="猴子排序"><a href="#猴子排序" class="headerlink" title="猴子排序"></a>猴子排序</h3><h3 id="睡眠排序"><a href="#睡眠排序" class="headerlink" title="睡眠排序"></a>睡眠排序</h3><h3 id="面条排序"><a href="#面条排序" class="headerlink" title="面条排序"></a>面条排序</h3><h3 id="珠排序"><a href="#珠排序" class="headerlink" title="珠排序"></a>珠排序</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 并查集</title>
    <url>/post/2020/4fe8298f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="并查集介绍"><a href="#并查集介绍" class="headerlink" title="并查集介绍"></a>并查集介绍</h2><p>在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合 - 查找算法（union-find algorithm）定义了两个用于此数据结构的操作：</p>
<ul>
<li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li>
<li>Union：将两个子集合并成同一个集合。</li>
</ul>
<p>由于支持这两种操作，一个不相交集也常被称为联合 - 查找数据结构（union-find data structure）或合并 - 查找集合（merge-find set）。</p>
<a id="more"></a>
<p>其他的重要方法：</p>
<ul>
<li>MakeSet，用于创建单元素集合。</li>
</ul>
<p>有了这些方法，许多经典的划分问题可以被解决。</p>
<p>为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。</p>
<h2 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h2><h3 id="并查集森林"><a href="#并查集森林" class="headerlink" title="并查集森林"></a>并查集森林</h3><p>并查集森林是一种将每一个集合以树表示的数据结构，其中每一个节点保存着到它的父节点的引用。这个数据结构最早由 Bernard A. Galler 和 Michael J. Fischer 于 1964 年提出，但是经过了数年才完成了精确的分析。</p>
<p>在并查集森林中，每个集合的代表即是集合的根节点。Find 根据其父节点的引用向根行进直到到底树根。Union 将两棵树合并到一起，这通过将一棵树的根连接到另一棵树的根。实现这样操作的一种方法是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> <span class="built_in">size</span>) : parent(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">size</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeSet</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; parent.<span class="built_in">size</span>()) parent[x] = x;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> osize = parent.<span class="built_in">size</span>();</span><br><span class="line">            parent.resize(x + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = osize; i &lt;= x; i++) parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> Find(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xRoot = Find(x);</span><br><span class="line">        <span class="keyword">int</span> yRoot = Find(y);</span><br><span class="line">        parent[xRoot] = yRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="并查集森林的优化"><a href="#并查集森林的优化" class="headerlink" title="并查集森林的优化"></a>并查集森林的优化</h3><h4 id="方法一：按秩合并"><a href="#方法一：按秩合并" class="headerlink" title="方法一：按秩合并"></a>方法一：按秩合并</h4><p>“按秩合并”，即总是将更小的树连接至更大的树上。因为影响运行时间的是树的深度，更小的树添加到更深的树的根上将不会增加秩除非它们的秩相同。在这个算法中，术语 “秩” 替代了 “深度”，因为同时应用了路径压缩时（见下文）秩将不会与高度相同。</p>
<h4 id="方法二：路径压缩"><a href="#方法二：路径压缩" class="headerlink" title="方法二：路径压缩"></a>方法二：路径压缩</h4><p>第二个优化，称为 “路径压缩”，是一种在执行 “查找” 时扁平化树结构的方法。关键在于在路径上的每个节点都可以直接连接到根上，他们都有同样的表示方法。为了达到这样的效果，Find 递归地经过树，改变每一个节点的引用到根节点。得到的树将更加扁平，为以后直接或者间接引用节点的操作加速。</p>
<h4 id="优化后代码"><a href="#优化后代码" class="headerlink" title="优化后代码"></a>优化后代码</h4><p>以上两种方法优化的代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> <span class="built_in">size</span>) : parent(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">size</span>)) ,rank(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">size</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 对 MakeSet 函数进行按秩合并优化 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeSet</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; parent.<span class="built_in">size</span>()) parent[x] = x;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> osize = parent.<span class="built_in">size</span>();</span><br><span class="line">            parent.resize(x + <span class="number">1</span>);</span><br><span class="line">            rank.resize(x + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = osize; i &lt;= x; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                rank[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 对 Find 函数进行路径压缩优化 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) parent[x] = Find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 对 Union 函数进行按秩合并优化 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xRoot = Find(x);</span><br><span class="line">        <span class="keyword">int</span> yRoot = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[xRoot] &lt; rank[yRoot]) parent[xRoot] = yRoot;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[xRoot] &gt; rank[yRoot]) parent[yRoot] = xRoot;</span><br><span class="line">        <span class="keyword">else</span> &#123;parent[yRoot] = xRoot; rank[xRoot]++; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="并查集题目解析"><a href="#并查集题目解析" class="headerlink" title="并查集题目解析"></a>并查集题目解析</h2><h3 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a>684. 冗余连接</h3><blockquote>
<p>684.冗余连接 - 力扣：<a href="https://leetcode-cn.com/problems/redundant-connection/">https://leetcode-cn.com/problems/redundant-connection/</a></p>
</blockquote>
<p>思路：</p>
<p>判断节点第一次出现环的边 edge 进行返回，如下图，当 1 的根节点是 4 的时候，从 1-&gt;2-&gt;3-&gt;41 出现一条路径，大概 [1,4] 这个 edge 进来后，发现 1 可以直接指向 4，这时候出现了环，这条边是冗余边</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200829193511.png" alt="冗余连接"></p>
<p>代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> rootp = uf.Find(edges[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> rootq = uf.Find(edges[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(rootp == rootq) <span class="keyword">return</span> edges[i];</span><br><span class="line">            uf.Union(rootp, rootq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h3><ul>
<li>「力扣」第 547 题：省份数量（中等）</li>
<li>「力扣」第 684 题：冗余连接（中等）</li>
<li>「力扣」第 1319 题：连通网络的操作次数（中等）</li>
<li>「力扣」第 1631 题：最小体力消耗路径（中等）</li>
<li>「力扣」第 959 题：由斜杠划分区域（中等）</li>
<li>「力扣」第 399 题：除法求值（中等）</li>
<li>「力扣」第 1202 题：交换字符串中的元素（中等）</li>
<li>「力扣」第 947 题：移除最多的同行或同列石头（中等）</li>
<li>「力扣」第 721 题：账户合并（中等）</li>
<li>「力扣」第 803 题：打砖块（困难）</li>
<li>「力扣」第 1579 题：保证图可完全遍历（困难）</li>
<li>「力扣」第 778 题：水位上升的泳池中游泳（困难）</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集 - 维基百科，自由的百科全书</a></li>
<li>[2] <a href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接 - 力扣（LeetCode）</a></li>
<li>[3] <a href="https://leetcode-cn.com/problems/redundant-connection/solution/yi-wen-zhang-wo-bing-cha-ji-suan-fa-by-a-fei-8/">一文掌握并查集算法 - 冗余连接 - 力扣（LeetCode）</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 最小生成树</title>
    <url>/post/2021/2d042192/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们定义无向连通图的 最小生成树（Minimum Spanning Tree，MST）为边权和最小的生成树。</p>
<blockquote>
<p>注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。</p>
</blockquote>
<a id="more"></a>
<h2 id="1584-连接所有点的最小费用"><a href="#1584-连接所有点的最小费用" class="headerlink" title="1584. 连接所有点的最小费用"></a>1584. 连接所有点的最小费用</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">https://leetcode-cn.com/problems/min-cost-to-connect-all-points/</a></p>
<p>给你一个 points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。</p>
<p>连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。</p>
<p>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。</p>
<p>示例：</p>
<pre><code>输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
输出：20
</code></pre><h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>Kruskal 算法是一种常见并且好写的最小生成树算法，由 Kruskal 发明。该算法的基本思想是从小到大加入边，是个贪心算法。</p>
<p>前置知识：</p>
<ol>
<li>并查集：<a href="/post/2020/4fe8298f/" title="数据结构与算法 - 并查集">数据结构与算法 - 并查集</a>)</li>
<li>贪心</li>
<li>图的存储（直接存边，邻接矩阵，邻接表）</li>
</ol>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是基础的并查集实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> n) : count(n) &#123;</span><br><span class="line">        parent.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n == parent[n] ? n : parent[n] = Find(parent[n]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = Find(a), rootB = Find(b);</span><br><span class="line">        <span class="keyword">if</span> (rootA != rootB) count--, parent[rootA] = rootB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个结构体使用直接存边的方式存图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len, x, y;</span><br><span class="line">    Edge(<span class="keyword">int</span> len = <span class="number">0</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>) : len(len), x(x), y(y) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> caldist = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 1. 建图 存储方式：直接存边</span></span><br><span class="line">        <span class="keyword">int</span> N = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            edges.emplace_back(caldist(i, j), i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 排序所有的边，贪心选择较短的边</span></span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        sort(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](Edge &amp;a, Edge &amp;b) &#123; <span class="keyword">return</span> a.len &lt; b.len; &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; edge : edges) &#123;</span><br><span class="line">            <span class="comment">// 如果这条边的左右顶点已经连接上 则跳过这条边 否则这条边加入最小生成树</span></span><br><span class="line">            <span class="keyword">if</span> (uf.Find(edge.x) == uf.Find(edge.y)) <span class="keyword">continue</span>;</span><br><span class="line">            uf.Union(edge.x, edge.y);</span><br><span class="line">            cost += edge.len;</span><br><span class="line">            <span class="keyword">if</span> (uf.Count() == <span class="number">1</span>) <span class="keyword">return</span> cost; <span class="comment">// 最小生成树已经生成</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>Accepted
72/72 cases passed (532 ms)
Your runtime beats 58.35 % of cpp submissions
Your memory usage beats 25.13 % of cpp submissions (56.9 MB)
</code></pre><h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><p>Prim 算法是一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。</p>
<p>在稠密图尤其是完全图上，暴力 Prim 的复杂度比 Kruskal 优，但不一定实际跑得更快。</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Distance 用来存储定点到最小生成树的距离</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Distance</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> index <span class="comment">/* 定点在 points 中的索引值 */</span>, len <span class="comment">/* 定点到最小生成树的距离 */</span>;</span><br><span class="line">    Distance(<span class="keyword">int</span> index = <span class="number">0</span>, <span class="keyword">int</span> len = <span class="number">0</span>) : index(index), len(len) &#123;&#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Distance&amp; a) <span class="keyword">const</span> &#123; <span class="keyword">return</span> len &gt; a.len; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> caldist = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Distance&gt; Q; <span class="comment">// 优先队列 用来查找距离最小生成树最近的点</span></span><br><span class="line">        Q.push(Distance&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            Distance e = Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">if</span> (!visited[e.index]) &#123;</span><br><span class="line">                cost += e.len;</span><br><span class="line">                visited[e.index] = <span class="number">1</span>; <span class="comment">// 将找到的最近的点加入最小生成树</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                    <span class="comment">// 遍历计算未加入点距离最小生成树的距离 这里不是最小距离 最小距离由优先队列选择</span></span><br><span class="line">                    <span class="keyword">if</span> (!visited[i] &amp;&amp; i != e.index) Q.push(Distance&#123;i, caldist(i, e.index)&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>Accepted
72/72 cases passed (668 ms)
Your runtime beats 24.34 % of cpp submissions
Your memory usage beats 64.91 % of cpp submissions (41.3 MB)
</code></pre><h2 id="特殊的-Prim-算法"><a href="#特殊的-Prim-算法" class="headerlink" title="特殊的 Prim 算法"></a>特殊的 Prim 算法</h2><p>对于稠密图来说，有一种特殊的 Prim 算法可以达到 O(n^2) 的时间复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> caldist = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 1. 建图 存储方式：邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span> N = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">edges</span><span class="params">(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">            edges[i][j] = edges[j][i] = caldist(i, j);</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; distance(N, INT_MAX), visited(N, 0);</span><br><span class="line">        distance[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 将 0 点加入最小生成树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123; <span class="comment">// 在剩余定点中，找到最小路径值的定点</span></span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; (next == <span class="number">-1</span> || distance[j] &lt; distance[next])) next = j;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[next] = <span class="literal">true</span>;         <span class="comment">// 将找到最小路径值的定点加入最小生成树</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; k++) &#123; <span class="comment">// 加入新定点后，导致连通分量到其他定点距离变化</span></span><br><span class="line">                <span class="keyword">if</span> (!visited[k]) distance[k] = <span class="built_in">min</span>(distance[k], edges[next][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(distance.<span class="built_in">begin</span>(), distance.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>Accepted
72/72 cases passed (128 ms)
Your runtime beats 82.67 % of cpp submissions
Your memory usage beats 75.12 % of cpp submissions (26.1 MB)
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://oi-wiki.org/graph/mst/">最小生成树 - OI Wiki</a></li>
<li>[2] <a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用 - 力扣（LeetCode）</a></li>
<li>[3] <a href="https://www.bilibili.com/video/BV1yh41117re">图的基础算法 (一) - MST 最小生成树_哔哩哔哩 (゜ - ゜) つロ 干杯~-bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 栈&amp;队列</title>
    <url>/post/2020/7c5d0b60/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-用栈实现队列"><a href="#1-用栈实现队列" class="headerlink" title="1. 用栈实现队列"></a>1. 用栈实现队列</h2><h3 id="leetCode-232-用栈实现队列"><a href="#leetCode-232-用栈实现队列" class="headerlink" title="leetCode 232. 用栈实现队列"></a>leetCode 232. 用栈实现队列</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">https://leetcode-cn.com/problems/implement-queue-using-stacks/</a></p>
<a id="more"></a>
<ul>
<li><strong>方法一：双栈 - 数据栈和缓存栈</strong></li>
</ul>
<p>思路：队列为 FIFO，而栈为 LIFO，用栈实现队列，需要将最后一个入栈的数据放到栈底，可通过引入缓存栈实现。</p>
<p>构建两个栈：栈 s1 作为数据栈，栈 s2 作为缓存栈；当数据入队时，将 s1 中所有数据缓存到 s2 中，然后将新元素压入 s2 ，最后再将 s2 中所有元素再压回 s1 中，这样操作之后，其他的队列操作（出队/判空/取队首元素）只需要操作 s1 即可。</p>
<ul>
<li><strong>方法二：双栈 - 入队栈和出队栈</strong></li>
</ul>
<p>思路: 栈 s1 作为入队栈，栈 s2 作为出队栈, 当数据入队时，将数据直接插入到 s1 中，当数据出队或获取队首元素时，需要从 s2 中取数据，如果取数据时 s2 为空，此时需要将 s1 中的所有数据压入到 s2 中，当 s1 和 s2 均为空栈时，证明该队列为空。</p>
<p>相对于方法一，该方法减少了数据在两个栈之间轮转, 将入栈的时间复杂度从O(n)降到了O(1)。</p>
<h2 id="2-用队列实现栈"><a href="#2-用队列实现栈" class="headerlink" title="2. 用队列实现栈"></a>2. 用队列实现栈</h2><h3 id="leetCode-225-用队列实现栈"><a href="#leetCode-225-用队列实现栈" class="headerlink" title="leetCode 225. 用队列实现栈"></a>leetCode 225. 用队列实现栈</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">https://leetcode-cn.com/problems/implement-stack-using-queues/</a></p>
<ul>
<li><strong>方法一：双队列 - 数据队列和缓存队列</strong></li>
</ul>
<p>思路：队列为 FIFO，而栈为 LIFO，用队列实现栈，需要将最后一个入队列的数据放到队列头，可通过引入缓存队列实现。</p>
<p>队列 q1 作为数据队列，队列 q2 作为缓存队列，当数据入队时，将 q1 中所有数据缓存到 q2 中，然后将新元素压入 q1 ，最后再将 q2 中所有元素再压回 q1 中，这样操作之后，其他的队列操作（出队/判空/取队首元素）只需要操作 q1 即可。</p>
<ul>
<li><strong>方法二：单队列</strong></li>
</ul>
<p>思路: 要实现将最后一个入队列的数据放到队列头，也可以不使用缓存队列，只需要将新压入队列的数据之前的数据循环弹出再压回队列内即可。</p>
<p>相对于方法一，该方法只需要使用一个队列, 可以降低空间占用（空间复杂度没有降低）。</p>
<h2 id="3-最小栈"><a href="#3-最小栈" class="headerlink" title="3. 最小栈"></a>3. 最小栈</h2><h3 id="leetCode-155-最小栈"><a href="#leetCode-155-最小栈" class="headerlink" title="leetCode 155. 最小栈"></a>leetCode 155. 最小栈</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p>
<ul>
<li><strong>方法一：辅助栈法</strong></li>
</ul>
<p>思路：一个栈保存数据，另一个栈保存最小值，两个栈同时 push 和 pop。</p>
<ul>
<li><strong>方法二：单栈 + 最小值法</strong></li>
</ul>
<p>思路：仅使用一个栈，栈中元素最小值使用变量保存。如果即将入栈的数据小于或等于最小值，则先把最小值压栈，再压入数据；出栈的时候如果出栈的数据与最小值相等，需要再弹出栈顶元素赋值给最小值。</p>
<h2 id="4-单调栈的应用"><a href="#4-单调栈的应用" class="headerlink" title="4. 单调栈的应用"></a>4. 单调栈的应用</h2><h3 id="leetCode-42-接雨水"><a href="#leetCode-42-接雨水" class="headerlink" title="leetCode 42. 接雨水"></a>leetCode 42. 接雨水</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/trapping-rain-water/">https://leetcode-cn.com/problems/trapping-rain-water/</a></p>
<ul>
<li><strong>方法一：暴力法及其优化</strong></li>
</ul>
<p>思路：对于每一个柱子，遍历其左侧的最高柱子和右侧的最高柱子，则可求得当前柱子的水位值，将所有位置的水位值进行累加即可。</p>
<p>改进：<strong>双指针法</strong> 通过双指针记录左右两侧的最高柱子，从而减少遍历。</p>
<ul>
<li><strong>方法二：单调栈法 - 单调递减栈</strong></li>
</ul>
<p>思路：记录一个柱子高度单调下降的栈（栈中保存的柱子的位置），如果即将入栈的柱子高度上升，则代表栈顶元素的位置可以保存雨水：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设栈顶元素为 top , 将 top 弹出后的新栈顶元素为 subtop , 即将入栈的元素为 index</span></span><br><span class="line">rainblock = (min(height[index]， height[subtop]) - height[top]) * (index - subtop - 1)</span><br></pre></td></tr></table></figure>
<p>过程中将每一个 rainblock 累加即可。</p>
<h3 id="leetCode-84-柱状图中最大的矩形"><a href="#leetCode-84-柱状图中最大的矩形" class="headerlink" title="leetCode 84.柱状图中最大的矩形"></a>leetCode 84.柱状图中最大的矩形</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p>
<ul>
<li><strong>方法一：暴力法及其优化</strong></li>
</ul>
<p>思路：对于每一个柱子，遍历寻找其左右两侧第一个低于当前柱子高度的柱子，则可求得完全覆盖当前柱子的矩形面积，将所有位置进行遍历，找到最大的矩形面积即可。</p>
<p>提交 Leetcode 测试，发现该方法会超时，原因是测试用例中有上万个高度为1的柱子的用例，在执行这个用例时，每个柱子都需要向前向后寻找左右两侧第一个低于当前柱子高度的柱子，造成时间的浪费，所以我们需要改进方案减少遍历次数。</p>
<p>改进：通过哈希表记录当前高度遍历到的最右侧柱子，如果当前柱子高度对应的哈希表中最右柱子在当前柱子右侧，则说明该高度的矩形已计算过，从而减少遍历。</p>
<ul>
<li><strong>方法二：单调栈法 - 单调递增栈</strong></li>
</ul>
<p>思路：记录一个柱子高度单调上升的栈（栈中保存的柱子的位置），如果即将入栈的柱子高度下降，则代表找到了栈顶元素的右侧边界，此时将栈顶元素弹出，新栈顶元素即为老栈顶元素高度的左侧边界，从而可以计算出栈顶元素对应矩形的面积:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设栈顶元素为 top , 将 top 弹出后的新栈顶元素为 subtop , 即将入栈的元素为 index</span></span><br><span class="line">Area = height[top] * (index - subtop - 1);</span><br></pre></td></tr></table></figure>
<p>过程中找出最大的 Area 值即可（记得最后要将栈弹空）。</p>
<h2 id="5-判断栈的-push-和-pop-序列是否一致"><a href="#5-判断栈的-push-和-pop-序列是否一致" class="headerlink" title="5. 判断栈的 push 和 pop 序列是否一致"></a>5. 判断栈的 push 和 pop 序列是否一致</h2><p>//TODO</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 最短路径</title>
    <url>/post/2021/b1770ae8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>图的最短路算法有很多，在此记录一下非常常用的四个算法</p>
<ul>
<li>单源最短路：<ul>
<li>不带负权边：<code>Dijkstra</code></li>
<li>带负权边：<code>Bellman-Ford</code>、<code>SPFA</code></li>
</ul>
</li>
<li>多源最短路：<ul>
<li>适用于正负权边：<code>Floyd</code>（但不能有负环）</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a>743. 网络延迟时间</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/network-delay-time/">https://leetcode-cn.com/problems/network-delay-time/</a></p>
<p>有 <code>n</code> 个网络节点，标记为 <code>1</code> 到 <code>n</code>。</p>
<p>给你一个列表 times，表示信号经过 有向 边的传递时间。<code>times[i] = (ui, vi, wi)</code>，其中 <code>ui</code> 是源节点，<code>vi</code> 是目标节点，<code>wi</code> 是一个信号从源节点传递到目标节点的时间。</p>
<p>现在，从某个节点 <code>K</code> 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 <code>-1</code> 。</p>
<p>示例：</p>
<p><img data-src="https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png" alt="743. 网络延迟时间"></p>
<pre><code>输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出：2
</code></pre><h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><p>支持负权。能找到某个结点出发到所有结点的最短路，或者报告某些最短路不存在。</p>
<p><code>SPFA</code> 算法就是 <code>Bellman-Ford</code> 算法的一种实现。</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distance</span><span class="params">(n + <span class="number">1</span>, INT_MAX / <span class="number">2</span>)</span></span>;</span><br><span class="line">        distance[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; n; t++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; relax = distance;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; time : times) &#123;</span><br><span class="line">                relax[time[<span class="number">1</span>]] = <span class="built_in">min</span>(relax[time[<span class="number">1</span>]], distance[time[<span class="number">0</span>]] + time[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            distance = relax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = *max_element(distance.<span class="built_in">begin</span>() + <span class="number">1</span>, distance.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX / <span class="number">2</span> ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>Accepted
52/52 cases passed (248 ms)
Your runtime beats 24.45 % of cpp submissions
Your memory usage beats 45.09 % of cpp submissions (36.2 MB)
</code></pre><h3 id="队列优化：SPFA"><a href="#队列优化：SPFA" class="headerlink" title="队列优化：SPFA"></a>队列优化：SPFA</h3><p>即 <code>Shortest Path Faster Algorithm</code>，很显然，只有上一次被松弛的结点所连接的边，才有可能引起下一次的松弛操作。</p>
<p>那么我们用队列来维护哪些结点可能会引起松弛操作，就能只访问必要的边了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 建图 存储方式：邻接表（索引方式）</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">edges</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            edges[times[i][<span class="number">0</span>]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 通过队列来判断哪些结点需要更新</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distance</span><span class="params">(n + <span class="number">1</span>, INT_MAX / <span class="number">2</span>)</span></span>;</span><br><span class="line">        distance[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">in_queue</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        q.push(k);</span><br><span class="line">        in_queue[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            in_queue[u] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; index : edges[u]) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = times[index][<span class="number">1</span>], w = times[index][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (distance[v] &gt; distance[u] + w) &#123;</span><br><span class="line">                    distance[v] = distance[u] + w;</span><br><span class="line">                    <span class="keyword">if</span> (!in_queue[v]) &#123;</span><br><span class="line">                        q.push(v);</span><br><span class="line">                        in_queue[v] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = *max_element(distance.<span class="built_in">begin</span>() + <span class="number">1</span>, distance.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX / <span class="number">2</span> ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>Accepted
52/52 cases passed (128 ms)
Your runtime beats 89.48 % of cpp submissions
Your memory usage beats 32.26 % of cpp submissions (37.6 MB)
</code></pre><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>这种算法只适用于非负权图，但是时间复杂度非常优秀。是可以用来求单源最短路径的算法。</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Target</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    Target(<span class="keyword">int</span> p = <span class="number">0</span>, <span class="keyword">int</span> t = <span class="number">0</span>) : pos(p), time(t) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Target&amp; a) <span class="keyword">const</span> &#123; <span class="keyword">return</span> time &gt; a.time; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">edges</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            edges[times[i][<span class="number">0</span>]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Target&gt; Q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cost</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        Q.push(Target&#123;k, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            Target t = Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">if</span> (!visited[t.pos]) &#123;</span><br><span class="line">                cost[t.pos] = t.time;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; index : edges[t.pos]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[times[index][<span class="number">1</span>]]) &#123;</span><br><span class="line">                        Q.push(Target&#123;times[index][<span class="number">1</span>], times[index][<span class="number">2</span>] + t.time&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[t.pos] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = *max_element(cost.<span class="built_in">begin</span>() + <span class="number">1</span>, cost.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>Accepted
52/52 cases passed (164 ms)
Your runtime beats 61.02 % of cpp submissions
Your memory usage beats 31.36 % of cpp submissions (38.7 MB)
</code></pre><h2 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h2><p>本质是动态规划，能解决任意两点间的最短路径，时间复杂度 O(V^3)</p>
<p>主要算法思想如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// i 到 j 的最短路径 = i 到 k 的最短路径 + k 到 j 的最短路径</span></span><br><span class="line">            <span class="comment">// 当然 要取较小值</span></span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">cost</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, INT_MAX / <span class="number">2</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cost[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : times) cost[t[<span class="number">0</span>] - <span class="number">1</span>][t[<span class="number">1</span>] - <span class="number">1</span>] = t[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; n; m++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    cost[i][j] = <span class="built_in">min</span>(cost[i][j], cost[i][m] + cost[m][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = *max_element(cost[k - <span class="number">1</span>].<span class="built_in">begin</span>(), cost[k - <span class="number">1</span>].<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX / <span class="number">2</span> ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>Accepted
52/52 cases passed (240 ms)
Your runtime beats 26.05 % of cpp submissions
Your memory usage beats 40.68 % of cpp submissions (36.4 MB)
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://oi-wiki.org/graph/shortest-path/">最短路 - OI Wiki</a></li>
<li>[2] <a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间 - 力扣（LeetCode）</a></li>
<li>[3] <a href="https://www.bilibili.com/video/BV1L5411G7P8">图的基础算法 (二) - SSSP/MSSP 单源 / 多源 最短路径_哔哩哔哩 (゜ - ゜) つロ 干杯~-bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 欧拉回路 &amp; 通路</title>
    <url>/post/2020/a98e5da5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="欧拉回路-amp-通路介绍"><a href="#欧拉回路-amp-通路介绍" class="headerlink" title="欧拉回路 &amp; 通路介绍"></a>欧拉回路 &amp; 通路介绍</h2><h3 id="一笔画问题"><a href="#一笔画问题" class="headerlink" title="一笔画问题"></a>一笔画问题</h3><p><strong>一笔画问题</strong>：给定一个 n 个点 m 条边的图，要求从指定的顶点出发，经过所有的边恰好一次。</p>
<h3 id="欧拉回路-amp-通路与一笔画问题的关系"><a href="#欧拉回路-amp-通路与一笔画问题的关系" class="headerlink" title="欧拉回路 &amp; 通路与一笔画问题的关系"></a>欧拉回路 &amp; 通路与一笔画问题的关系</h3><p>定义：</p>
<ul>
<li>通过图中所有边恰好一次且行遍所有顶点的通路称为 <strong>欧拉通路</strong>。</li>
<li>通过图中所有边恰好一次且行遍所有顶点的回路称为 <strong>欧拉回路</strong>。</li>
</ul>
<blockquote>
<ul>
<li>注：定义中边经过且仅经过 1 次，顶点的经过次数不受限制。</li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="欧拉图-amp-半欧拉图"><a href="#欧拉图-amp-半欧拉图" class="headerlink" title="欧拉图 &amp; 半欧拉图"></a>欧拉图 &amp; 半欧拉图</h3><p>定义：</p>
<ul>
<li>具有欧拉回路的图称为 <strong>欧拉图</strong>。</li>
<li>具有欧拉通路但不具有欧拉回路的图称为 <strong>半欧拉图</strong>。</li>
</ul>
<h3 id="欧拉图-amp-半欧拉图的判别"><a href="#欧拉图-amp-半欧拉图的判别" class="headerlink" title="欧拉图 &amp; 半欧拉图的判别"></a>欧拉图 &amp; 半欧拉图的判别</h3><p>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</p>
<ul>
<li>对于无向图 G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。</li>
<li>对于无向图 G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2 个奇度顶点。</li>
<li>对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</li>
<li>对于有向图 G，G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且<ul>
<li>恰有一个顶点的出度与入度差为 1；</li>
<li>恰有一个顶点的入度与出度差为 1；</li>
<li>所有其他顶点的入度和出度相同。</li>
</ul>
</li>
</ul>
<p>从上述描述中可知，如果图 G 是一个连通图，则可用如下表格判断其是否是欧拉图 / 半欧拉图：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>欧拉图（具有欧拉回路）</th>
<th>半欧拉图（欧拉通路）</th>
</tr>
</thead>
<tbody>
<tr>
<td>无向图</td>
<td>所有顶点都是偶度</td>
<td>所有顶点都是偶度或有且仅有两个奇度节点</td>
</tr>
<tr>
<td>有向图</td>
<td>所有节点的出度和入度均相同</td>
<td>有且仅有一个顶点的出度减入度等于 1 <br> 有且仅有一个顶点的入度减出度等于 1 <br> 所有其他顶点的入度和出度相同</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Code332-重新安排行程"><a href="#Code332-重新安排行程" class="headerlink" title="Code332 重新安排行程"></a>Code332 重新安排行程</h2><blockquote>
<p>332: 重新安排行程 - 力扣 <a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">https://leetcode-cn.com/problems/reconstruct-itinerary/</a></p>
</blockquote>
<p>将该题转化为一笔画问题：给定一个 n 个点 m 条边的图，要求从指定的顶点出发，经过所有的边恰好一次，<strong>且使得路径的字典序最小</strong>。</p>
<h3 id="Hierholzer-算法"><a href="#Hierholzer-算法" class="headerlink" title="Hierholzer 算法"></a>Hierholzer 算法</h3><p>Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：</p>
<ol>
<li>从起点出发，进行深度优先搜索。</li>
<li>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</li>
<li>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</li>
</ol>
<p>当我们顺序地考虑该问题时，我们也许很难解决该问题，因为我们无法判断当前节点的哪一个分支是「死胡同」分支。</p>
<p>不妨倒过来思考。我们注意到只有那个入度与出度差为 1 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。</p>
<p>对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。</p>
<p>这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。</p>
<p>另外，为了保证我们能够快速找到当前节点所连的节点中字典序最小的那一个，我们可以使用优先队列存储当前节点所连到的点，每次我们 O(1) 地找到最小字典序的节点，并 O(logm) 地删除它。</p>
<p>C++ 代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">priority_queue</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="built_in">string</span>&gt;&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (vec.count(curr) &amp;&amp; vec[curr].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = vec[curr].top();</span><br><span class="line">            vec[curr].pop();</span><br><span class="line">            dfs(<span class="built_in">move</span>(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        stk.emplace_back(curr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findItinerary</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : tickets) &#123;</span><br><span class="line">            vec[it[<span class="number">0</span>]].emplace(it[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line"></span><br><span class="line">        reverse(stk.<span class="built_in">begin</span>(), stk.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Code753-破解保险箱"><a href="#Code753-破解保险箱" class="headerlink" title="Code753 破解保险箱"></a>Code753 破解保险箱</h2><blockquote>
<p>753: 破解保险箱 - 力扣 <a href="https://leetcode-cn.com/problems/cracking-the-safe/">https://leetcode-cn.com/problems/cracking-the-safe/</a></p>
</blockquote>
<p>题目描述：</p>
<p>有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位是 k 位序列 0, 1, …, k-1 中的一个。</p>
<p>你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。</p>
<p>举个例子，假设密码是 “345”，你可以输入 “012345” 来打开它，只是你输入了 6 个字符.</p>
<p>请返回一个能打开保险箱的最短字符串。</p>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>这道题说的是给了 k 个数字，值为 0 到 k-1，让我们组成 n 位密码。我们可以发现，为了尽可能的使钥匙串变短，所以我们的密码之间尽可能要相互重叠：</p>
<ul>
<li>如果密码是 2 位数，00 和 001 共享一个数 0，可以用来解锁密码为 00 和 01 的两个保险箱</li>
<li>如果密码是 3 个数，012 和 0120 共享两个数 12，可以用来解锁密码为 012 和 120 的两个保险箱</li>
</ul>
<p>我们可以发现，两个长度为 n 的密码最好能共享 n-1 个数字，这样累加出来的钥匙串肯定是最短的。</p>
<p>密码共有 n 位，每一个位可以有 k 个数字，那么总共不同的密码总数就有 k<sup>n</sup> 个，而每个密码可以公用 n - 1 位，所以破解保险箱的密码最短长度为：n - 1 + k<sup>n</sup> 位。</p>
<p>我们可以考虑创建一个有 k<sup>n-1</sup> 个节点的图，每个节点有 k 条出边，则该图中一共有 k<sup>n</sup> 条边，将【节点代表的 n - 1 位数字 + 边代表的 1 位数字】作为经过该条边后尝试的密码值，而经过边后到达的新节点代表的 n - 1 位数字，可以作为下一个密码的前 n - 1 位数字使用，这样可以保证每个密码值不重复，又完全覆盖了 k<sup>n</sup> 个密码值。</p>
<p>以三位密码的二进制保险箱（n = 3, k = 2）举例：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200907002929.png" alt="3 位密码的破解保险箱"></p>
<p>我们可以按如下顺序遍历图中所有的边：</p>
<pre><code>00 -&gt; 00 -&gt; 01 -&gt; 11 -&gt; 11 -&gt; 10 -&gt; 01 -&gt; 10 -&gt; 00
00     0     1     1     1     0     1     0     0  --&gt; 0011101000
</code></pre><p>最后可得出破解该保险箱的最短字符顺序为：0011101000，其位数也正好为 n - 1 + k<sup>n</sup> = 3 - 1 + 2<sup>3</sup> = 10 位。</p>
<p>将其拓展为 n 位 k 个数字的密码：比如节点为 a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>…a<sub>n</sub> 经过边 a<sub>m</sub> 后的新节点为 a<sub>2</sub>a<sub>3</sub>…a<sub>n</sub>a<sub>m</sub>。</p>
<p>仍利用 Hierholzer 算法：</p>
<ol>
<li>从起点（以 n - 1 个 0 的节点作为起点，当然也可以选择其他节点）出发，进行深度优先搜索。</li>
<li>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边（标记该条边已经过）。</li>
<li>如果没有可移动的路径，则将所在节点加入到字符串中，并返回。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> node = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; side, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> i, <span class="built_in">string</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currNode = i % node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = currNode * k + j;</span><br><span class="line">            <span class="keyword">if</span> (!side[t]++) &#123; <span class="comment">/* 仅遍历没有走过的边 */</span></span><br><span class="line">                dfs(side, n, k, t, res);</span><br><span class="line">                res += j + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">crackSafe</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        node = <span class="built_in">pow</span>(k, n - <span class="number">1</span>);            <span class="comment">/* 节点个数 */</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">side</span><span class="params">(node * k, <span class="number">0</span>)</span></span>;   <span class="comment">/* 边数个标志，用来指示每条边是否遍历过 */</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        dfs(side, n, k, <span class="number">0</span>, res);         <span class="comment">/* 从 n -1 个 0 的节点开始寻找 */</span></span><br><span class="line">        res.append(n - <span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>);          <span class="comment">/* 补充起始节点字符串 */</span></span><br><span class="line">        <span class="keyword">return</span> res;                      <span class="comment">/* 无需 reverse，翻转前后均为正确答案 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/">重新安排行程 - 重新安排行程 - 力扣（LeetCode）</a></li>
<li>[2] <a href="https://leetcode-cn.com/problems/cracking-the-safe/solution/po-jie-bao-xian-xiang-by-leetcode/">破解保险箱 - 破解保险箱 - 力扣（LeetCode）</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 泛洪填充算法</title>
    <url>/post/2021/70c4ac0c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>泛洪填充算法 (Flood Fill Algorithm) 泛洪填充算法又称洪水填充算法是在很多图形绘制软件中常用的填充算法，最熟悉不过就是 windows paint 的油漆桶功能。算法的原理很简单，就是从一个点开始附近像素点，填充成新的颜色，直到封闭区域内的所有像素点都被填充新颜色为止。泛红填充实现最常见有四邻域像素填充法，八邻域像素填充法，基于扫描线的像素填充方法。根据实现又可以分为递归与非递归方法，递归方法一般通过深度优先搜索进行实现，非递归方法一般通过广度优先搜索或并查集实现。</p>
<a id="more"></a>
<h2 id="泛洪填充题目解析"><a href="#泛洪填充题目解析" class="headerlink" title="泛洪填充题目解析"></a>泛洪填充题目解析</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h4><p>题目描述：</p>
<pre><code>给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。

示例 1：

    输入：grid = [
        [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],
        [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],
        [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
        [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]
    ]
    输出：1
</code></pre><p>深度优先搜索解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> M, N;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dis&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isvalid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; M &amp;&amp; j &lt; N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markIand</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;d : dis) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + d[<span class="number">0</span>], y = j + d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isvalid(x, y) &amp;&amp; grid[x][y] == <span class="string">&#x27;1&#x27;</span>) markIand(grid, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        M = grid.<span class="built_in">size</span>();</span><br><span class="line">        N = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">/* 寻找未发现的岛屿 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123; <span class="comment">/* 找到新岛屿 进行标记 */</span></span><br><span class="line">                markIand(grid, i, j);</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><h4 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733. 图像渲染"></a>733. 图像渲染</h4><p>题目描述：</p>
<pre><code>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。
给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。

为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，
接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，
重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。

最后返回经过上色渲染后的图像。

示例 1:

    输入: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2
    输出: [[2,2,2],[2,2,0],[2,0,1]]
    解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),
          在路径上所有符合条件的像素点的颜色都被更改成2。
          注意，右下角的像素没有更改为2，
          因为它不是在上下左右四个方向上与初始点相连的像素点。
</code></pre><p>广度优先搜索解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> M, N;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dis&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isvalid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; M &amp;&amp; j &lt; N;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="built_in">image</span>, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preColor = <span class="built_in">image</span>[sr][sc];</span><br><span class="line">        <span class="keyword">if</span> (preColor == newColor) <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">        M = <span class="built_in">image</span>.<span class="built_in">size</span>();</span><br><span class="line">        N = <span class="built_in">image</span>[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace_back(sr, sc);</span><br><span class="line">        <span class="built_in">image</span>[sr][sc] = newColor;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = q.front().first, j = q.front().second;</span><br><span class="line">            q.pop_front();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; d : dis) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = i + d[<span class="number">0</span>], y = j + d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (isvalid(x, y) &amp;&amp; <span class="built_in">image</span>[x][y] == preColor) &#123;</span><br><span class="line">                    q.emplace_back(x, y);</span><br><span class="line">                    <span class="built_in">image</span>[x][y] = newColor;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="1020-飞地的数量"><a href="#1020-飞地的数量" class="headerlink" title="1020. 飞地的数量"></a>1020. 飞地的数量</h4><p>题目描述：</p>
<pre><code>给出一个二维数组 A，每个单元格为 0（代表海）或 1（代表陆地）。
移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。
返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。

示例 1：

    输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
    输出：3
    解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。

示例 2：

    输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
    输出：0
    解释：所有 1 都在边界上或可以到达边界。
</code></pre><p>并查集解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        parent.resize(n);</span><br><span class="line">        rank.resize(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n == parent[n] ? n : parent[n] = Find(parent[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = Find(a), rootB = Find(b);</span><br><span class="line">        <span class="keyword">if</span> (rootA != rootB) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootA] &gt; rank[rootB]) swap(rootA, rootB);</span><br><span class="line">            parent[rootA] = rootB;</span><br><span class="line">            rank[rootB] += rank[rootA] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rank</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> rank[Find(a)]; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> N = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> landCount = <span class="number">0</span>;</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(N * M + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> INDEX(i,j) ((i) * N + (j))</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            landCount++;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == M - <span class="number">1</span> || j == <span class="number">0</span> || j == N - <span class="number">1</span>) uf.Union(M * N, INDEX(i,j)); <span class="comment">// 边界</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; A[i - <span class="number">1</span>][j] == <span class="number">1</span>) uf.Union(INDEX(i - <span class="number">1</span>,j), INDEX(i,j)); <span class="comment">// 上侧</span></span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; A[i][j - <span class="number">1</span>] == <span class="number">1</span>) uf.Union(INDEX(i,j - <span class="number">1</span>), INDEX(i,j)); <span class="comment">// 左侧</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> landCount - uf.Rank(N * M);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="泛洪填充算法题目"><a href="#泛洪填充算法题目" class="headerlink" title="泛洪填充算法题目"></a>泛洪填充算法题目</h2><ul>
<li>「力扣」第 733 题：图像渲染（简单）<a href="https://leetcode-cn.com/problems/flood-fill/">https://leetcode-cn.com/problems/flood-fill/</a></li>
<li>「力扣」第 1034 题：边框着色（中等）<a href="https://leetcode-cn.com/problems/coloring-a-border">https://leetcode-cn.com/problems/coloring-a-border</a></li>
<li>「力扣」第 785 题：判断二分图（中等）<a href="https://leetcode-cn.com/problems/is-graph-bipartite">https://leetcode-cn.com/problems/is-graph-bipartite</a></li>
<li>「力扣」第 886 题：可能的二分法（中等）<a href="https://leetcode-cn.com/problems/possible-bipartition">https://leetcode-cn.com/problems/possible-bipartition</a></li>
<li>「力扣」第 529 题：扫雷游戏（中等）<a href="https://leetcode-cn.com/problems/minesweeper">https://leetcode-cn.com/problems/minesweeper</a></li>
<li>「力扣」第 200 题：岛屿数量（中等）<a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a></li>
<li>「力扣」第 827 题：最大人工岛（困难）<a href="https://leetcode-cn.com/problems/making-a-large-island">https://leetcode-cn.com/problems/making-a-large-island</a></li>
<li>「力扣」第 695 题：岛屿的最大面积（中等）<a href="https://leetcode-cn.com/problems/max-area-of-island">https://leetcode-cn.com/problems/max-area-of-island</a></li>
<li>「力扣」第 463 题：岛屿的周长（简单）<a href="https://leetcode-cn.com/problems/island-perimeter">https://leetcode-cn.com/problems/island-perimeter</a></li>
<li>「力扣」第 1254 题：统计封闭岛屿的数目（中等）<a href="https://leetcode-cn.com/problems/number-of-closed-islands">https://leetcode-cn.com/problems/number-of-closed-islands</a></li>
<li>「力扣」第 130 题：被围绕的区域（中等）<a href="https://leetcode-cn.com/problems/surrounded-regions">https://leetcode-cn.com/problems/surrounded-regions</a></li>
<li>「力扣」第 289 题：生命游戏（中等）<a href="https://leetcode-cn.com/problems/game-of-life">https://leetcode-cn.com/problems/game-of-life</a></li>
<li>「力扣」第 1020 题：飞地的数量（困难）<a href="https://leetcode-cn.com/problems/number-of-enclaves/">https://leetcode-cn.com/problems/number-of-enclaves/</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/wat1r/article/details/113702607">搜索与图论之 FloodFill_wat1r 的博客 - CSDN 博客</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 矩阵快速幂</title>
    <url>/post/2020/41da3a83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note success"><h2 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h2><ul>
<li>作者：力扣 (LeetCode)</li>
<li>链接：<a href="https://leetcode-cn.com/leetbook/read/dynamic-programming-2-plus/">https://leetcode-cn.com/leetbook/read/dynamic-programming-2-plus/</a></li>
<li>来源：力扣（LeetCode）</li>
<li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
</div>
<a id="more"></a>
<p>矩阵快速幂是一种基础算法，本身与动态规划没有关系，但常用于优化线性递推关系的计算，并且其思路比较固定，本章将矩阵快速幂做基础介绍。</p>
<p>动态规划主要用于解决两类问题，一类是优化问题，求最优解，另一类是组合计数，求方案数。<br>矩阵快速幂主要用在第二类，即组合计数，求方法数这类问题，可以将时间复杂度从 O(N) 降到 O(logN)。</p>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>==50. Pow(x, n)==</p>
<h3 id="快速幂的推导"><a href="#快速幂的推导" class="headerlink" title="快速幂的推导"></a>快速幂的推导</h3><p>不求 $a^{n}$ 而是求 $a^{\frac{n}{2}}$，然后先不求 $a^{\frac{n}{2}}$, 而是先求 $a^{\frac{n}{4}}$…</p>
<p>对以上思路最直接的实现方式是递归, 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> _myPow(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / _myPow(x, -n);</span><br><span class="line">    <span class="keyword">double</span> mid = _myPow(x, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> mid * mid * x;</span><br><span class="line">    <span class="keyword">return</span> mid * mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外还有另外一个代码实现技巧：二进制分解，n -&gt; 1, 2, 4, 8, 16, 32. n 可以分解为 2 的幂次的和 。例如 13 = 8 + 4 + 113=8+4+1，求 $a^{13}$ 需要求 $a^{8}$, $a^{4}$, $a^{1}$ 可以用变量存 $a^{1}$, $a^{2}$, …, $a^{n - 1}$，如果当前幂次是 n 需要的，则加到结果中。如何判断当前幂次是否需要，可以用位掩码来决定，即下面代码中的 n&amp;1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickpower</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// a==0 &amp;&amp; n==0 特判</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>; <span class="comment">// n = 0 时候不进循环</span></span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><h3 id="矩阵快速幂的推导"><a href="#矩阵快速幂的推导" class="headerlink" title="矩阵快速幂的推导"></a>矩阵快速幂的推导</h3><p>矩阵快速幂与快速幂的思想是一致的：求矩阵的幂 $A^{n}$ 的时候，先不求 $A^{n}$，而是先求 $A^{\frac{n}{2}}$，然后先不求 $A^{\frac{n}{2}}$，而是先求 $A^{\frac{n}{4}}$, …</p>
<p>以上思路同样可以用二进制分解加位掩码来实现, 只是当某个位掩码为 1 表示该位需要的时候, 做的是快速幂做的是乘法，矩阵快速幂做的是矩阵乘法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">        ans = ans * A; <span class="comment">// 这一步是矩阵的乘法</span></span><br><span class="line">    A = A * A;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵快速幂的代码模板"><a href="#矩阵快速幂的代码模板" class="headerlink" title="矩阵快速幂的代码模板"></a>矩阵快速幂的代码模板</h3><p>实现矩阵快速幂，可以先写一个 struct Matrix 表示矩阵，之后的乘法，求幂都是针对这个类的运算。</p>
<p>其中用一个二维数组做数据成员，一个 init() 方法，将矩阵初始化为单位阵 (相当于 $A^{0}$) 的结果。<br>然后重载 * 和 ^ 分别表示矩阵乘法和矩阵快速幂。代码如下：</p>
<p>其中 M 表示方阵的行数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ma</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[M][M];</span><br><span class="line">    Ma()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 复位为单位阵</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ma <span class="keyword">operator</span>*(<span class="keyword">const</span> Ma&amp; B) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Ma ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; M; ++k)</span><br><span class="line">                    ans.a[i][j] += a[i][k] * B.a[k][j];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ma <span class="keyword">operator</span>^(<span class="keyword">int</span> n) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Ma ans;</span><br><span class="line">        ans.init();</span><br><span class="line">        Ma A = *<span class="keyword">this</span>; <span class="comment">// 拷贝一个出来用于自乘</span></span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">                ans = ans * A;</span><br><span class="line">            A = A * A;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵快速幂的适用问题"><a href="#矩阵快速幂的适用问题" class="headerlink" title="矩阵快速幂的适用问题"></a>矩阵快速幂的适用问题</h3><p>矩阵快速幂主要用于线性的递推型计数问题，以及一些动态规划中状态转移方程是线性递推关系的时候。有一些计数问题，通过对 n 比较小的情况进行手动推导，发现规律，可以猜想出递推关系。如果这个递推关系是线性，那么它可以转换成矩阵求幂问题，进而可以用矩阵快速幂加速。</p>
<p>例如斐波那契问题，即力扣第 70 题</p>
<p>【70. 爬楼梯】</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201005111813.png" alt="70. 爬楼梯"></p>
<p>我们会思考是否可以构造一个矩阵 A，使得：</p>
<script type="math/tex; mode=display">\begin{bmatrix} a_{00} & a_{01} \\ a_{10} & a_{11} \end{bmatrix}\begin{bmatrix} f(0) \\ f(1) \end{bmatrix} = \begin{bmatrix} f(1) \\ f(2) \end{bmatrix}</script><p>通过一些推导，可以得到 $A = \begin{bmatrix} 0 &amp; 1 \\ 1 &amp; 1 \end{bmatrix}$， 此关系可以继续推导下去，直到推出 $\begin{bmatrix} f(n) \\ f(n + 1) \end{bmatrix}$</p>
<p>最终可以得到：</p>
<script type="math/tex; mode=display">\begin{bmatrix} f(n) \\ f(n + 1) \end{bmatrix} = A^{n}\begin{bmatrix} f(0) \\ f(1) \end{bmatrix} = {\begin{bmatrix} 0 & 1 \\ 1 & 1 \end{bmatrix}}^{n}\begin{bmatrix} f(0) \\ f(1) \end{bmatrix}</script><p>推出以上公式之后就可以用套矩阵快速幂的算法求 $A^{n}$ 了，此过程时间复杂度为 $O(M^{3}logN)$，M 为方阵的行数。</p>
<p>其它的线性递推关系均可以这样做：先找规律得到递推关系，然后将递推关系变为矩阵的形式，套矩阵快速幂。</p>
<p>例如：$f(n) = 3f(n - 1) + 6f(n - 2) - 7f(n - 3)$，的递推关系，可以变为矩阵形式</p>
<script type="math/tex; mode=display">\begin{bmatrix} f(1) \\ f(2) \\ f(3) \end{bmatrix} = \begin{bmatrix} 0 & 1 & 0 \\ 0 & 0 & 1 \\ -7 & 6 & 3 \end{bmatrix}\begin{bmatrix} f(0) \\ f(1) \\ f(2) \end{bmatrix}</script><p>在上一章中的 16 道练习题中，部分题目的递推关系是线性的，进而可以用矩阵快速幂来做，尝试判断哪些题目可以用矩阵快速幂做，并用矩阵快速幂解决这些问题，加深对本节的理解。</p>
<h2 id="推荐阅读顺序"><a href="#推荐阅读顺序" class="headerlink" title="推荐阅读顺序"></a>推荐阅读顺序</h2><ol>
<li><a href="/post/2020/aecf6ec6/" title="数据结构与算法 - 动态规划（简介）">数据结构与算法 - 动态规划（简介）</a></li>
<li><a href="/post/2020/610682be/" title="数据结构与算法 - 动态规划（线性动态规划）">数据结构与算法 - 动态规划（线性动态规划）</a></li>
<li><a href="/post/2020/9158b835/" title="数据结构与算法 - 动态规划（前缀和）">数据结构与算法 - 动态规划（前缀和）</a></li>
<li><a href="/post/2020/cb02a3b0/" title="数据结构与算法 - 动态规划（区间动态规划）">数据结构与算法 - 动态规划（区间动态规划）</a></li>
<li><a href="/post/2020/2cea0e37/" title="数据结构与算法 - 动态规划（背包问题）">数据结构与算法 - 动态规划（背包问题）</a></li>
<li><a href="/post/2020/2a7541d6/" title="数据结构与算法 - 动态规划（状态压缩）">数据结构与算法 - 动态规划（状态压缩）</a></li>
<li><a href="/post/2020/8ed94cfd/" title="数据结构与算法 - 动态规划（计数问题）">数据结构与算法 - 动态规划（计数问题）</a></li>
<li><a href="/post/2020/41da3a83/" title="数据结构与算法 - 矩阵快速幂">数据结构与算法 - 矩阵快速幂</a></li>
<li><a href="/post/2020/16341583/" title="数据结构与算法 - 动态规划（数位动态规划）">数据结构与算法 - 动态规划（数位动态规划）</a>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 逆元</title>
    <url>/post/2021/47588647/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于加减乘运算都会满足：</p>
<p>　　<script type="math/tex">(a + b) \bmod p = a \bmod p + b \bmod p</script></p>
<p>　　<script type="math/tex">(a - b) \bmod p = a \bmod p - b \bmod p</script></p>
<p>　　<script type="math/tex">(a \times b) \bmod p = a \bmod p \times (b \bmod p)</script></p>
<p>但是对于除法而言 $ (a/b) \bmod p \neq (a \bmod p) / (b \bmod p) $</p>
<p>这个可以通过举例验证一下或者可以通过 $b \bmod p$ 可以为 0 但是分母不能为 0 得到对于除法而言不满足这个运算的结论。</p>
<p>但是如果非要求 $(a/b) \bmod p$ 要怎么办呢？</p>
<a id="more"></a>
<h2 id="逆元的定义"><a href="#逆元的定义" class="headerlink" title="逆元的定义"></a>逆元的定义</h2><p>为了解决模意义下的除法问题，我们引入了逆元 $\text{inv}(a)$。 $\text{inv}(a)$ 其实可以看做模 $p$ 意义下的 $\displaystyle\frac{1}{a}$ ，那么在模 $p$ 意义下， $\displaystyle\frac{a}{b}$ 就可以变形为 $a\cdot \text{inv}(b))$</p>
<p>定义：如果一个线性同余方程 $ax \equiv 1 \pmod b$ ，则 $x$ 称为 $a \bmod b$ 的逆元，记作 $\text{inv}(a)$ 。</p>
<h2 id="逆元的求解"><a href="#逆元的求解" class="headerlink" title="逆元的求解"></a>逆元的求解</h2><p>这里介绍三种计算逆元的方法：拓展欧几里得，费马小定理，线性递推。</p>
<h3 id="拓展欧几里得"><a href="#拓展欧几里得" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h3><h4 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h4><p>如果我们已知两个数 $a$ 和 $b$ ，如何求出二者的最大公约数呢？</p>
<p>不妨设 $a &gt; b$</p>
<p>我们发现如果 $b$ 是 $a$ 的约数，那么 $b$ 就是二者的最大公约数。<br>下面讨论不能整除的情况，即 $a = b \times q + r$ ，其中 $r &lt; b$ 。</p>
<p>我们通过证明可以得到 $\gcd(a,b)=\gcd(b,a \bmod b)$ ，过程如下：</p>
<hr>
<p>设 $a=bk+c$ ，显然有 $c=a \bmod b$ 。设 $d|a\ \ \ d|b$ ，则 $c=a-bk$  $\frac{c}{d}=\frac{a}{d}-\frac{b}{d}k$ 由右边的式子可知 $\frac{c}{d}$ 为整数，即 $d|c$ 所以对于 $a,b$ 的公约数，它也会是 $a \bmod b$ 的公约数。</p>
<p>反过来也需要证明</p>
<p>设 $d|b\ \ \ d|(a \bmod b)$ ，我们还是可以像之前一样得到以下式子 $\frac{a\bmod b}{d}=\frac{a}{d}-\frac{b}{d}k$  $\frac{a\bmod b}{d}+\frac{b}{d}k=\frac{a}{d}$ 因为左边式子显然为整数，所以 $\frac{a}{d}$ 也为整数，即 $d|a$ ，所以 $b,a\bmod b$ 的公约数也是 $a,b$ 的公约数。</p>
<p>既然两式公约数都是相同的，那么最大公约数也会相同。</p>
<p>所以得到式子 $\gcd(a,b)=\gcd(b,a\bmod b)$</p>
<p>既然得到了 $\gcd(a, b) = \gcd(b, r)$ ，这里两个数的大小是不会增大的，那么我们也就得到了关于两个数的最大公约数的一个递归求法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归至 <code>b==0</code> （即上一步的 <code>a%b==0</code> ) 的情况再返回值即可。</p>
<hr>
<h4 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h4><p>扩展欧几里德定理（Extended Euclidean algorithm, EXGCD），常用于求 $ax+by=\gcd(a,b)$ 的一组可行解。</p>
<p>证明：</p>
<p>设</p>
<p>$ax_1+by_1=\gcd(a,b)$</p>
<p>$bx_2+(a\bmod b)y_2=\gcd(b,a\bmod b)$</p>
<p>由欧几里得定理可知： $\gcd(a,b)=\gcd(b,a\bmod b)$</p>
<p>所以 $ax_1+by_1=bx_2+(a\bmod b)y_2$</p>
<p>又因为 $a\bmod b=a-(\lfloor\frac{a}{b}\rfloor\times b)$</p>
<p>所以 $ax_1+by_1=bx_2+(a-(\lfloor\frac{a}{b}\rfloor\times b))y_2$</p>
<p> $ax_1+by_1=ay_2+bx_2-\lfloor\frac{a}{b}\rfloor\times by_2=ay_2+b(x_2-\lfloor\frac{a}{b}\rfloor y_2)$</p>
<p>因为 $a=a,b=b$ ，所以可令 $x_1=y_2,y_1=x_2-\lfloor\frac{a}{b}\rfloor y_2$</p>
<p>将 $x_2,y_2$ 不断代入递归求解直至 GCD（最大公约数，下同）为 <code>0</code> 递归 <code>x=1,y=0</code> 回去求解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = Exgcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数返回的值为 GCD，在这个过程中计算 $x,y$ 即可。</p>
<h4 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h4><p>形如 $ax \equiv c \pmod b$ 的方程被称为 线性同余方程 (Congruence Equation)。</p>
<p>根据以下两个定理，我们可以求出同余方程 $ax \equiv c \pmod b$ 的解。</p>
<p>定理 1 ：方程 $ax+by=c$ 与方程 $ax \equiv c \pmod b$ 是等价的，有整数解的充要条件为 $\gcd(a,b) \mid c$</p>
<p>根据定理 1，方程 $ax+by=c$，我们可以先用扩展欧几里得算法求出一组 $x_0,y_0$ ，也就是 $ax_0+by_0=\gcd(a,b)$，然后两边同时除以 $\gcd(a,b)$，再乘 $c$。然后就得到了方程 $a\dfrac{c}{\gcd(a,b)}x_0+b\dfrac{c}{\gcd(a,b)}y_0=c$，然后我们就找到了方程的一个解。</p>
<p>定理 2 ：若 $\gcd(a,b)=1$，且 $x_0$、$y_0$ 为方程 $ax+by=c$ 的一组解，则该方程的任意解可表示为：$x=x_0+bt$，$y=y_0-at$ , 且对任意整数 $t$ 都成立。</p>
<p>根据定理 2，可以求出方程的所有解。但在实际问题中，我们往往被要求求出一个最小整数解，也就是一个特解 $x=(x \bmod t+t) \bmod t$，其中 $t=\dfrac{b}{\gcd(a,b)}$。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展欧几里得法和求解 线性同余方程 是一个原理，在这里不展开解释。</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>费马小定理是数论里的重要定理，叙述如下：</p>
<blockquote>
<p>若 $p$ 是质数，且 $\gcd(a,p)=1$ ，则有 $a^{p-1}\equiv1\pmod{p}$</p>
</blockquote>
<p>从逆元的定义推导，可得：</p>
<script type="math/tex; mode=display">a\cdot\text{inv}(a)\equiv1\equiv a^{p-1}\pmod{p}</script><p>于是有：</p>
<script type="math/tex; mode=display">\text{inv}(a)\equiv a^{p-2}\pmod{p}</script><p>于是对 $a^{p-2}$ 算一下快速幂就好了。注意这个方法只对 $p$ 是质数的情形有效。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速幂算法 (a ^ n) mod p</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    a = (a % p + p) % p;</span><br><span class="line">    <span class="keyword">for</span> (; n; n&gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans = (a * ans) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a mod b</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qpow(a, p - <span class="number">2</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h4><pre><code>快速幂算法解读（以 3^10 为例）：

3^10 = (3*3*3*3*3*3*3*3*3*3)

尽量想办法把指数变小来，这里的指数为 10

3^10 = (3*3)*(3*3)*(3*3)*(3*3)*(3*3)
     = (3*3)^5
     = 9^5

此时指数由 10 缩减一半变成了 5，而底数变成了原来的平方
求 3^10 原本需要执行 10 次循环操作，求 9^5 却只需要执行 5 次循环操作
但是 3^10 却等于 9^5, 我们用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好
例如 2^10000=4^5000, 底数只是做了一个小小的平方操作，而指数就从 10000 变成了 5000，减少了 5000 次的循环操作。

现在我们的问题是如何把指数 5 变成原来的一半，5 是一个奇数，5 的一半是 2.5
但是我们知道，指数不能为小数，因此我们不能这么简单粗暴的直接执行 5/2
然而，这里还有另一种方法能表示 9^5

9^5 =（9^4）*（9^1）

此时我们抽出了一个底数的一次方，这里即为 9^1，这个 9^1 我们先单独移出来
剩下的 9^4 又能够在执行缩指数操作了，把指数缩小一半，底数执行平方操作

9^5 =（81^2）*(9^1)

把指数缩小一半，底数执行平方操作

9^5 =（6561^1）*(9^1)

此时，我们发现指数又变成了一个奇数 1
按照上面对指数为奇数的操作方法，应该抽出了一个底数的一次方，这里即为 6561^1
这个 6561^1 我们先单独移出来，但是此时指数却变成了 0，也就意味着我们无法再进行缩指数操作了

9^5 =（6561^0）*(9^1)*(6561^1)
    = 1*(9^1)*(6561^1)
    = (9^1)*(6561^1)
    = 9*6561
    = 59049

我们能够发现，最后的结果是 9*6561
而 9 是怎么产生的？是不是当指数为奇数 5 时，此时底数为 9
那 6561 又是怎么产生的呢？是不是当指数为奇数 1 时，此时的底数为 6561

所以我们能发现一个规律：最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积
</code></pre>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 自平衡二叉搜索树</title>
    <url>/post/2020/4e311301/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二叉搜索树的缺陷"><a href="#二叉搜索树的缺陷" class="headerlink" title="二叉搜索树的缺陷"></a>二叉搜索树的缺陷</h2><p>二叉搜索树的插入顺序决定了二叉搜索树的结构，如果按照 [1,2,3,4,5,6] 这样的顺序插入，其流程是这样的：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200809204257.gif" alt="二叉搜索树的缺陷"></p>
<a id="more"></a>
<p>如果在上面的二叉搜索树中查找 6，是要将所有节点都遍历一遍的，时间复杂度就变成了 O(n)，几乎就是一个链表。</p>
<p>细心的朋友可能已经发现，插入的序列越接近有序，生成的二叉搜索树就越像一个链表。</p>
<p>为了避免二叉搜索树变成 “链表”，我们引入了自平衡二叉搜索树（平衡二叉树，AVL 树），即让树的结构看起来尽量 “均匀”，左右子树的节点数尽量一样多。</p>
<h2 id="平衡二叉搜索树的特点"><a href="#平衡二叉搜索树的特点" class="headerlink" title="平衡二叉搜索树的特点"></a>平衡二叉搜索树的特点</h2><p>平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树（有别于 AVL 算法），且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</p>
<h2 id="平衡二叉搜索树的生成"><a href="#平衡二叉搜索树的生成" class="headerlink" title="平衡二叉搜索树的生成"></a>平衡二叉搜索树的生成</h2><p>那给定插入序列，如何生成一棵平衡二叉树呢？</p>
<h3 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h3><p>某结点的左子树与右子树的高度 (深度) 差即为该结点的平衡因子（BF,Balance Factor）。平衡二叉树上所有结点的平衡因子只可能是 -1，0 或 1。如果某一结点的平衡因子绝对值大于 1 则说明此树不是平衡二叉树。</p>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>往平衡二叉树中添加节点很可能会导致二叉树失去平衡，所以我们需要在每次插入节点后进行平衡的维护操作。插入节点破坏平衡性有如下四种情况：</p>
<ol>
<li>新加入节点为 node.left 的左孩子， height(node.left) - height(node.right) &gt; 1 。直接对 node 节点右旋。</li>
<li>新加入节点为 node.left 的右孩子， height(node.left) - height(node.right) &gt; 1 。这时候要先对 node.left 左旋，调整为 1 的情况，再进行右旋。</li>
<li>新加入节点为 node.right 的右孩子， height(node.right) - height(node.left) &gt; 1 。直接对 node 节点左旋。</li>
<li>新加入节点为 node.right 的左孩子， height(node.right) - height(node.left) &gt; 1 。这时候要先对 node.right 右旋，调整为 3 的情况，再进行左旋。</li>
</ol>
<p>要注意的是，节点旋转的时候，高度不是简单的 +/-1，而是要根据从当前节点旋转调整后的左右节点高度中获取较大值 +1。旋转高度调整完成后，返回 node 节点时候，也要重新计算一下新的高度，其高度为左右子树最大值 +1。</p>
<h4 id="LL（右旋）"><a href="#LL（右旋）" class="headerlink" title="LL（右旋）"></a>LL（右旋）</h4><p>LL 的意思是向左子树（L）的左孩子（L）中插入新节点后导致不平衡，这种情况下需要右旋操作。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200809205756.gif" alt="右旋"></p>
<p>代码示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* node 节点右旋</span></span><br><span class="line"><span class="comment">* @param node node</span></span><br><span class="line"><span class="comment">* @param nodeHeight node 高度缓存</span></span><br><span class="line"><span class="comment">* @return 旋转后的当前节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">rotateRight</span><span class="params">(TreeNode* node, <span class="built_in">map</span>&lt;TreeNode*,<span class="keyword">int</span>&gt;&amp; nodeHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// --- 指针调整</span></span><br><span class="line">    TreeNode* left = node-&gt;left;</span><br><span class="line">    node-&gt;left = left-&gt;right;</span><br><span class="line">    left-&gt;right = node;</span><br><span class="line">    <span class="comment">// --- 高度更新</span></span><br><span class="line">    <span class="comment">// 先更新 node 节点的高度，这个时候 node 是 right 节点的左孩子</span></span><br><span class="line">    <span class="keyword">int</span> newNodeHeight = getCurNodeNewHeight(node, nodeHeight);</span><br><span class="line">    nodeHeight[node] = newNodeHeight;</span><br><span class="line">    <span class="comment">// 更新原 left 节点高度 取现在 right 左右子树最大高度 + 1</span></span><br><span class="line">    nodeHeight[left] = <span class="built_in">max</span>(newNodeHeight, nodeHeight[left-&gt;left]) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取当前节点的新高度</span></span><br><span class="line"><span class="comment">* @param node node</span></span><br><span class="line"><span class="comment">* @param nodeHeight node 高度缓存</span></span><br><span class="line"><span class="comment">* @return 当前 node 的新高度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCurNodeNewHeight</span><span class="params">(TreeNode&amp; node, <span class="built_in">map</span>&lt;TreeNode*,<span class="keyword">int</span>&gt;&amp; nodeHeight)</span></span>&#123;</span><br><span class="line">    <span class="comment">// node 节点的高度，为现在 node 左右子树最大高度 + 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(nodeHeight[node.left], nodeHeight[node.right]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RR（左旋）"><a href="#RR（左旋）" class="headerlink" title="RR（左旋）"></a>RR（左旋）</h4><p>RR 的意思是向右子树（R）的右孩子（R）中插入新节点后导致不平衡，这种情况下需要左旋操作。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200809205756.gif" alt="左旋"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* node 节点左旋</span></span><br><span class="line"><span class="comment">* @param node node</span></span><br><span class="line"><span class="comment">* @param nodeHeight node 高度缓存</span></span><br><span class="line"><span class="comment">* @return 旋转后的当前节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">rotateLeft</span><span class="params">(TreeNode* node, <span class="built_in">map</span>&lt;TreeNode*,<span class="keyword">int</span>&gt;&amp; nodeHeight)</span></span>&#123;</span><br><span class="line">    <span class="comment">// --- 旋转进行指针调整</span></span><br><span class="line">    TreeNode* right = node-&gt;right;</span><br><span class="line">    node-&gt;right = right-&gt;left;</span><br><span class="line">    right-&gt;left = node;</span><br><span class="line">    <span class="comment">// --- 高度更新</span></span><br><span class="line">    <span class="comment">// 先更新 node 节点的高度，这个时候 node 是 right 节点的左孩子</span></span><br><span class="line">    <span class="keyword">int</span> newNodeHeight = getCurNodeNewHeight(node, nodeHeight);</span><br><span class="line">    nodeHeight[node] = newNodeHeight;</span><br><span class="line">    <span class="comment">// 取现在 right 左右子树最大高度 + 1 更新原 right 节点高度</span></span><br><span class="line">    nodeHeight[right] = <span class="built_in">max</span>(newNodeHeight,nodeHeight.getOrDefault(right.right,<span class="number">0</span>)) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/solution/shou-si-avlshu-wo-bu-guan-wo-jiu-shi-yao-xuan-zhua/">手撕 AVL 树，我不管，我就是要旋转 - 将二叉搜索树变平衡 - 力扣（LeetCode）</a></li>
<li>[2] <a href="https://blog.csdn.net/qq_25343557/article/details/89110319">详细图文——AVL树_带翅膀的猫的博客 - CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法 - 链表</title>
    <url>/post/2021/759c397f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="链表基础"><a href="#链表基础" class="headerlink" title="链表基础"></a>链表基础</h2><p>链表的定义（来自维基百科）：</p>
<p>在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个或下一个节点的位置的链接。</p>
<a id="more"></a>
<p>链表与顺序表的区别（来自维基百科）：</p>
<p>链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针 (Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到 O(1) 的复杂度，比顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要 O(n) 的时间，而顺序表相应的时间复杂度分别是 O(logn) 和 O(1)。</p>
<p>链表的优缺点（来自维基百科）：</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。<br>链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p>
<p>链表的类型（来自维基百科）：</p>
<p>单向链表，双向链表以及循环链表。</p>
<h2 id="链表练习题目"><a href="#链表练习题目" class="headerlink" title="链表练习题目"></a>链表练习题目</h2><h3 id="链表中的双指针技巧"><a href="#链表中的双指针技巧" class="headerlink" title="链表中的双指针技巧"></a>链表中的双指针技巧</h3><ul>
<li><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个节点</a></li>
<li><a href="https://leetcode-cn.com/problems/partition-list">86. 分隔链表</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii">92. 反转链表 II</a></li>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a></li>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">142. 环形链表 II</a></li>
<li><a href="https://leetcode-cn.com/problems/reorder-list">143. 重排链表</a></li>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">160. 相交链表</a></li>
<li><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree">109. 有序链表转换二叉搜索树</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list">206. 反转链表</a></li>
<li><a href="https://leetcode-cn.com/problems/palindrome-linked-list">234. 回文链表</a></li>
<li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">876. 链表的中间结点</a></li>
</ul>
<h3 id="链表排序问题"><a href="#链表排序问题" class="headerlink" title="链表排序问题"></a>链表排序问题</h3><ul>
<li><a href="https://leetcode-cn.com/problems/insertion-sort-list">147. 对链表进行插入排序</a></li>
<li><a href="https://leetcode-cn.com/problems/sort-list">148. 排序链表</a></li>
</ul>
<h3 id="链表其他经典题目"><a href="#链表其他经典题目" class="headerlink" title="链表其他经典题目"></a>链表其他经典题目</h3><ul>
<li><a href="https://leetcode-cn.com/problems/add-two-numbers">2. 两数相加</a></li>
<li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a></li>
<li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">23. 合并 K 个排序链表</a></li>
<li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs">24. 两两交换链表中的节点</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group">25. K 个一组翻转链表</a></li>
<li><a href="https://leetcode-cn.com/problems/rotate-list">61. 旋转链表</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii">82. 删除排序链表中的重复元素 II</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list">83. 删除排序链表中的重复元素</a></li>
<li><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer">138. 复制带随机指针的链表</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-linked-list-elements">203. 移除链表元素</a></li>
<li><a href="https://leetcode-cn.com/problems/add-two-numbers-ii">445. 两数相加 II</a></li>
<li><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts">725. 分隔链表</a></li>
<li><a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list">430. 扁平化多级双向链表</a></li>
<li><a href="https://leetcode-cn.com/problems/linked-list-components">817. 链表组件</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list">1171. 从链表中删去总和值为零的连续节点</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://xiaoneng.blog.csdn.net/article/details/104007259">leetcode 刷题总结之链表_algsup-CSDN 博客</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>日常生活 - 东方时尚实际道路训练考试路线图</title>
    <url>/post/2018/32900a5b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200517155411.jpg" alt="东方时尚实际道路训练考试路线图"></p>
]]></content>
      <categories>
        <category>日常生活</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派日记 - 安装 SRS</title>
    <url>/post/2020/f3c9706d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>SRS/3.0</code>，是一个流媒体集群，支持 <code>RTMP</code>/<code>HLS</code>/<code>WebRTC</code>/<code>SRT</code>/<code>GB28181</code>，高效、稳定、易用，简单而快乐。</p>
<a id="more"></a>
<h2 id="SRS-介绍"><a href="#SRS-介绍" class="headerlink" title="SRS 介绍"></a>SRS 介绍</h2><p><code>SRS</code> 定位是运营级的互联网直播服务器集群，追求更好的概念完整性和最简单实现的代码。<code>SRS</code> 提供了丰富的接入方案将 <code>RTMP</code> 流接入 <code>SRS</code>， 包括推送 <code>RTMP</code> 到 <code>SRS</code>、推送 <code>RTSP</code>/<code>UDP</code>/<code>FLV</code> 到 <code>SRS</code>、拉取流到 <code>SRS</code>。<code>SRS</code> 还支持将接入的 <code>RTMP</code> 流进行各种变换，譬如将 <code>RTMP</code> 流转码、流截图、 转发给其他服务器、转封装成 <code>HTTP-FLV</code> 流、转封装成 HLS、 转封装成 <code>HDS</code>、转封装成 <code>DASH</code>、录制成 <code>FLV</code>/<code>MP4</code>。<code>SRS</code> 包含支大规模集群如 <code>CDN</code> 业务的关键特性， 譬如 <code>RTMP</code> 多级集群、源站集群、<code>VHOST</code> 虚拟服务器 、 无中断服务 <code>Reload</code>、<code>HTTP-FLV</code> 集群。此外，<code>SRS</code> 还提供丰富的应用接口， 包括 <code>HTTP</code> 回调、安全策略 <code>Security</code>、<code>HTTP</code> <code>API</code> 接口、 <code>RTMP</code> 测速。<code>SRS</code> 在源站和 <code>CDN</code> 集群中都得到了广泛的应用 <code>Applications</code>。</p>
<h2 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## python2</span></span><br><span class="line">$ sudo apt-get install python python-dev</span><br><span class="line"><span class="comment">## net-tools</span></span><br><span class="line">$ sudo apt-get install net-tools</span><br><span class="line"><span class="comment">## cmake</span></span><br><span class="line">$ sudo apt-get install -y cmake</span><br><span class="line"><span class="comment">## gcc</span></span><br><span class="line">$ sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="Get-SRS"><a href="#Get-SRS" class="headerlink" title="Get SRS"></a>Get SRS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git clone https://gitee.com/winlinvip/srs.oschina.git srs</span></span><br><span class="line"><span class="comment"># cd srs/trunk &amp;&amp; git remote set-url origin https://github.com/ossrs/srs.git &amp;&amp; git pull</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/ossrs/srs.git &amp;&amp; <span class="built_in">cd</span> srs/trunk</span><br></pre></td></tr></table></figure>
<h3 id="Build-SRS"><a href="#Build-SRS" class="headerlink" title="Build SRS"></a>Build SRS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./configure &amp;&amp; make</span><br></pre></td></tr></table></figure>
<h3 id="安装过程中遇到的问题"><a href="#安装过程中遇到的问题" class="headerlink" title="安装过程中遇到的问题"></a>安装过程中遇到的问题</h3><h4 id="Build-openssl-1-1-0e-failed-ret-2"><a href="#Build-openssl-1-1-0e-failed-ret-2" class="headerlink" title="Build openssl-1.1.0e failed, ret=2"></a>Build openssl-1.1.0e failed, ret=2</h4><p><code>Ubuntu 20.04 LTS</code> 中 <code>openssl</code> 存在缺陷，无法编译通过，建议使用以下配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./configure --full --use-sys-ssl --without-utest</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="添加系统服务"><a href="#添加系统服务" class="headerlink" title="添加系统服务"></a>添加系统服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ln -sf /usr/<span class="built_in">local</span>/srs/etc/init.d/srs /etc/init.d/srs</span><br><span class="line">$ sudo cp -f /usr/<span class="built_in">local</span>/srs/usr/lib/systemd/system/srs.service /usr/lib/systemd/system/srs.service</span><br><span class="line">$ sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<p>此时可用以下命令启动 <code>SRS</code> 服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start srs</span><br></pre></td></tr></table></figure>
<h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> srs</span><br></pre></td></tr></table></figure>
<h3 id="启用-HLS-和-HTTP-FLV"><a href="#启用-HLS-和-HTTP-FLV" class="headerlink" title="启用 HLS 和 HTTP_FLV"></a>启用 HLS 和 HTTP_FLV</h3><p>修改 <code>SRS</code> 的配置文件 <code>/usr/local/srs/conf/srs.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main config for srs.</span></span><br><span class="line"><span class="comment"># @see full.conf for detail config.</span></span><br><span class="line"></span><br><span class="line">listen              1935;</span><br><span class="line">max_connections     1000;</span><br><span class="line">srs_log_tank        file;</span><br><span class="line">srs_log_file        ./objs/srs.log;</span><br><span class="line">http_api &#123;</span><br><span class="line">    enabled         on;</span><br><span class="line">    listen          1985;</span><br><span class="line">&#125;</span><br><span class="line">http_server &#123;</span><br><span class="line">    enabled         on;</span><br><span class="line">    listen          8080;</span><br><span class="line">    dir             ./objs/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line">stats &#123;</span><br><span class="line">    network         0;</span><br><span class="line">    disk            sda sdb xvda xvdb;</span><br><span class="line">&#125;</span><br><span class="line">vhost __defaultVhost__ &#123;</span><br><span class="line">    <span class="comment"># HTTP_FLV Configure</span></span><br><span class="line">    http_remux&#123;</span><br><span class="line">        enabled    on;</span><br><span class="line">        mount      [vhost]/[app]/[stream].flv;</span><br><span class="line">        hstrs      on;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># HLS Configure</span></span><br><span class="line">    hls&#123;</span><br><span class="line">        enabled       on;</span><br><span class="line">        hls_path      ./objs/nginx/html;</span><br><span class="line">        hls_fragment  10;</span><br><span class="line">        hls_window    60;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新启动 <code>SRS</code> 服务：<code>sudo systemctl restart srs</code>。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="使用-ffmpeg-推流"><a href="#使用-ffmpeg-推流" class="headerlink" title="使用 ffmpeg 推流"></a>使用 ffmpeg 推流</h3><p>在服务器上使用 ffmpeg 向 SRS 服务进行推流，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i <span class="string">&quot;rtsp://username:password@192.168.199.242/ch1/main/av_stream&quot;</span> \</span><br><span class="line">    -vcodec libx264 -vprofile baseline -acodec libmp3lame -ar 44100 -ac 1 \</span><br><span class="line">    -f flv rtmp://localhost:1935/hls/movie</span><br></pre></td></tr></table></figure>
<h3 id="使用-VLC-拉流"><a href="#使用-VLC-拉流" class="headerlink" title="使用 VLC 拉流"></a>使用 VLC 拉流</h3><p>使用可以连接到服务器的计算机打开 <code>VLC</code> 播放器进行拉流，<code>VLC</code> 的 <code>URL</code> 格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTMP : rtmp:&#x2F;&#x2F;192.168.199.152:1935&#x2F;hls&#x2F;movie</span><br><span class="line">RTMP : http:&#x2F;&#x2F;192.168.199.152:8080&#x2F;hls&#x2F;movie.m3u8</span><br><span class="line">HTTP_FLV : http:&#x2F;&#x2F;192.168.199.152:8080&#x2F;hls&#x2F;movie.flv</span><br></pre></td></tr></table></figure>
<p>拉流播放效果如图所示：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201122220304.png" alt="HTTP_FLV"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/ossrs/srs">ossrs/srs: SRS is a RTMP/HLS/WebRTC/SRT/GB28181 streaming cluster, high efficiency, stable and simple.</a></li>
</ul>
]]></content>
      <categories>
        <category>树莓派日记</category>
      </categories>
      <tags>
        <tag>SRS</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派日记 - 安装 Ubuntu 20.04</title>
    <url>/post/2020/2e43eec/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>树莓派开不开机了，身边暂时没有显示器，所以打算直接重装系统吧……<br>记录以下装系统过程，方便以后再发生如此问题（希望不会）</p>
</blockquote>
<p>树莓派安装 Ubuntu 的作用：</p>
<ol>
<li>作为流媒体服务器学习音视频传输技术</li>
<li>搭建 Web 服务器学习 Nginx 原理</li>
<li>学习 Linux 基本操作和 Shell 脚本</li>
<li>尝试简单的内核级开发</li>
</ol>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="硬件准备工作"><a href="#硬件准备工作" class="headerlink" title="硬件准备工作"></a>硬件准备工作</h3><ol>
<li>树莓派 4b</li>
<li>Micro SD 卡（32G ~ 128G 容量，Class 10 以上）</li>
<li>SD 卡读卡器</li>
<li>个人计算机</li>
</ol>
<h3 id="软件准备工作"><a href="#软件准备工作" class="headerlink" title="软件准备工作"></a>软件准备工作</h3><ul>
<li>Ubuntu 20.04 镜像<blockquote>
<p>下载地址：<a href="https://ubuntu.com/download/raspberry-pi">https://ubuntu.com/download/raspberry-pi</a></p>
</blockquote>
</li>
<li>balenaEtcher（用于刻录镜像）<blockquote>
<p>下载地址：<a href="https://github.com/balena-io/etcher/releases">https://github.com/balena-io/etcher/releases</a></p>
</blockquote>
</li>
</ul>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="What-you’ll-need"><a href="#What-you’ll-need" class="headerlink" title="What you’ll need"></a>What you’ll need</h3><ul>
<li>A Raspberry Pi 2, 3, or 4</li>
<li>A micro-USB power cable for the Pi 2 &amp; 3, or a USB-C power cable for the Pi 4</li>
<li>A microSD card with the Ubuntu Server image</li>
<li>A monitor with an HDMI interface</li>
<li>An HDMI cable for the Pi 2 &amp; 3 and a MicroHDMI cable for the Pi 4</li>
<li>A USB keyboard</li>
</ul>
<h3 id="Flash-Ubuntu-onto-your-microSD-card"><a href="#Flash-Ubuntu-onto-your-microSD-card" class="headerlink" title="Flash Ubuntu onto your microSD card"></a>Flash Ubuntu onto your microSD card</h3><p>The first thing you need to do is take a minute to copy the Ubuntu image on to a microSD card by following our tutorials, we have one for Ubuntu machines, Windows machines and Macs.</p>
<h3 id="Boot-Ubuntu-Server"><a href="#Boot-Ubuntu-Server" class="headerlink" title="Boot Ubuntu Server"></a>Boot Ubuntu Server</h3><ol>
<li>You need to attach a monitor and keyboard to the board. You can alternatively use a serial cable.</li>
<li>Now insert the microSD card</li>
<li>Plug the power adaptor into the board</li>
</ol>
<h3 id="Login-to-your-Pi"><a href="#Login-to-your-Pi" class="headerlink" title="Login to your Pi"></a>Login to your Pi</h3><p>When prompted to log in, use <code>ubuntu</code> for the username and the password. You will be asked to change this default password after you log in.</p>
<p>You are now running the Ubuntu Server on your Raspberry Pi.</p>
<h2 id="基础环境配置过程"><a href="#基础环境配置过程" class="headerlink" title="基础环境配置过程"></a>基础环境配置过程</h2><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>Ubuntu 安装后默认使用官方源，服务器位于国外，网络环境较差，推荐更换国内阿里源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak_`date <span class="string">&quot;+%y_%m_%d&quot;</span>`</span><br><span class="line">$ sudo sed -i <span class="string">&#x27;s/http:\/\/ports.ubuntu.com/https:\/\/mirrors.aliyun.com/g&#x27;</span> /etc/apt/sources.list</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<h3 id="安装常用依赖"><a href="#安装常用依赖" class="headerlink" title="安装常用依赖"></a>安装常用依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install libssl-dev</span><br></pre></td></tr></table></figure>
<h3 id="安装常用工具"><a href="#安装常用工具" class="headerlink" title="安装常用工具"></a>安装常用工具</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="comment"># sudo apt-get install net-tools # 已启用，建议使用 iproute2</span></span><br><span class="line">$ sudo apt-get install samba <span class="comment"># 需要配置</span></span><br><span class="line">$ sudo apt-get install lrzsz</span><br></pre></td></tr></table></figure>
<h3 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install build-essential</span><br><span class="line">$ sudo apt-get install cmake cmake-curses-gui</span><br><span class="line">$ sudo apt-get install python3 python3-dev</span><br></pre></td></tr></table></figure>
<h2 id="进阶环境配置过程"><a href="#进阶环境配置过程" class="headerlink" title="进阶环境配置过程"></a>进阶环境配置过程</h2><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><p>详见：<a href="/post/2020/8f761f75/" title="Nginx - 环境搭建">Nginx - 环境搭建</a></p>
<h3 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h3><h4 id="安装-ffmpeg"><a href="#安装-ffmpeg" class="headerlink" title="安装 ffmpeg"></a>安装 ffmpeg</h4><p>详见：<a href="/post/2020/c30ccf98/" title="树莓派日记 - 安装 ffmpeg">树莓派日记 - 安装 ffmpeg</a></p>
<h4 id="安装-SRS"><a href="#安装-SRS" class="headerlink" title="安装 SRS"></a>安装 SRS</h4><p>详见：<a href="/post/2020/f3c9706d/" title="树莓派日记 - 安装 SRS">树莓派日记 - 安装 SRS</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://ubuntu.com/download/raspberry-pi">Install Ubuntu Server on a Raspberry Pi 2, 3 or 4 | Ubuntu</a></li>
</ul>
]]></content>
      <categories>
        <category>树莓派日记</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派日记 - 安装 ffmpeg</title>
    <url>/post/2020/c30ccf98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>Ubuntu Server 20.04 LTS</li>
</ul>
<blockquote>
<p>安装过程详见：<a href="/post/2020/2e43eec/" title="树莓派日记 - 安装 Ubuntu 20.04">树莓派日记 - 安装 Ubuntu 20.04</a></p>
</blockquote>
<a id="more"></a>
<h2 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h2><h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For Ubuntu</span></span><br><span class="line">$ sudo apt-get install -y cmake cmake-curses-gui</span><br></pre></td></tr></table></figure>
<h3 id="gcc-g"><a href="#gcc-g" class="headerlink" title="gcc/g++"></a>gcc/g++</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For Ubuntu</span></span><br><span class="line">$ sudo apt-get install -y build-essential</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For Ubuntu</span></span><br><span class="line">$ sudo apt-get install -y pkg-config</span><br></pre></td></tr></table></figure>
<h2 id="安装方式一：包管理器安装"><a href="#安装方式一：包管理器安装" class="headerlink" title="安装方式一：包管理器安装"></a>安装方式一：包管理器安装</h2><p><code>Ubuntu</code> 系统通过 <code>apt</code> 包管理器安装 <code>ffmpeg</code> 较为方便，依次执行以下命令即可完成安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install -y libsdl-dev libavcodec-dev libavutil-dev</span><br><span class="line">$ sudo apt-get install ffmpeg ffmpeg-devel</span><br></pre></td></tr></table></figure>
<p>对于 <code>CentOS</code> 系统，<code>yum</code> 包管理器中并没有 <code>ffmpeg</code> 包，需要手动添加额外的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">sudo rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS 7 执行以下命令</span></span><br><span class="line">sudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS 7 执行以下命令</span></span><br><span class="line">sudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el6/x86_64/nux-dextop-release-0-2.el6.nux.noarch.rpm</span><br><span class="line"></span><br><span class="line">yum repolist</span><br><span class="line">yum install -y ffmpeg ffmpeg-devel</span><br></pre></td></tr></table></figure>
<h2 id="安装方式二：源码安装"><a href="#安装方式二：源码安装" class="headerlink" title="安装方式二：源码安装"></a>安装方式二：源码安装</h2><h3 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nasm, x264 依赖 nasm 的汇编加速</span></span><br><span class="line">$ wget https://www.nasm.us/pub/nasm/releasebuilds/2.15rc12/nasm-2.15rc12.tar.xz</span><br><span class="line">$ tar -xJf nasm-2.15rc12.tar.xz</span><br><span class="line">$ <span class="built_in">cd</span> nasm-2.15rc12/</span><br><span class="line">$ ./configure &amp;&amp; make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># x264, 建议安装 x264 的 H264 编码质量较高</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://code.videolan.org/videolan/x264.git</span><br><span class="line">$ <span class="built_in">cd</span> x264</span><br><span class="line">$ ./configure --<span class="built_in">enable</span>-shared --<span class="built_in">enable</span>-static &amp;&amp; make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># yasm, ffmpeg 依赖 yasm</span></span><br><span class="line">$ wget http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz</span><br><span class="line">$ tar xzf yasm-1.3.0.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> yasm-1.3.0/</span><br><span class="line">$ sed -i <span class="string">&#x27;s#) ytasm.*#)#&#x27;</span> Makefile.in</span><br><span class="line">$ ./configure --prefix=/usr &amp;&amp; make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下依赖库可选安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x265</span></span><br><span class="line"><span class="comment"># get x265 at http://ftp.videolan.org/pub/videolan/x265/</span></span><br><span class="line">$ tar xzf x265_2.3.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> x265_2.3/build/linux/</span><br><span class="line">$ ./make-Makefiles.bash     <span class="comment"># 注意将 ENABLE_PIC 设置为 ON</span></span><br><span class="line">$ make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># fdk-aac</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/mstorsjo/fdk-aac.git</span><br><span class="line">$ <span class="built_in">cd</span> fdk-aac</span><br><span class="line">$ sudo apt install -y autoconf libtool</span><br><span class="line">$ ./configure CFLAGS=-fPIC &amp;&amp; make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>
<h3 id="编译-amp-安装"><a href="#编译-amp-安装" class="headerlink" title="编译 &amp; 安装"></a>编译 &amp; 安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/FFmpeg/FFmpeg.git ffmpeg</span><br><span class="line">$ <span class="built_in">cd</span> ffmpeg/</span><br><span class="line">$ ./configure --<span class="built_in">enable</span>-libx264 --<span class="built_in">enable</span>-gpl</span><br><span class="line">$ make -j4 &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">echo</span> <span class="string">&quot;/usr/local/x264/lib/&quot;</span> &gt; /etc/ld.so.conf.d/ffmpeg.conf</span><br><span class="line">$ ldconfig</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      <categories>
        <category>树莓派日记</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派日记 - 安装 rtmpdump</title>
    <url>/post/2020/5ff634f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>rtmpdump</code> 是一个 <code>C++</code> 的开源工程，也可以说是一个用来处理 <code>RTMP</code> 流媒体的工具包，支持 <code>rtmp://</code>, <code>rtmpt://</code>, <code>rtmpe://</code>, <code>rtmpte://</code>, 和 <code>rtmps://</code> 等。我们可以通过对 <code>rtmpdump</code> 的学习来学习 <code>RTMP</code> 协议。</p>
<p>首先可以了解一下其使用方法：<code>rtmpdump</code> 使用说明：</p>
<p>官网：<a href="http://rtmpdump.mplayerhq.hu/">http://rtmpdump.mplayerhq.hu/</a></p>
<a id="more"></a>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://git.ffmpeg.org/rtmpdump &amp;&amp; <span class="built_in">cd</span> rtmpdump</span><br></pre></td></tr></table></figure>
<h2 id="打补丁包"><a href="#打补丁包" class="headerlink" title="打补丁包"></a>打补丁包</h2><p>对于 <code>openssl 1.1</code> 以上的 <code>linux</code> 用户，直接编译无法编译通过，需要打补丁包对 <code>openssl</code> 的接口进行一些修改，并消除了部分编译警告。</p>
<p>补丁包下载链接如下：</p>
<p><a href="/slave/Openssl-1.1.1.patch" title="补丁下载">点击下载</a></p>
<p>补丁包使用方法：</p>
<p>将 <code>patch</code> 文件放在源码同一目录下，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git am Openssl-1.1.1.patch</span><br><span class="line">Applying: 【MOD】支持 Openssl 1.1.1</span><br></pre></td></tr></table></figure>
<h2 id="编译-amp-安装"><a href="#编译-amp-安装" class="headerlink" title="编译 &amp; 安装"></a>编译 &amp; 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="http://rtmpdump.mplayerhq.hu/">rtmpdump</a></li>
<li>[2] <a href="https://github.com/JudgeZarbi/RTMPDump-OpenSSL-1.1">JudgeZarbi/RTMPDump-OpenSSL-1.1: RTMPDump modified to compile with the changes made in OpenSSL 1.1.0</a></li>
</ul>
]]></content>
      <categories>
        <category>树莓派日记</category>
      </categories>
      <tags>
        <tag>rtmpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派日记 - 系统备份</title>
    <url>/post/2020/4fd2fc4f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在树莓派 Linux 环境折腾过程中，由于 Linux 系统开放的权限比较高，以 root 权限操作的话很有可能就会误删一些系统文件导致系统崩溃。我手里树莓派的系统搞挂过好几次，每次只能重新刷入镜像，开机后还得重复一大堆操作，所以备份树莓派的系统就很重要了。还可以把已经部署好的树莓派系统，批量复制到更多的树莓派上。</p>
<a id="more"></a>
<div class="note danger no-icon"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文采用 kallsbo 大神提供的树莓派备份工具 BASH-RaspberryPI-System-Backup</p>
<p>注意：该备份工具采用的备份方式为==全卡备份==，备份速度慢，效率低，不建议使用，本文后续还会更新其他备份方式</p>
<p>Github 地址：<a href="https://github.com/kallsbo/BASH-RaspberryPI-System-Backup">https://github.com/kallsbo/BASH-RaspberryPI-System-Backup</a></p>
<p>工具主页：<a href="https://hackviking.com/2017/09/25/automated-raspberry-pi-backup-complete-image/">https://hackviking.com/2017/09/25/automated-raspberry-pi-backup-complete-image/</a></p>
</div>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>需要一个 nas 系统挂载到树莓派设备上，可以用带 nas 功能的路由器，我手里正好有一个海康云盘，带有 nas 功能。</li>
<li>设置开机自动挂载 nas 到文件夹 <code>/mnt/backup</code></li>
</ol>
<h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir /mnt/backup</span><br></pre></td></tr></table></figure>
<h3 id="添加-fstab"><a href="#添加-fstab" class="headerlink" title="添加 fstab"></a>添加 fstab</h3><p>修改文件 <code>/etc/fstab/</code>，在文件末尾增加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;192.168.123.68&#x2F;Disk1share&#x2F;Backup&#x2F;raspberrypi_boot &#x2F;mnt&#x2F;backup cifs  username&#x3D;admin,password&#x3D;Abc12345 0 0</span><br></pre></td></tr></table></figure>
<h3 id="测试挂载"><a href="#测试挂载" class="headerlink" title="测试挂载"></a>测试挂载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 执行 fstab 挂载</span></span><br><span class="line">sudo mount -a</span><br><span class="line"><span class="comment">## 查看是否挂载成功</span></span><br><span class="line">mount</span><br></pre></td></tr></table></figure>
<h3 id="挂载过程中遇到了一些问题"><a href="#挂载过程中遇到了一些问题" class="headerlink" title="挂载过程中遇到了一些问题"></a>挂载过程中遇到了一些问题</h3><h4 id="bad-option-for-several-filesystems"><a href="#bad-option-for-several-filesystems" class="headerlink" title="bad option for several filesystems"></a>bad option for several filesystems</h4><p>根据需要挂载的文件系统类型，可能需要安装以下依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## for cifs</span></span><br><span class="line">sudo apt install -y cifs-utils</span><br><span class="line"><span class="comment">## for nfs</span></span><br><span class="line">sudo apt install -y  nfs-common</span><br></pre></td></tr></table></figure>
<h4 id="mount-cifs-bad-UNC"><a href="#mount-cifs-bad-UNC" class="headerlink" title="mount.cifs: bad UNC"></a>mount.cifs: bad UNC</h4><ol>
<li>检查用户名密码以及格式是否输入正确<ul>
<li>正确格式示范：username=admin,password=Abc12345</li>
</ul>
</li>
<li>检查挂载地址 URL 格式是否正确<ul>
<li>IP 前带有两个斜杠 ‘//‘</li>
<li>IP 后不要有冒号</li>
<li>目录中避免出现反斜杠 ‘\’</li>
<li>正确 URL 示范：//192.168.123.68/Disk1share/Backup/raspberrypi_boot</li>
</ul>
</li>
</ol>
<h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/kallsbo/BASH-RaspberryPI-System-Backup/raw/master/system_backup.sh</span><br><span class="line">chmod +x system_backup.sh</span><br></pre></td></tr></table></figure>
<h2 id="设置自动备份"><a href="#设置自动备份" class="headerlink" title="设置自动备份"></a>设置自动备份</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<p>增加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## This will make the script take a full image backup every night at 3 am.</span><br><span class="line">0 3 * * * &#x2F;mnt&#x2F;backup&#x2F;system_backup.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>树莓派日记</category>
      </categories>
  </entry>
  <entry>
    <title>流媒体传输 - HLS 协议</title>
    <url>/post/2020/f5bbcc60/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>HLS</code> 全称是 <code>HTTP Live Streaming</code>，是一个由 <code>Apple</code> 公司提出的基于 <code>HTTP</code> 的媒体流传输协议，用于实时音视频流的传输。目前 <code>HLS</code> 协议被广泛的应用于视频点播和直播领域。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>通过将整条流切割成一个小的可以通过 <code>HTTP</code> 下载的媒体文件, 然后提供一个配套的媒体列表文件, 提供给客户端, 让客户端顺序地拉取这些媒体文件播放, 来实现看上去是在播放一条流的效果. 由于传输层协议只需要标准的 <code>HTTP</code> 协议, HLS 可以方便的透过防火墙或者代理服务器, 而且可以很方便的利用 CDN 进行分发加速, 并且客户端实现起来也很方便.</p>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><code>HLS</code> 的架构分为三部分：Server，CDN，Client 。即服务器、分发组件和客户端。</p>
<p>下面是 <code>HLS</code> 整体架构图：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201122225230.png" alt="HLS 整体架构图"></p>
<p>服务器用于接收媒体输入流，对它们进行编码，封装成适合于分发的格式，然后准备进行分发。</p>
<p>分发组件为标准的 Web 服务器。它们用于接收客户端请求，传递处理过的媒体，把资源和客户端联系起来。</p>
<p>客户端软件决定请求何种合适的媒体，下载这些资源，然后把它们重新组装成用户可以观看的连续流。</p>
<h2 id="HLS-协议分析"><a href="#HLS-协议分析" class="headerlink" title="HLS 协议分析"></a>HLS 协议分析</h2><h3 id="HLS-Playlist"><a href="#HLS-Playlist" class="headerlink" title="HLS Playlist"></a>HLS Playlist</h3><p>其实, <code>HLS</code> 协议的主要内容是关于 <code>M3U8</code> 这个文本协议的, 其实生成与解析都非常简单. 为了更加直接地说明这一点, 我下面举两个简单的例子:</p>
<p>简单的 <code>Media Playlist</code>：</p>
<pre><code>#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:8
#EXT-X-MEDIA-SEQUENCE:2680
#EXTINF:7.975,
https://priv.example.com/fileSequence2680.ts
#EXTINF:7.941,
https://priv.example.com/fileSequence2681.ts
#EXTINF:7.975,
https://priv.example.com/fileSequence2682.ts
</code></pre><p>包含多种比特率的 <code>Master Playlist</code>：</p>
<pre><code>#EXTM3U
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1280000
http://example.com/low.m3u8
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2560000
http://example.com/mid.m3u8
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=7680000
http://example.com/hi.m3u8
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=65000,CODECS=&quot;mp4a.40.5&quot;
http://example.com/audio-only.m3u8
</code></pre><ul>
<li><code>HLS</code> 通过 <code>URI(RFC3986)</code> 指向的一个 <code>Playlist</code> 来表示一个媒体流</li>
<li>一个 <code>Playlist</code> 可以是一个 <code>Media Playlist</code> 或者 <code>Master Playlist</code>, 使用 <code>UTF-8</code> 编码的文本文件, 包含一些 <code>URI</code> 跟描述性的 <code>tags</code></li>
<li>一个 <code>Media Playlist</code> 包含一个 <code>Media Segments</code> 列表,当顺序播放时, 能播放整个完整的流</li>
<li>要想播放这个 <code>Playlist</code>, 客户端需要首先下载他, 然后播放里面的每一个 <code>Media Segment</code></li>
<li><p>更加复杂的情况是, <code>Playlist</code> 是一个 <code>Master Playlist</code>, 包含一个 <code>Variant Stream</code> 集合, 通常每个 <code>Variant Stream</code> 里面是同一个流的多个不同版本(如: 分辨率, 码率不同)</p>
</li>
<li><p>一个 <code>Playlist</code> 文件必须通过 <code>URI(.m3u8 或 m3u)</code> 或者 <code>HTTP Content-Type</code> 来识别 (<code>application/vnd.apple.mpegurl</code> 或 <code>audio/mpegurl</code>)</p>
</li>
<li>换行符可以用 <code>\n</code> 或者 <code>\r\n</code></li>
<li>以 <code>#</code> 开头的是 <code>tag</code> 或者注释, 以 <code>#EXT</code> 开头的是 <code>tag</code>, 其余的为注释, 在解析时应该忽略</li>
<li><code>Playlist</code> 里面的 <code>URI</code> 可以用绝对地址或者相对地址, 如果使用相对地址, 那么是相对于 <code>Playlist</code> 文件的地址</li>
</ul>
<h3 id="HLS-Media-Segments"><a href="#HLS-Media-Segments" class="headerlink" title="HLS Media Segments"></a>HLS Media Segments</h3><ul>
<li>每一个 <code>Media Segment</code> 通过一个 <code>URI</code> 指定, 可能包含一个 <code>byte range</code></li>
<li>每一个 <code>Media Segment</code> 的 <code>duration</code> 通过 <code>EXTINF</code> <code>tag</code> 指定</li>
<li>每一个 <code>Media Segment</code> 有一个唯一的整数 <code>Media Segment Number</code></li>
<li>有些媒体格式需要一个 <code>format-specific sequence</code> 来初始化一个 <code>parser</code>, 在 <code>Media Segment</code> 被 <code>parse</code> 之前. 这个字段叫做 <code>Media Initialization Section</code>, 通过 <code>EXT-X-MAP</code> <code>tag</code> 来指定. 支持的 <code>Media Segment</code> 格式</li>
</ul>
<h3 id="HLS-TAGS"><a href="#HLS-TAGS" class="headerlink" title="HLS TAGS"></a>HLS TAGS</h3><ul>
<li><code>Basic Tags</code> : 用在 <code>Media Playlist</code> 和 <code>Master Playlist</code> 里面<ul>
<li><code>EXTM3U</code>: 必须在文件的第一行, 标识是一个 <code>Extended M3U Playlist</code> 文件</li>
<li><code>EXT-X-VERSION</code>: 表示 <code>Playlist</code> 兼容的版本</li>
</ul>
</li>
<li><code>Media Segment Tags</code> : 只能出现在 <code>Media Playlist</code> 里面<ul>
<li><code>EXTINF</code>: 用于指定 <code>Media Segment</code> 的 <code>duration</code></li>
<li><code>EXT-X-BYTERANGE</code>: 用于指定 <code>URI</code> 的 <code>sub-range</code></li>
<li><code>EXT-X-DISCONTINUITY</code>: 表示不连续</li>
<li><code>EXT-X-KEY</code>: 表示 <code>Media Segment</code> 已加密, 该值用于解密</li>
<li><code>EXT-X-MAP</code>: 用于指定 <code>Media Initialization Section</code></li>
<li><code>EXT-X-PROGRAM-DATE-TIME</code>: 和 <code>Media Segment</code> 的第一个 <code>sample</code> 一起来确定时间戳</li>
<li><code>EXT-X-DATERANGE</code>: 将一个时间范围和一组属性键值对结合到一起</li>
</ul>
</li>
<li><code>Media Playlist tags</code> : 只能出现在 <code>Media Playlist</code> 里面<ul>
<li><code>EXT-X-TARGETDURATION</code>: 用于指定最大的 <code>Media Segment duration</code></li>
<li><code>EXT-X-MEDIA-SEQUENCE</code>: 用于指定第一个 <code>Media Segment</code> 的 <code>Media Sequence Number</code></li>
<li><code>EXT-X-DISCONTINUITY-SEQUENCE</code>: 用于不同 <code>Variant Stream</code> 之间同步</li>
<li><code>EXT-X-ENDLIST</code>: 表示结束</li>
<li><code>EXT-X-PLAYLIST-TYPE</code>: 可选, 指定整个 <code>Playlist</code> 的类型</li>
<li><code>EXT-X-I-FRAMES-ONLY</code>: 表示每个 <code>Media Segment</code> 描述一个单一的 <code>I-frame</code></li>
</ul>
</li>
<li><code>Master Playlist tags</code> : 只能出现在 <code>Master Playlist</code> 中<ul>
<li><code>EXT-X-MEDIA</code>: 用于关联同一个内容的多个 <code>Media Playlist</code> 的多种 <code>renditions</code></li>
<li><code>EXT-X-STREAM-INF</code>: 用于指定一个 <code>Variant Stream</code></li>
<li><code>EXT-X-I-FRAME-STREAM-INF</code>: 用于指定一个 <code>Media Playlist</code> 包含媒体的 <code>I-frames</code></li>
<li><code>EXT-X-SESSION-DATA</code>: 存放一些 <code>session</code> 数据</li>
<li><code>EXT-X-SESSION-KEY</code>: 用于解密</li>
</ul>
</li>
<li><code>Media or Master Playlist Tags</code> : 可以出现在 <code>Media Playlist</code> 或者 <code>Master Playlist</code> 中，但是如果同时出现在同一个 <code>Master Playlist</code> 和 <code>Media Playlist</code> 中时，必须为相同值<ul>
<li><code>EXT-X-INDEPENDENT-SEGMENTS</code>: 表示每个 <code>Media Segment</code> 可以独立解码</li>
<li><code>EXT-X-START</code>: 标识一个优选的点来播放这个 <code>Playlist</code></li>
</ul>
</li>
</ul>
<h2 id="HLS-播放"><a href="#HLS-播放" class="headerlink" title="HLS 播放"></a>HLS 播放</h2><h3 id="播放未加密-HLS"><a href="#播放未加密-HLS" class="headerlink" title="播放未加密 HLS"></a>播放未加密 HLS</h3><p>我们通过 <code>VLC</code> 播放器播放苹果官方提供的一个例子：<code>http://devimages.apple.com/iphone/samples/bipbop/gear1/prog_index.m3u8</code>，并使用 <code>Wirshark</code> 对其中交互进行抓包。</p>
<pre><code>GET /iphone/samples/bipbop/gear1/prog_index.m3u8 HTTP/1.1
Host: devimages.apple.com
Accept: */*
Accept-Language: zh_CN
User-Agent: VLC/3.0.8 LibVLC/3.0.8
Range: bytes=0-

    HTTP/1.1 206 Partial Content
    Accept-Ranges: bytes
    Content-Type: audio/x-mpegurl
    ETag: &quot;50117c8233644c19b5ab49551b72507f:1239907352&quot;
    Last-Modified: Thu, 16 Apr 2009 18:42:32 GMT
    Server: AkamaiNetStorage
    Date: Sun, 22 Nov 2020 15:01:49 GMT
    Content-Range: bytes 0-7018/7019
    Content-Length: 7019
    X-Cache: TCP_MEM_HIT from a184-26-91-45.deploy.akamaitechnologies.com (AkamaiGHost/10.2.0.2-31441410) (-)
    Connection: keep-alive

    #EXTM3U
    #EXT-X-TARGETDURATION:10
    #EXT-X-MEDIA-SEQUENCE:0
    #EXTINF:10, no desc
    fileSequence0.ts
    #EXTINF:10, no desc
    fileSequence1.ts
    #EXTINF:10, no desc
    fileSequence2.ts
    #EXTINF:10, no desc
    ......
    #EXTINF:1, no desc
    fileSequence180.ts
    #EXT-X-ENDLIST
</code></pre><p>我们可以看到返回的 <code>M3U8</code> 里面他有一个一个 <code>ts</code> 视频片段，这个一个一个视频片段就是我们需要的播放的视频片段。</p>
<p><code>#EXTINF</code> 表示每个 <code>ts</code> 切片视频文件的时长。<br><code>#EXT-X-TARGETDURATION</code> 指定当前视频流中的切片文件的最大时长，也就是说这些 <code>ts</code> 切片的时长不能大于 <code>#EXT-X-TARGETDURATION</code> 的值。<br><code>#EXT-X-MEDIA-SEQUENCE</code> 第一个 <code>ts</code> 分片的序列号<br><code>#EXT-X-ENDLIST</code> 这个表示视频结束，有这个标志同时也说明当前的流是一个非直播流。<br><code>#EXT-X-PLAYLIST-TYPE:VOD</code> 的意思是当前的视频流并不是一个直播流，而是点播流，换句话说就是该视频的全部的 <code>ts</code> 文件已经被生成好了<br><code>#EXT-X-ALLOW-CACHE</code> 是否允许 <code>cache</code></p>
<h3 id="播放加密-HLS"><a href="#播放加密-HLS" class="headerlink" title="播放加密 HLS"></a>播放加密 HLS</h3><h2 id="HLS-协议总结"><a href="#HLS-协议总结" class="headerlink" title="HLS 协议总结"></a>HLS 协议总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>客户端支持简单, 只需要支持 <code>HTTP</code> 请求即可, <code>HTTP</code> 协议无状态, 只需要按顺序下载媒体片段即可。</li>
<li>使用 <code>HTTP</code> 协议网络兼容性好, <code>HTTP</code> 数据包也可以方便地通过防火墙或者代理服务器, <code>CDN</code> 支持良好。</li>
<li><code>Apple</code> 的全系列产品支持，不需要安装任何插件就可以原生支持播放 <code>HLS</code>, 目前 <code>Android</code> 也加入了对 <code>HLS</code> 的支持。</li>
<li>自带多码率自适应机制。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>相比 <code>RTMP</code> 这类长连接协议, 延时较高, 难以用到互动直播场景。</li>
<li>对于点播服务来说, 由于 <code>TS</code> 切片通常较小, 海量碎片在文件分发, 一致性缓存, 存储等方面都有较大挑战。</li>
</ul>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul>
<li>由于客户端每次请求 <code>TS</code> 或 <code>M3U8</code> 有可能一个新的连接请求, 无法有效的标识客户端, 一旦出现问题, 基本无法有效的定位问题。</li>
<li>一般工业级的服务器都会对传统的 <code>HLS</code> 做一些改进，常见优化是对每个 <code>M3U8</code> 文件增加 <code>Session</code> 来标识一条 <code>HLS</code> 连接。</li>
<li>不管通过哪种方式, 最终我们都能通过一个唯一的 <code>id</code> 来标识一条流, 这样在排查问题时就可以根据这个 <code>id</code> 来定位播放过程中的问题。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://www.cnblogs.com/renhui/p/8081869.html">流媒体协议（一）：HLS 协议 - 灰色飘零 - 博客园</a></li>
</ul>
]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>HLS</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体传输 - RTCP 协议</title>
    <url>/post/2020/634443fb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="RTCP-协议"><a href="#RTCP-协议" class="headerlink" title="RTCP 协议"></a>RTCP 协议</h2><h3 id="SR-Sender-Report-RTCP-Packet"><a href="#SR-Sender-Report-RTCP-Packet" class="headerlink" title="SR (Sender Report RTCP Packet)"></a>SR (Sender Report RTCP Packet)</h3><pre><code>        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    RC   |   PT=SR=200   |             length            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         SSRC of sender                        |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
sender |              NTP timestamp, most significant word             |
info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |             NTP timestamp, least significant word             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         RTP timestamp                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                     sender&#39;s packet count                     |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      sender&#39;s octet count                     |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_1 (SSRC of first source)                 |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  1    | fraction lost |       cumulative number of packets lost       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           extended highest sequence number received           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      interarrival jitter                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         last SR (LSR)                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                   delay since last SR (DLSR)                  |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_2 (SSRC of second source)                |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  2    :                               ...                             :
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
       |                  profile-specific extensions                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><a id="more"></a>
<blockquote>
<p><a href="https://www.rfc-editor.org/rfc/rfc3551.txt">RFC 3551: RTP Profile for Audio and Video Conferences with Minimal Control</a> : 6.4.1 SR: Sender Report RTCP Packet</p>
</blockquote>
<h3 id="RR-Receiver-Report-RTCP-Packet"><a href="#RR-Receiver-Report-RTCP-Packet" class="headerlink" title="RR: Receiver Report RTCP Packet"></a>RR: Receiver Report RTCP Packet</h3><pre><code>        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    RC   |   PT=RR=201   |             length            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                     SSRC of packet sender                     |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_1 (SSRC of first source)                 |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  1    | fraction lost |       cumulative number of packets lost       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           extended highest sequence number received           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      interarrival jitter                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         last SR (LSR)                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                   delay since last SR (DLSR)                  |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_2 (SSRC of second source)                |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  2    :                               ...                             :
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
       |                  profile-specific extensions                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><blockquote>
<p><a href="https://www.rfc-editor.org/rfc/rfc3551.txt">RFC 3551: RTP Profile for Audio and Video Conferences with Minimal Control</a> : 6.4.2 RR: Receiver Report RTCP Packet</p>
</blockquote>
<h3 id="SDES-Source-Description-RTCP-Packet"><a href="#SDES-Source-Description-RTCP-Packet" class="headerlink" title="SDES: Source Description RTCP Packet"></a>SDES: Source Description RTCP Packet</h3><pre><code>        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    SC   |  PT=SDES=202  |             length            |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
chunk  |                          SSRC/CSRC_1                          |
  1    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           SDES items                          |
       |                              ...                              |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
chunk  |                          SSRC/CSRC_2                          |
  2    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           SDES items                          |
       |                              ...                              |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
</code></pre><blockquote>
<p><a href="https://www.rfc-editor.org/rfc/rfc3551.txt">RFC 3551: RTP Profile for Audio and Video Conferences with Minimal Control</a> : 6.5 SDES: Source Description RTCP Packet</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://www.rfc-editor.org/rfc/rfc3550.txt">RFC 3550: RTP: A Transport Protocol for Real-Time Applications</a></li>
<li>[2] <a href="https://www.rfc-editor.org/rfc/rfc2326.txt">RFC 2326: Real Time Streaming Protocol (RTSP)</a></li>
<li>[3] <a href="https://www.rfc-editor.org/rfc/rfc3551.txt">RFC 3551: RTP Profile for Audio and Video Conferences with Minimal Control</a></li>
<li>[4] <a href="https://www.rfc-editor.org/rfc/rfc6184.txt">RFC 6184: RTP Payload Format for H.264 Video</a></li>
<li>[5] <a href="https://www.rfc-editor.org/rfc/rfc3550.txt">RFC 3550: RTP: A Transport Protocol for Real-Time Applications</a></li>
</ul>
]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>RTCP</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体传输 - RTMP 协议</title>
    <url>/post/2020/ccfdbe65/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>RTMP 是 Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。它是由 Adobe 公司提出的一种应用层的协议，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题。</p>
<p>该协议基于 TCP，是一个协议族，包括 RTMP 基本协议及 RTMPT/RTMPS/RTMPE 等多种变种。</p>
<p>RTMP 是一种设计用来进行实时数据通信的网络协议，主要用来在 Flash/AIR 平台和支持 RTMP 协议的流媒体或交互服务器之间进行音视频和数据通信。</p>
<a id="more"></a>
<h2 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h2><p>RTMP 协议规定，播放一个流媒体有两个前提步骤：第一步，建立一个网络连接（NetConnection）；第二步，建立一个网络流（NetStream）。</p>
<p>其中，网络连接代表服务器端应用程序和客户端之间基础的连通关系。网络流代表了发送多媒体数据的通道。服务器和客户端之间只能建立一个网络连接，但是基于该连接可以创建很多网络流。他们的关系如图所示：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201012214637.png" alt="RTMP 中的逻辑结构"></p>
<p>播放一个 RTMP 协议的流媒体需要经过以下几个步骤：握手，建立连接，建立流，播放，四个步骤流程如下：</p>
<pre><code>            +----------+                     +----------+
            |  Client  |   TCP/IP Network    |  Server  |
            +----------+                     +----------+
--------+---|                     |                     |
        |Uninitialized            |            Uninitialized
        |   |----------C0--------&gt;|                     |
        |   |                     |---------C0---------&gt;|
        |   |----------C1--------&gt;|                     |
        |   |                     |&lt;--------S0----------|
        |Version sent             |&lt;--------S1----------|
Hand-   |   |&lt;---------S0---------|                     |
shake   |   |&lt;---------S1---------|             Version sent
        |   |                     |---------C1---------&gt;|
        |   |----------C2--------&gt;|                     |
        |   |                     |&lt;--------S2----------|
        |Ack Sent                 |                Ack Sent
        |   |&lt;---------S2---------|                     |
        |   |                     |---------C2---------&gt;|
        |Handshake Done           |           Handshake Done
--------+---|                                           |
            |                                           |
--------+---|---------- Command Message(connect) ------&gt;|
        |   |                                           |
        |   |&lt;------ Window Acknowledgement Size -------|
        |   |                                           |
        |   |&lt;---------- Set Peer Bandwidth ------------|
        |   |                                           |
Appli-  |   |------- Window Acknowledgement Size ------&gt;|
cation  |   |                                           |
Connect |   |&lt;---- User Control Message(StreamBegin) ---|
        |   |                                           |
        |   |&lt;----------- Command Message --------------|
        |   |       (_result- connect response)         |
--------+---|                                           |
            |                                           |
--------+---|------ Command Message(createStream) -----&gt;|
Create  |   |                                           |
Stream  |   |&lt;----------- Command Message --------------|
--------+---|      (_result- createStream response)     |
            |                                           |
--------+---|--------- Command Message (play) ---------&gt;|
        |   |                                           |
        |   |&lt;-------------- SetChunkSize --------------|
        |   |                                           |
        |   |&lt;---- User Control (StreamIsRecorded) -----|
        |   |                                           |
        |   |&lt;------- UserControl (StreamBegin) --------|
        |   |                                           |
Play    |   |&lt;-- Command Message(onStatus-play reset) --|
        |   |                                           |
        |   |&lt;-- Command Message(onStatus-play start) --|
        |   |                                           |
        |   |&lt;------------- Audio Message --------------|
        |   |                                           |
        |   |&lt;------------- Video Message --------------|
        |   |                     |                     |
                                  |
           Keep receiving audio and video stream till finishes
</code></pre><h2 id="握手（HandShake）"><a href="#握手（HandShake）" class="headerlink" title="握手（HandShake）"></a>握手（HandShake）</h2><h3 id="握手交互流程"><a href="#握手交互流程" class="headerlink" title="握手交互流程"></a>握手交互流程</h3><p>一个 RTMP 连接以握手开始，双方分别发送大小固定的三个数据块：</p>
<ol>
<li>握手开始于客户端发送 C0、C1 块。服务器收到 C0 或 C1 后发送 S0 和 S1。</li>
<li>当客户端收齐 S0 和 S1 后，开始发送 C2。当服务器收齐 C0 和 C1 后，开始发送 S2。</li>
<li><p>当客户端和服务器分别收到 S2 和 C2 后，握手完成。</p>
<pre><code>             +----------+                     +----------+
             |  Client  |   TCP/IP Network    |  Server  |
             +----------+                     +----------+
 --------+---|                     |                     |
         |Uninitialized            |            Uninitialized
         |   |----------C0--------&gt;|                     |
         |   |                     |---------C0---------&gt;|
         |   |----------C1--------&gt;|                     |
         |   |                     |&lt;--------S0----------|
         |Version sent             |&lt;--------S1----------|
 Hand-   |   |&lt;---------S0---------|                     |
 shake   |   |&lt;---------S1---------|             Version sent
         |   |                     |---------C1---------&gt;|
         |   |----------C2--------&gt;|                     |
         |   |                     |&lt;--------S2----------|
         |Ack Sent                 |                Ack Sent
         |   |&lt;---------S2---------|                     |
         |   |                     |---------C2---------&gt;|
         |Handshake Done           |           Handshake Done
 --------+---|                                           |
                 Pictorial Representation of Handshake
</code></pre></li>
</ol>
<h3 id="简化的握手交互流程"><a href="#简化的握手交互流程" class="headerlink" title="简化的握手交互流程"></a>简化的握手交互流程</h3><p>而在实际应用中，通常使用三次握手来简化以上握手流程：</p>
<ol>
<li>Client —— C0&amp;C1 ——&gt; Server</li>
<li>Client &lt;—— S0&amp;S1&amp;S2 —— Server</li>
<li>Client —— C2 ——&gt; Server</li>
</ol>
<h3 id="握手交互抓包"><a href="#握手交互抓包" class="headerlink" title="握手交互抓包"></a>握手交互抓包</h3><p>通过 Wirshark 抓包，得到以下数据包：</p>
<ol>
<li><p>Client —— C0&amp;C1 ——&gt; Server</p>
<pre><code> 0000   03 00 00 00 00 09 00 7c 02 f7 78 55 1e ce ab 8e   .......|..xU....
 0010   1e 36 2f 07 c5 86 8a 70 b2 66 d4 02 20 e5 08 61   .6/....p.f.. ..a
 ····   ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ··   ················
 05f0   c4 10 96 07 08 84 39 34 53 ce 50 96 94 af be ab   ......94S.P.....
 0600   e0                                                .
 -------------------------------------------------------------------------
 Protocol version: 03
 Handshake C1: 0000000009007c02f778551eceab8e1e362f07c5868a70b2…
</code></pre></li>
<li><p>Client &lt;—— S0&amp;S1&amp;S2 —— Server</p>
<pre><code> 0000   03 06 a7 7f 3b 0d 0e 0a 0d 8b 4c 51 8d d0 a9 c7   ....;.....LQ....
 0010   21 e8 6a 5b b0 4a 9d 74 91 0f 30 03 fa bc 77 6e   !.j[.J.t..0...wn
 ····   ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ··   ················
 0600   2d a1 d7 ca 81 18 80 02 9a d4 94 92 ab 14 ea 8a   -...............
 ····   ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ··   ················
 0bf0   96 4b 7e 0c f1 27 fb fd 52 02 19 5d d7 73 57 47   .K~..&#39;..R..].sWG
 0c00   f0                                                .
 -------------------------------------------------------------------------
 Protocol version: 03
 Handshake S1: 06a77f3b0d0e0a0d8b4c518dd0a9c721e86a5bb04a9d7491…
 Handshake S2: a1d7ca811880029ad49492ab14ea8a119cd415aa26c62ee4…
</code></pre></li>
<li><p>Client —— C2 ——&gt; Server</p>
<pre><code> 0000   e2 5c 15 c2 2c af 72 d0 98 6f bd 3e da 0d 71 51   .\..,.r..o.&gt;..qQ
 ····   ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ··   ················
 05f0   94 e0 bc b0 94 31 f4 20 d6 e7 d3 03 6d 2c 71 77   .....1. ....m,qw
 -------------------------------------------------------------------------
 Handshake C2: e25c15c22caf72d0986fbd3eda0d7151973e19083e0abbef…
</code></pre></li>
</ol>
<h3 id="握手报文分析"><a href="#握手报文分析" class="headerlink" title="握手报文分析"></a>握手报文分析</h3><h4 id="C0-与-S0"><a href="#C0-与-S0" class="headerlink" title="C0 与 S0"></a>C0 与 S0</h4><pre><code>    C0 与 S0
+-+-+-+-+-+-+-+-+
|    version    |
+-+-+-+-+-+-+-+-+
</code></pre><ul>
<li>C0：客户端发送其所支持的 RTMP 版本号：3~31。一般都是写 3</li>
<li>S1：服务端返回其所支持的版本号。如果没有客户端的版本号，默认返回 3</li>
</ul>
<h4 id="C1-与-S1"><a href="#C1-与-S1" class="headerlink" title="C1 与 S1"></a>C1 与 S1</h4><pre><code>       C1 与 S1
+-+-+-+-+-+-+-+-+-+-+
|   time (4 bytes)  |
+-+-+-+-+-+-+-+-+-+-+
|   zero (4 bytes)  |
+-+-+-+-+-+-+-+-+-+-+
|   random bytes    |
+-+-+-+-+-+-+-+-+-+-+
|random bytes(cont) |
|       ....        |
+-+-+-+-+-+-+-+-+-+-+
</code></pre><ul>
<li>C1/S1 长度为 1536B。主要目的是确保握手的唯一性。</li>
<li>格式为 time + zero + random</li>
<li>time 发送时间戳，长度 4 byte</li>
<li>zero 保留值 0，长度 4 byte</li>
<li>random 随机值，长度 1528 byte，保证此次握手的唯一性，确定握手的对象</li>
</ul>
<h4 id="C2-与-S2"><a href="#C2-与-S2" class="headerlink" title="C2 与 S2"></a>C2 与 S2</h4><pre><code>       C2 与 S2
+-+-+-+-+-+-+-+-+-+-+
|   time (4 bytes)  |
+-+-+-+-+-+-+-+-+-+-+
|   time2(4 bytes)  |
+-+-+-+-+-+-+-+-+-+-+
|   random bytes    |
+-+-+-+-+-+-+-+-+-+-+
|random bytes(cont) |
|       ....        |
+-+-+-+-+-+-+-+-+-+-+
</code></pre><ul>
<li>C2/S2 的长度也是 1536B。相当于就是 S1/C1 的响应值，对应 C1/S1 的 Copy 值，在于字段有点区别</li>
<li>time， C2/S2 发送的时间戳，长度 4 byte</li>
<li>time2， S1/C1 发送的时间戳，长度 4 byte</li>
<li>random，S1/C1 发送的随机数，长度为 1528B</li>
</ul>
<h2 id="建立网络连接（NetConnection）"><a href="#建立网络连接（NetConnection）" class="headerlink" title="建立网络连接（NetConnection）"></a>建立网络连接（NetConnection）</h2><h3 id="建立网络连接交互流程"><a href="#建立网络连接交互流程" class="headerlink" title="建立网络连接交互流程"></a>建立网络连接交互流程</h3><ol>
<li>Client ——&gt; Server : Command Message Connect</li>
<li>Client &lt;—— Server : Window Acknowledgement Size</li>
<li>Client &lt;—— Server : Set Peer Bandwidth</li>
<li>Client ——&gt; Server : Window Acknowledgement Size</li>
<li>Client &lt;—— Server : User Control Message Stream Begin</li>
<li><p>Client &lt;—— Server : Command Message _result</p>
<pre><code>             +----------+                     +----------+
             |  Client  |          |          |  Server  |
             +----------+          |          +----------+
 --------+---|---------- Command Message(connect) ------&gt;|
         |   |                                           |
         |   |&lt;------ Window Acknowledgement Size -------|
         |   |                                           |
         |   |&lt;---------- Set Peer Bandwidth ------------|
         |   |                                           |
 Appli-  |   |------- Window Acknowledgement Size ------&gt;|
 cation  |   |                                           |
 Connect |   |&lt;---- User Control Message(StreamBegin) ---|
         |   |                                           |
         |   |&lt;----------- Command Message --------------|
         |   |       (_result- connect response)         |
 --------+---|                                           |
                 Message flow in the connect command
</code></pre></li>
</ol>
<h3 id="建立网络连接抓包"><a href="#建立网络连接抓包" class="headerlink" title="建立网络连接抓包"></a>建立网络连接抓包</h3><ol>
<li><p>Client ——&gt; Server : AMF0 Command connect()</p>
<pre><code> 0000   03 00 00 00 00 00 cc 14 00 00 00 00 02 00 07 63   ...............c
 0010   6f 6e 6e 65 63 74 00 3f f0 00 00 00 00 00 00 03   onnect.?........
 0020   00 03 61 70 70 02 00 06 6d 79 6c 69 76 65 00 08   ..app...mylive..
 0030   66 6c 61 73 68 56 65 72 02 00 0d 4c 4e 58 20 39   flashVer...LNX 9
 0040   2c 30 2c 31 32 34 2c 32 00 05 74 63 55 72 6c 02   ,0,124,2..tcUrl.
 0050   00 20 72 74 6d 70 3a 2f 2f 36 32 2e 32 33 34 2e   . rtmp://62.234.
 0060   31 31 31 2e 31 33 3a 31 39 33 35 2f 6d 79 6c 69   111.13:1935/myli
 0070   76 65 00 04 66 70 61 64 01 00 00 0c 63 61 70 61   ve..fpad....capa
 0080   62 69 6c 69 74 69 65 73 00 40 2e 00 00 00 00 00   bilities.@......
 0090   00 00 0b 61 75 64 69 6f 43 6f 64 65 63 73 00 40   ...audioCodecs.@
 00a0   af ce 00 00 00 00 00 00 0b 76 69 64 65 6f 43 6f   .........videoCo
 00b0   64 65 63 73 00 40 6f 80 00 00 00 00 00 00 0d 76   decs.@o........v
 00c0   69 64 65 6f 46 75 6e 63 74 69 6f 6e 00 3f f0 00   ideoFunction.?..
 00d0   00 00 00 00 00 00 00 09                           ........
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (AMF0 Command connect(&#39;mylive&#39;))
     Response to this call in frame: 20
     RTMP Header
         00.. .... = Format: 0
         ..00 0011 = Chunk Stream ID: 3
         Timestamp: 0
         Body size: 204
         Type ID: AMF0 Command (0x14)
         Stream ID: 0
     RTMP Body
         String &#39;connect&#39;
         Number 1
         Object (8 items)
             AMF0 type: Object (0x03)
             Property &#39;app&#39; String &#39;mylive&#39;
             Property &#39;flashVer&#39; String &#39;LNX 9,0,124,2&#39;
             Property &#39;tcUrl&#39; String &#39;rtmp://62.234.111.13:1935/mylive&#39;
             Property &#39;fpad&#39; Boolean false
             Property &#39;capabilities&#39; Number 15
             Property &#39;audioCodecs&#39; Number 4071
             Property &#39;videoCodecs&#39; Number 252
             Property &#39;videoFunction&#39; Number 1
             End Of Object Marker
</code></pre></li>
<li><p>Server ——&gt; Client : Window Acknowledgement Size</p>
<pre><code> 0000   02 00 00 00 00 00 04 05 00 00 00 00 00 4c 4b 40   .............LK@
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (Window Acknowledgement Size 5000000)
     RTMP Header
         00.. .... = Format: 0
         ..00 0010 = Chunk Stream ID: 2
         Timestamp: 0
         Body size: 4
         Type ID: Window Acknowledgement Size (0x05)
         Stream ID: 0
     RTMP Body
         Window acknowledgement size: 5000000
</code></pre></li>
<li><p>Server ——&gt; Client : Set Peer Bandwidth</p>
<pre><code> 0000   02 00 00 00 00 00 05 06 00 00 00 00 00 4c 4b 40   .............LK@
 0010   02                                                .
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (Set Peer Bandwidth 5000000,Dynamic)
     RTMP Header
         00.. .... = Format: 0
         ..00 0010 = Chunk Stream ID: 2
         Timestamp: 0
         Body size: 5
         Type ID: Set Peer Bandwidth (0x06)
         Stream ID: 0
     RTMP Body
         Window acknowledgement size: 5000000
         Limit type: Dynamic (2)
</code></pre></li>
<li><p>Server ——&gt; Client : Set Chunk Size</p>
<pre><code> 0000   02 00 00 00 00 00 04 01 00 00 00 00 00 00 10 00   ................
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (Set Chunk Size 4096)
     RTMP Header
         00.. .... = Format: 0
         ..00 0010 = Chunk Stream ID: 2
         Timestamp: 0
         Body size: 4
         Type ID: Set Chunk Size (0x01)
         Stream ID: 0
     RTMP Body
         Chunk size: 4096
</code></pre></li>
<li><p>Server ——&gt; Client : AMF0 Command _result</p>
<pre><code> 0000   03 00 00 00 00 00 be 14 00 00 00 00 02 00 07 5f   ..............._
 0010   72 65 73 75 6c 74 00 3f f0 00 00 00 00 00 00 03   result.?........
 0020   00 06 66 6d 73 56 65 72 02 00 0d 46 4d 53 2f 33   ..fmsVer...FMS/3
 0030   2c 30 2c 31 2c 31 32 33 00 0c 63 61 70 61 62 69   ,0,1,123..capabi
 0040   6c 69 74 69 65 73 00 40 3f 00 00 00 00 00 00 00   lities.@?.......
 0050   00 09 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61   .....level...sta
 0060   74 75 73 00 04 63 6f 64 65 02 00 1d 4e 65 74 43   tus..code...NetC
 0070   6f 6e 6e 65 63 74 69 6f 6e 2e 43 6f 6e 6e 65 63   onnection.Connec
 0080   74 2e 53 75 63 63 65 73 73 00 0b 64 65 73 63 72   t.Success..descr
 0090   69 70 74 69 6f 6e 02 00 15 43 6f 6e 6e 65 63 74   iption...Connect
 00a0   69 6f 6e 20 73 75 63 63 65 65 64 65 64 2e 00 0e   ion succeeded...
 00b0   6f 62 6a 65 63 74 45 6e 63 6f 64 69 6e 67 00 00   objectEncoding..
 00c0   00 00 00 00 00 00 00 00 00 09                     ..........
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (AMF0 Command _result(&#39;NetConnection.Connect.Success&#39;))
     Call for this response in frame: 17
     RTMP Header
         00.. .... = Format: 0
         ..00 0011 = Chunk Stream ID: 3
         Timestamp: 0
         Body size: 190
         Type ID: AMF0 Command (0x14)
         Stream ID: 0
     RTMP Body
         String &#39;_result&#39;
         Number 1
         Object (2 items)
             AMF0 type: Object (0x03)
             Property &#39;fmsVer&#39; String &#39;FMS/3,0,1,123&#39;
             Property &#39;capabilities&#39; Number 31
             End Of Object Marker
         Object (4 items)
             AMF0 type: Object (0x03)
             Property &#39;level&#39; String &#39;status&#39;
             Property &#39;code&#39; String &#39;NetConnection.Connect.Success&#39;
             Property &#39;description&#39; String &#39;Connection succeeded.&#39;
             Property &#39;objectEncoding&#39; Number 0
             End Of Object Marker
</code></pre></li>
<li><p>Client ——&gt; Server : Window Acknowledgement Size</p>
<pre><code> 0000   02 00 00 00 00 00 04 05 00 00 00 00 00 4c 4b 40   .............LK@
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (Window Acknowledgement Size 5000000)
     RTMP Header
         00.. .... = Format: 0
         ..00 0010 = Chunk Stream ID: 2
         Timestamp: 0
         Body size: 4
         Type ID: Window Acknowledgement Size (0x05)
         Stream ID: 0
     RTMP Body
         Window acknowledgement size: 5000000
</code></pre></li>
</ol>
<h2 id="建立网络流（NetStream）"><a href="#建立网络流（NetStream）" class="headerlink" title="建立网络流（NetStream）"></a>建立网络流（NetStream）</h2><ol>
<li>客户端发送命令消息中的“创建流”（createStream）命令到服务器端。</li>
<li><p>服务器端接收到“创建流”命令后，发送命令消息中的“结果”(_result)，通知客户端流的状态。</p>
<pre><code>             +----------+                     +----------+
             |  Client  |          |          |  Server  |
             +----------+          |          +----------+
 --------+---|------ Command Message(createStream) -----&gt;|
 Create  |   |                                           |
 Stream  |   |&lt;----------- Command Message --------------|
 --------+---|      (_result- createStream response)     |
</code></pre></li>
</ol>
<h3 id="建立网络流抓包"><a href="#建立网络流抓包" class="headerlink" title="建立网络流抓包"></a>建立网络流抓包</h3><ol>
<li><p>Client ——&gt; Server : AMF0 Command createStream()</p>
<pre><code> 0000   43 00 00 00 00 00 19 14 02 00 0c 63 72 65 61 74   C..........creat
 0010   65 53 74 72 65 61 6d 00 40 00 00 00 00 00 00 00   eStream.@.......
 0020   05                                                .
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (AMF0 Command createStream())
     Response to this call in frame: 25
     RTMP Header
         01.. .... = Format: 1
         ..00 0011 = Chunk Stream ID: 3
         Timestamp delta: 0
         Timestamp: 0 (calculated)
         Body size: 25
         Type ID: AMF0 Command (0x14)
     RTMP Body
         String &#39;createStream&#39;
         Number 2
         Null
</code></pre></li>
<li><p>Server ——&gt; Client : AMF0 Command _result</p>
<pre><code> 0000   03 00 00 00 00 00 1d 14 00 00 00 00 02 00 07 5f   ..............._
 0010   72 65 73 75 6c 74 00 40 00 00 00 00 00 00 00 05   result.@........
 0020   00 3f f0 00 00 00 00 00 00                        .?.......
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (AMF0 Command _result())
     Call for this response in frame: 23
     RTMP Header
         00.. .... = Format: 0
         ..00 0011 = Chunk Stream ID: 3
         Timestamp: 0
         Body size: 29
         Type ID: AMF0 Command (0x14)
         Stream ID: 0
     RTMP Body
         String &#39;_result&#39;
         Number 2
         Null
         Number 1
</code></pre></li>
</ol>
<h2 id="播放（Play）"><a href="#播放（Play）" class="headerlink" title="播放（Play）"></a>播放（Play）</h2><ol>
<li>客户端发送命令消息中的播放（play）命令到服务器。</li>
<li>接收到播放命令后，服务器发送设置块大小（ChunkSize）协议消息。</li>
<li>服务器发送用户控制消息中的 streambegin，告知客户端流ID。</li>
<li>播放命令成功的话，服务器发送命令消息中的“响应状态” NetStream.Play.Start &amp; NetStream.Play.reset，告知客户端播放命令执行成功。</li>
<li><p>在此之后服务器发送客户端要播放的音频和视频数据。</p>
<pre><code>         +----------+                     +----------+
         |  Client  |          |          |  Server  |
         +----------+          |          +----------+
</code></pre><p> ————+—-|————- Command Message (play) ————-&gt;|</p>
<pre><code>     |   |                                           |
     |   |&lt;-------------- SetChunkSize --------------|
     |   |                                           |
     |   |&lt;---- User Control (StreamIsRecorded) -----|
     |   |                                           |
     |   |&lt;------- UserControl (StreamBegin) --------|
     |   |                                           |
</code></pre><p> Play    |   |&lt;— Command Message(onStatus-play reset) —|</p>
<pre><code>     |   |                                           |
     |   |&lt;-- Command Message(onStatus-play start) --|
     |   |                                           |
     |   |&lt;------------- Audio Message --------------|
     |   |                                           |
     |   |&lt;------------- Video Message --------------|
     |   |                     |                     |
                               |
        Keep receiving audio and video stream till finishes
</code></pre></li>
</ol>
<h3 id="播放抓包"><a href="#播放抓包" class="headerlink" title="播放抓包"></a>播放抓包</h3><ol>
<li><p>Client ——&gt; Server : Command getStreamLength()</p>
<pre><code> 0000   08 00 00 00 00 00 1f 14 00 00 00 00 02 00 0f 67   ...............g
 0010   65 74 53 74 72 65 61 6d 4c 65 6e 67 74 68 00 40   etStreamLength.@
 0020   08 00 00 00 00 00 00 05 02 00 00                  ...........
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (AMF0 Command getStreamLength())
     RTMP Header
         00.. .... = Format: 0
         ..00 1000 = Chunk Stream ID: 8
         Timestamp: 0
         Body size: 31
         Type ID: AMF0 Command (0x14)
         Stream ID: 0
     RTMP Body
         String &#39;getStreamLength&#39;
         Number 3
         Null
         String &#39;&#39;
</code></pre></li>
<li><p>Client ——&gt; Server : Command play(‘’)</p>
<pre><code> 0000   08 00 00 00 00 00 1d 14 01 00 00 00 02 00 04 70   ...............p
 0010   6c 61 79 00 40 10 00 00 00 00 00 00 05 02 00 00   lay.@...........
 0020   00 c0 9f 40 00 00 00 00 00                        ...@.....
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (AMF0 Command play(&#39;&#39;))
     RTMP Header
         00.. .... = Format: 0
         ..00 1000 = Chunk Stream ID: 8
         Timestamp: 0
         Body size: 29
         Type ID: AMF0 Command (0x14)
         Stream ID: 1
     RTMP Body
         String &#39;play&#39;
         Number 4
         Null
         String &#39;&#39;
         Number -2000
</code></pre></li>
<li><p>Client ——&gt; Server : User Control Message Set Buffer Length</p>
<pre><code> 0000   42 00 00 01 00 00 0a 04 00 03 00 00 00 01 00 00   B...............
 0010   0b b8                                             ..
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (User Control Message Set Buffer Length 1,3000ms)
     RTMP Header
         01.. .... = Format: 1
         ..00 0010 = Chunk Stream ID: 2
         Timestamp delta: 1
         Timestamp: 1 (calculated)
         Body size: 10
         Type ID: User Control Message (0x04)
     RTMP Body
         Event type: Set Buffer Length (3)
</code></pre></li>
<li><p>Server ——&gt; Client : User Control Message Stream Begin</p>
<pre><code> 0000   02 00 00 00 00 00 06 04 00 00 00 00 00 00 00 00   ................
 0010   00 01                                             ..
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (User Control Message Stream Begin 1)
     RTMP Header
         00.. .... = Format: 0
         ..00 0010 = Chunk Stream ID: 2
         Timestamp: 0
         Body size: 6
         Type ID: User Control Message (0x04)
         Stream ID: 0
     RTMP Body
         Event type: Stream Begin (0)
</code></pre></li>
<li><p>Server ——&gt; Client : Command onStatus(‘NetStream.Play.Start’)</p>
<pre><code> 0000   05 00 00 00 00 00 60 14 01 00 00 00 02 00 08 6f   ......`........o
 0010   6e 53 74 61 74 75 73 00 00 00 00 00 00 00 00 00   nStatus.........
 0020   05 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74   ....level...stat
 0030   75 73 00 04 63 6f 64 65 02 00 14 4e 65 74 53 74   us..code...NetSt
 0040   72 65 61 6d 2e 50 6c 61 79 2e 53 74 61 72 74 00   ream.Play.Start.
 0050   0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 0a 53   .description...S
 0060   74 61 72 74 20 6c 69 76 65 00 00 09               tart live...
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (AMF0 Command onStatus(&#39;NetStream.Play.Start&#39;))
     RTMP Header
         00.. .... = Format: 0
         ..00 0101 = Chunk Stream ID: 5
         Timestamp: 0
         Body size: 96
         Type ID: AMF0 Command (0x14)
         Stream ID: 1
     RTMP Body
         String &#39;onStatus&#39;
         Number 0
         Null
         Object (3 items)
</code></pre></li>
<li><p>Server ——&gt; Client : Data |RtmpSampleAccess()</p>
<pre><code> 0000   05 00 00 00 00 00 18 12 01 00 00 00 02 00 11 7c   ...............|
 0010   52 74 6d 70 53 61 6d 70 6c 65 41 63 63 65 73 73   RtmpSampleAccess
 0020   01 01 01 01                                       ....
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (AMF0 Data |RtmpSampleAccess())
     RTMP Header
         00.. .... = Format: 0
         ..00 0101 = Chunk Stream ID: 5
         Timestamp: 0
         Body size: 24
         Type ID: AMF0 Data (0x12)
         Stream ID: 1
     RTMP Body
         String &#39;|RtmpSampleAccess&#39;
         Boolean true
         Boolean true
</code></pre></li>
<li><p>Server ——&gt; Client : Data onMetaData()</p>
<pre><code> 0000   05 00 00 00 00 01 83 12 01 00 00 00 02 00 0a 6f   ...............o
 0010   6e 4d 65 74 61 44 61 74 61 03 00 06 53 65 72 76   nMetaData...Serv
 ····   ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ··   ················
 0180   00 00 00 00 00 00 00 00 00 00 00 00 00 00 09      ...............
 -------------------------------------------------------------------------
 Real Time Messaging Protocol (AMF0 Data onMetaData())
     RTMP Header
         00.. .... = Format: 0
         ..00 0101 = Chunk Stream ID: 5
         Timestamp: 0
         Body size: 387
         Type ID: AMF0 Data (0x12)
         Stream ID: 1
     RTMP Body
         String &#39;onMetaData&#39;
         Object (14 items)
             AMF0 type: Object (0x03)
             Property &#39;Server&#39; String &#39;NGINX RTMP (github.com/arut/nginx-rtmp-module)&#39;
             Property &#39;width&#39; Number 1280
             Property &#39;height&#39; Number 720
             Property &#39;displayWidth&#39; Number 1280
             Property &#39;displayHeight&#39; Number 720
             Property &#39;duration&#39; Number 0
             Property &#39;framerate&#39; Number 25
             Property &#39;fps&#39; Number 25
             Property &#39;videodatarate&#39; Number 0
             Property &#39;videocodecid&#39; Number 7
             Property &#39;audiodatarate&#39; Number 125
             Property &#39;audiocodecid&#39; Number 1
             Property &#39;profile&#39; String &#39;&#39;
             Property &#39;level&#39; String &#39;&#39;
             End Of Object Marker
</code></pre></li>
</ol>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><h3 id="音频数据"><a href="#音频数据" class="headerlink" title="音频数据"></a>音频数据</h3><pre><code>0000   80 fa 5b 46 e3 29 dc a6 32 90 25 1e 08 00 45 00   ..[F.)..2.%...E.
····   ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ··   ················
05e0   aa aa 02 ab 2a 26 a8 20 06 60                     ....*&amp;. .`
-------------------------------------------------------------------------
Real Time Messaging Protocol (Audio Data)
    RTMP Header
        00.. .... = Format: 0
        ..00 0110 = Chunk Stream ID: 6
        Timestamp: 59947
        Body size: 2054
        Type ID: Audio Data (0x08)
        Stream ID: 1
    RTMP Body
        Control: 0x1f (ADPCM 44 kHz 16 bit stereo)
            0001 .... = Format: ADPCM (1)
            .... 11.. = Sample rate: 44 kHz (3)
            .... ..1. = Sample size: 16 bit (1)
            .... ...1 = Channels: stereo (1)
        Audio data: 80a1a80292a0884488cccd0c9088cd54cc88888888c8ccd0…
</code></pre><h3 id="视频数据"><a href="#视频数据" class="headerlink" title="视频数据"></a>视频数据</h3><pre><code>0000   47 00 00 28 00 1a 1b 09 27 01 00 00 a0 00 00 1a   G..(....&#39;.......
····   ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ·· ··   ················
1a20   b4 9e 58                                          ..X
-------------------------------------------------------------------------
Real Time Messaging Protocol (Video Data)
    RTMP Header
        01.. .... = Format: 1
        ..00 0111 = Chunk Stream ID: 7
        Timestamp delta: 40
        Timestamp: 129960 (calculated)
        Body size: 6683
        Type ID: Video Data (0x09)
    RTMP Body
        Control: 0x27 (inter-frame H.264)
            0010 .... = Type: inter-frame (2)
            .... 0111 = Format: H.264 (7)
        Video data: 010000a000001a12419aab49a8416c994c085ffffe8d340d…
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://wwwimages2.adobe.com/content/dam/acom/en/devnet/rtmp/pdf/rtmp_specification_1.0.pdf">《Adobe’s Real Time Messaging Protocol》</a></li>
<li>[2] <a href="https://www.cnblogs.com/jimodetiantang/p/8974075.html">RTMP 协议详解 - 季末的天堂 - 博客园</a></li>
</ul>
]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>RTMP</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体传输 - RTMP 协议报文分析</title>
    <url>/post/2020/50f2e42d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>握手之后，连接开始对一个或多个 <code>chunk stream</code> 进行合并。创建的每个块都有一个唯一 <code>id</code> 对其进行关联，这个 <code>id</code> 叫做 <code>chunk stream id</code>。这些块通过网络进行传输。传递时，每个块必须被完全发送才可以发送下一块。在接收端，这些块被根据 <code>chunk stream id</code> 被组装成消息。</p>
<p>每个块包含一个头和数据体。块头包含三个部分：</p>
<pre><code>+--------------+----------------+--------------------+--------------+
| Basic Header | Message Header | Extended Timestamp |  Chunk Data  |
+--------------+----------------+--------------------+--------------+
|&lt;------------------- Chunk Header -----------------&gt;|
                            Chunk Format
</code></pre><a id="more"></a>
<h2 id="Chunk-Header"><a href="#Chunk-Header" class="headerlink" title="Chunk Header"></a>Chunk Header</h2><p><code>chunk Header</code> 包括 <code>Basic Header</code>、<code>Message Header</code>、<code>Extended Timestamp</code> 三部分。</p>
<ul>
<li><code>Basic Header</code> (1 - 3 bits)：这个字段对 <code>chunk stream id</code> 和块类型进行编码。块类型决定了消息头的编码格式。该字段长度完全取决于 <code>chunk stream id</code>，因为 <code>chunk stream id</code> 是一个可变长度的字段。</li>
<li><code>Message Header</code> (0 / 3 / 7 / 11bits)：这一字段对正在发送的消息 (不管是整个消息，还是只是一小部分) 的信息进行编码。这一字段的长度可以使用块头中定义的块类型进行决定。</li>
<li><code>Extended Timestamp</code> (0 / 4 bytes)：这一字段是否出现取决于块消息头中的 <code>timestamp</code> 或者 <code>timestamp delta</code> 字段。更多信息参考</li>
</ul>
<h3 id="Chunk-Basic-Header"><a href="#Chunk-Basic-Header" class="headerlink" title="Chunk Basic Header"></a>Chunk Basic Header</h3><p><code>chunk Basic Header</code> 对 <code>chunk stream id</code> 和块类型 (由下图中的 fmt 字段表示) 进行编码。<code>chunk Basic Header</code> 字段可能会有 <code>1</code>，<code>2</code> 或者 <code>3</code> 个字节，取决于 <code>chunk stream id</code>。</p>
<p>一个 <code>RTMP</code> 实现应该使用能够容纳这个 <code>id</code> 的最小的容量进行表示。</p>
<p><code>RTMP</code> 协议最多支持 <code>65597</code> 个流，<code>chunk stream id</code> 范围 <code>3 - 65599</code>。<code>id</code> <code>0</code>、<code>1</code>、<code>2</code> 被保留。</p>
<ul>
<li><p><code>0</code> 值表示二字节形式，并且 <code>chunk stream id</code> 范围 <code>64 - 319</code></p>
<pre><code>   0                   1
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |fmt|     0     |   cs id - 64  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        Chunk Basic Header 2
</code></pre></li>
<li><p><code>1</code> 值表示三字节形式，并且 <code>chunk stream id</code> 范围为 <code>64 - 65599</code></p>
<pre><code>   0                   1                   2
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |fmt|     1     |           cs id - 64          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              chunk Basic Header 3
</code></pre></li>
<li><p><code>3 - 63</code> 范围内的值表示整个流 <code>chunk stream id</code></p>
<pre><code>    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |fmt|   cs id   |
   +-+-+-+-+-+-+-+-+
  chunk Basic Header 1
</code></pre></li>
<li><p>带有 <code>2</code> 值的 <code>chunk stream id</code> 被保留，用于下层协议控制消息和命令。</p>
</li>
</ul>
<p>协议中字段代表的意义如下：</p>
<ul>
<li><code>fmt</code> (2bits)：这一字段指示 <code>chunk Message Header</code> 使用的四种格式之一。</li>
<li><code>cs id</code> (6bits)：这一字段包含有 <code>chunk stream id</code>，值的范围是 <code>2 - 63</code>。值 <code>0</code> 或 <code>1</code> 用于指示这一字段是 2 或 3 字节版本。</li>
<li><p><code>cs id - 64</code> (8/16bits)：这一字段包含了 <code>chunk stream id</code> 减掉 <code>64</code> 后的值。例如，<code>chunk stream id</code> 为 <code>365</code> 时会在 <code>cs id</code> 中会以一个 <code>1</code> 和 <code>cs id - 64</code> 中的一个 <code>16</code> 位 的 <code>301</code> 进行表示。</p>
<blockquote>
<p><code>chunk stream id</code> <code>64 - 319</code> 可以使用 2-byte 或者 3-byte 的形式在头中表示。</p>
</blockquote>
</li>
</ul>
<h3 id="Message-Header"><a href="#Message-Header" class="headerlink" title="Message Header"></a>Message Header</h3><ul>
<li><p><code>Type 0</code>：块头的长度是 <code>11bits</code>。这一类型必须用在 <code>chunk stream</code> 的起始位置，和流 <code>timestamp</code> 重来的时候 (比如，重置)。</p>
<pre><code>  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                     timestamp                 |message length |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     message length (cont)     |message type id| msg stream id |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |           message stream id (cont)            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                  chunk Message Header - Type 0
</code></pre><blockquote>
<p><code>timestamp</code> (<code>3bits</code>)：对于 type-0 块，当前消息的绝对 <code>timestamp</code> 在这里发送。如果 <code>timestamp</code> 大于或者等于 <code>16777215</code> (十六进制 <code>0xFFFFFF</code>)，这一字段必须是 <code>16777215</code>，表明有扩展 <code>timestamp</code> 字段来补充完整的 <code>32</code> 位 <code>timestamp</code>。否则的话，这一字段必须是整个的 <code>timestamp</code>。</p>
</blockquote>
</li>
<li><p><code>Type 1</code>：块头长为 <code>7bits</code>。不包含消息流 <code>id</code>；这一块使用前一块一样的流 <code>id</code>。可变长度消息的流 (例如，一些视频格式) 应该在第一块之后使用这一格式表示之后的每个新消息。</p>
<pre><code>   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                timestamp delta                |message length |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     message length (cont)     |message type id|
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                    chunk Message Header - Type 1
</code></pre></li>
<li><p><code>Type 2</code>：块头长度为 <code>3bits</code>。既不包含流 <code>id</code> 也不包含消息长度；这一块具有和前一块相同的流 id 和消息长度。具有不变长度的消息 (例如，一些音频和数据格式) 应该在第一块之后使用这一格式表示之后的每个新消息。</p>
<pre><code>   0                   1                   2
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                timestamp delta                |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            chunk Message Header - Type 2
</code></pre></li>
<li><p><code>Type 3</code>：块没有消息头。流 id、消息长度以及 timestamp delta 等字段都不存在；这种类型的块使用前面块一样的 chunk stream id。当单一一个消息被分割为多块时，除了第一块的其他块都应该使用这种类型。参考例 2 (5.3.2.2 小节)。组成流的消息具有同样的大小，流 id 和时间间隔应该在类型 2 之后的所有块都使用这一类型。参考例 1 (5.3.2.1 小节)。如果第一个消息和第二个消息之间的 delta 和第一个消息的 timestamp 一样的话，那么在类型 0 的块之后要紧跟一个类型 3 的块，因为无需再来一个类型 2 的块来注册 delta 了。如果一个类型 3 的块跟着一个类型 0 的块，那么这个类型 3 块的 timestamp delta 和类型 0 块的 timestamp 是一样的。</p>
</li>
</ul>
<p>块消息头中各字段的描述如下：</p>
<ul>
<li><code>timestamp delta</code> (3bits)：对于一个类型 1 或者类型 2 的块，前一块的 timestamp 和当前块的 timestamp 的区别在这里发送。如果 delta 大于或者等于 16777215 (十六进制 0xFFFFFF)，那么这一字段必须是为 16777215，表示具有扩展 timestamp 字段来对整个 32 位 delta 进行编码。否则的话，这一字段应该是为具体 delta。</li>
<li><code>message length</code> (3bits)：对于一个类型 0 或者类型 1 的块，消息长度在这里进行发送。注意这通常不同于块的有效载荷的长度。块的有效载荷代表所有的除了最后一块的最大块大小，以及剩余的 (也可能是小消息的整个长度) 最后一块。</li>
<li><code>message type id</code> (1bit)：对于类型 0 或者类型 1 的块，消息的类型在这里发送。</li>
<li><code>message stream id</code> (4bits)：对于一个类型为 0 的块，保存消息流 id。消息流 id 以小端格式保存。所有同一个 chunk stream 下的消息都来自同一个消息流。当可以将不同的消息流组合进同一个 chunk stream 时，这种方法比头压缩的做法要好。但是，当一个消息流被关闭而其他的随后另一个是打开着的，就没有理由将现有 chunk stream 以发送一个新的类型 0 的块进行复用了。</li>
</ul>
<h3 id="Extended-Timestamp"><a href="#Extended-Timestamp" class="headerlink" title="Extended Timestamp"></a>Extended Timestamp</h3><p><code>extended timestamp</code> 字段用于对大于 <code>16777215</code> (<code>0xFFFFFF</code>) 的 <code>timestamp</code> 或者 <code>timestamp delta</code> 进行编码；也就是，对于不适合于在 <code>24</code> 位的 <code>Type 0</code>、<code>Type 1</code> 和 <code>Type 2</code> 的块里的 <code>timestamp</code> 和 <code>timestamp delta</code> 编码。这一字段包含了整个 <code>32</code> 位的 <code>timestamp</code> 或者 <code>timestamp delta</code> 编码。可以通过设置 <code>Type 0</code> 块的 <code>timestamp</code> 字段、<code>Type 1</code> 或者 <code>Type 2</code> 块的 <code>timestamp delta</code> 字段 <code>16777215</code> (<code>0xFFFFFF</code>) 来启用这一字段。当最近的具有同一 <code>chunk stream</code> 的 <code>Type 0</code>、<code>Type 1</code> 和 <code>Type 2</code> 指示扩展 <code>timestamp</code> 字段出现时，这一字段才会在 <code>Type 3</code> 的块中出现。</p>
<h2 id="Chunk-Data"><a href="#Chunk-Data" class="headerlink" title="Chunk Data"></a>Chunk Data</h2><p><code>chunk data</code> 的长度可变，是当前块的有效负载。</p>
<ul>
<li><code>chunk data</code> 的长度由 <code>chunk header</code> 中的 <code>message length</code> 决定</li>
<li><code>chunk data</code> 的类型由 <code>chunk header</code> 中的 <code>message type id</code> 决定</li>
</ul>
<p>根据 message type id 的不同，可以将 <code>chunk data</code> 分为以下类型：</p>
<ul>
<li>协议控制消息 （Protocol Control Messages）</li>
<li>用户控制消息 （User Control Message）</li>
<li>RTMP 命令消息 （RTMP Command Messages）</li>
</ul>
<h3 id="协议控制消息-1-2-3-5-6"><a href="#协议控制消息-1-2-3-5-6" class="headerlink" title="协议控制消息 (1, 2, 3, 5, 6)"></a>协议控制消息 (1, 2, 3, 5, 6)</h3><p>协议控制消息主要用来沟通 <code>RTMP</code> 初始状态的相关连接信息，比如：<code>Windows Size</code>，<code>chunk Size</code> 等。</p>
<p>协议控制消息中一共有 5 种不同的 <code>Message</code> 类型，是根据 <code>chunk Header</code> 中 <code>Message Header</code> 的 <code>message type id</code> 决定的，取值范围为 1, 2, 3, 5, 6。</p>
<p>另外，协议控制消息在构造的时候需要注意，其 <code>chunk Header</code> 中的 <code>message stream id</code> 和 <code>chunk stream id</code> 需要设置为固定值：</p>
<ul>
<li><code>message stream id == 0</code></li>
<li><code>chunk stream id == 2</code></li>
</ul>
<h4 id="设置块大小-1"><a href="#设置块大小-1" class="headerlink" title="设置块大小 (1)"></a>设置块大小 (1)</h4><p>设置块大小，被用来通知对方新的最大的块大小。</p>
<p>默认最大的块大小为 128 字节，客户端和服务器可以使用此消息来修改默认的块大小。例如，假设客户端想要发送的音频数据大小为 131 字节，而块大小为 128 字节。在这种情况下，客户端可以通知服务器新的块大小为 131 字节，然后就可以使用一个块来发送完整的音频数据了。</p>
<p>最大的块大小至少为 128 字节，块至少携带 1 个字节的内容。通信的每一个方向（例如从客户端到服务器）拥有独立的块大小设置。</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0|                     chunk size (31 bits)                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        Payload for the &#39;Set Chunk Size&#39; protocol message
</code></pre><ul>
<li><code>0</code>：当前比特位必须为零。</li>
<li><code>chunk size</code> (31bits)：本字段标识了新的最大块大小，以字节为单位，发送端之后将使用此值作为最大的块大小。本字段的有效值为 <code>1-2147483647(0x7FFFFFFF)</code>，由于消息的最大长度为 <code>16777215(0xFFFFFF)</code>，而一个块最多只能携带一条消息，因此本字段的实际有效值为 <code>1-16777215(0xFFFFFF)</code>。</li>
</ul>
<h4 id="中断消息-2"><a href="#中断消息-2" class="headerlink" title="中断消息 (2)"></a>中断消息 (2)</h4><p>中断消息，用来通知通信的对方，如果正在等待一条消息的部分块（已经接收了一部分），那么可以丢弃<br>之前已经接收到的块。通信的一方将接收到 <code>chunk stream id</code> 作为当前协议消息的有效数据。应用程序可以发送此消息来通知对方，当前正在传输的消息没有必要再处理了。</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       chunk stream id (32 bits)               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      Payload for the &#39;Abort Message&#39; protocol message
</code></pre><ul>
<li><code>chunk stream id</code>(32bits)：本字段中 <code>chunk stream id</code> 用来标识哪个 <code>chunk stream id</code> 的消息将被丢弃。</li>
</ul>
<h4 id="应答-3"><a href="#应答-3" class="headerlink" title="应答 (3)"></a>应答 (3)</h4><p>客户端和服务器在接收到与接收窗口大小相等的数据后，必须发送应答消息给对方。窗口大小的定义为发送方在接收到接收方的任何应答前，可以发送的最大数据量。本消息包含了序列号，序列号为截至目前接收到的数据总和，以字节为单位。</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        sequence number (4 bytes)              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       Payload for the &#39;Acknowledgement&#39; protocol message
</code></pre><ul>
<li>序列号 (32bits)：本字段包含了截止目前接收到的数据总和，以字节为单位。</li>
</ul>
<h4 id="窗口确认大小-5"><a href="#窗口确认大小-5" class="headerlink" title="窗口确认大小 (5)"></a>窗口确认大小 (5)</h4><p>客户端和服务器发送这个消息来通知对方应答窗口的大小。发送方在发送了等于窗口大小的数据之后，等待接收对方的应答消息（在接收到应答之前停止发送数据）。接收方必须发送应答消息，在会话开始时，或从上一次发送应答之后接收到了等于窗口大小的数据。</p>
<p>这是用来协商发送包的大小的。这个和上面的 chunk size 不同，这里主要针对的是客户端可接受的最大数据包的值，而 chunk size 是指每次发送的包的大小。一般电脑设置的大小都是 500000B</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Acknowledgement Window size (4 bytes)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 Payload for the &#39;Window Acknowledgement Size&#39; protocol message
</code></pre><h4 id="设置对端带宽-6"><a href="#设置对端带宽-6" class="headerlink" title="设置对端带宽 (6)"></a>设置对端带宽 (6)</h4><p>客户端和服务器发送此消息来说明对方的出口带宽限制。接收方以此来限制自己的出口带宽，即限制未被应答的消息数据大小。接收到此消息的一方，如果窗口大小与上次发送的不一致，应该回复应答窗口大小的消息。</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Acknowledgement Window size                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Limit Type   |
+-+-+-+-+-+-+-+-+
      Payload for the &#39;Set Peer Bandwidth&#39; protocol message
</code></pre><ul>
<li>限制类型的取值为下面之一：<ul>
<li>硬限制（0）：应该限制出口带宽为指明的窗口大小。</li>
<li>软限制（1）：应该限制出口带宽为指明的窗口大小，或已经生效的小一点的窗口大小。</li>
<li>动态限制（2）：如果上一次为硬限制，此消息被视为硬限制，否则忽略此消息。</li>
</ul>
</li>
</ul>
<h3 id="用户控制消息-4"><a href="#用户控制消息-4" class="headerlink" title="用户控制消息 (4)"></a>用户控制消息 (4)</h3><p>客户端或者服务器端发送这一消息来通知对端用户控制事件。</p>
<h3 id="命令消息"><a href="#命令消息" class="headerlink" title="命令消息"></a>命令消息</h3><ul>
<li>命令消息 (20, 17)</li>
<li>数据消息 (18, 15)</li>
<li>共享对象消息 (19, 16)</li>
<li>音频消息 (8)</li>
<li>视频消息 (9)</li>
<li>统计消息 (22)</li>
</ul>
<h4 id="命令消息-20-17"><a href="#命令消息-20-17" class="headerlink" title="命令消息 (20, 17)"></a>命令消息 (20, 17)</h4><p>命令消息在客户端和服务器端传递 AMF 编码的命令。这些消息被分配以消息类型值为 20 以进行 <code>AMF0</code> 编码，消息类型值为 17 以进行 <code>AMF3</code> 编码。</p>
<p>这些消息发送以进行一些操作，比如，连接，创建流，发布，播放，对端暂停。命令消息，像 <code>onstatus</code>、<code>result</code> 等等，用于通知发送者请求的命令的状态。一个命令消息由命令名、事务 id 和包含相关参数的命令对象组成。一个客户端或者一个服务器端可以通过和对端通信的流使用这些命令消息请求远程调用 (RPC)。</p>
<p>客户端和服务器通过 <code>AMF</code> 编码的数据交换命令。发送者发送包含命令名称，事务 ID，包含相关参数的命令对象的消息。例如，通过连接命令中包含的 APP 参数来告诉服务器连接的对方是哪个客户端。接收方处理命令消息，并使用相同的事务 ID 应答。应答字符串为 <code>_result</code> 或 <code>_error</code> 或方法名，例如 <code>verifyClient</code> 或 <code>contactExternalServer</code>。事务 ID 标明了应答指向的命令。事务 ID 相当于 <code>IMAP</code> 协议或其他协议中的标签。命令字符串中的方法名，表明了发送端想要在接收端执行的方法。</p>
<p>下面的类对象被用来发送各种命令：</p>
<p><code>NetConnection</code>：服务器和客户端之间进行网络连接的一种高级表示形式。<br><code>NetStream</code>：代表了发送音频流，视频流，或其他相关数据的频道。当然还有一些像播放，暂停之类的命令，用来控制数据流。</p>
<h5 id="NetConnection"><a href="#NetConnection" class="headerlink" title="NetConnection"></a>NetConnection</h5><p>网络连接管理着客户端和服务器之间的双向连接。另外，它也支持异步远程命令调用。</p>
<p>网络连接允许使用以下的命令：</p>
<ul>
<li>连接 connect</li>
<li>调用 call</li>
<li>停止 close</li>
<li>创建流 createStream</li>
</ul>
<h6 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h6><p>客户端发送连接命令给服务器，来获取一个和服务器通信的实例。客户端发送给服务器的命令结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>Name of the command. Set to “connect”.</td>
</tr>
<tr>
<td>Transaction ID</td>
<td>Number</td>
<td>Always set to 1.</td>
</tr>
<tr>
<td>Command Object</td>
<td>Object</td>
<td>Command information object which has the name-value pairs.</td>
</tr>
<tr>
<td>Optional User Arguments</td>
<td>Object</td>
<td>Any optional information</td>
</tr>
</tbody>
</table>
</div>
<p>下面是连接命令的命令对象里包含的键值对的说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
<th>Example Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>app</td>
<td>String</td>
<td>The Server application name the client is connected to.</td>
<td>testapp</td>
</tr>
<tr>
<td>flashver</td>
<td>String</td>
<td>Flash Player version. It is the same string as returned by the ApplicationScript getversion () function.</td>
<td>FMSc/1.0</td>
</tr>
<tr>
<td>swfUrl</td>
<td>String</td>
<td>URL of the source SWF file making the connection.</td>
<td>file://C:/FlvPlayer.swf</td>
</tr>
<tr>
<td>tcUrl</td>
<td>String</td>
<td>URL of the Server. It has the following format. protocol://servername:port/appName/appInstance</td>
<td>rtmp://localhost:1935/testapp/instance1</td>
</tr>
<tr>
<td>fpad</td>
<td>Boolean</td>
<td>True if proxy is being used.</td>
<td>true or false</td>
</tr>
<tr>
<td>audioCodecs</td>
<td>Number</td>
<td>Indicates what audio codecs the client supports.</td>
<td>SUPPORT_SND_MP3</td>
</tr>
<tr>
<td>videoCodecs</td>
<td>Number</td>
<td>Indicates what video codecs are supported.</td>
<td>SUPPORT_VID_SORENSON</td>
</tr>
<tr>
<td>videoFunction</td>
<td>Number</td>
<td>Indicates what special video functions are supported.</td>
<td>SUPPORT_VID_CLIENT_SEEK</td>
</tr>
<tr>
<td>pageUrl</td>
<td>String</td>
<td>URL of the web page from where the SWF file was loaded.</td>
<td><a href="http://somehost/sample.html">http://somehost/sample.html</a></td>
</tr>
<tr>
<td>object Encoding</td>
<td>Number</td>
<td>AMF encoding method.</td>
<td>AMF3</td>
</tr>
</tbody>
</table>
</div>
<p>音频编码属性的可选值：</p>
<p>原始 PCM，ADPCM，MP3，NellyMoser（5，8,11，16，22，44kHz），AAC，Speex。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Codec Flag</th>
<th>Usage</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>SUPPORT_SND_NONE</td>
<td>Raw sound, no compression</td>
<td>0x0001</td>
</tr>
<tr>
<td>SUPPORT_SND_ADPCM</td>
<td>ADPCM compression</td>
<td>0x0002</td>
</tr>
<tr>
<td>SUPPORT_SND_MP3</td>
<td>mp3 compression</td>
<td>0x0004</td>
</tr>
<tr>
<td>SUPPORT_SND_INTEL</td>
<td>Not used</td>
<td>0x0008</td>
</tr>
<tr>
<td>SUPPORT_SND_UNUSED</td>
<td>Not used</td>
<td>0x0010</td>
</tr>
<tr>
<td>SUPPORT_SND_NELLY8</td>
<td>NellyMoser at 8-kHz compression</td>
<td>0x0020</td>
</tr>
<tr>
<td>SUPPORT_SND_NELLY</td>
<td>NellyMoser compression (5, 11, 22, and 44 kHz)</td>
<td>0x0040</td>
</tr>
<tr>
<td>SUPPORT_SND_G711A</td>
<td>G711A sound compression (Flash Media Server only)</td>
<td>0x0080</td>
</tr>
<tr>
<td>SUPPORT_SND_G711U</td>
<td>G711U sound compression (Flash Media Server only)</td>
<td>0x0100</td>
</tr>
<tr>
<td>SUPPORT_SND_NELLY16</td>
<td>NellyMouser at 16-kHz compression</td>
<td>0x0200</td>
</tr>
<tr>
<td>SUPPORT_SND_AAC</td>
<td>Advanced audio coding (AAC) codec</td>
<td>0x0400</td>
</tr>
<tr>
<td>SUPPORT_SND_SPEEX</td>
<td>Speex Audio</td>
<td>0x0800</td>
</tr>
<tr>
<td>SUPPORT_SND_ALL</td>
<td>All RTMP-supported audio codecs</td>
<td>0x0FFF</td>
</tr>
</tbody>
</table>
</div>
<h6 id="call"><a href="#call" class="headerlink" title="call"></a>call</h6><p>网络连接对象中包含的 call 方法，会在接收端执行远程过程调用（RPC）。被调用的 RPC 方法名作为 call 方法的参数传输。</p>
<p>从发送端到接收端的命令结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Procedure Name</td>
<td>String</td>
<td>Name of the remote procedure that is called.</td>
</tr>
<tr>
<td>Transaction ID</td>
<td>Number</td>
<td>If a response is expected we give a transaction Id. Else we pass a value of 0</td>
</tr>
<tr>
<td>Command Object</td>
<td>Object</td>
<td>If there exists any command info this is set, else this is set to null type.</td>
</tr>
<tr>
<td>Optional Arguments</td>
<td>Object</td>
<td>Any optional arguments to be provided</td>
</tr>
</tbody>
</table>
</div>
<p>应答的命令结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>Name of the command.</td>
</tr>
<tr>
<td>Transaction ID</td>
<td>Number</td>
<td>ID of the command, to which the response belongs.</td>
</tr>
<tr>
<td>Command Object</td>
<td>Object</td>
<td>If there exists any command info this is set, else this is set to null type.</td>
</tr>
<tr>
<td>Response</td>
<td>Object</td>
<td>Response from the method that was called.</td>
</tr>
</tbody>
</table>
</div>
<h6 id="createStream"><a href="#createStream" class="headerlink" title="createStream"></a>createStream</h6><p>客户端通过发送此消息给服务器来创建一个用于消息交互的逻辑通道。音频，视频，和元数据都是通过 createStream 命令创建<br>的流通道发布出去的。</p>
<p>NetConnection 是默认的交互通道，流 ID 为0. 协议和一部分命令消息，包含 createStream，都是使用默认的交互通道发布<br>的。</p>
<p>从客户端发送给服务器的命令结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>Name of the command. Set to “createStream”.</td>
</tr>
<tr>
<td>Transaction ID</td>
<td>Number</td>
<td>Transaction ID of the command.</td>
</tr>
<tr>
<td>Command Object</td>
<td>Object</td>
<td>If there exists any command info this is set, else this is set to null type.</td>
</tr>
</tbody>
</table>
</div>
<p>从服务器发送给客户端的命令结构：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>_result or _error; indicates whether the response is result or error.</td>
</tr>
<tr>
<td>Transaction ID</td>
<td>Number</td>
<td>ID of the command that response belongs to.</td>
</tr>
<tr>
<td>Command Object</td>
<td>Object</td>
<td>If there exists any command info this is set, else this is set to null type.</td>
</tr>
<tr>
<td>Stream ID</td>
<td>Number</td>
<td>The return value is either a stream ID or an error information object.</td>
</tr>
</tbody>
</table>
</div>
<h5 id="NetStream"><a href="#NetStream" class="headerlink" title="NetStream"></a>NetStream</h5><p>网络流定义了通过网络连接把音频，视频和数据消息流在客户端和服务器之间进行交换的通道。一个网络连接对象可以有多个<br>网络流，进而支持多个数据流。</p>
<p>客户端可以通过网络流发送到服务器的命令如下：</p>
<ul>
<li>播放play</li>
<li>播放2 play2</li>
<li>删除流 deleteStream</li>
<li>关闭流 closeStream</li>
<li>接收音频 receiveAudio</li>
<li>接收视频 receiveVideo</li>
<li>发布 publish</li>
<li>定位 seek</li>
<li>暂停 pause</li>
</ul>
<p>服务器通过发送 onStatus 命令给客户端来通知网络流状态的更新。</p>
<pre><code>+--------------+----------+----------------------------------------+
| Field Name   |   Type   |             Description                |
+--------------+----------+----------------------------------------+
| Command Name |  String  | The command name &quot;onStatus&quot;.           |
+--------------+----------+----------------------------------------+
| Transaction  |  Number  | Transaction ID set to 0.               |
| ID           |          |                                        |
+--------------+----------+----------------------------------------+
| Command      |  Null    | There is no command object for         |
| Object       |          | onStatus messages.                     |
+--------------+----------+----------------------------------------+
| Info Object  | Object   | An AMF object having at least the      |
|              |          | following three properties: &quot;level&quot;    |
|              |          | (String): the level for this message,  |
|              |          | one of &quot;warning&quot;, &quot;status&quot;, or &quot;error&quot;;|
|              |          | &quot;code&quot; (String): the message code, for |
|              |          | example &quot;NetStream.Play.Start&quot;; and    |
|              |          | &quot;description&quot; (String): a human-       |
|              |          | readable description of the message.   |
|              |          | The Info object MAY contain other      |
|              |          | properties as appropriate to the code. |
+--------------+----------+----------------------------------------+
           Format of NetStream status message commands.
</code></pre><h4 id="数据消息-18-15"><a href="#数据消息-18-15" class="headerlink" title="数据消息 (18, 15)"></a>数据消息 (18, 15)</h4><p>客户端或者服务器端通过发送这些消息以发送元数据或者任何用户数据到对端。元数据包括数据 (音频，视频等等) 的详细信息，比如创建时间，时长，主题等等。这些消息被分配以消息类型为 18 以进行 AMF0 编码和消息类型 15 以进行 AMF3 编码。</p>
<h4 id="共享对象消息-19-16"><a href="#共享对象消息-19-16" class="headerlink" title="共享对象消息 (19, 16)"></a>共享对象消息 (19, 16)</h4><p>所谓共享对象其实是一个 Flash 对象 (一个名值对的集合)，这个对象在多个不同客户端、应用实例中保持同步。消息类型 19 用于 AMF0 编码、16 用于 AMF3 编码都被为共享对象事件保留。每个消息可以包含有不同事件。</p>
<h4 id="音频消息-8"><a href="#音频消息-8" class="headerlink" title="音频消息 (8)"></a>音频消息 (8)</h4><p>客户端或者服务器端发送这一消息以发送音频数据到对端。消息类型 8 为音频消息保留。</p>
<h4 id="视频消息-9"><a href="#视频消息-9" class="headerlink" title="视频消息 (9)"></a>视频消息 (9)</h4><p>客户端或者服务器发送这一消息以发送视频数据到对端。消息类型 9 为视频消息保留。</p>
<h4 id="统计消息-22"><a href="#统计消息-22" class="headerlink" title="统计消息 (22)"></a>统计消息 (22)</h4><p>统计消息是一个单一的包含一系列的使用 6.1 节描述的 RTMP 子消息的消息。消息类型 22 用于统计消息。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://wwwimages2.adobe.com/content/dam/acom/en/devnet/rtmp/pdf/rtmp_specification_1.0.pdf">《Adobe’s Real Time Messaging Protocol》</a></li>
</ul>
]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>RTMP</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体传输 - RTP 协议</title>
    <url>/post/2020/faccfa50/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="RTP-协议"><a href="#RTP-协议" class="headerlink" title="RTP 协议"></a>RTP 协议</h2><h3 id="RTP-Header"><a href="#RTP-Header" class="headerlink" title="RTP Header"></a>RTP Header</h3><pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|X|  CC   |M|     PT      |       sequence number         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           timestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           synchronization source (SSRC) identifier            |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|            contributing source (CSRC) identifiers             |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><a id="more"></a>
<p>前 12 个字节出现在每个 RTP 数据包中，这些字段具有的含义如下：</p>
<ul>
<li><p><strong>版本 (V)</strong>：2 位，该字段标识 RTP 的版本。RFC3550 定义的版本规范为 2.</p>
</li>
<li><p><strong>填充 (P)</strong>：1 位，如果设置了填充位，则数据包包含一个或多个末尾的其他填充字节不属于有效载荷。</p>
</li>
<li><p><strong>扩展名 (X)</strong>：1 位，如果扩展位被置位，则固定报头必须后跟一个扩展头部。</p>
</li>
<li><p><strong>CSRC 计数 (CC)</strong>：4 位，CSRC 计数包含随后的 CSRC 标识符的数量固定头。</p>
</li>
<li><p><strong>标记 (M)</strong>：1 位，由配置文件定义，它允许诸如框架边界之类的重要事件发生在数据包流中被标记。</p>
</li>
</ul>
<blockquote>
<p><strong>标记 (M)</strong>：1 位，标识此 RTP 包携带了一组 NAL 数据的最后一个 NAL Unit。（RFC 6184）</p>
</blockquote>
<ul>
<li><p><strong>有效载荷类型 (PT)</strong>：7 位，该字段标识 RTP 有效负载的格式并确定由应用程序对其进行解释。一个配置文件可以指定一个负载类型代码到负载格式的默认静态映射。</p>
</li>
<li><p><strong>序列号 (sequence number)</strong>：16 位，每个 RTP 数据包的序列号加 1 发送，接收方可以使用它来检测丢包并恢复报文序列，序号的初始值应该是随机的。</p>
</li>
<li><p><strong>时间戳 (timestamp)</strong>：32 位，时间戳记录了该包中数据的第一个字节的采样时刻。在一次会话开始时，时间戳初始化成一个初始值。即使在没有信号发送时，时间戳的数值也要随时间而不断地增加（时间在流逝嘛）。时间戳是去除抖动和实现同步不可缺少的。</p>
</li>
<li><p><strong>同步源标识符 (SSRC)</strong>：32 位，同步源就是指 RTP 包流的来源。在同一个 RTP 会话中不能有两个相同的 SSRC 值。该标识符是随机选取的 RFC1889 推荐了 MD5 随机算法。</p>
</li>
<li><p><strong>贡献源列表 (CSRC List)</strong>：0～15 项，每项 32 位，用来标志对一个 RTP 混合器产生的新包有贡献的所有 RTP 包的源。由混合器将这些有贡献的 SSRC 标识符插入表中。SSRC 标识符都被列出来，以便接收端能正确指出交谈双方的身份。</p>
</li>
</ul>
<blockquote>
<p><a href="https://www.rfc-editor.org/rfc/rfc3551.txt">RFC 3551: RTP Profile for Audio and Video Conferences with Minimal Control</a>: 5.1. RTP Fixed Header Fields</p>
</blockquote>
<h2 id="RTP-协议拓展"><a href="#RTP-协议拓展" class="headerlink" title="RTP 协议拓展"></a>RTP 协议拓展</h2><h3 id="RTP-over-RTSP"><a href="#RTP-over-RTSP" class="headerlink" title="RTP over RTSP"></a>RTP over RTSP</h3><p>RTP over RTSP 并不是在 RTP 协议文档（RFC 3550）中定义，而是在 RTSP 协议文档（RFC 2326）中定义的二进制数据交织传输方式拓展而来。</p>
<h4 id="1-设置-RTP-over-RTSP"><a href="#1-设置-RTP-over-RTSP" class="headerlink" title="1. 设置 RTP over RTSP"></a>1. 设置 RTP over RTSP</h4><p>首次要确保 RTSP 协议交互使用的 TCP 连接，并且 RTSP 客户端需要在 SETUP 阶段请求使用 TCP 连接传输二进制数据。SETUP 命令中应该包括如下格式：</p>
<pre><code>Transport: RTP/AVP/TCP;interleaved=0-1
</code></pre><p>上述 Transport 将告诉服务端使用 TCP 协议发送媒体数据（<strong>RTP/AVP/TCP</strong>），并且使用信道 0 和 1 对流数据以及控制信息进行交织。详细说来，使用偶数信道作为数据传输信道，使用奇数信道作为控制信道（数据信道 + 1）。所以，如果你设定数据信道为 0 ，那控制信道应该是 0 + 1 = 1。</p>
<pre><code>C-&gt;S: SETUP rtsp://foo.com/bar.file RTSP/1.0
      CSeq: 2
      Transport: RTP/AVP/TCP;interleaved=0-1

S-&gt;C: RTSP/1.0 200 OK
      CSeq: 2
      Date: 05 Jun 1997 18:57:18 GMT
      Transport: RTP/AVP/TCP;interleaved=0-1
</code></pre><h4 id="2-RTP-over-RTSP-的数据传输"><a href="#2-RTP-over-RTSP-的数据传输" class="headerlink" title="2. RTP over RTSP 的数据传输"></a>2. RTP over RTSP 的数据传输</h4><blockquote>
<p><a href="https://www.rfc-editor.org/rfc/rfc2326.txt">RFC 2326: Real Time Streaming Protocol (RTSP)</a> : 10.12 Embedded (Interleaved) Binary Data</p>
</blockquote>
<p>PLAY 之后，RTP 数据将通过用来发送 RTSP 命令的 TCP Socket 进行发送。RTP 数据将以如下格式进行封装：</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    0x24($)    |      CID      |     embedded data length      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:        ...       data      ...        :
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><ul>
<li><strong>0x24($)</strong>：1 字节，二进制数据交错标识符，固定使用 “$”。</li>
<li><strong>CID(channel identifier)</strong>：1 字节，交错参数，携带 RTP 数据时用来指示信道。<blockquote>
<p>一般来说 CID = 0 代表视频 RTP 数据，CID = 1 代表视频 RTCP 数据<br>CID = 2 代表音频 RTP 数据，CID = 3 代表音频 RTCP 数据</p>
</blockquote>
</li>
<li><strong>embedded data length</strong>：2 个字节，用来指示插入的二进制数据长度。</li>
<li><strong>data</strong>：二进制数据包，为 RTP 包，长度与 embedded data length 指示的数据长度一致。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://www.rfc-editor.org/rfc/rfc2326.txt">RFC 2326: Real Time Streaming Protocol (RTSP)</a></li>
<li>[2] <a href="https://www.rfc-editor.org/rfc/rfc3550.txt">RFC 3550: RTP: A Transport Protocol for Real-Time Applications</a></li>
<li>[3] <a href="https://www.cnblogs.com/lidabo/p/4483497.html">DoubleLi 的博客园：《RTSP - RTP over TCP》</a></li>
<li>[4] <a href="https://www.rfc-editor.org/rfc/rfc2326.txt">RFC 2326: Real Time Streaming Protocol (RTSP)</a></li>
<li>[5] <a href="https://www.rfc-editor.org/rfc/rfc3551.txt">RFC 3551: RTP Profile for Audio and Video Conferences with Minimal Control</a></li>
<li>[6] <a href="https://www.rfc-editor.org/rfc/rfc6184.txt">RFC 6184: RTP Payload Format for H.264 Video</a></li>
<li>[7] <a href="https://www.rfc-editor.org/rfc/rfc3550.txt">RFC 3550: RTP: A Transport Protocol for Real-Time Applications</a></li>
</ul>
]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>RTP</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体传输 - RTP 荷载 H264</title>
    <url>/post/2020/fc237a45/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="H264-码流结构"><a href="#H264-码流结构" class="headerlink" title="H264 码流结构"></a>H264 码流结构</h2><p>H264 码流是由很多 NAL Unit 组成，所有 NAL Unit 均存在一个八位数据的 NAL Unit Header ，这八位数据也充当此 RTP 有效负载格式的有效负载头。一个 NAL Unit Header 的语法如下:</p>
<pre><code>    +---------------+
    |0|1|2|3|4|5|6|7|
    +-+-+-+-+-+-+-+-+
    |F|NRI|  Type   |
    +---------------+
</code></pre><a id="more"></a>
<ul>
<li>F: 1bit forbidden_zero_bit，在 H.264 规范中规定了这一位必须为 0。</li>
<li>NRI: 2bit nal_ref_idc，取 00 ~ 11, 似乎指示这个 NALU 的重要性, 如 00 的 NALU 解码器可以丢弃它而不影响图像的回放. 不过一般情况下不太关心这个属性。</li>
<li><p>Type: 5bit 等于 nal_unit_type，标识着这个 NAL Unit 的 Type，其类型如下：</p>
<pre><code>  Table 1.  Summary of NAL unit types and the corresponding packet types

      NAL Unit  Packet    Packet Type Name               Section
      Type      Type
      -------------------------------------------------------------
      0        reserved                                     -
      1-23     NAL unit  Single NAL unit packet             5.6
      24       STAP-A    Single-time aggregation packet     5.7.1
      25       STAP-B    Single-time aggregation packet     5.7.1
      26       MTAP16    Multi-time aggregation packet      5.7.2
      27       MTAP24    Multi-time aggregation packet      5.7.2
      28       FU-A      Fragmentation unit                 5.8
      29       FU-B      Fragmentation unit                 5.8
      30-31    reserved
</code></pre></li>
</ul>
<h2 id="H264-码流打包"><a href="#H264-码流打包" class="headerlink" title="H264 码流打包"></a>H264 码流打包</h2><p><a href="https://www.rfc-editor.org/rfc/rfc6184.txt">RFC 6184 Section 5.2</a> 中指定了 3 种打包方式：</p>
<ul>
<li>单 NAL 单元模式（Single NAL Unit Packet）: 仅包含单个 NAL 单元的有效载荷。</li>
<li>组合封包模式（Aggregation Packet）：用于聚合多个 NAL 单元的分组类型成为单个 RTP 有效负载。</li>
<li>分片封包模式（Fragmentation Unit）：用于将单个 NAL 单元分段成多个 RTP 数据包。</li>
</ul>
<h3 id="单-NAL-单元模式"><a href="#单-NAL-单元模式" class="headerlink" title="单 NAL 单元模式"></a>单 NAL 单元模式</h3><p>一个 RTP 包仅由一个完整的 NALU 组成. 这种情况下 RTP 的 NAL 头类型字段和原始的 H.264 的 NALU 头类型字段是一样的。</p>
<p>对于 NALU 的长度小于 MTU 大小的包, 一般采用单一 NAL 单元模式。一个原始的 H.264 NALU 单元常由 [Start Code] [NALU Header] [NALU Payload] 三部分组成, 其中 Start Code 用于标示这是一个 NALU 单元的开始, 必须是 “00 00 00 01” 或 “00 00 01”, NALU 头仅一个字节, 其后都是 NALU 单元内容，打包时去除 “00 00 01” 或 “00 00 00 01” 的开始码, 把其他数据封包为 RTP 包即可。</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|F|NRI|  Type   |                                               |
+-+-+-+-+-+-+-+-+                                               |
|                                                               |
|               Bytes 2..n of a single NAL unit                 |
|                                                               |
|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               :...OPTIONAL RTP padding        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    Figure 2.  RTP payload format for single NAL unit packet
</code></pre><h3 id="组合封包模式"><a href="#组合封包模式" class="headerlink" title="组合封包模式"></a>组合封包模式</h3><p>可能是由多个 NAL 单元组成一个 RTP 包。分别有 4 种组合方式: STAP-A, STAP-B, MTAP16, MTAP24，类型值分别是 24, 25, 26 以及 27。</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|F|NRI|  Type   |                                               |
+-+-+-+-+-+-+-+-+                                               |
|                                                               |
|             one or more aggregation units                     |
|                                                               |
|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               :...OPTIONAL RTP padding        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    Figure 3.  RTP payload format for aggregation packets
</code></pre><p>MTAP 和 STAP 共享以下打包规则：</p>
<ul>
<li>RTP 时间戳必须设置为所有要组合的 NAL 单元中 NALU-times 的最早时间。</li>
<li>必须将 NAL 单元类型八位字节的类型字段设置为适当的值，如表 4 所示。</li>
<li>如果聚合的 NAL 的所有 F 位均为零，则必须置零 F 位；否则，必须设置它。</li>
<li><p>NRI 的值必须是所有在聚合数据包中 NAL 单元的最大值。</p>
<pre><code>       Table 4.  Type field for STAPs and MTAPs

  Type   Packet    Timestamp offset   DON-related fields
                  field length       (DON, DONB, DOND)
                  (in bits)          present
  --------------------------------------------------------
  24     STAP-A       0                 no
  25     STAP-B       0                 yes
  26     MTAP16      16                 yes
  27     MTAP24      24                 yes
</code></pre></li>
</ul>
<h3 id="分片封包模式"><a href="#分片封包模式" class="headerlink" title="分片封包模式"></a>分片封包模式</h3><p>用于把一个 NALU 单元封装成多个 RTP 包. 存在两种类型 FU-A 和 FU-B. 类型值分别是 28 和 29。<br>这种载荷类型允许将 NAL 单元分为多个 RTP 包。该封包模式具有以下优点：</p>
<ul>
<li>有效负载格式能够在 IPv4 网络传输大于 64 KB 的 NAL 单元，特别是在高清晰度格式中（每张图片的切片数量有限，导致每张图片的 NAL 单位数上限，可能会导致 NAL 单位数变大）</li>
<li>分段机制允许分段单个 NAL 单元并应用通用前向纠错。</li>
</ul>
<h4 id="FU-A"><a href="#FU-A" class="headerlink" title="FU-A"></a>FU-A</h4><p>下图给出了 FU-As 的 RTP 有效载荷格式：</p>
<pre><code>    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | FU indicator  |   FU header   |                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
    |                                                               |
    |                         FU payload                            |
    |                                                               |
    |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                               :...OPTIONAL RTP padding        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

            Figure 14.  RTP payload format for FU-A
</code></pre><ul>
<li><p>FU indicator 格式与 NAL Header 一致:</p>
<pre><code>  +---------------+
  |0|1|2|3|4|5|6|7|
  +-+-+-+-+-+-+-+-+
  |F|NRI|  Type   |
  +---------------+
</code></pre></li>
</ul>
<p>Type 字段的值等于 28 和 29 分别标识该 RTP 包的封包模式为 FU-A 和 FU-B。</p>
<ul>
<li><p>FU header 格式如下:</p>
<pre><code>  +---------------+
  |0|1|2|3|4|5|6|7|
  +-+-+-+-+-+-+-+-+
  |S|E|R|  Type   |
  +---------------+
</code></pre><ul>
<li>S: 1 bit 开始位<ul>
<li>当设置成 1 时，指示跟随的 FU 荷载是分片 NAL 单元的开始。</li>
<li>当设置成 0 时，指示跟随的 FU 荷载不是分片 NAL 单元荷载的开始。</li>
</ul>
</li>
<li>E: 1 bit 结束位<ul>
<li>当设置成 1 时，指示跟随的 FU 荷载是分片 NAL 单元的结束。</li>
<li>当设置成 1 时，指示跟随的 FU 荷载不是分片 NAL 单元的结束。</li>
</ul>
</li>
<li>R: 1 bit 保留位<ul>
<li>保留位必须设置为 0。</li>
</ul>
</li>
<li>Type: 5 bits<ul>
<li>NAL 单元荷载类型定义见下表：<br><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200814220249.jpg" alt="NAL 单元荷载类型定义"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以两段 Wirshark 抓包的码流为例：</p>
<ol>
<li><p>FU - Start</p>
<pre><code> 0000   7c 85 b8 00 00 1d dc 40 00 02 ff ea 14 34 0c ab   |......@.....4..
 0010   5a 02 6f 1a 0f d5 5c f3 a9 df 6f d6 6b a8 25 1f   Z.o...\...o.k.%.

 ===================== 转化 第一个字节 7c 第二个字节 85 =====================
 0111 1100  F=0 NRI=11 Type=28 说明是 FU-A
 1000 0101  S=1 E=0 R=0 Type=5 非参考帧

 ============================= Wirshark 解析 =============================
 FU header：
   1... .... = Start bit: the first packet of FU-A picture
   .0.. .... = End bit: Not the last packet of FU-A picture
   ..0. .... = Forbidden bit: 0
   ...0 0101 = Nal_unit_type: Coded slice of an IDR picture (5)
</code></pre></li>
<li><p>FU - End</p>
<pre><code> 0000   7c 45 c0                                          |E.

 ============== 转化 第一个字节 7c 第二个字节 45 ================
</code></pre><p> 0111 1100  F=0 NRI=11 Type=28</p>
<pre><code> 0100 0101  S=0 E=1 R=0 Type=5

 ======================= Wirshark 解析 =======================
 FU header：
   0... .... = Start bit: Not the first packet of FU-A picture
   .1.. .... = End bit: the last packet of FU-A picture
   ..0. .... = Forbidden bit: 0
   ...0 0101 = Nal_unit_type: Coded slice of an IDR picture (5)
</code></pre></li>
</ol>
<h4 id="FU-B"><a href="#FU-B" class="headerlink" title="FU-B"></a>FU-B</h4><p>FU-B 的封包格式仅仅是在 FU header 后面多了 2 个字节的 DON 解码顺序号，它允许 NAL 单元的传输顺序和 NAL 单元的解码顺序不同 ，用来 指示 NAL 单元的解码顺序。</p>
<pre><code>    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | FU indicator  |   FU header   |               DON             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|
    |                                                               |
    |                         FU payload                            |
    |                                                               |
    |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                               :...OPTIONAL RTP padding        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

             Figure 15.  RTP payload format for FU-B
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://www.rfc-editor.org/rfc/rfc6184.txt">RFC 6184: RTP Payload Format for H.264 Video</a></li>
<li>[2] <a href="http://cdmd.cnki.com.cn/Article/CDMD-10293-1016294288.htm">《基于 web 浏览的视频监控与回溯系统的研究与设计》</a></li>
<li>[3] <a href="https://www.rfc-editor.org/rfc/rfc3550.txt">RFC 3550: RTP: A Transport Protocol for Real-Time Applications</a></li>
<li>[4] <a href="https://www.rfc-editor.org/rfc/rfc2326.txt">RFC 2326: Real Time Streaming Protocol (RTSP)</a></li>
<li>[5] <a href="https://www.rfc-editor.org/rfc/rfc3551.txt">RFC 3551: RTP Profile for Audio and Video Conferences with Minimal Control</a></li>
<li>[6] <a href="https://www.rfc-editor.org/rfc/rfc3550.txt">RFC 3550: RTP: A Transport Protocol for Real-Time Applications</a></li>
</ul>
]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>RTP</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体传输 - RTP 荷载 H265</title>
    <url>/post/2020/8b244ad3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="H265-码流结构"><a href="#H265-码流结构" class="headerlink" title="H265 码流结构"></a>H265 码流结构</h2><p>H265 码流和是由很多 NAL Unit 组成，所有 NAL Unit 均存在一个 16 位数据的 NAL Unit Header ，一个 NAL Unit Header 的语法如下:</p>
<pre><code>        +---------------+---------------+
        |0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7|
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |F|   Type    |  LayerId  | TID |
        +-------------+-----------------+

Figure 1: The Structure of the H265 NAL Unit Header
</code></pre><a id="more"></a>
<ul>
<li>F: 1bit forbidden_zero_bit，在 H.265 规范中规定了这一位必须为 0。它的作用是在尚存 MPEG-2 系统环境中，防止产生可以解释为 MPEG-2 起始码的比特模式。</li>
<li>Type: 6bit 其允许的 NAL Unit 的类型编码比 H264 多一倍，达到了 64 类，其中 32 类作用于 VCL NAL Unit，32 类作用于 non-VCL NAL Unit。</li>
<li>LayerId: 6bit 用于 H265 拓展层标识符</li>
<li>TID: 3bit temporal_id，表示 H265 的接入单元（AU）属于哪个时域子层，时域标识符值为 0 到 6。</li>
</ul>
<h2 id="H265-码流打包"><a href="#H265-码流打包" class="headerlink" title="H265 码流打包"></a>H265 码流打包</h2><p><a href="https://www.rfc-editor.org/rfc/rfc7798.txt">RFC 7798 Section 4.4</a> 指定了四种不同类型的 RTP 数据包有效负载结构：</p>
<ul>
<li><p>单 NAL 单元模式（Single NAL Unit Packet）: 仅包含单个 NAL Unit 的有效载荷。</p>
</li>
<li><p>组合封包模式（Aggregation Packet）：用于聚合多个 NAL Unit 的分组类型成为单个 RTP 有效负载。</p>
</li>
<li><p>分片封包模式（Fragmentation Unit）：用于将单个 NAL Unit 分段成多个 RTP 数据包。</p>
</li>
<li><p>携带 RTP 数据包的 PACI：包含有效载荷报头（与其他有效载荷报头有所不同），有效载荷报头扩展结构（PHES）和 PACI 有效载荷。</p>
<p>  其中常用的有两种类型：单 NAL 单元模式和分片封包模式。</p>
</li>
</ul>
<h3 id="单-NAL-单元模式"><a href="#单-NAL-单元模式" class="headerlink" title="单 NAL 单元模式"></a>单 NAL 单元模式</h3><p>一个 RTP 包仅由一个完整的 NALU 组成. 这种情况下 RTP 的 NAL 头类型字段 PayloadHdr 和原始的 H.265 的 NALU Header 字段是一样的。</p>
<p>对于 NALU 的长度小于 MTU 大小的包, 一般采用单一 NAL 单元模式。一个原始的 H.264 NALU 单元常由 [Start Code] [NALU Header] [NALU Payload] 三部分组成, 其中 Start Code 用于标示这是一个 NALU 单元的开始, 必须是 “00 00 00 01” 或 “00 00 01”, NALU 头仅一个字节, 其后都是 NALU 单元内容，打包时去除 “00 00 01” 或 “00 00 00 01” 的开始码, 把其他数据封包为 RTP 包即可。</p>
<pre><code>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           PayloadHdr          |      DONL (conditional)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                  NAL unit payload data                        |
|                                                               |
|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               :...OPTIONAL RTP padding        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Figure 3: The Structure of a Single NAL Unit Packet
</code></pre><h3 id="分片封包模式"><a href="#分片封包模式" class="headerlink" title="分片封包模式"></a>分片封包模式</h3><p>分片封包模式（FU）能将单个 NAL 单元分段成多个 RTP 数据包。</p>
<p>NAL 单元的片段由该 NAL 单元的整数个连续八位位组组成。 分片封包的 NAL 单元必须以升序的 RTP 序列号连续顺序发送（同一 RTP 流中的其他 RTP 数据包不得在第一个片段与最后一个片段之间发送）。</p>
<p>FU 绝对不能嵌套； 即，FU 一定不能包含另一个 FU 的子集。</p>
<p>携带 FU 的 RTP 分组的 RTP 时间戳被设置为分段 NAL 单元的 NALU 时间。</p>
<p>FU 由一个有效负载报头（PayloadHdr），一个 8bit 的 FU Header，一个有条件的 16 位 DONL 字段和 FU 有效负载组成，如下图所示。</p>
<pre><code>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    PayloadHdr (Type=49)       |   FU header   | DONL (cond)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|
| DONL (cond)   |                                               |
|-+-+-+-+-+-+-+-+                                               |
|                         FU payload                            |
|                                                               |
|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               :...OPTIONAL RTP padding        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

            Figure 9: The Structure of an FU
</code></pre><p>PayloadHdr 的字段含义与 NALU Header 的字段含义一直，其各字段设置为：</p>
<pre><code>- Type 字段必须等于 49
- 字段 F，LayerId 和 TID 必须分别等于分段的 NAL 单元的字段 F，LayerId 和 TID
</code></pre><p>FU header 包含 1bit 的字段 S，1 字节的字段 E 和 6bit 的字段 FuType：</p>
<pre><code>        +---------------+
        |0|1|2|3|4|5|6|7|
        +-+-+-+-+-+-+-+-+
        |S|E|  FuType   |
        +---------------+

Figure 10: The Structure of FU Header
</code></pre><ul>
<li>S: 1bit 当设置为 1 时，S 位指示分段 NAL 单元的开始，即 FU 有效载荷的第一个字节也是分段 NAL 单元的有效载荷的第一个字节。 当 FU 有效载荷不是分段式 NAL 单元有效载荷的开始时，必须将 S 位设置为 0。</li>
<li>E: 1bit 当设置为 1 时，E 位表示分段 NAL 单元的末尾，即有效载荷的最后一个字节也是分段 NAL 单元的最后一个字节。 当 FU 有效负载不是分段的 NAL 单元的最后一个分段时，E 位务必设置为 0。</li>
<li>FuType: 6bit 字段 FuType 必须等于分段的 NAL 单元的字段 Type。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://www.rfc-editor.org/rfc/rfc7798.txt">RFC 7798 : RTP Payload Format for High Efficiency Video Coding (H265)</a></li>
</ul>
]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>RTP</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体传输 - RTSP Over HTTP</title>
    <url>/post/2020/65370ad/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>RTSP 的标准端口是 554，但是由于各种不同的防火墙等安全策略配置的原因，客户端在访问 554 端口时可能存在限制，从而无法正常传输 RTSP 报文。<br>但是 HTTP 端口（80 端口）是普遍开放的，于是就有了让 RTSP 报文通过 80 端口透传的想法，即 RTSP Over HTTP。</p>
<a id="more"></a>
<h2 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h2><p>RTSP Over HTTP 的关键在于：让 RTSP 报文通过 HTTP 端口通信，但目前 RTSP Over HTTP 没有标准做法，苹果公司出了一份非正式文档公开在外，并且也被 Live555 等支持</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="RTSP-和-HTTP"><a href="#RTSP-和-HTTP" class="headerlink" title="RTSP 和 HTTP"></a>RTSP 和 HTTP</h3><p>RTSP(Real Time Streaming Protocol，实时流传输协议) 和 HTTP(HyperText Transfer Protocol，超文本传输协议) 的共同点如下：</p>
<ul>
<li>两者均为应用层协议</li>
<li>两者均为工作于客户端 - 服务端架构</li>
</ul>
<p>两者区别如下：</p>
<ul>
<li>HTTP 协议是无连接（HTTP/1.1 版本之后支持长连接），而 RTSP 为面向连接协议<blockquote>
<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。</p>
</blockquote>
</li>
<li>HTTP 协议是无状态协议，而 RTSP 为有状态协议</li>
</ul>
<h2 id="协议交互"><a href="#协议交互" class="headerlink" title="协议交互"></a>协议交互</h2><p>Live555 的具体做法如下</p>
<p>首先客户端开启 2 个 socket 链接服务器 HTTP 端口，我们称这 2 个 socket 分别为 “数据 socket” 和 “命令 socket”。</p>
<ol>
<li>客户端通过 “数据 socket” 发送 HTTP GET 命令，请求 RTSP 链接。</li>
<li>服务器通过 “数据 socket” 响应 HTTP GET 命令，并回复成功 / 失败。</li>
<li><p>客户端创建 “命令 socket”，并通过 “命令 socket” 发送 HTTP POST 命令，建立 RTSP 会话。</p>
<p> 至此，HTTP 的辅助功能完成，服务器不返回客户端的 HTTP POST 命令。接下来是 RTSP 在 HTTP 端口上的标准流程，但是需要通过 2 个 socket 协同完成，”命令 socket” 只负责发送，”数据 socket” 只负责接受。</p>
</li>
<li><p>客户端通过 “命令 socket” 发送 RTSP 命令（BASE64 编码加密）。</p>
</li>
<li>服务器通过 “数据 socket” 响应 RTSP 命令（明文）。</li>
<li>重复 Step4-Step5，直到客户端发送 RTSP PLAY 命令，服务器响应 RTSP PLAY 命令。</li>
<li><p>服务器通过 数据 socket” 向客户端传输音视频数据</p>
<p> 数据交互…</p>
</li>
<li><p>客户端通过 “命令 socket” 发送 RTSP TEARDOWN 命令（BASE64 编码加密）</p>
</li>
<li>服务器通过 “数据 socket” 响应 RTSP TEARDOWN 命令（明文）。</li>
<li>关闭 2 个 socket。</li>
</ol>
<h2 id="交互示例"><a href="#交互示例" class="headerlink" title="交互示例"></a>交互示例</h2><p>通过海康的 IPC 和 海康播放器 VSPlayer 进行抓包，得到数据交互过程如下：</p>
<blockquote>
<p>由于有两个连接之间进行交互 直接通过 Wirshark 观察数据不够清晰，这里对每次交互的数据方向和通道进行了注释</p>
</blockquote>
<ol>
<li><p>Data Socket, C -&gt; S</p>
<pre><code> GET /ch1/main/av_stream HTTP/1.0
 CSeq: 1
 User-Agent: NKPlayer-VSPlayer1.0
 x-sessioncookie: 6521ade129b5b5e14e8eacd
 Accept: application/x-rtsp-tunnelled
 Pragma: no-cache
 Cache-Control: no-cache
</code></pre></li>
<li><p>Data Socket, S -&gt; C</p>
<pre><code> HTTP/1.1 200 OK
 Connection: close
 Content-Type: application/x-rtsp-tunnelled
</code></pre></li>
<li><p>Command Socket, C -&gt; S</p>
<pre><code> POST /ch1/main/av_stream HTTP/1.0
 CSeq: 1
 User-Agent: NKPlayer-VSPlayer1.0
 x-sessioncookie: 6521ade129b5b5e14e8eacd
 Content-Type: application/x-rtsp-tunnelled
 Pragma: no-cache
 Cache-Control: no-cache
 Content-Length: 32767
 Expires: Sun, 9 Jan 1972 00:00:00 GMT
</code></pre><blockquote>
<p>至此，HTTP 的辅助功能完成，服务器不返回客户端的 HTTP POST 命令。接下来是 RTSP 在 HTTP 端口上的标准流程，但是需要通过 2 个 socket 协同完成，”命令 socket” 只负责发送，”数据 socket” 只负责接受。</p>
</blockquote>
</li>
<li><p>Command Socket, C -&gt; S</p>
<pre><code> T1BUSU9OUyBydHNwOi8vMTAuMTkyLjQ0Ljk3OjU1NC9jaDEvbWFpbi9hdl9zdHJlYW0gUlRTUC8xLjANCkNTZXE6IDINClVzZXItQWdlbnQ6IE5LUGxheWVyLVZTUGxheWVyMS4wDQoNCg==
 -------------------------------------------------------------------
 OPTIONS rtsp://10.192.44.97:554/ch1/main/av_stream RTSP/1.0
 CSeq: 2
 User-Agent: NKPlayer-VSPlayer1.0
</code></pre></li>
<li><p>Data Socket, S -&gt; C</p>
<pre><code> RTSP/1.0 200 OK
 CSeq: 2
 Public: OPTIONS, DESCRIBE, PLAY, PAUSE, SETUP, TEARDOWN, SET_PARAMETER
 Date:  Mon, Sep 21 2020 20:08:41 GMT
</code></pre></li>
<li><p>Command Socket, C -&gt; S</p>
<pre><code> REVTQ1JJQkUgcnRzcDovLzEwLjE5Mi40NC45Nzo1NTQvY2gxL21haW4vYXZfc3RyZWFtIFJUU1AvMS4wDQpDU2VxOiAzDQpVc2VyLUFnZW50OiBOS1BsYXllci1WU1BsYXllcjEuMA0KQWNjZXB0OiBhcHBsaWNhdGlvbi9zZHANCg0K
 -------------------------------------------------------------------
 DESCRIBE rtsp://10.192.44.97:554/ch1/main/av_stream RTSP/1.0
 CSeq: 3
 User-Agent: NKPlayer-VSPlayer1.0
 Accept: application/sdp
</code></pre></li>
<li><p>Data Socket, S -&gt; C</p>
<pre><code> RTSP/1.0 401 Unauthorized
 CSeq: 3
 WWW-Authenticate: Digest realm=&quot;IP Camera(E6990)&quot;, nonce=&quot;921e0ab66f8f6763ef05ecb06c4c86a0&quot;, stale=&quot;FALSE&quot;
 WWW-Authenticate: Basic realm=&quot;IP Camera(E6990)&quot;
 Date:  Mon, Sep 21 2020 20:08:41 GMT
</code></pre></li>
<li><p>Command Socket, C -&gt; S</p>
<pre><code> REVTQ1JJQkUgcnRzcDovLzEwLjE5Mi40NC45Nzo1NTQvY2gxL21haW4vYXZfc3RyZWFtIFJUU1AvMS4wDQpDU2VxOiA0DQpBdXRob3JpemF0aW9uOiBEaWdlc3QgdXNlcm5hbWU9ImFkbWluIiwgcmVhbG09IklQIENhbWVyYShFNjk5MCkiLCBub25jZT0iOTIxZTBhYjY2ZjhmNjc2M2VmMDVlY2IwNmM0Yzg2YTAiLCB1cmk9InJ0c3A6Ly8xMC4xOTIuNDQuOTc6NTU0L2NoMS9tYWluL2F2X3N0cmVhbSIsIHJlc3BvbnNlPSIwNjk0ZjhkMmNlODE3NzE5OTIxOTk1MzJkNDdiNzNhZCINClVzZXItQWdlbnQ6IE5LUGxheWVyLVZTUGxheWVyMS4wDQpBY2NlcHQ6IGFwcGxpY2F0aW9uL3NkcA0KDQo=
 -------------------------------------------------------------------
 DESCRIBE rtsp://10.192.44.97:554/ch1/main/av_stream RTSP/1.0
 CSeq: 4
 Authorization: Digest username=&quot;admin&quot;, realm=&quot;IP Camera(E6990)&quot;, nonce=&quot;921e0ab66f8f6763ef05ecb06c4c86a0&quot;, uri=&quot;rtsp://10.192.44.97:554/ch1/main/av_stream&quot;, response=&quot;0694f8d2ce81771992199532d47b73ad&quot;
 User-Agent: NKPlayer-VSPlayer1.0
 Accept: application/sdp
</code></pre></li>
<li><p>Data Socket, S -&gt; C</p>
<pre><code> RTSP/1.0 200 OK
 CSeq: 4
 Content-Type: application/sdp
 Content-Length: 633

 v=0
 o=- 1600718921878550 1600718921878550 IN IP6 6d69:6e22:3a09:302c:a09:909:909:2240
 s=Media Presentation
 e=NONE
 b=AS:5100
 t=0 0
 a=control:*
 m=video 0 RTP/AVP 96
 c=IN IP4 0.0.0.0
 b=AS:5000
 a=recvonly
 a=x-dimensions:2560,1440
 a=control:trackID=1
 a=rtpmap:96 H264/90000
 a=fmtp:96 profile-level-id=420029; packetization-mode=1; sprop-parameter-sets=Z00AMpY1QFABa03AQEBQAABwgAAV+QBA,aO48gA==
 m=audio 0 RTP/AVP 8
 c=IN IP4 0.0.0.0
 b=AS:50
 a=recvonly
 a=control:trackID=2
 a=rtpmap:8 PCMA/8000
 a=Media_header:MEDIAINFO=494D4B48010200000400000111710110401F000000FA000000000000000000000000000000000000;
 a=appversion:1.0
</code></pre></li>
<li><p>Command Socket, C -&gt; S</p>
<pre><code>U0VUVVAgcnRzcDovLzEwLjE5Mi40NC45Nzo1NTQvY2gxL21haW4vYXZfc3RyZWFtL3RyYWNrSUQ9MSBSVFNQLzEuMA0KQ1NlcTogNQ0KQXV0aG9yaXphdGlvbjogRGlnZXN0IHVzZXJuYW1lPSJhZG1pbiIsIHJlYWxtPSJJUCBDYW1lcmEoRTY5OTApIiwgbm9uY2U9IjkyMWUwYWI2NmY4ZjY3NjNlZjA1ZWNiMDZjNGM4NmEwIiwgdXJpPSJydHNwOi8vMTAuMTkyLjQ0Ljk3OjU1NC9jaDEvbWFpbi9hdl9zdHJlYW0iLCByZXNwb25zZT0iNmRmZTdiMjhhMmZmZjliMTYxYmFjNWRkYWQxMjg5ZTQiDQpVc2VyLUFnZW50OiBOS1BsYXllci1WU1BsYXllcjEuMA0KVHJhbnNwb3J0OiBSVFAvQVZQL1RDUDt1bmljYXN0O2ludGVybGVhdmVkPTAtMQ0KDQo=
-------------------------------------------------------------------
SETUP rtsp://10.192.44.97:554/ch1/main/av_stream/trackID=1 RTSP/1.0
CSeq: 5
Authorization: Digest username=&quot;admin&quot;, realm=&quot;IP Camera(E6990)&quot;, nonce=&quot;921e0ab66f8f6763ef05ecb06c4c86a0&quot;, uri=&quot;rtsp://10.192.44.97:554/ch1/main/av_stream&quot;, response=&quot;6dfe7b28a2fff9b161bac5ddad1289e4&quot;
User-Agent: NKPlayer-VSPlayer1.0
Transport: RTP/AVP/TCP;unicast;interleaved=0-1
</code></pre></li>
<li><p>Data Socket, S -&gt; C</p>
<pre><code>RTSP/1.0 200 OK
CSeq: 5
Session:       2090545605;timeout=60
Transport: RTP/AVP/TCP;unicast;interleaved=0-1;ssrc=11c14094;mode=&quot;play&quot;
Date:  Mon, Sep 21 2020 20:08:41 GMT
</code></pre></li>
<li><p>Command Socket, C -&gt; S</p>
<pre><code>U0VUVVAgcnRzcDovLzEwLjE5Mi40NC45Nzo1NTQvY2gxL21haW4vYXZfc3RyZWFtL3RyYWNrSUQ9MiBSVFNQLzEuMA0KQ1NlcTogNg0KQXV0aG9yaXphdGlvbjogRGlnZXN0IHVzZXJuYW1lPSJhZG1pbiIsIHJlYWxtPSJJUCBDYW1lcmEoRTY5OTApIiwgbm9uY2U9IjkyMWUwYWI2NmY4ZjY3NjNlZjA1ZWNiMDZjNGM4NmEwIiwgdXJpPSJydHNwOi8vMTAuMTkyLjQ0Ljk3OjU1NC9jaDEvbWFpbi9hdl9zdHJlYW0iLCByZXNwb25zZT0iNmRmZTdiMjhhMmZmZjliMTYxYmFjNWRkYWQxMjg5ZTQiDQpVc2VyLUFnZW50OiBOS1BsYXllci1WU1BsYXllcjEuMA0KVHJhbnNwb3J0OiBSVFAvQVZQL1RDUDt1bmljYXN0O2ludGVybGVhdmVkPTItMw0KU2Vzc2lvbjogMjA5MDU0NTYwNQ0KDQo=
-------------------------------------------------------------------
SETUP rtsp://10.192.44.97:554/ch1/main/av_stream/trackID=2 RTSP/1.0
CSeq: 6
Authorization: Digest username=&quot;admin&quot;, realm=&quot;IP Camera(E6990)&quot;, nonce=&quot;921e0ab66f8f6763ef05ecb06c4c86a0&quot;, uri=&quot;rtsp://10.192.44.97:554/ch1/main/av_stream&quot;, response=&quot;6dfe7b28a2fff9b161bac5ddad1289e4&quot;
User-Agent: NKPlayer-VSPlayer1.0
Transport: RTP/AVP/TCP;unicast;interleaved=2-3
Session: 2090545605
</code></pre></li>
<li><p>Data Socket, S -&gt; C</p>
<pre><code>RTSP/1.0 200 OK
CSeq: 6
Session:       2090545605;timeout=60
Transport: RTP/AVP/TCP;unicast;interleaved=2-3;ssrc=6819e89f;mode=&quot;play&quot;
Date:  Mon, Sep 21 2020 20:08:41 GMT
</code></pre></li>
<li><p>Command Socket, C -&gt; S</p>
<pre><code>UExBWSBydHNwOi8vMTAuMTkyLjQ0Ljk3OjU1NC9jaDEvbWFpbi9hdl9zdHJlYW0gUlRTUC8xLjANCkNTZXE6IDcNCkF1dGhvcml6YXRpb246IERpZ2VzdCB1c2VybmFtZT0iYWRtaW4iLCByZWFsbT0iSVAgQ2FtZXJhKEU2OTkwKSIsIG5vbmNlPSI5MjFlMGFiNjZmOGY2NzYzZWYwNWVjYjA2YzRjODZhMCIsIHVyaT0icnRzcDovLzEwLjE5Mi40NC45Nzo1NTQvY2gxL21haW4vYXZfc3RyZWFtIiwgcmVzcG9uc2U9IjkzN2VhNWIyMjUxNGViNzVjZjIxNTNiODZmOTEzMmQyIg0KVXNlci1BZ2VudDogTktQbGF5ZXItVlNQbGF5ZXIxLjANClNlc3Npb246IDIwOTA1NDU2MDUNClJhbmdlOiBucHQ9MC4wMDAtDQoNCg==
-------------------------------------------------------------------
PLAY rtsp://10.192.44.97:554/ch1/main/av_stream RTSP/1.0
CSeq: 7
Authorization: Digest username=&quot;admin&quot;, realm=&quot;IP Camera(E6990)&quot;, nonce=&quot;921e0ab66f8f6763ef05ecb06c4c86a0&quot;, uri=&quot;rtsp://10.192.44.97:554/ch1/main/av_stream&quot;, response=&quot;937ea5b22514eb75cf2153b86f9132d2&quot;
User-Agent: NKPlayer-VSPlayer1.0
Session: 2090545605
Range: npt=0.000-
</code></pre></li>
<li><p>Data Socket, S -&gt; C</p>
<pre><code>RTSP/1.0 200 OK
CSeq: 7
Session:       2090545605
RTP-Info: url=trackID=1;seq=19485,url=trackID=2;seq=5076
Date:  Mon, Sep 21 2020 20:08:42 GMT
</code></pre></li>
<li><p>Command Socket, C -&gt; S</p>
<pre><code>VEVBUkRPV04gcnRzcDovLzEwLjE5Mi40NC45Nzo1NTQvY2gxL21haW4vYXZfc3RyZWFtIFJUU1AvMS4wDQpDU2VxOiA4DQpBdXRob3JpemF0aW9uOiBEaWdlc3QgdXNlcm5hbWU9ImFkbWluIiwgcmVhbG09IklQIENhbWVyYShFNjk5MCkiLCBub25jZT0iOTIxZTBhYjY2ZjhmNjc2M2VmMDVlY2IwNmM0Yzg2YTAiLCB1cmk9InJ0c3A6Ly8xMC4xOTIuNDQuOTc6NTU0L2NoMS9tYWluL2F2X3N0cmVhbSIsIHJlc3BvbnNlPSJiMDQxZWY0Yzk3ZDExZTYyMjUwNmFjZjhiZTBlYmZkNyINClVzZXItQWdlbnQ6IE5LUGxheWVyLVZTUGxheWVyMS4wDQpTZXNzaW9uOiAyMDkwNTQ1NjA1DQoNCg==
-------------------------------------------------------------------
TEARDOWN rtsp://10.192.44.97:554/ch1/main/av_stream RTSP/1.0
CSeq: 8
Authorization: Digest username=&quot;admin&quot;, realm=&quot;IP Camera(E6990)&quot;, nonce=&quot;921e0ab66f8f6763ef05ecb06c4c86a0&quot;, uri=&quot;rtsp://10.192.44.97:554/ch1/main/av_stream&quot;, response=&quot;b041ef4c97d11e622506acf8be0ebfd7&quot;
User-Agent: NKPlayer-VSPlayer1.0
Session: 2090545605
</code></pre></li>
<li><p>Data Socket, S -&gt; C</p>
<pre><code>RTSP/1.0 200 OK
CSeq: 8
Session:       2090545605
Date:  Mon, Sep 21 2020 20:08:42 GMT
</code></pre></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://www.cnblogs.com/ansersion/p/7514035.html">关于 RTSP-Over-HTTP - Ansersion - 博客园</a></li>
</ul>
]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>RTSP</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体传输 - RTSP Over HTTPS</title>
    <url>/post/2020/880163e6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><a href="/post/2020/65370ad/" title="流媒体传输 - RTSP Over HTTP">流媒体传输 - RTSP Over HTTP</a> 中我们分析了如何使用 HTTP 来进行 RTSP 交互，而在一些使用场景中，RTSP 和 HTTP 的明文交互带来了很多安全性问题，而 HTTPS 的出现，大大提高了数据交互的安全性，而在 RTSP Over HTTP 协议中，我们也可以参考 HTTP 和 HTTPS 的修改，实现 RTSP Over HTTPS 协议，从而可以应用在一些安全性要求较高的场景中。

<a id="more"></a>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h3><p>详见：</p>
<ul>
<li><a href="#">Post not found: HTTP 和 HTTPS 协议</a></li>
<li><a href="http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html">The First Few Milliseconds of an HTTPS Connection</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>RTSP</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体传输 - RTSP 协议</title>
    <url>/post/2020/cf84018a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc -->
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h3><h4 id="RTSP"><a href="#RTSP" class="headerlink" title="RTSP"></a>RTSP</h4><p>RTSP(Real-Time Stream Protocol) 实时流传输协议是一种基于文本的应用层协议，常被用于 <strong>建立的控制媒体流的传输</strong>，该协议用于 <strong>C/S 模型</strong>, 是一个 <strong>基于文本</strong> 的协议, 用于在客户端和服务器端建立和协商实时流会话。</p>
<a id="more"></a>
<h4 id="RTP"><a href="#RTP" class="headerlink" title="RTP"></a>RTP</h4><p>RTP(Real-time Transport Potocol) 实时传输协议，用于 <strong>实时数据的传输</strong>。</p>
<blockquote>
<p>详见：<a href="/post/2020/faccfa50/" title="流媒体传输 - RTP 协议">流媒体传输 - RTP 协议</a></p>
</blockquote>
<h4 id="RTCP"><a href="#RTCP" class="headerlink" title="RTCP"></a>RTCP</h4><p>RTCP(Real-time Transport Control Protocol) 实时传输控制协议， <code>RTCP</code> 为 <code>RTP</code> 数据流提供 <strong>信道外控制</strong>，RTCP 的主要功能是保证服务质量，<strong>为 RTP 提供服务质量反馈</strong>。</p>
<blockquote>
<p>详见：<a href="/post/2020/faccfa50/" title="流媒体传输 - RTP 协议">流媒体传输 - RTP 协议</a></p>
</blockquote>
<h3 id="传输渠道"><a href="#传输渠道" class="headerlink" title="传输渠道"></a>传输渠道</h3><div class="table-container">
<table>
<thead>
<tr>
<th>协议名称</th>
<th>协议文档</th>
<th>传输层协议</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>RTSP</td>
<td><a href="https://www.rfc-editor.org/rfc/rfc2326.pdf">RFC 2326</a><br><a href="https://tools.ietf.org/pdf/rfc7826.pdf">RFC 7836</a></td>
<td>TCP/UDP</td>
<td>控制媒体流的传输</td>
</tr>
<tr>
<td>RTP</td>
<td><a href="https://www.rfc-editor.org/rfc/rfc3550.pdf">RFC 3550</a><br><a href="https://www.rfc-editor.org/rfc/rfc3551.pdf">RFC 3551</a><br><a href="https://www.rfc-editor.org/rfc/rfc6184.pdf">RFC 6184</a></td>
<td>UDP/TCP</td>
<td>媒体流的传输</td>
</tr>
<tr>
<td>RTCP</td>
<td><a href="https://www.rfc-editor.org/rfc/rfc3550.pdf">RFC 3550</a></td>
<td>UDP/TCP</td>
<td>传输质量反馈</td>
</tr>
</tbody>
</table>
</div>
<h2 id="RTSP-协议"><a href="#RTSP-协议" class="headerlink" title="RTSP 协议"></a>RTSP 协议</h2><h3 id="RTSP-URL"><a href="#RTSP-URL" class="headerlink" title="RTSP URL"></a>RTSP URL</h3><pre><code>rtsp_URL = &quot;rtsp://&quot; host [&quot;:&quot; port] [ abs_path ]
host: 有效的域名或 IP 地址
port: 端口号，缺省为 554，若为缺省可不填写，否则必须写明
例如：rtsp://media.example.com:554/twister/audiotrack
</code></pre><p>以海康摄像机为例，其 RTSP URL 格式为：</p>
<pre><code>rtsp://[username]:[password]@[ip]:[port]/[channel]/[subtype]/av_stream
例如：
rtsp://admin:12345@192.168.1.67:554/h264/ch1/main/av_stream
rtsp://admin:12345@192.168.1.67/mpeg4/ch1/sub/av_stream
</code></pre><h3 id="RTSP-报文"><a href="#RTSP-报文" class="headerlink" title="RTSP 报文"></a>RTSP 报文</h3><p>RTSP 是一种基于文本的协议，用 CRLF(回车换行) 作为每一行的结束符，其好处是，在使用过程中可以方便地增加自定义参数，也方便抓包分析。从消息传送方向上来分，RTSP 的报文有两类：请求报文和响应报文。请求报文是指从客户端向服务器发送的请求 (也有少量从服务器向客户端发送的请求)，响应报文是指从服务器到客户端的回应。</p>
<p>RTSP 请求报文的常用方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>方向</th>
<th>对象</th>
<th>是否必要</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>DESCRIBE</td>
<td>C-&gt;S</td>
<td>P, S</td>
<td>推荐</td>
<td>得到会话描述信息</td>
</tr>
<tr>
<td>ANNOUNCE</td>
<td>C-&gt;S, S-&gt;C</td>
<td>P, S</td>
<td>可选</td>
</tr>
<tr>
<td>GET_PARAMETER</td>
<td>C-&gt;S, S-&gt;C</td>
<td>P, S</td>
<td>可选</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>C-&gt;S, S-&gt;C</td>
<td>P, S</td>
<td>必须 (S-&gt;C: 可选)</td>
<td>获得服务器提供的可用方法</td>
</tr>
<tr>
<td>PAUSE</td>
<td>C-&gt;S</td>
<td>P, S</td>
<td>推荐</td>
<td>客户端发起暂停播放请求</td>
</tr>
<tr>
<td>PLAY</td>
<td>C-&gt;S</td>
<td>P, S</td>
<td>必须</td>
<td>客户端发起播放请求</td>
</tr>
<tr>
<td>RECORD</td>
<td>C-&gt;S</td>
<td>P, S</td>
<td>可选</td>
</tr>
<tr>
<td>REDIRECT</td>
<td>S-&gt;C</td>
<td>P, S</td>
<td>可选</td>
</tr>
<tr>
<td>SETUP</td>
<td>C-&gt;S</td>
<td>S</td>
<td>必须</td>
<td>客户端请求建立会话</td>
</tr>
<tr>
<td>SET_PARAMETER</td>
<td>C-&gt;S, S-&gt;C</td>
<td>P, S</td>
<td>可选</td>
</tr>
<tr>
<td>TEARDOWN</td>
<td>C-&gt;S</td>
<td>P, S</td>
<td>必须</td>
<td>客户端发起关闭会话</td>
</tr>
</tbody>
</table>
</div>
<p>通过 <code>VLC</code> 播放 <code>RTSP</code> 网络流，经抓包得以下内容：</p>
<pre><code>OPTIONS rtsp://192.168.199.152:554/live/test RTSP/1.0
CSeq: 2
User-Agent: LibVLC/3.0.8 (LIVE555 Streaming Media v2016.11.28)

RTSP/1.0 200 OK
CSeq: 2
Date: Mon, Jul 27 2020 15:32:38 GMT
Public: OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, ANNOUNCE, RECORD, SET_PARAMETER, GET_PARAMETER
Server: ZLMediaKit-5.0(build in Jul 12 2020 14:02:13)

DESCRIBE rtsp://192.168.199.152:554/live/test RTSP/1.0
CSeq: 3
User-Agent: LibVLC/3.0.8 (LIVE555 Streaming Media v2016.11.28)
Accept: application/sdp

RTSP/1.0 200 OK
Content-Base: rtsp://192.168.199.152:554/live/test/
Content-Length: 544
Content-Type: application/sdp
CSeq: 3
Date: Mon, Jul 27 2020 15:32:38 GMT
Server: ZLMediaKit-5.0(build in Jul 12 2020 14:02:13)
Session: hEu0JzMKcfK2
x-Accept-Dynamic-Rate: 1
x-Accept-Retransmit: our-retransmit

v=0
o=- 0 0 IN IP4 127.0.0.1
c=IN IP4 127.0.0.1
t=0 0
s=Streamed by ZLMediaKit-5.0(build in Jul 12 2020 14:01:57)
a=tool:libavformat 58.29.100
m=video 0 RTP/AVP 96
a=fmtp:96 packetization-mode=1; sprop-parameter-sets=Z2QAHqzZQNg95f/wFAAUEQAAAwABAAADADIPFi2W,aOvjyyLA; profile-level-id=64001E
a=rtpmap:96 H264/90000
a=control:streamid=0
m=audio 0 RTP/AVP 97
b=AS:128
a=fmtp:97 profile-level-id=1;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3; config=121056E500
a=rtpmap:97 MPEG4-GENERIC/44100/2
a=control:streamid=1
SETUP rtsp://192.168.199.152:554/live/test/streamid=0 RTSP/1.0
CSeq: 4
User-Agent: LibVLC/3.0.8 (LIVE555 Streaming Media v2016.11.28)
Transport: RTP/AVP;unicast;client_port=60836-60837

RTSP/1.0 200 OK
CSeq: 4
Date: Mon, Jul 27 2020 15:32:38 GMT
Server: ZLMediaKit-5.0(build in Jul 12 2020 14:02:13)
Session: hEu0JzMKcfK2
Transport: RTP/AVP/UDP;unicast;client_port=60836-60837;server_port=41070-41071;ssrc=50E36E3B

SETUP rtsp://192.168.199.152:554/live/test/streamid=1 RTSP/1.0
CSeq: 5
User-Agent: LibVLC/3.0.8 (LIVE555 Streaming Media v2016.11.28)
Transport: RTP/AVP;unicast;client_port=60838-60839
Session: hEu0JzMKcfK2

RTSP/1.0 200 OK
CSeq: 5
Date: Mon, Jul 27 2020 15:32:38 GMT
Server: ZLMediaKit-5.0(build in Jul 12 2020 14:02:13)
Session: hEu0JzMKcfK2
Transport: RTP/AVP/UDP;unicast;client_port=60838-60839;server_port=58452-58453;ssrc=3463B21F

PLAY rtsp://192.168.199.152:554/live/test/ RTSP/1.0
CSeq: 6
User-Agent: LibVLC/3.0.8 (LIVE555 Streaming Media v2016.11.28)
Session: hEu0JzMKcfK2
Range: npt=0.000-

RTSP/1.0 200 OK
CSeq: 6
Date: Mon, Jul 27 2020 15:32:38 GMT
Range: npt=42535.41
RTP-Info: url=rtsp://192.168.199.152:554/live/test/streamid=0;seq=3889;rtptime=-466780396,url=rtsp://192.168.199.152:554/live/test/streamid=1;seq=1155;rtptime=-179511072
Server: ZLMediaKit-5.0(build in Jul 12 2020 14:02:13)
Session: hEu0JzMKcfK2

TEARDOWN rtsp://192.168.199.152:554/live/test/ RTSP/1.0
CSeq: 7
User-Agent: LibVLC/3.0.8 (LIVE555 Streaming Media v2016.11.28)
Session: hEu0JzMKcfK2

RTSP/1.0 200 OK
CSeq: 7
Date: Mon, Jul 27 2020 15:32:41 GMT
Server: ZLMediaKit-5.0(build in Jul 12 2020 14:02:13)
Session: hEu0JzMKcfK2
</code></pre><p>从上述抓包中看出，VLC 在播放 RTSP 网络流时，客户端与服务端经过了 6 次交互：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>方向</th>
<th>方法</th>
<th>消息内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>C-&gt;S</td>
<td>OPTIONS</td>
<td>Client 询问 Server 有哪些方法可用</td>
</tr>
<tr>
<td>1</td>
<td>S-&gt;C</td>
<td>OPTIONS</td>
<td>Server 回应所有可用的方法</td>
</tr>
<tr>
<td>2</td>
<td>C-&gt;S</td>
<td>DESCRIBE</td>
<td>Client 请求得到 Server 提供的媒体初始化描述信息</td>
</tr>
<tr>
<td>2</td>
<td>S-&gt;C</td>
<td>DESCRIBE</td>
<td>Server 回应媒体初始化信息，主要是 SDP （会话描述协议）</td>
</tr>
<tr>
<td>3</td>
<td>C-&gt;S</td>
<td>SETUP</td>
<td>设置视频会话属性以及传输模式，请求建立会话</td>
</tr>
<tr>
<td>3</td>
<td>S-&gt;C</td>
<td>SETUP</td>
<td>Server 建立会话，返回会话标识以及会话相关信息</td>
</tr>
<tr>
<td>4</td>
<td>C-&gt;S</td>
<td>SETUP</td>
<td>设置音频会话属性以及传输模式，请求建立会话</td>
</tr>
<tr>
<td>4</td>
<td>S-&gt;C</td>
<td>SETUP</td>
<td>Server 建立会话，返回会话标识以及会话相关信息</td>
</tr>
<tr>
<td>5</td>
<td>C-&gt;S</td>
<td>PLAY</td>
<td>Client 请求播放</td>
</tr>
<tr>
<td>5</td>
<td>S-&gt;C</td>
<td>PLAY</td>
<td>Server 回应播放请求</td>
</tr>
<tr>
<td>6</td>
<td>C-&gt;S</td>
<td>TEARDOWN</td>
<td>Client 请求关闭会话</td>
</tr>
<tr>
<td>6</td>
<td>S-&gt;C</td>
<td>TEARDOWN</td>
<td>Server 回应关闭会话请求</td>
</tr>
</tbody>
</table>
</div>
<p>下面我们一步一步了解 RTSP 会话建立流程：</p>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>OPTIONS 请求可以在任何时间被发出，而且不会影响到 Server 的状态，例如：</p>
<pre><code> C-&gt;S:  OPTIONS * RTSP/1.0
        CSeq: 1
        Require: implicit-play
        Proxy-Require: gzipped-messages

 S-&gt;C:  RTSP/1.0 200 OK
        CSeq: 1
        Public: DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE
</code></pre><h3 id="DESCRIBE"><a href="#DESCRIBE" class="headerlink" title="DESCRIBE"></a>DESCRIBE</h3><p>客户端向服务器请求媒体资源描述，服务器端通过 SDP(Session Description Protocol) 格式回应客户端的请求。资源描述中会列出所请求媒体的媒体流及其相关信息，典型情况下，音频和视频分别作为一个媒体流传输。例如：</p>
<pre><code> C-&gt;S: DESCRIBE rtsp://server.example.com/fizzle/foo RTSP/1.0
       CSeq: 312
       Accept: application/sdp, application/rtsl, application/mheg

 S-&gt;C: RTSP/1.0 200 OK
       CSeq: 312
       Date: 23 Jan 1997 15:35:06 GMT
       Content-Type: application/sdp
       Content-Length: 376

       v=0
       o=mhandley 2890844526 2890842807 IN IP4 126.16.64.4
       s=SDP Seminar
       i=A Seminar on the session description protocol
       u=http://www.cs.ucl.ac.uk/staff/M.Handley/sdp.03.ps
       e=mjh@isi.edu (Mark Handley)
       c=IN IP4 224.2.17.12/127
       t=2873397496 2873404696
       a=recvonly
       m=audio 3456 RTP/AVP 0
       m=video 2232 RTP/AVP 31
       m=whiteboard 32416 UDP WB
       a=orient:portrait
</code></pre><blockquote>
<p>媒体流及其相关信息由 SDP(Session Description Protocol) 格式携带，关于 SDP 的详细说明，参见拓展阅读 5</p>
</blockquote>
<h3 id="SETUP"><a href="#SETUP" class="headerlink" title="SETUP"></a>SETUP</h3><p>SETUP 请求确定了具体的媒体流如何传输，该请求必须在 PLAY 请求之前发送。SETUP 请求包含媒体流的 URL 和客户端用于接收 RTP 数据 (audio or video) 的端口以及接收 RTCP 数据 (meta information) 的端口。服务器端的回复通常包含客户端请求参数的确认，并会补充缺失的部分，比如服务器选择的发送端口。每一个媒体流在发送 PLAY 请求之前，都要首先通过 SETUP 请求来进行相应的配置。</p>
<pre><code>C-&gt;S: SETUP rtsp://example.com/foo/bar/baz.rm RTSP/1.0
      CSeq: 302
      Transport: RTP/AVP;unicast;client_port=4588-4589

S-&gt;C: RTSP/1.0 200 OK
      CSeq: 302
      Date: 23 Jan 1997 15:35:06 GMT
      Session: 47112344
      Transport: RTP/AVP;unicast;client_port=4588-4589;server_port=6256-6257
</code></pre><h3 id="PLAY"><a href="#PLAY" class="headerlink" title="PLAY"></a>PLAY</h3><p>客户端通过 PLAY 请求来播放一个或全部媒体流，PLAY 请求可以发送一次或多次，发送一次时，URL 为包含所有媒体流的地址，发送多次时，每一次请求携带的 URL 只包含一个相应的媒体流。PLAY 请求中可指定播放的 range，若未指定，则从媒体流的开始播放到结束，如果媒体流在播放过程中被暂停，则可在暂停处重新启动流的播放。</p>
<pre><code>C-&gt;S: PLAY rtsp://example.com/media.mp4 RTSP/1.0
      CSeq: 4
      Range: npt=5-20
      Session: 12345678

S-&gt;C: RTSP/1.0 200 OK
      CSeq: 4
      Session: 12345678
      RTP-Info: url=rtsp://example.com/media.mp4/streamid=0;seq=9810092;rtptime=3450012
</code></pre><blockquote>
<p>Server 处理 client 发来的 PLAY 请求后，就会开始向 client 发送媒体数据，一般采用 RTP 协议进行发送，关于 RTP 协议的相关说明，参见拓展阅读 6</p>
</blockquote>
<h3 id="TEARDOWN"><a href="#TEARDOWN" class="headerlink" title="TEARDOWN"></a>TEARDOWN</h3><p>结束会话请求，该请求会停止所有媒体流，并释放服务器上的相关会话数据。</p>
<pre><code>C-&gt;S: TEARDOWN rtsp://example.com/media.mp4 RTSP/1.0
      CSeq: 8
      Session: 12345678

S-&gt;C: RTSP/1.0 200 OK
      CSeq: 8
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/xia-chu/ZLMediaKit">ZLMediaKit</a> （作为 RTSP Server）</li>
<li>[2] <a href="https://www.videolan.org/">VLC</a> （作为 RTSP Client）</li>
<li>[3] <a href="https://www.cnblogs.com/linhaostudy/p/11140823.html">yooooooo 的博客园：《网络流媒体协议之——RTSP 协议》</a></li>
<li>[4] <a href="https://www.rfc-editor.org/rfc/rfc2326.txt">RFC 2326: Real Time Streaming Protocol (RTSP)</a></li>
<li>[5] <a href="https://www.rfc-editor.org/rfc/rfc3551.txt">RFC 3551: RTP Profile for Audio and Video Conferences with Minimal Control</a></li>
<li>[6] <a href="https://www.rfc-editor.org/rfc/rfc6184.txt">RFC 6184: RTP Payload Format for H.264 Video</a></li>
<li>[7] <a href="https://www.rfc-editor.org/rfc/rfc3550.txt">RFC 3550: RTP: A Transport Protocol for Real-Time Applications</a></li>
</ul>
]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>RTSP</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体传输 - RTSP 协议报文分析</title>
    <url>/post/2020/c8d9fa71/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <a href="/post/2020/cf84018a/" title="流媒体传输 - RTSP 协议">流媒体传输 - RTSP 协议</a> 中，我们分析 RTSP 协议交互的整个流程，在本篇文章中，我们对交互中携带的报文进行详细分析。</p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><pre><code>Request     =       Request-Line              ; Section 6.1
            *(      general-header            ; Section 5
            |       request-header            ; Section 6.2
            |       entity-header )           ; Section 8.1
                    CRLF
                    [message-body]            ; Section 4.3
</code></pre><a id="more"></a>
<h3 id="Request-Line"><a href="#Request-Line" class="headerlink" title="Request-Line"></a>Request-Line</h3><pre><code>Request-Line = Method SP Request-URI SP RTSP-Version CRLF

Method      =         &quot;DESCRIBE&quot;              ; Section 10.2
            |         &quot;ANNOUNCE&quot;              ; Section 10.3
            |         &quot;GET_PARAMETER&quot;         ; Section 10.8
            |         &quot;OPTIONS&quot;               ; Section 10.1
            |         &quot;PAUSE&quot;                 ; Section 10.6
            |         &quot;PLAY&quot;                  ; Section 10.5
            |         &quot;RECORD&quot;                ; Section 10.11
            |         &quot;REDIRECT&quot;              ; Section 10.10
            |         &quot;SETUP&quot;                 ; Section 10.4
            |         &quot;SET_PARAMETER&quot;         ; Section 10.9
            |         &quot;TEARDOWN&quot;              ; Section 10.7
            |         extension-method

SP = space

extension-method = token

Request-URI = &quot;*&quot; | absolute_URI

RTSP-Version = &quot;RTSP&quot; &quot;/&quot; 1*DIGIT &quot;.&quot; 1*DIGIT
</code></pre><blockquote>
<p>注意，与 HTTP / 1.1 相比，RTSP 请求始终包含绝对 URL（即，包括 方案、主机、端口），而不仅仅是绝对路径。<br>Request-URI 中的星号 “*” 表示该请求不适用于特定资源，而是适用于服务器本身，并且仅在所使用的方法不一定适用于资源时才被允许。比如：</p>
<blockquote>
<p><code>OPTIONS * RTSP/1.0</code></p>
</blockquote>
</blockquote>
<h3 id="Request-Header-Fields"><a href="#Request-Header-Fields" class="headerlink" title="Request Header Fields"></a>Request Header Fields</h3><pre><code>request-header  =      Accept                   ; Section 12.1
                |      Accept-Encoding          ; Section 12.2
                |      Accept-Language          ; Section 12.3
                |      Authorization            ; Section 12.5
                |      From                     ; Section 12.20
                |      If-Modified-Since        ; Section 12.23
                |      Range                    ; Section 12.29
                |      Referer                  ; Section 12.30
                |      User-Agent               ; Section 12.41
</code></pre><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>在接收并解释了请求消息后，接收者以 RTSP 响应消息进行响应。</p>
<p>响应消息除了将 HTTP 版本替换为 RTSP 版本之外，其他都适用。 此外，RTSP 定义了其他状态代码，并且没有定义某些 HTTP 代码。 表 1 中定义了有效的响应代码及其可使用的方法。</p>
<pre><code>Response    =     Status-Line         ; Section 7.1
            *(    general-header      ; Section 5
            |     response-header     ; Section 7.1.2
            |     entity-header )     ; Section 8.1
                  CRLF
                  [message-body]    ; Section 4.3
</code></pre><h3 id="Status-Line"><a href="#Status-Line" class="headerlink" title="Status-Line"></a>Status-Line</h3><p>响应消息的第一行是状态行，由协议版本，后跟数字状态代码以及与状态代码关联的文本短语组成，每个元素由 SP 字符分隔。 除最后的 CRLF 序列外，不允许有 CR 或 LF。</p>
<pre><code>Status-Line    =    RTSP-Version SP Status-Code SP Reason-Phrase CRLF

Status-code    =    3DIGIT

Reason-Phrase  =    *&lt;TEXT, excluding CR, LF&gt;
</code></pre><h4 id="Status-Code-和-Reason-Phrase"><a href="#Status-Code-和-Reason-Phrase" class="headerlink" title="Status Code 和 Reason-Phrase"></a>Status Code 和 Reason-Phrase</h4><p>Status Code 是 3 位数的整数结果代码，表示请求是否被理解或被满足。这些代码在第 11 节中有完整定义。Reason-Phrase 旨在简要说明 Status Code。Status Code 供机器使用，Reason-Phrase 供人类用户使用。 客户端不需要检查或显示 Reason-Phrase。</p>
<p>Status Code 的第一位数字定义了回应的类别，后面两位数字没有具体分类。首位数字有 5 种取值可能：</p>
<ul>
<li>1xx：保留，将来使用。</li>
<li>2xx：成功：操作被接收、理解、接受（received, understood, accepted）。</li>
<li>3xx：重定向（Redirection）：要完成请求必须进行进一步操作。</li>
<li>4xx：客户端出错：请求有语法错误或无法实现。</li>
<li>5xx：服务器端出错：服务器无法实现合法的请求。</li>
</ul>
<blockquote>
<p>具体 Status Code 含义可查看 RFC 2326 Session 11 : Status Code Definitions</p>
</blockquote>
<h3 id="Response-Header-Fields"><a href="#Response-Header-Fields" class="headerlink" title="Response Header Fields"></a>Response Header Fields</h3><p>响应头字段允许请求接收者传递关于响应的其他信息，这些信息不能放在状态行中。 这些头字段提供有关服务器以及对由 Request-URI 标识的资源的进一步访问的信息。</p>
<pre><code>response-header  =     Location             ; Section 12.25
                 |     Proxy-Authenticate   ; Section 12.26
                 |     Public               ; Section 12.28
                 |     Retry-After          ; Section 12.31
                 |     Server               ; Section 12.36
                 |     Vary                 ; Section 12.42
                 |     WWW-Authenticate     ; Section 12.44
</code></pre><h2 id="Method-Definitions"><a href="#Method-Definitions" class="headerlink" title="Method Definitions"></a>Method Definitions</h2><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>OPTIONS 用于询问 Server 有哪些方法可用</p>
<pre><code>C-&gt;S:  OPTIONS * RTSP/1.0
       CSeq: 1
       Require: implicit-play
       Proxy-Require: gzipped-messages

S-&gt;C:  RTSP/1.0 200 OK
       CSeq: 1
       Public: DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE
</code></pre><h3 id="DESCRIBE"><a href="#DESCRIBE" class="headerlink" title="DESCRIBE"></a>DESCRIBE</h3><p>DESCRIBE 方法从服务器检索表示的描述或媒体对象，这些资源通过请求统一资源定位符（the request URL）识别。此方法可能结合使用 Accept 首部域来指定客户端理解的描述格式。服务器端用被请求资源的描述对客户端作出响应。 DESCRIBE 的答复 - 响应对（reply-response pair）组成了 RTSP 的媒体初始化阶段。</p>
<pre><code>C-&gt;S: DESCRIBE rtsp://server.example.com/fizzle/foo RTSP/1.0
      CSeq: 312
      Accept: application/sdp, application/rtsl, application/mheg

S-&gt;C: RTSP/1.0 200 OK
      CSeq: 312
      Date: 23 Jan 1997 15:35:06 GMT
      Content-Type: application/sdp
      Content-Length: 376

      v=0
      o=mhandley 2890844526 2890842807 IN IP4 126.16.64.4
      s=SDP Seminar
      i=A Seminar on the session description protocol
      u=http://www.cs.ucl.ac.uk/staff/M.Handley/sdp.03.ps
      e=mjh@isi.edu (Mark Handley)
      c=IN IP4 224.2.17.12/127
      t=2873397496 2873404696
      a=recvonly
      m=audio 3456 RTP/AVP 0
      m=video 2232 RTP/AVP 31
      m=whiteboard 32416 UDP WB
      a=orient:portrait
</code></pre><p>DESCRIBE 响应必须包含它描述的资源的所有媒体初始化信息。 如果媒体客户端从 DESCRIBE 以外的来源获得媒体描述，并且该描述包含完整的媒体初始化参数集，则客户端应使用这些参数，而不是通过 RTSP 请求相同媒体描述。</p>
<p>DESCRIBE 响应携带的 SDP 信息详见：</p>
<blockquote>
<a href="/post/2020/1fa21384/" title="流媒体传输 - SDP 协议">流媒体传输 - SDP 协议</a>
</blockquote>
<h3 id="SETUP"><a href="#SETUP" class="headerlink" title="SETUP"></a>SETUP</h3><pre><code>C-&gt;S: SETUP rtsp://example.com/foo/bar/baz.rm RTSP/1.0
      CSeq: 302
      Transport: RTP/AVP;unicast;client_port=4588-4589

S-&gt;C: RTSP/1.0 200 OK
      CSeq: 302
      Date: 23 Jan 1997 15:35:06 GMT
      Session: 47112344
      Transport: RTP/AVP;unicast;client_port=4588-4589;server_port=6256-6257
</code></pre><p>URI 的 SETUP 请求指定要用于流媒体的传输机制。客户端可以对已经播放的流发出 SETUP 请求，以更改传输参数（服务器可以允许）。如果不允许这样做，它必须以错误 “455 方法在此状态下无效” 响应。为了使任何中间的防火墙受益，客户端必须指示传输参数，即使它对这些参数没有影响，例如，在服务器通告固定的多播地址的地方。</p>
<p>由于 SETUP 包含所有传输初始化信息，因此防火墙和其他中间网络设备（需要此信息）可以省去解析 DESCRIBE 响应的更艰巨的任务，该响应已保留给媒体初始化。</p>
<p>Transport Header 指定客户端可接受的数据传输传输参数；响应将包含服务器选择的传输参数。</p>
<h4 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h4><p>以下是与 Transport 关联的配置参数：</p>
<pre><code>Transport           =    &quot;Transport&quot; &quot;:&quot; SP transport-spec
transport-spec      =    transport-protocol/profile[/lower-transport]
                         *parameter
transport-protocol  =    &quot;RTP&quot;
profile             =    &quot;AVP&quot;
lower-transport     =    &quot;TCP&quot; | &quot;UDP&quot;
parameter           =    (&quot;unicast&quot; | &quot;multicast&quot;)
                    |    &quot;;&quot; &quot;destination&quot; [&quot;=&quot; address]
                    |    &quot;;&quot; &quot;interleaved&quot; &quot;=&quot; channel [&quot;-&quot; channel]
                    |    &quot;;&quot; &quot;append&quot;
                    |    &quot;;&quot; &quot;ttl&quot; &quot;=&quot; ttl
                    |    &quot;;&quot; &quot;layers&quot; &quot;=&quot; 1*DIGIT
                    |    &quot;;&quot; &quot;port&quot; &quot;=&quot; port [&quot;-&quot; port]
                    |    &quot;;&quot; &quot;client_port&quot; &quot;=&quot; port [&quot;-&quot; port]
                    |    &quot;;&quot; &quot;server_port&quot; &quot;=&quot; port [&quot;-&quot; port]
                    |    &quot;;&quot; &quot;ssrc&quot; &quot;=&quot; ssrc
                    |    &quot;;&quot; &quot;mode&quot; = &lt;&quot;&gt; 1\#mode &lt;&quot;&gt;
ttl                 =    1*3(DIGIT)
port                =    1*5(DIGIT)
ssrc                =    8*8(HEX)
channel             =    1*3(DIGIT)
address             =    host
mode                =    &lt;&quot;&gt; *Method &lt;&quot;&gt; | Method
</code></pre><ul>
<li><p>unicast | multicast:</p>
<p>  二选一地指定是进行单播还是多播的传输尝试。 默认值为多播。 单播和多播传输均能处理的客户端必须通过包括两个完整的传输规范以及每个独立的参数来指示这种能力</p>
</li>
<li><p>destination:<br>  流将被发送到的地址。 客户端可以使用该参数指定多播地址。为了避免在不知情的情况下被用于拒绝服务攻击，服务器应该对客户端进行身份验证，并应该记录此类尝试，然后再允许客户端将媒体流定向到服务器未选择的地址。 这对通过 UDP 发出的 RTSP 命令尤其重要，但是实现不能依赖 TCP 作为可靠的客户端验证手段。 服务器应该不允许客户端将媒体流定向到与命令来源不同的地址上去</p>
</li>
<li><p>mode<br>  mode指示会话支持的方法。有效的值有 PLAY 和 RECORD。如果没有提供，默认值是 PLAY</p>
</li>
<li><p>port<br>  该参数为多播会话提供 RTP/RTCP 端口号对，它以范围的方式给出，例如：port=34567-34568</p>
</li>
<li><p>client_port<br>  该参数提供客户端选择的接收媒体数据和控制信息的单播 RTP/RTCP 端口号对，它以范围的方式给出，例如：client_port=34567-34568</p>
</li>
<li><p>server_port<br>  该参数提供服务端选择的接收媒体数据和控制信息的单播 RTP/RTCP 端口号对，它以范围的方式给出，例如：server_port=45678-45679</p>
</li>
<li><p>ssrc<br>  该参数指示媒体服务器应该用的（请求）或将要用的（响应）RTSP SSRC 值，该参数只对单播传输有效，他是和媒体流关联的同步源的标识</p>
</li>
</ul>
<p>例如：</p>
<p>Transport: RTP/AVP;multicast;ttl=127;mode=”PLAY”,<br>           RTP/AVP;unicast;client_port=3456-3457;mode=”PLAY”</p>
<h3 id="PLAY"><a href="#PLAY" class="headerlink" title="PLAY"></a>PLAY</h3><p>PLAY 方法告诉服务器通过 SETUP 规定的机制开始传输数据。客户端不允许在 SETUP 请求在明确确认成功以前发送 PLAY 请求。</p>
<p>PLAY 请求通过给出相对于正常播放时间的开始时间和结束时间，来给出播放范围。从开始时间开始传输流数据直到到达结束时间。PLAY 可以用管道（队列）形式，服务器必须按顺序执行收到的 PLAY 请求。即：在前一个 PLAY 请求依然活动期间收到 PLAY 请求，要延迟到前一个 PLAY 请求执行完毕后开始生效。</p>
<p>例如：不管下面例子中的两个 PLAY 请求的到达间隔多短，服务器将先从第 10 秒播放至第 15 秒，然后马上播放第 20 秒到第 25 秒，再从第 30 秒播放至结束。</p>
<pre><code>C-&gt;S: PLAY rtsp://audio.example.com/audio RTSP/1.0
      CSeq: 835
      Session: 12345678
      Range: npt=10-15
C-&gt;S: PLAY rtsp://audio.example.com/audio RTSP/1.0
      CSeq: 836
      Session: 12345678
      Range: npt=20-25
C-&gt;S: PLAY rtsp://audio.example.com/audio RTSP/1.0
      CSeq: 837
      Session: 12345678
      Range: npt=30-
</code></pre><h3 id="TEARDOWN"><a href="#TEARDOWN" class="headerlink" title="TEARDOWN"></a>TEARDOWN</h3><p>TEARDOWN 请求会停止所给 URI 的流传输，释放与它相关的资源。如果所给的 URI 是这个表示的表示 URI，任何与此会话相关的会话标识都将不再有效。除非所有传输参数都在会话描述中定义了，否则在再次播放前必须发送 SETUP 请求。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://www.rfc-editor.org/rfc/rfc2326.txt">RFC 2326: Real Time Streaming Protocol (RTSP)</a></li>
</ul>
]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>RTSP</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 事件主循环</title>
    <url>/post/2020/f65e9050/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <code>libevent</code> 中，事件主循环的作用就是执行一个循环，在循环中监听事件以及超时的事件并且将这些激活的事件进行处理。<code>libevent</code> 提供了对用户开放了两种执行事件主循环的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="事件主循环"><a href="#事件主循环" class="headerlink" title="事件主循环"></a>事件主循环</h2><blockquote>
<p><a href="/post/2020/afa6fb2f/" title="源码阅读 libevent - 结构体：event">源码阅读 libevent - 结构体：event</a> 中提到了 <code>event</code> 结构体的生命周期:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128204050.png" alt="event 的生命周期"></p>
</blockquote>
<p>事件主循环做的工作就是该流程图的下半部分：</p>
<p>pending 状态：等待事件发生<br>active 状态：事件已经发生，等待调用事件回调</p>
<p>总体流程分为三部分</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>流程</th>
<th>调用相关函数</th>
<th>event 状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>事件发生</td>
<td>event_active()</td>
<td>pending —&gt; avtive</td>
</tr>
<tr>
<td>单次事件处理</td>
<td>callback done</td>
<td>avtive —&gt; non-pending</td>
</tr>
<tr>
<td>持久事件处理</td>
<td>callback done</td>
<td>avtive —&gt; pending</td>
</tr>
</tbody>
</table>
</div>
<p>事件主循环函数 <code>event_base_dispatch()</code> 其实就是调用 <code>event_base_loop()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *event_base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (event_base_loop(event_base, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>event_base_loop()</code> 函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> = <span class="title">base</span>-&gt;<span class="title">evsel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">tv_p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res, done, retval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 加锁. 在调用 evsel-&gt;dispatch 时会进行解锁, 在调用用户回调函数时也会解锁 */</span></span><br><span class="line">    EVBASE_ACQUIRE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;running_loop) &#123;</span><br><span class="line">        event_warnx(<span class="string">&quot;%s: reentrant invocation.  Only one event_base_loop can run on each event_base at once.&quot;</span>, __func__);</span><br><span class="line">        EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;running_loop = <span class="number">1</span>; <span class="comment">/* 只允许一个事件主循环 */</span></span><br><span class="line"></span><br><span class="line">    clear_time_cache(base); <span class="comment">/* 清空缓存的超时 */</span></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;sig.ev_signal_added &amp;&amp; base-&gt;sig.ev_n_signals_added) evsig_set_base_(base);</span><br><span class="line">    done = <span class="number">0</span>; <span class="comment">/* 用来确定是否退出循环 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EVENT__DISABLE_THREAD_SUPPORT</span></span><br><span class="line">    base-&gt;th_owner_id = EVTHREAD_GET_ID(); <span class="comment">/* 保存当前线程 ID */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    base-&gt;event_gotterm = base-&gt;event_break = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        base-&gt;event_continue = <span class="number">0</span>;</span><br><span class="line">        base-&gt;n_deferreds_queued = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 中止循环的两个条件 */</span></span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_gotterm) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_break) <span class="keyword">break</span>;</span><br><span class="line">        tv_p = &amp;tv;</span><br><span class="line">        <span class="comment">/* 如果当前 event_base 里没有已经激活的事件，就将时间最小堆，堆顶的超时值取出来，作为下一轮 dispatch 的超时值</span></span><br><span class="line"><span class="comment">        ** 否则就将超时时间置为 0，evsel-&gt;dispatch 会立马超时返回，激活的事件得以处理 */</span></span><br><span class="line">        <span class="keyword">if</span> (!N_ACTIVE_CALLBACKS(base) &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) timeout_next(base, &amp;tv_p);</span><br><span class="line">        <span class="keyword">else</span> evutil_timerclear(&amp;tv);</span><br><span class="line">        <span class="comment">/* If we have no events, we just exit */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (flags &amp; EVLOOP_NO_EXIT_ON_EMPTY) &amp;&amp;</span><br><span class="line">            !event_haveevents(base) &amp;&amp; !N_ACTIVE_CALLBACKS(base)) &#123;</span><br><span class="line">            event_debug((<span class="string">&quot;%s: no events registered.&quot;</span>, __func__));</span><br><span class="line">            retval = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        event_queue_make_later_events_active(base);</span><br><span class="line">        clear_time_cache(base);</span><br><span class="line">        res = evsel-&gt;dispatch(base, tv_p);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            event_debug((<span class="string">&quot;%s: dispatch returned unsuccessfully.&quot;</span>, __func__));</span><br><span class="line">            retval = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update_time_cache(base);</span><br><span class="line">        <span class="comment">/* 将 base 的 min_heap 中所有超时的事件以超时激活类型添加到激活队列中 */</span></span><br><span class="line">        timeout_process(base);</span><br><span class="line">        <span class="keyword">if</span> (N_ACTIVE_CALLBACKS(base)) &#123; <span class="comment">/* 如果激活队列中有事件 */</span></span><br><span class="line">            <span class="comment">/* 执行激活队列中的 event 相应的回调函数，返回的 n 是成功执行的非内部事件数目 */</span></span><br><span class="line">            <span class="keyword">int</span> n = event_process_active(base);</span><br><span class="line">            <span class="comment">/* 如果设置了 EVLOOP_ONCE，并且所有激活的事件都处理完了，那么就退出 event_loop */</span></span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; EVLOOP_ONCE) &amp;&amp; N_ACTIVE_CALLBACKS(base) == <span class="number">0</span> &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">                done = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; EVLOOP_NONBLOCK) <span class="comment">/* 如果设置了 EVLOOP_NONBLOCK 那么也会退出 event_loop 循环 */</span></span><br><span class="line">            done = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    event_debug((<span class="string">&quot;%s: asked to terminate loop.&quot;</span>, __func__));</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    clear_time_cache(base);</span><br><span class="line">    base-&gt;running_loop = <span class="number">0</span>;</span><br><span class="line">    EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="keyword">return</span> (retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接阅读 <code>event_base_loop()</code> 较为困难，我们根据上述流程进行分析</p>
<ol>
<li>事件发生<ul>
<li>如何监听事件发生</li>
<li>事件发生后如何激活事件</li>
</ul>
</li>
<li>事件处理<ul>
<li>如何处理已激活事件</li>
<li>如何持久化事件</li>
</ul>
</li>
</ol>
<h2 id="事件发生"><a href="#事件发生" class="headerlink" title="事件发生"></a>事件发生</h2><h3 id="如何监听事件发生"><a href="#如何监听事件发生" class="headerlink" title="如何监听事件发生"></a>如何监听事件发生</h3><h4 id="监听方式"><a href="#监听方式" class="headerlink" title="监听方式"></a>监听方式</h4><p>libevent 提供了多种监听事件的方案，如单次监听、循环监听等，监听方案由 <code>event_base_loop()</code> 参数决定：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 阻塞, 直到一个 event 变成 active. 在 active 状态的 event 的 Callback 函数执行后，就退出。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_ONCE 0x01</span></span><br><span class="line"><span class="comment">/* 不会阻塞，它仅仅是查看是否已经有 event ready. 有则运行其 callback. 然后退出 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_NONBLOCK 0x02</span></span><br><span class="line"><span class="comment">/* 哪怕 event_base 中没有 active 或者 pending 的 event 了。也不退出。直到调用 event_base_loopbreak() or event_base_loopexit(). */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_NO_EXIT_ON_EMPTY 0x04</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当 flags 什么都不设置时，则 loop 一直运行，检查到 event 变为 active 时，运行其 callback 函数。</span></span><br><span class="line"><span class="comment">** 当没有 active 或 pending 的 event 后，退出 loop。</span></span><br><span class="line"><span class="comment">** 有人调用了 event_base_loopbreak() or event_base_loopexit()，也退出 loop. */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关 event_base_loopbreak() 和 event_base_loopexit() 参见：<a href="#">Post not found: 源码阅读 libevent - 事件主循环的停止</a></p>
</blockquote>
<h4 id="监听超时时间的计算"><a href="#监听超时时间的计算" class="headerlink" title="监听超时时间的计算"></a>监听超时时间的计算</h4><h4 id="监听-IO-事件和-Signal-事件"><a href="#监听-IO-事件和-Signal-事件" class="headerlink" title="监听 IO 事件和 Signal 事件"></a>监听 IO 事件和 Signal 事件</h4><p><code>libevent</code> 调用 <code>evsel-&gt;dispatch</code> 回调函数监听 <code>IO</code> 事件和 <code>Signal</code> 事件的发生：</p>
<p>以 <code>select.c</code> 为例：</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">select_dispatch</span><span class="params">(struct event_base *base, struct timeval *tv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>, i, j, nfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">selectop</span> *<span class="title">selectop</span> = <span class="title">base</span>-&gt;<span class="title">evbase</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selectop-&gt;resize_out_sets) &#123;</span><br><span class="line">        fd_set *readset_out = <span class="literal">NULL</span>, *writeset_out = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">size_t</span> sz = selectop-&gt;event_fdsz;</span><br><span class="line">        <span class="keyword">if</span> (!(readset_out = mm_realloc(selectop-&gt;event_readset_out, sz))) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        selectop-&gt;event_readset_out = readset_out;</span><br><span class="line">        <span class="keyword">if</span> (!(writeset_out = mm_realloc(selectop-&gt;event_writeset_out, sz))) &#123;</span><br><span class="line">            <span class="comment">/* We don&#x27;t free readset_out here, since it was already successfully reallocated.</span></span><br><span class="line"><span class="comment">            ** The next time we call select_dispatch, the realloc will be a no-op. */</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        selectop-&gt;event_writeset_out = writeset_out;</span><br><span class="line">        selectop-&gt;resize_out_sets = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(selectop-&gt;event_readset_out, selectop-&gt;event_readset_in, selectop-&gt;event_fdsz);</span><br><span class="line">    <span class="built_in">memcpy</span>(selectop-&gt;event_writeset_out, selectop-&gt;event_writeset_in, selectop-&gt;event_fdsz);</span><br><span class="line">    nfds = selectop-&gt;event_fds + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">    res = select(nfds, selectop-&gt;event_readset_out, selectop-&gt;event_writeset_out, <span class="literal">NULL</span>, tv);</span><br><span class="line">    EVBASE_ACQUIRE_LOCK(base, th_base_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EINTR) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    event_debug((<span class="string">&quot;%s: select reports %d&quot;</span>, __func__, res));</span><br><span class="line"></span><br><span class="line">    i = evutil_weakrand_range_(&amp;base-&gt;weakrand_seed, nfds);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nfds; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++i&gt;= nfds) i = <span class="number">0</span>;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(i, selectop-&gt;event_readset_out)) res |= EV_READ;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(i, selectop-&gt;event_writeset_out)) res |= EV_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        evmap_io_active_(base, i, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在事件发生后调用 <code>evmap_io_active_()</code> 将发生的事件加入到激活事件队列中，参见 <a href="# 事件发生后如何激活事件">事件发生后如何激活事件</a>。</p>
<h3 id="事件发生后如何激活事件"><a href="#事件发生后如何激活事件" class="headerlink" title="事件发生后如何激活事件"></a>事件发生后如何激活事件</h3><p>三种事件的激活方式如下图所示：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201111125131.png" alt="事件激活"></p>
<h4 id="激活-IO-事件"><a href="#激活-IO-事件" class="headerlink" title="激活 IO 事件"></a>激活 IO 事件</h4><h5 id="evmap-io-active"><a href="#evmap-io-active" class="headerlink" title="evmap_io_active_"></a>evmap_io_active_</h5><p>从 <code>select_dispatch</code> 函数中可以看出，对于每一个事件发生的 <code>fd</code>，均会调用一次 <code>evmap_io_active_</code> 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evmap_io_active_</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_io_map</span> *<span class="title">io</span> = &amp;<span class="title">base</span>-&gt;<span class="title">io</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evmap_io</span> *<span class="title">ctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span> || fd&gt;= io-&gt;nentries) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 在 IO 事件的哈希表中获取该 fd 已添加的事件 */</span></span><br><span class="line">    GET_IO_SLOT(ctx, io, fd, evmap_io);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == ctx) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 遍历哈希表中所有该 fd 已添加的事件 */</span></span><br><span class="line">    LIST_FOREACH(ev, &amp;ctx-&gt;events, ev_io_next) &#123;</span><br><span class="line">        <span class="comment">/* 比对 dispatch 的事件和已添加的事件 */</span></span><br><span class="line">        <span class="keyword">if</span> (ev-&gt;ev_events &amp; events) s(ev, ev-&gt;ev_events &amp; events, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="event-active-nolock"><a href="#event-active-nolock" class="headerlink" title="event_active_nolock_"></a>event_active_nolock_</h5><p><code>evmap_io_active_</code> 对 <code>dispatch</code> 的所有事件进行过滤后，对于所有已添加事件，就需要调用 <code>event_active_nolock_</code> 进行激活。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_active_nolock_</span><span class="params">(struct event *ev, <span class="keyword">int</span> res, <span class="keyword">short</span> ncalls)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    base = ev-&gt;ev_base;</span><br><span class="line">    EVENT_BASE_ASSERT_LOCKED(base);</span><br><span class="line">    <span class="comment">/* #define ev_flags ev_evcallback.evcb_flags */</span></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_FINALIZING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* event 是否在激活链表和下一次激活链表中 */</span></span><br><span class="line">    <span class="keyword">switch</span> ((ev-&gt;ev_flags &amp; (EVLIST_ACTIVE|EVLIST_ACTIVE_LATER))) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> EVLIST_ACTIVE|EVLIST_ACTIVE_LATER:</span><br><span class="line">        EVUTIL_ASSERT(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EVLIST_ACTIVE: <span class="comment">/* We get different kinds of events, add them together */</span></span><br><span class="line">        ev-&gt;ev_res |= res;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> EVLIST_ACTIVE_LATER:</span><br><span class="line">        ev-&gt;ev_res |= res;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ev-&gt;ev_res = res;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_pri &lt; base-&gt;event_running_priority) base-&gt;event_continue = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 对于 signal 事件，需要对 IO 事件触发次数进行计数 */</span></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_SIGNAL) &#123;</span><br><span class="line">        ev-&gt;ev_ncalls = ncalls;</span><br><span class="line">        ev-&gt;ev_pncalls = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    event_callback_activate_nolock_(base, event_to_event_callback(ev));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="event-callback-activate-nolock"><a href="#event-callback-activate-nolock" class="headerlink" title="event_callback_activate_nolock_"></a>event_callback_activate_nolock_</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_callback_activate_nolock_</span><span class="params">(struct event_base *base, struct event_callback *evcb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (evcb-&gt;evcb_flags &amp; EVLIST_FINALIZING) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* event 是否在激活链表和下一次激活链表中 */</span></span><br><span class="line">    <span class="keyword">switch</span> (evcb-&gt;evcb_flags &amp; (EVLIST_ACTIVE|EVLIST_ACTIVE_LATER)) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        EVUTIL_ASSERT(<span class="number">0</span>);</span><br><span class="line">        EVUTIL_FALLTHROUGH;</span><br><span class="line">    <span class="keyword">case</span> EVLIST_ACTIVE_LATER:</span><br><span class="line">        event_queue_remove_active_later(base, evcb); <span class="comment">/* 删除下一次激活列表中的该 event */</span></span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EVLIST_ACTIVE:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 没有在激活列表和在下一次激活列表中的 event 会走到这里 */</span></span><br><span class="line">    event_queue_insert_active(base, evcb); <span class="comment">/* 加入激活队列 */</span></span><br><span class="line">    <span class="keyword">if</span> (EVBASE_NEED_NOTIFY(base))evthread_notify_base(base);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="event-queue-insert-active"><a href="#event-queue-insert-active" class="headerlink" title="event_queue_insert_active"></a>event_queue_insert_active</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">event_queue_insert_active(struct event_base *base, struct event_callback *evcb)</span><br><span class="line">&#123;</span><br><span class="line">    EVENT_BASE_ASSERT_LOCKED(base);</span><br><span class="line">    <span class="comment">/* Double insertion is possible for active events */</span></span><br><span class="line">    <span class="keyword">if</span> (evcb-&gt;evcb_flags &amp; EVLIST_ACTIVE) <span class="keyword">return</span>;</span><br><span class="line">    INCR_EVENT_COUNT(base, evcb-&gt;evcb_flags); <span class="comment">/* 非内部事件计数自增 increase */</span></span><br><span class="line">    evcb-&gt;evcb_flags |= EVLIST_ACTIVE; <span class="comment">/* event 事件增加激活标志位 */</span></span><br><span class="line"></span><br><span class="line">    base-&gt;event_count_active++; <span class="comment">/* 激活事件计数自增 */</span></span><br><span class="line">    MAX_EVENT_COUNT(base-&gt;event_count_active_max, base-&gt;event_count_active);</span><br><span class="line">    <span class="comment">/* #define ev_pri ev_evcallback.evcb_pri 事件优先级 */</span></span><br><span class="line">    EVUTIL_ASSERT(evcb-&gt;evcb_pri &lt; base-&gt;nactivequeues);</span><br><span class="line">    <span class="comment">/* 插入到对应优先级的激活队列尾部 */</span></span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;base-&gt;activequeues[evcb-&gt;evcb_pri], evcb, evcb_active_next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="激活-Signal-事件"><a href="#激活-Signal-事件" class="headerlink" title="激活 Signal 事件"></a>激活 Signal 事件</h4><p>对于 <code>Signal</code> 事件，<code>libevent</code> 将其统一转换为了 <code>IO</code> 事件，在 <code>IO</code> 事件中，有一个特殊的事件专门用来接收信号事件，该特殊事件的回调函数会调用 <code>evmap_signal_active_</code> 将发生的 <code>Signal</code> 事件添加到激活事件列表中。</p>
<blockquote>
<p>参见：<a href="/post/2020/89de67d/" title="源码阅读 libevent - 信号事件处理">源码阅读 libevent - 信号事件处理</a></p>
</blockquote>
<p><code>evmap_signal_active_</code> 代码如下，其最终也是调用了 <code>event_active_nolock_</code> 进行事件的激活。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evmap_signal_active_</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> sig, <span class="keyword">int</span> ncalls)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_signal_map</span> *<span class="title">map</span> = &amp;<span class="title">base</span>-&gt;<span class="title">sigmap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evmap_signal</span> *<span class="title">ctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sig &lt; <span class="number">0</span> || sig&gt;= <span class="built_in">map</span>-&gt;nentries) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 在 Signal 事件的数组中获取该 Signal 已添加的事件 */</span></span><br><span class="line">    GET_SIGNAL_SLOT(ctx, <span class="built_in">map</span>, sig, evmap_signal);</span><br><span class="line">    <span class="keyword">if</span> (!ctx) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 将该 Signal 已添加的事件全部加入到激活事件列表中 */</span></span><br><span class="line">    LIST_FOREACH(ev, &amp;ctx-&gt;events, ev_signal_next)</span><br><span class="line">        event_active_nolock_(ev, EV_SIGNAL, ncalls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="激活超时事件"><a href="#激活超时事件" class="headerlink" title="激活超时事件"></a>激活超时事件</h4><p>遍历检查小根堆中每个事件是否超时，如果超时，则将其加入到激活队列中，激活事件调用的函数也为 <code>event_active_nolock_</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeout_process</span><span class="params">(struct event_base *base)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Caller must hold lock. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (min_heap_empty_(&amp;base-&gt;timeheap)) <span class="keyword">return</span>;</span><br><span class="line">    gettime(base, &amp;now);</span><br><span class="line">    <span class="keyword">while</span> ((ev = min_heap_top_(&amp;base-&gt;timeheap))) &#123;</span><br><span class="line">        <span class="comment">/* 根据小根堆的特性，如果顶部的事件没有超时，其他事件就不用再遍历了 */</span></span><br><span class="line">        <span class="keyword">if</span> (evutil_timercmp(&amp;ev-&gt;ev_timeout, &amp;now, &gt;)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* delete this event from the I/O queues */</span></span><br><span class="line">        event_del_nolock_(ev, EVENT_DEL_NOBLOCK);</span><br><span class="line">        event_debug((<span class="string">&quot;timeout_process: event: %p, call %p&quot;</span>, ev, ev-&gt;ev_callback));</span><br><span class="line">        event_active_nolock_(ev, EV_TIMEOUT, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><code>IO</code> 事件的激活是在 <code>libevent</code> 调用多路 <code>IO</code> 复用函数后，然后将发生的事件添加入激活队列</li>
<li><code>Signal</code> 事件的激活在 <code>libevent</code> 处理 <code>IO</code> 事件的回调中</li>
<li>超时事件的激活在 <code>libevent</code> 调用完多路 <code>IO</code> 复用函数后，检查小根堆里的超时情况时</li>
</ul>
<h2 id="单次事件处理"><a href="#单次事件处理" class="headerlink" title="单次事件处理"></a>单次事件处理</h2><h3 id="如何处理已激活事件"><a href="#如何处理已激活事件" class="headerlink" title="如何处理已激活事件"></a>如何处理已激活事件</h3><h4 id="event-process-active"><a href="#event-process-active" class="headerlink" title="event_process_active"></a>event_process_active</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">event_process_active</span><span class="params">(struct event_base *base)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Caller must hold th_base_lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evcallback_list</span> *<span class="title">activeq</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">endtime</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxcb = base-&gt;max_dispatch_callbacks;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> limit_after_prio = base-&gt;limit_callbacks_after_prio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;max_dispatch_time.tv_sec &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        update_time_cache(base);</span><br><span class="line">        gettime(base, &amp;tv);</span><br><span class="line">        evutil_timeradd(&amp;base-&gt;max_dispatch_time, &amp;tv, &amp;tv);</span><br><span class="line">        endtime = &amp;tv;</span><br><span class="line">    &#125; <span class="keyword">else</span> endtime = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按优先级遍历激活队列中的事件 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; base-&gt;nactivequeues; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TAILQ_FIRST(&amp;base-&gt;activequeues[i]) != <span class="literal">NULL</span>) &#123; <span class="comment">/* 同一个优先级下可以有多个事件 */</span></span><br><span class="line">            base-&gt;event_running_priority = i; <span class="comment">/* 设置当前的优先级 */</span></span><br><span class="line">            activeq = &amp;base-&gt;activequeues[i]; <span class="comment">/* 获取优先级 i 下的所有 event 组成的链表 */</span></span><br><span class="line">            <span class="comment">/* 遍历 activeq 链表，调用其中每个 event 的回调函数 */</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; limit_after_prio) c = event_process_active_single_queue(base, activeq, INT_MAX, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">else</span> c = event_process_active_single_queue(base, activeq, maxcb, endtime);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>) <span class="keyword">goto</span> done; <span class="comment">/* c 是执行的非内部事件数目 */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c&gt; <span class="number">0</span>) <span class="comment">/* Processed a real event; do not consider lower-priority events */</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* If we get here, all of the events we processed were internal. Continue. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    base-&gt;event_running_priority = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="event-process-active-single-queue"><a href="#event-process-active-single-queue" class="headerlink" title="event_process_active_single_queue"></a>event_process_active_single_queue</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">event_process_active_single_queue</span><span class="params">(struct event_base *base,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evcallback_list *activeq, <span class="keyword">int</span> max_to_process, <span class="keyword">const</span> struct timeval *endtime)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_callback</span> *<span class="title">evcb</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    EVUTIL_ASSERT(activeq != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* activeq 为某一优先级的激活队列，该处遍历该优先级的激活队列中的所有事件 */</span></span><br><span class="line">    <span class="comment">/* 从遍历结束的结束条件和遍历下一个事件的方式就可知，每次遍历会在激活队列中删除当前事件 */</span></span><br><span class="line">    <span class="keyword">for</span> (evcb = TAILQ_FIRST(activeq); evcb; evcb = TAILQ_FIRST(activeq)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="comment">/* 在激活队列中删除当前事件 */</span></span><br><span class="line">        <span class="keyword">if</span> (evcb-&gt;evcb_flags &amp; EVLIST_INIT) &#123;</span><br><span class="line">            <span class="comment">/* 激活队列中仅插入了 event 结构体中的 event_callback 结构体，需要获取 event 所在地址 */</span></span><br><span class="line">            ev = event_callback_to_event(evcb);</span><br><span class="line">            <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_PERSIST || ev-&gt;ev_flags &amp; EVLIST_FINALIZING)</span><br><span class="line">                event_queue_remove_active(base, evcb); <span class="comment">/* 永久事件从激活队列中删除 */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                event_del_nolock_(ev, EVENT_DEL_NOBLOCK); <span class="comment">/* 非永久事件从所有队列中删除 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> event_queue_remove_active(base, evcb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(evcb-&gt;evcb_flags &amp; EVLIST_INTERNAL)) ++count; <span class="comment">/* 非内部事件回调次数计数 */</span></span><br><span class="line">        base-&gt;current_event = evcb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (evcb-&gt;evcb_closure) &#123; <span class="comment">/* 在调用回调函数是否进行其他行为 */</span></span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_EVENT_SIGNAL:</span><br><span class="line">            EVUTIL_ASSERT(ev != <span class="literal">NULL</span>);</span><br><span class="line">            event_signal_closure(base, ev);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_EVENT_PERSIST: <span class="comment">/* 对于永久事件，在调用回调函数之前会重新调用 event_add 来添加该事件到对应队列中 */</span></span><br><span class="line">            EVUTIL_ASSERT(ev != <span class="literal">NULL</span>);</span><br><span class="line">            event_persist_closure(base, ev);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_EVENT: <span class="comment">/* 对于一般事件，直接调用回调函数 */</span></span><br><span class="line">            <span class="keyword">void</span> (*evcb_callback)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *);</span><br><span class="line">            <span class="keyword">short</span> res;</span><br><span class="line">            EVUTIL_ASSERT(ev != <span class="literal">NULL</span>);</span><br><span class="line">            evcb_callback = *ev-&gt;ev_callback;</span><br><span class="line">            res = ev-&gt;ev_res;</span><br><span class="line">            EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">            evcb_callback(ev-&gt;ev_fd, res, ev-&gt;ev_arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_CB_SELF:</span><br><span class="line">            <span class="keyword">void</span> (*evcb_selfcb)(struct event_callback *, <span class="keyword">void</span> *) = evcb-&gt;evcb_cb_union.evcb_selfcb;</span><br><span class="line">            EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">            evcb_selfcb(evcb, evcb-&gt;evcb_arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_EVENT_FINALIZE:</span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_EVENT_FINALIZE_FREE:</span><br><span class="line">            <span class="keyword">void</span> (*evcb_evfinalize)(struct event *, <span class="keyword">void</span> *);</span><br><span class="line">            <span class="keyword">int</span> evcb_closure = evcb-&gt;evcb_closure;</span><br><span class="line">            EVUTIL_ASSERT(ev != <span class="literal">NULL</span>);</span><br><span class="line">            base-&gt;current_event = <span class="literal">NULL</span>;</span><br><span class="line">            evcb_evfinalize = ev-&gt;ev_evcallback.evcb_cb_union.evcb_evfinalize;</span><br><span class="line">            EVUTIL_ASSERT((evcb-&gt;evcb_flags &amp; EVLIST_FINALIZING));</span><br><span class="line">            EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">            evcb_evfinalize(ev, ev-&gt;ev_arg);</span><br><span class="line">            event_debug_note_teardown_(ev);</span><br><span class="line">            <span class="keyword">if</span> (evcb_closure == EV_CLOSURE_EVENT_FINALIZE_FREE) mm_free(ev);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_CLOSURE_CB_FINALIZE:</span><br><span class="line">            <span class="keyword">void</span> (*evcb_cbfinalize)(struct event_callback *, <span class="keyword">void</span> *) = evcb-&gt;evcb_cb_union.evcb_cbfinalize;</span><br><span class="line">            base-&gt;current_event = <span class="literal">NULL</span>;</span><br><span class="line">            EVUTIL_ASSERT((evcb-&gt;evcb_flags &amp; EVLIST_FINALIZING));</span><br><span class="line">            EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">            evcb_cbfinalize(evcb, evcb-&gt;evcb_arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            EVUTIL_ASSERT(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EVBASE_ACQUIRE_LOCK(base, th_base_lock);</span><br><span class="line">        base-&gt;current_event = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_break) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (count&gt;= max_to_process) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">if</span> (count &amp;&amp; endtime) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">            update_time_cache(base);</span><br><span class="line">            gettime(base, &amp;now);</span><br><span class="line">            <span class="keyword">if</span> (evutil_timercmp(&amp;now, endtime,&gt;=)) <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (base-&gt;event_continue) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何持久化事件"><a href="#如何持久化事件" class="headerlink" title="如何持久化事件"></a>如何持久化事件</h4><p><code>libevent</code> 持久化事件是在调用事件的回调函数之前，调用 <code>event_add_nolock_</code> 重新将事件添加到事件列表中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Closure function invoked when we&#x27;re activating a persistent event. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">event_persist_closure</span><span class="params">(struct event_base *base, struct event *ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*evcb_callback)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="comment">// Other fields of *ev that must be stored before executing</span></span><br><span class="line">    <span class="keyword">evutil_socket_t</span> evcb_fd;</span><br><span class="line">    <span class="keyword">short</span> evcb_res;</span><br><span class="line">    <span class="keyword">void</span> *evcb_arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reschedule the persistent event if we have a timeout. */</span></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_io_timeout.tv_sec || ev-&gt;ev_io_timeout.tv_usec) &#123;</span><br><span class="line">        <span class="comment">/* If there was a timeout, we want it to run at an interval of ev_io_timeout after the last time</span></span><br><span class="line"><span class="comment">        ** it was _scheduled_ for, not ev_io_timeout after _now_.  If it fired for another reason,</span></span><br><span class="line"><span class="comment">        ** though,the timeout ought to start ticking _now_. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">run_at</span>, <span class="title">relative_to</span>, <span class="title">delay</span>, <span class="title">now</span>;</span></span><br><span class="line">        <span class="keyword">ev_uint32_t</span> usec_mask = <span class="number">0</span>;</span><br><span class="line">        EVUTIL_ASSERT(is_same_common_timeout(&amp;ev-&gt;ev_timeout, &amp;ev-&gt;ev_io_timeout));</span><br><span class="line">        gettime(base, &amp;now);</span><br><span class="line">        <span class="keyword">if</span> (is_common_timeout(&amp;ev-&gt;ev_timeout, base)) &#123;</span><br><span class="line">            <span class="built_in">delay</span> = ev-&gt;ev_io_timeout;</span><br><span class="line">            usec_mask = <span class="built_in">delay</span>.tv_usec &amp; ~MICROSECONDS_MASK;</span><br><span class="line">            <span class="built_in">delay</span>.tv_usec &amp;= MICROSECONDS_MASK;</span><br><span class="line">            <span class="keyword">if</span> (ev-&gt;ev_res &amp; EV_TIMEOUT) &#123;</span><br><span class="line">                relative_to = ev-&gt;ev_timeout;</span><br><span class="line">                relative_to.tv_usec &amp;= MICROSECONDS_MASK;</span><br><span class="line">            &#125; <span class="keyword">else</span> relative_to = now;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">delay</span> = ev-&gt;ev_io_timeout;</span><br><span class="line">            <span class="keyword">if</span> (ev-&gt;ev_res &amp; EV_TIMEOUT) relative_to = ev-&gt;ev_timeout;</span><br><span class="line">            <span class="keyword">else</span> relative_to = now;</span><br><span class="line">        &#125;</span><br><span class="line">        evutil_timeradd(&amp;relative_to, &amp;<span class="built_in">delay</span>, &amp;run_at);</span><br><span class="line">        <span class="keyword">if</span> (evutil_timercmp(&amp;run_at, &amp;now, &lt;)) &#123;</span><br><span class="line">            <span class="comment">/* Looks like we missed at least one invocation due to a clock jump, not running the event</span></span><br><span class="line"><span class="comment">            ** loop for a while, really slow callbacks, or something. Reschedule relative to now.*/</span></span><br><span class="line">            evutil_timeradd(&amp;now, &amp;<span class="built_in">delay</span>, &amp;run_at);</span><br><span class="line">        &#125;</span><br><span class="line">        run_at.tv_usec |= usec_mask;</span><br><span class="line">        event_add_nolock_(ev, &amp;run_at, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save our callback before we release the lock</span></span><br><span class="line">    evcb_callback = ev-&gt;ev_callback;</span><br><span class="line">    evcb_fd = ev-&gt;ev_fd;</span><br><span class="line">    evcb_res = ev-&gt;ev_res;</span><br><span class="line">    evcb_arg = ev-&gt;ev_arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the lock</span></span><br><span class="line">    EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="comment">// Execute the callback</span></span><br><span class="line">    (evcb_callback)(evcb_fd, evcb_res, evcb_arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
<li>[2] <a href="https://blog.csdn.net/qq_28114615/article/details/96826553">libevent 源码学习（13）：事件主循环 event_base_loop_HerofH_的博客 - CSDN 博客</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体传输 - RTSP 协议认证过程</title>
    <url>/post/2020/dc673a79/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Rtsp 认证 主要分为两种：</p>
<p>基本认证 （Basic authentication）和 摘要认证 （Digest authentication）</p>
<p>基本认证是 HTTP 1.0 提出的认证方案，其消息传输不经过加密转换因此存在严重的安全隐患。</p>
<p>摘要认证是 HTTP 1.1 提出的基本认证的替代方案，其消息经过 MD5 哈希转换因此具有更高的安全性。</p>
<a id="more"></a>
<h2 id="基本认证"><a href="#基本认证" class="headerlink" title="基本认证"></a>基本认证</h2><ol>
<li><p>客户端发送 DESCRIBE 请求到服务端</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESCRIBE rtsp:&#x2F;&#x2F;192.168.199.242:554&#x2F;ch1&#x2F;main&#x2F;av_stream RTSP&#x2F;1.0</span><br><span class="line">CSeq: 3</span><br><span class="line">User-Agent: LibVLC&#x2F;3.0.8 (LIVE555 Streaming Media v2016.11.28)</span><br><span class="line">Accept: application&#x2F;sdp</span><br></pre></td></tr></table></figure>
</li>
<li><p>RTSP 服务端认为没有通过认证，发出 WWW-Authenticate 认证响应</p>
<pre><code> WWW-Authenticate 中应携带有 Basic 字样、realm 字段
</code></pre> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTSP&#x2F;1.0 401 Unauthorized</span><br><span class="line">CSeq: 3</span><br><span class="line">WWW-Authenticate: Basic realm&#x3D;&quot;IP Camera(D1846)&quot;</span><br><span class="line">Date:  Thu, Oct 15 2020 23:30:55 GMT</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端携带 Authorization 串再次发出 DESCRIBE 请求</p>
<pre><code> Authorization 串计算方法：
 Authorization = base64(username:password)

 * 用户名：admin * 密码：Abc12345
 Authorization = base64(admin:Abc12345)
               = YWRtaW46QWJjMTIzNDU=
</code></pre> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESCRIBE rtsp:&#x2F;&#x2F;192.168.199.242:554&#x2F;ch1&#x2F;main&#x2F;av_stream RTSP&#x2F;1.0</span><br><span class="line">CSeq: 4</span><br><span class="line">Authorization: Basic YWRtaW46QWJjMTIzNDU&#x3D;</span><br><span class="line">User-Agent: LibVLC&#x2F;3.0.8 (LIVE555 Streaming Media v2016.11.28)</span><br><span class="line">Accept: application&#x2F;sdp</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器对客户端反馈的 Authorization 进行校验，通过则返回 200 OK</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTSP&#x2F;1.0 200 OK</span><br><span class="line">CSeq: 4</span><br><span class="line">Content-Type: application&#x2F;sdp</span><br><span class="line">Content-Base: rtsp:&#x2F;&#x2F;192.168.199.242:554&#x2F;ch1&#x2F;main&#x2F;av_stream&#x2F;</span><br><span class="line">Content-Length: 594</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="摘要认证"><a href="#摘要认证" class="headerlink" title="摘要认证"></a>摘要认证</h2><ol>
<li><p>客户端发送 DESCRIBE 请求到服务端</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESCRIBE rtsp:&#x2F;&#x2F;192.168.199.242:554&#x2F;ch1&#x2F;main&#x2F;av_stream RTSP&#x2F;1.0</span><br><span class="line">CSeq: 3</span><br><span class="line">User-Agent: LibVLC&#x2F;3.0.8 (LIVE555 Streaming Media v2016.11.28)</span><br><span class="line">Accept: application&#x2F;sdp</span><br></pre></td></tr></table></figure>
</li>
<li><p>RTSP 服务端认为没有通过认证，发出 WWW-Authenticate 认证响应</p>
<pre><code> WWW-Authenticate 中应携带有 Digest 字样、realm 字段、nonce 字段
</code></pre> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTSP&#x2F;1.0 401 Unauthorized</span><br><span class="line">CSeq: 3</span><br><span class="line">WWW-Authenticate: Digest realm&#x3D;&quot;IP Camera(D1846)&quot;, nonce&#x3D;&quot;61f92652b25e740d73887108b419e8b6&quot;, stale&#x3D;&quot;FALSE&quot;</span><br><span class="line">Date:  Thu, Oct 15 2020 23:30:55 GMT</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端以 用户名、密码、nonce、RTSP 方法、请求的 URI 等信息为基础产生 response 信息进行反馈</p>
<pre><code> response 计算方法：
 RTSP 客户端应该使用 username + password 并计算 response 如下:
 如果 password 为 MD5 编码, 则
     response = md5(password:nonce:md5(public_method:url));
 如果 password 为 ANSI 字符串, 则
     response = md5(md5(username:realm:password):nonce:md5(public_method:url));

 * 用户名：admin * 密码：Abc12345
 response = md5(md5(admin:IP Camera(D1846):Abc12345):61f92652b25e740d73887108b419e8b6:md5(DESCRIBE:rtsp://192.168.199.242:554/ch1/main/av_stream));
          = md5(e03ca5323610c45d55574699008d1c34:61f92652b25e740d73887108b419e8b6:034c626594db40bb96121247d4492461)
          = 58ad47d8436ca5db7356e6a084abcbf9
</code></pre> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESCRIBE rtsp:&#x2F;&#x2F;192.168.199.242:554&#x2F;ch1&#x2F;main&#x2F;av_stream RTSP&#x2F;1.0</span><br><span class="line">CSeq: 4</span><br><span class="line">Authorization: Digest username&#x3D;&quot;admin&quot;, realm&#x3D;&quot;IP Camera(D1846)&quot;, nonce&#x3D;&quot;61f92652b25e740d73887108b419e8b6&quot;, uri&#x3D;&quot;rtsp:&#x2F;&#x2F;192.168.199.242:554&#x2F;ch1&#x2F;main&#x2F;av_stream&quot;, response&#x3D;&quot;58ad47d8436ca5db7356e6a084abcbf9&quot;</span><br><span class="line">User-Agent: LibVLC&#x2F;3.0.8 (LIVE555 Streaming Media v2016.11.28)</span><br><span class="line">Accept: application&#x2F;sdp</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器对客户端反馈的 response 进行校验，通过则返回 200 OK</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTSP&#x2F;1.0 200 OK</span><br><span class="line">CSeq: 4</span><br><span class="line">Content-Type: application&#x2F;sdp</span><br><span class="line">Content-Base: rtsp:&#x2F;&#x2F;192.168.199.242:554&#x2F;ch1&#x2F;main&#x2F;av_stream&#x2F;</span><br><span class="line">Content-Length: 594</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>RTSP</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 优先级管理</title>
    <url>/post/2020/27de5435/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>event_base</code> 允许用户对它里面的 <code>event</code> 设置优先级，这样可以使得有些更重要的 <code>event</code> 能够得到优先处理。</p>
<a id="more"></a>
<h2 id="实现优先级"><a href="#实现优先级" class="headerlink" title="实现优先级"></a>实现优先级</h2><p><code>libevent</code> 实现优先级功能的方法是：用一个激活队列数组来存放激活 <code>event</code>。即数组的元素是一个激活队列，所以有多个激活队列。并且规定不同的队列有不同的优先级。</p>
<p>可以通过 <code>event_base_priority_init</code> 函数设置 <code>event_base</code> 的优先级个数，该函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_priority_init</span><span class="params">(struct event_base *base, <span class="keyword">int</span> npriorities)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, r = <span class="number">-1</span>;</span><br><span class="line">    EVBASE_ACQUIRE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="keyword">if</span> (N_ACTIVE_CALLBACKS(base) || npriorities &lt; <span class="number">1</span> || npriorities &gt;= EVENT_MAX_PRIORITIES) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">if</span> (npriorities == base-&gt;nactivequeues) <span class="keyword">goto</span> ok;</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;nactivequeues) &#123;</span><br><span class="line">        mm_free(base-&gt;activequeues);</span><br><span class="line">        base-&gt;nactivequeues = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Allocate our priority queues */</span></span><br><span class="line">    base-&gt;activequeues = (struct evcallback_list *)mm_calloc(npriorities, <span class="keyword">sizeof</span>(struct evcallback_list));</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;activequeues == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        event_warn(<span class="string">&quot;%s: calloc&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;nactivequeues = npriorities;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; base-&gt;nactivequeues; ++i) TAILQ_INIT(&amp;base-&gt;activequeues[i]);</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="keyword">return</span> (r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从前面一个判断可知，因为 <code>event_base_dispatch</code> 函数会改动激活事件的个数，即会使得 <code>N_ACTIVE_CALLBACKS(base)</code> 为真。所以 <code>event_base_priority_init</code> 函数要在 <code>event_base_dispatch</code> 函数之前调用。此外要设置的优先级个数，要小于 <code>EVENT_MAX_PRIORITIES</code>。这个宏是在 <code>event.h</code> 文件中定义，在 <code>2.1.11</code> 版本中，该宏被定义成 <code>256</code>。在调用 <code>event_base_new</code> 得到的 <code>event_base</code> 只有一个优先级，也就是所有 <code>event</code> 都是同级的。</p>
<p>上面的代码调用 <code>mm_alloc</code> 分配了一个优先级数组。不同优先级的 <code>event</code> 会被放到数组的不同位置上 (下面可以看到这一点)。这样就可以区分不同 <code>event</code> 的优先级了。以后处理 <code>event</code> 时，就可以从高优先级到低优先级处理 <code>event</code>。</p>
<h2 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h2><p>上面是设置 <code>event_base</code> 的优先级个数。现在来看一下怎么设置 <code>event</code> 的优先级。可以通过 <code>event_priority_set</code> 函数设置，该函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set&#x27;s the priority of an event - if an event is already scheduled changing the priority is going to fail. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_priority_set</span><span class="params">(struct event *ev, <span class="keyword">int</span> pri)</span> </span>&#123;</span><br><span class="line">    event_debug_assert_is_setup_(ev);</span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_ACTIVE) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (pri &lt; <span class="number">0</span> || pri&gt;= ev-&gt;ev_base-&gt;nactivequeues) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    ev-&gt;ev_pri = pri;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码的第一个判断中，可以知道当 <code>event</code> 的状态是 <code>EVLIST_ACTIVE</code> 时，就不能对这个 <code>event</code> 进行优先级设置了。因此，如果要对 <code>event</code> 进行优先级设置，那么得在调用 <code>event_base_dispatch</code> 函数之前。因为一旦调用了 <code>event_base_dispatch</code>，那么 <code>event</code> 就随时可能变成 <code>EVLIST_ACTIVE</code> 状态。</p>
<h2 id="按优先级激活队列"><a href="#按优先级激活队列" class="headerlink" title="按优先级激活队列"></a>按优先级激活队列</h2><p>现在看一下一个 <code>event</code> 是怎么插入到 <code>event_base</code> 的优先级数组中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">event_queue_insert_active</span><span class="params">(struct event_base *base, struct event_callback *evcb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">/* #define ev_pri ev_evcallback.evcb_pri 事件优先级 */</span></span><br><span class="line">    EVUTIL_ASSERT(evcb-&gt;evcb_pri &lt; base-&gt;nactivequeues);</span><br><span class="line">    <span class="comment">/* 插入到对应优先级的激活队列尾部 */</span></span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;base-&gt;activequeues[evcb-&gt;evcb_pri], evcb, evcb_active_next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>event</code> 插入到 <code>event_base</code> 的优先级数组中后，会被按照优先级顺序被调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">event_process_active</span><span class="params">(struct event_base *base)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">/* 按优先级遍历激活队列中的事件 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; base-&gt;nactivequeues; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TAILQ_FIRST(&amp;base-&gt;activequeues[i]) != <span class="literal">NULL</span>) &#123; <span class="comment">/* 同一个优先级下可以有多个事件 */</span></span><br><span class="line">            base-&gt;event_running_priority = i; <span class="comment">/* 设置当前的优先级 */</span></span><br><span class="line">            activeq = &amp;base-&gt;activequeues[i]; <span class="comment">/* 获取优先级 i 下的所有 event 组成的链表 */</span></span><br><span class="line">            <span class="comment">/* 遍历 activeq 链表，调用其中每个 event 的回调函数 */</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; limit_after_prio) c = event_process_active_single_queue(base, activeq, INT_MAX, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">else</span> c = event_process_active_single_queue(base, activeq, maxcb, endtime);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>) <span class="keyword">goto</span> done; <span class="comment">/* c 是执行的非内部事件数目 */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c&gt; <span class="number">0</span>) <span class="comment">/* Processed a real event; do not consider lower-priority events */</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* If we get here, all of the events we processed were internal. Continue. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认优先级"><a href="#默认优先级" class="headerlink" title="默认优先级"></a>默认优先级</h2><p>默认优先级是在新建 <code>event</code> 结构体时设置的。不错，看下面的 <code>event_assign</code> 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_assign</span><span class="params">(struct event *ev, struct event_base *base, <span class="keyword">evutil_socket_t</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">short</span> events, <span class="keyword">void</span> (*callback)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* by default, we put new events into the middle priority */</span></span><br><span class="line">        ev-&gt;ev_pri = base-&gt;nactivequeues / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
<li>[2] <a href="https://blog.csdn.net/luotuo44/article/details/38512719">Libevent源码分析 event优先级设置 luotuo44的专栏 - CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体传输 - SDP 协议</title>
    <url>/post/2020/1fa21384/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SDP-协议介绍"><a href="#SDP-协议介绍" class="headerlink" title="SDP 协议介绍"></a>SDP 协议介绍</h2><p>SDP 全称是 Session Description Protocol，翻译过来就是描述会话的协议。主要用于两个会话实体之间的媒体协商。</p>
<p>什么叫会话呢，比如一次网络电话、一次电话会议、一次视频聊天，这些都可以称之为一次会话。</p>
<p>那为什么要去发这个描述文本呢，主要是为了解决参与会话的各成员之间能力不对等的问题，如果参加本次通话的成员都支持高质量的通话，但是我们没有去进行协议，为了兼容性，使用的都是普通质量的通话格式，这样就很浪费资源了。所以 SDP 的作用还是很有必要的。</p>
<a id="more"></a>
<h2 id="SDP-协议结构"><a href="#SDP-协议结构" class="headerlink" title="SDP 协议结构"></a>SDP 协议结构</h2><p>SDP 描述由许多文本行组成，文本行的格式为 <code>&lt;type&gt; = &lt;value&gt;</code>，<code>&lt;type&gt;</code> 是一个字母，<code>&lt;value&gt;</code> 是结构化的文本串，其格式依 <code>&lt;type&gt;</code> 而定。</p>
<pre><code>&lt;type&gt; = &lt;value&gt;
</code></pre><p>SDP 的文本信息包括：</p>
<ul>
<li>会话名称和意图</li>
<li>会话持续时间</li>
<li>构成会话的媒体</li>
<li>有关接收媒体的信息</li>
</ul>
<h3 id="会话名称和意图描述"><a href="#会话名称和意图描述" class="headerlink" title="会话名称和意图描述"></a>会话名称和意图描述</h3><pre><code>v =  （协议版本）
o =  （所有者 / 创建者和会话标识符）
s =  （会话名称）
i = *（会话信息）
u = *（URI 描述）
e = *（Email 地址）
p = *（电话号码）
c = *（连接信息 ― 如果包含在所有媒体中，则不需要该字段）
b = *（带宽信息）
</code></pre><h3 id="时间描述"><a href="#时间描述" class="headerlink" title="时间描述"></a>时间描述</h3><pre><code>t =  （会话活动时间）
r = *（0 或多次重复次数）
</code></pre><h3 id="媒体描述"><a href="#媒体描述" class="headerlink" title="媒体描述"></a>媒体描述</h3><pre><code>m =  （媒体名称和传输地址）
i = *（媒体标题）
c = *（连接信息 — 如果包含在会话层则该字段可选）
b = *（带宽信息）
k = *（加密密钥）
a = *（0 个或多个会话属性行）
</code></pre><h3 id="SDP-举例"><a href="#SDP-举例" class="headerlink" title="SDP 举例"></a>SDP 举例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sdp 版本号，一直为 0,rfc4566 规定</span></span><br><span class="line">o=- <span class="number">7017624586836067756</span> <span class="number">2</span> IN IP4 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment">// o=&lt;username&gt; &lt;sess-id&gt; &lt;sess-version&gt; &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt;</span></span><br><span class="line"><span class="comment">//username 如何没有使用 - 代替，7017624586836067756 是整个会话的编号，2 代表会话版本，如果在会话</span></span><br><span class="line"><span class="comment">// 过程中有改变编码之类的操作，重新生成 sdp 时, sess-id 不变，sess-version 加 1</span></span><br><span class="line">s=-</span><br><span class="line"><span class="comment">// 会话名，没有的话使用 - 代替</span></span><br><span class="line">t=<span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="comment">// 两个值分别是会话的起始时间和结束时间，这里都是 0 代表没有限制</span></span><br><span class="line">a=group:BUNDLE audio video data</span><br><span class="line"><span class="comment">// 需要共用一个传输通道传输的媒体，如果没有这一行，音视频，数据就会分别单独用一个 udp 端口来发送</span></span><br><span class="line">a=msid-semantic: WMS h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C</span><br><span class="line"><span class="comment">// WMS 是 WebRTC Media Stream 简称，这一行定义了本客户端支持同时传输多个流，一个流可以包括多个 track,</span></span><br><span class="line"><span class="comment">// 一般定义了这个，后面 a=ssrc 这一行就会有 msid,mslabel 等属性</span></span><br><span class="line">m=audio <span class="number">9</span> UDP/TLS/RTP/SAVPF <span class="number">111</span> <span class="number">103</span> <span class="number">104</span> <span class="number">9</span> <span class="number">0</span> <span class="number">8</span> <span class="number">106</span> <span class="number">105</span> <span class="number">13</span> <span class="number">126</span></span><br><span class="line"><span class="comment">// m=audio 说明本会话包含音频，9 代表音频使用端口 9 来传输，但是在 webrtc 中一现在一般不使用，如果设置为 0，代表不</span></span><br><span class="line"><span class="comment">// 传输音频, UDP/TLS/RTP/SAVPF 是表示用户来传输音频支持的协议，udp，tls,rtp 代表使用 udp 来传输 rtp 包，并使用 tls 加密</span></span><br><span class="line"><span class="comment">// SAVPF 代表使用 srtcp 的反馈机制来控制通信过程, 后台 111 103 104 9 0 8 106 105 13 126 表示本会话音频支持的编码，后台几行会有详细补充说明</span></span><br><span class="line">c=IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment">// 这一行表示你要用来接收或者发送音频使用的 IP 地址，webrtc 使用 ice 传输，不使用这个地址</span></span><br><span class="line">a=rtcp:<span class="number">9</span> IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment">// 用来传输 rtcp 地地址和端口，webrtc 中不使用</span></span><br><span class="line">a=ice-ufrag:khLS</span><br><span class="line">a=ice-pwd:cxLzteJaJBou3DspNaPsJhlQ</span><br><span class="line"><span class="comment">// 以上两行是 ice 协商过程中的安全验证信息</span></span><br><span class="line">a=fingerprint:sha<span class="number">-256</span> FA:<span class="number">14</span>:<span class="number">42</span>:<span class="number">3B</span>:C7:<span class="number">97</span>:<span class="number">1B</span>:E8:AE:<span class="number">0</span>C2:<span class="number">71</span>:<span class="number">03</span>:<span class="number">05</span>:<span class="number">05</span>:<span class="number">16</span>:<span class="number">8F</span>:B9:C7:<span class="number">98</span>:E9:<span class="number">60</span>:<span class="number">43</span>:<span class="number">4B</span>:<span class="number">5B</span>:<span class="number">2</span>C:<span class="number">28</span>:EE:<span class="number">5</span>C:<span class="number">8F</span>3:<span class="number">17</span></span><br><span class="line"><span class="comment">// 以上这行是 dtls 协商过程中需要的认证信息</span></span><br><span class="line">a=<span class="built_in">setup</span>:actpass</span><br><span class="line"><span class="comment">// 以上这行代表本客户端在 dtls 协商过程中，可以做客户端也可以做服务端，参考 rfc4145 rfc4572</span></span><br><span class="line">a=mid:audio</span><br><span class="line"><span class="comment">// 在前面 BUNDLE 这一行中用到的媒体标识</span></span><br><span class="line">a=extmap:<span class="number">1</span> urn:ietf:params:rtp-hdrext:ssrc-audio-level</span><br><span class="line"><span class="comment">// 上一行指出我要在 rtp 头部中加入音量信息，参考 rfc6464</span></span><br><span class="line">a=sendrecv</span><br><span class="line"><span class="comment">// 上一行指出我是双向通信，另外几种类型是 recvonly,sendonly,inactive</span></span><br><span class="line">a=rtcp-mux</span><br><span class="line"><span class="comment">// 上一行指出 rtp,rtcp 包使用同一个端口来传输</span></span><br><span class="line"><span class="comment">// 下面几行都是对 m=audio 这一行的媒体编码补充说明，指出了编码采用的编号，采样率，声道等</span></span><br><span class="line">a=rtpmap:<span class="number">111</span> opus/<span class="number">48000</span>/<span class="number">2</span></span><br><span class="line">a=rtcp-fb:<span class="number">111</span> transport-cc</span><br><span class="line"><span class="comment">// 以上这行说明 opus 编码支持使用 rtcp 来控制拥塞，参考 https://tools.ietf.org/html/draft-holmer-rmcat-transport-wide-cc-extensions-01</span></span><br><span class="line">a=fmtp:<span class="number">111</span> minptime=<span class="number">10</span>;useinbandfec=<span class="number">1</span></span><br><span class="line"><span class="comment">// 对 opus 编码可选的补充说明, minptime 代表最小打包时长是 10ms，useinbandfec=1 代表使用 opus 编码内置 fec 特性</span></span><br><span class="line">a=rtpmap:<span class="number">103</span> ISAC/<span class="number">16000</span></span><br><span class="line">a=rtpmap:<span class="number">104</span> ISAC/<span class="number">32000</span></span><br><span class="line">a=rtpmap:<span class="number">9</span> G722/<span class="number">8000</span></span><br><span class="line">a=rtpmap:<span class="number">0</span> PCMU/<span class="number">8000</span></span><br><span class="line">a=rtpmap:<span class="number">8</span> PCMA/<span class="number">8000</span></span><br><span class="line">a=rtpmap:<span class="number">106</span> CN/<span class="number">32000</span></span><br><span class="line">a=rtpmap:<span class="number">105</span> CN/<span class="number">16000</span></span><br><span class="line">a=rtpmap:<span class="number">13</span> CN/<span class="number">8000</span></span><br><span class="line">a=rtpmap:<span class="number">126</span> telephone-event/<span class="number">8000</span></span><br><span class="line">a=ssrc:<span class="number">18509423</span> cname:sTjtznXLCNH7nbRw</span><br><span class="line"><span class="comment">// cname 用来标识一个数据源，ssrc 当发生冲突时可能会发生变化，但是 cname 不会发生变化，也会出现在 rtcp 包中 SDEC 中，</span></span><br><span class="line"><span class="comment">// 用于音视频同步</span></span><br><span class="line">a=ssrc:<span class="number">18509423</span> msid:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C <span class="number">15598</span>a91-caf9<span class="number">-4f</span>ff-a28f<span class="number">-3082310b</span>2b7a</span><br><span class="line"><span class="comment">// 以上这一行定义了 ssrc 和 WebRTC 中的 MediaStream,AudioTrack 之间的关系，msid 后面第一个属性是 stream-d, 第二个是 track-id</span></span><br><span class="line">a=ssrc:<span class="number">18509423</span> mslabel:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C</span><br><span class="line">a=ssrc:<span class="number">18509423</span> label:<span class="number">15598</span>a91-caf9<span class="number">-4f</span>ff-a28f<span class="number">-3082310b</span>2b7a</span><br><span class="line">m=video <span class="number">9</span> UDP/TLS/RTP/SAVPF <span class="number">100</span> <span class="number">101</span> <span class="number">107</span> <span class="number">116</span> <span class="number">117</span> <span class="number">96</span> <span class="number">97</span> <span class="number">99</span> <span class="number">98</span></span><br><span class="line"><span class="comment">// 参考上面 m=audio, 含义类似</span></span><br><span class="line">c=IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">a=rtcp:<span class="number">9</span> IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">a=ice-ufrag:khLS</span><br><span class="line">a=ice-pwd:cxLzteJaJBou3DspNaPsJhlQ</span><br><span class="line">a=fingerprint:sha<span class="number">-256</span> FA:<span class="number">14</span>:<span class="number">42</span>:<span class="number">3B</span>:C7:<span class="number">97</span>:<span class="number">1B</span>:E8:AE:<span class="number">0</span>C2:<span class="number">71</span>:<span class="number">03</span>:<span class="number">05</span>:<span class="number">05</span>:<span class="number">16</span>:<span class="number">8F</span>:B9:C7:<span class="number">98</span>:E9:<span class="number">60</span>:<span class="number">43</span>:<span class="number">4B</span>:<span class="number">5B</span>:<span class="number">2</span>C:<span class="number">28</span>:EE:<span class="number">5</span>C:<span class="number">8F</span>3:<span class="number">17</span></span><br><span class="line">a=<span class="built_in">setup</span>:actpass</span><br><span class="line">a=mid:video</span><br><span class="line">a=extmap:<span class="number">2</span> urn:ietf:params:rtp-hdrext:toffset</span><br><span class="line">a=extmap:<span class="number">3</span> http:<span class="comment">//www.webrtc.org/experiments/rtp-hdrext/abs-send-time</span></span><br><span class="line">a=extmap:<span class="number">4</span> urn:<span class="number">3</span>gpp:video-orientation</span><br><span class="line">a=extmap:<span class="number">5</span> http:<span class="comment">//www.ietf.org/id/draft-hol ... de-cc-extensions-01</span></span><br><span class="line">a=extmap:<span class="number">6</span> http:<span class="comment">//www.webrtc.org/experiments/rtp-hdrext/playout-delay</span></span><br><span class="line">a=sendrecv</span><br><span class="line">a=rtcp-mux</span><br><span class="line">a=rtcp-rsize</span><br><span class="line">a=rtpmap:<span class="number">100</span> VP8/<span class="number">90000</span></span><br><span class="line">a=rtcp-fb:<span class="number">100</span> ccm fir</span><br><span class="line"><span class="comment">// ccm 是 codec control using RTCP feedback message 简称，意思是支持使用 rtcp 反馈机制来实现编码控制，fir 是 Full Intra Request</span></span><br><span class="line"><span class="comment">// 简称，意思是接收方通知发送方发送幅完全帧过来</span></span><br><span class="line">a=rtcp-fb:<span class="number">100</span> nack</span><br><span class="line"><span class="comment">// 支持丢包重传，参考 rfc4585</span></span><br><span class="line">a=rtcp-fb:<span class="number">100</span> nack pli</span><br><span class="line"><span class="comment">// 支持关键帧丢包重传, 参考 rfc4585</span></span><br><span class="line">a=rtcp-fb:<span class="number">100</span> goog-remb</span><br><span class="line"><span class="comment">// 支持使用 rtcp 包来控制发送方的码流</span></span><br><span class="line">a=rtcp-fb:<span class="number">100</span> transport-cc</span><br><span class="line"><span class="comment">// 参考上面 opus</span></span><br><span class="line">a=rtpmap:<span class="number">101</span> VP9/<span class="number">90000</span></span><br><span class="line">a=rtcp-fb:<span class="number">101</span> ccm fir</span><br><span class="line">a=rtcp-fb:<span class="number">101</span> nack</span><br><span class="line">a=rtcp-fb:<span class="number">101</span> nack pli</span><br><span class="line">a=rtcp-fb:<span class="number">101</span> goog-remb</span><br><span class="line">a=rtcp-fb:<span class="number">101</span> transport-cc</span><br><span class="line">a=rtpmap:<span class="number">107</span> H264/<span class="number">90000</span></span><br><span class="line">a=rtcp-fb:<span class="number">107</span> ccm fir</span><br><span class="line">a=rtcp-fb:<span class="number">107</span> nack</span><br><span class="line">a=rtcp-fb:<span class="number">107</span> nack pli</span><br><span class="line">a=rtcp-fb:<span class="number">107</span> goog-remb</span><br><span class="line">a=rtcp-fb:<span class="number">107</span> transport-cc</span><br><span class="line">a=fmtp:<span class="number">107</span> level-asymmetry-allowed=<span class="number">1</span>;packetization-mode=<span class="number">1</span>;profile-level-id=<span class="number">42e01</span>f</span><br><span class="line"><span class="comment">// h264 编码可选的附加说明</span></span><br><span class="line">a=rtpmap:<span class="number">116</span> red/<span class="number">90000</span></span><br><span class="line"><span class="comment">// fec 冗余编码，一般如果 sdp 中有这一行的话，rtp 头部负载类型就是 116，否则就是各编码原生负责类型</span></span><br><span class="line">a=rtpmap:<span class="number">117</span> ulpfec/<span class="number">90000</span></span><br><span class="line"><span class="comment">// 支持 ULP FEC，参考 rfc5109</span></span><br><span class="line">a=rtpmap:<span class="number">96</span> rtx/<span class="number">90000</span></span><br><span class="line">a=fmtp:<span class="number">96</span> apt=<span class="number">100</span></span><br><span class="line"><span class="comment">// 以上两行是 VP8 编码的重传包 rtp 类型</span></span><br><span class="line">a=rtpmap:<span class="number">97</span> rtx/<span class="number">90000</span></span><br><span class="line">a=fmtp:<span class="number">97</span> apt=<span class="number">101</span></span><br><span class="line">a=rtpmap:<span class="number">99</span> rtx/<span class="number">90000</span></span><br><span class="line">a=fmtp:<span class="number">99</span> apt=<span class="number">107</span></span><br><span class="line">a=rtpmap:<span class="number">98</span> rtx/<span class="number">90000</span></span><br><span class="line">a=fmtp:<span class="number">98</span> apt=<span class="number">116</span></span><br><span class="line">a=ssrc-group:FID <span class="number">3463951252</span> <span class="number">1461041037</span></span><br><span class="line"><span class="comment">// 在 webrtc 中，重传包和正常包 ssrc 是不同的，上一行中前一个是正常 rtp 包的 ssrc, 后一个是重传包的 ssrc</span></span><br><span class="line">a=ssrc:<span class="number">3463951252</span> cname:sTjtznXLCNH7nbRw</span><br><span class="line">a=ssrc:<span class="number">3463951252</span> msid:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C ead4b4e9-b650<span class="number">-4</span>ed5<span class="number">-86f</span>8<span class="number">-6f</span>5f5806346d</span><br><span class="line">a=ssrc:<span class="number">3463951252</span> mslabel:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C</span><br><span class="line">a=ssrc:<span class="number">3463951252</span> label:ead4b4e9-b650<span class="number">-4</span>ed5<span class="number">-86f</span>8<span class="number">-6f</span>5f5806346d</span><br><span class="line">a=ssrc:<span class="number">1461041037</span> cname:sTjtznXLCNH7nbRw</span><br><span class="line">a=ssrc:<span class="number">1461041037</span> msid:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C ead4b4e9-b650<span class="number">-4</span>ed5<span class="number">-86f</span>8<span class="number">-6f</span>5f5806346d</span><br><span class="line">a=ssrc:<span class="number">1461041037</span> mslabel:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C</span><br><span class="line">a=ssrc:<span class="number">1461041037</span> label:ead4b4e9-b650<span class="number">-4</span>ed5<span class="number">-86f</span>8<span class="number">-6f</span>5f5806346d</span><br><span class="line">m=application <span class="number">9</span> DTLS/SCTP <span class="number">5000</span></span><br><span class="line">c=IN IP4 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">a=ice-ufrag:khLS</span><br><span class="line">a=ice-pwd:cxLzteJaJBou3DspNaPsJhlQ</span><br><span class="line">a=fingerprint:sha<span class="number">-256</span> FA:<span class="number">14</span>:<span class="number">42</span>:<span class="number">3B</span>:C7:<span class="number">97</span>:<span class="number">1B</span>:E8:AE:<span class="number">0</span>C2:<span class="number">71</span>:<span class="number">03</span>:<span class="number">05</span>:<span class="number">05</span>:<span class="number">16</span>:<span class="number">8F</span>:B9:C7:<span class="number">98</span>:E9:<span class="number">60</span>:<span class="number">43</span>:<span class="number">4B</span>:<span class="number">5B</span>:<span class="number">2</span>C:<span class="number">28</span>:EE:<span class="number">5</span>C:<span class="number">8F</span>3:<span class="number">17</span></span><br><span class="line">a=<span class="built_in">setup</span>:actpass</span><br><span class="line">a=mid:data</span><br><span class="line">a=sctpmap:<span class="number">5000</span> webrtc-datachannel <span class="number">1024</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://www.rfc-editor.org/rfc/rfc4566.txt">RFC 4566: Session Description Protocol</a></li>
<li>[2] <a href="https://www.jianshu.com/p/94b118b8fd97">SDP 协议 - 简书</a></li>
</ul>
]]></content>
      <categories>
        <category>流媒体传输</category>
      </categories>
      <tags>
        <tag>SDP</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 信号事件处理</title>
    <url>/post/2020/89de67d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不管使用的是什么多路 <code>IO</code> 复用模型，这些复用模型本身都是只支持读写 <code>IO</code> 事件的，而 <code>libevent</code> 支持的信号事件处理，就必须单独开发一套信号事件的处理逻辑，或者用某种办法将信号事件转换为 <code>IO</code> 事件进行处理。而 <code>libevent</code> 选择了后者，即统一事件源的方式。</p>
<a id="more"></a>
<h2 id="统一事件源的原理"><a href="#统一事件源的原理" class="headerlink" title="统一事件源的原理"></a>统一事件源的原理</h2><p>统一事件源的工作原理如下：假如用户要监听 <code>SIGINT</code> 信号，那么在实现的内部就对 <code>SIGINT</code> 这个信号设置捕抓函数。此外，在实现的内部还要建立一条管道 (<code>pipe</code>)，并把这个管道加入到多路 <code>IO</code> 复用函数中。当 <code>SIGINT</code> 这个信号发生后，捕抓函数将会被调用。而这个捕抓函数的工作就是往管道写入一个字符 (这个字符往往等于所捕抓到信号的信号值)。此时，这个管道就变成是可读的了，多路 <code>IO</code> 复用函数能检测到这个管道变成可读的了。换言之，多路 <code>IO</code> 复用函数检测到 <code>SIGINT</code> 信号的发生，也就完成了对信号的监听工作。这个过程如下图所示：</p>
<pre class="mermaid">graph LR
S1((信号发生)) -- 触发 --> S2[信号捕捉函数]
S2 -- 写入 1 字节 --> P1[>>> 管道 >>>]
P1 -- 管道可读 --> IO{多路 IO 复用函数}
IO -- 监听到可读 --> F[用户处理函数]</pre>

<h2 id="libevent-实现原理"><a href="#libevent-实现原理" class="headerlink" title="libevent 实现原理"></a>libevent 实现原理</h2><p>按照上述统一事件源的原理介绍，<code>libevent</code> 内部实现的工作有：</p>
<ol>
<li>创建一个管道 <code>pipe</code></li>
<li>为这个 <code>pipe</code> 的一个读端创建一个 <code>event</code>，并将之加入到多路 <code>IO</code> 复用函数的监听之中</li>
<li>设置信号捕捉函数</li>
<li>有信号发生，就往 <code>pipe</code> 写入一个字节</li>
</ol>
<p>统一事件源能够工作的一个原因是：多路 <code>IO</code> 复用函数都是可中断的。即处理完信号后，会从多路 <code>IO</code> 复用函数中退出，并将 <code>errno</code> 赋值为 <code>EINTR</code>。有些 <code>OS</code> 的某些系统调用，比如 <code>Linux</code> 的 <code>read</code>，即使被信号终端了，还是会自启动的。即不会从 <code>read</code> 函数中退出来。</p>
<p>下面开始介绍 <code>libevent</code> 统一事件源的实现代码。</p>
<h2 id="关键结构体"><a href="#关键结构体" class="headerlink" title="关键结构体"></a>关键结构体</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* file: event-internal.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsigsel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evsig_info</span> <span class="title">sig</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_signal_map</span> <span class="title">sigmap</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* file: evsignal-internal.h */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">ev_sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evsig_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">ev_signal</span>;</span> <span class="comment">/* 用于监听 socketpair 读端的 event. ev_signal_pair[1] 为读端 */</span></span><br><span class="line">    <span class="keyword">evutil_socket_t</span> ev_signal_pair[<span class="number">2</span>]; <span class="comment">/* Socketpair used to send notifications from the signal handler */</span></span><br><span class="line">    <span class="keyword">int</span> ev_signal_added; <span class="comment">/* True 标志已经将 ev_signal 这个 event 加入到 event_base 中了 */</span></span><br><span class="line">    <span class="keyword">int</span> ev_n_signals_added; <span class="comment">/* 用户一共要监听多少个信号 */</span></span><br><span class="line">    <span class="comment">/* 数组。用户可能已经设置过某个信号的信号捕抓函数。但 libevent 还是要为这个信号设置另外一个信号捕抓函数，</span></span><br><span class="line"><span class="comment">    ** 此时，就要保存用户之前设置的信号捕抓函数。当用户不要监听这个信号时，就能够恢复用户之前的捕抓函数。</span></span><br><span class="line"><span class="comment">    ** 因为是有多个信号，所以得用一个数组保存。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> EVENT__HAVE_SIGACTION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> **<span class="title">sh_old</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">ev_sighandler_t</span> **sh_old;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> sh_old_max; <span class="comment">/* 数组的长度. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evsig_init_</span><span class="params">(struct event_base *base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evutil_make_internal_pipe_(base-&gt;sig.ev_signal_pair) == <span class="number">-1</span>) &#123;</span><br><span class="line">        event_sock_err(<span class="number">1</span>, <span class="number">-1</span>, <span class="string">&quot;%s: socketpair&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;sig.sh_old) mm_free(base-&gt;sig.sh_old);</span><br><span class="line">    base-&gt;sig.sh_old = <span class="literal">NULL</span>;</span><br><span class="line">    base-&gt;sig.sh_old_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    event_assign(&amp;base-&gt;sig.ev_signal, base, base-&gt;sig.ev_signal_pair[<span class="number">0</span>], EV_READ | EV_PERSIST, evsig_cb, base);</span><br><span class="line">    base-&gt;sig.ev_signal.ev_flags |= EVLIST_INTERNAL;</span><br><span class="line">    event_priority_set(&amp;base-&gt;sig.ev_signal, <span class="number">0</span>);</span><br><span class="line">    base-&gt;evsigsel = &amp;evsigops;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h3><p><code>libevent</code> 中该管道的实现方式有三种方式，会根据编译期系统支持的函数确定，三种方式依次为：</p>
<ol>
<li><code>pipe2</code>：若支持，则 <code>libevent</code> 定义宏 <code>EVENT__HAVE_PIPE2</code></li>
<li><code>pipe</code>：若支持 则 <code>libevent</code> 定义宏 <code>EVENT__HAVE_PIPE</code></li>
<li><code>socketpair</code>：以上两种方式不支持时使用。</li>
</ol>
<p>三种方式均会创建一个文件描述符数组，数组中有两个元素：<code>fd[0]</code> 和 <code>fd[1]</code>，程序从 <code>fd[1]</code> 端写入数据，从 <code>fd[0]</code> 端读取数据。</p>
<p>三种方式的实现均在以下代码中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_internal_pipe_</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd[<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(EVENT__HAVE_PIPE2)</span></span><br><span class="line">    <span class="keyword">if</span> (pipe2(fd, O_NONBLOCK|O_CLOEXEC) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(EVENT__HAVE_PIPE)</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(fd) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (evutil_fast_socket_nonblocking(fd[<span class="number">0</span>]) &lt; <span class="number">0</span> || evutil_fast_socket_nonblocking(fd[<span class="number">1</span>]) &lt; <span class="number">0</span> ||</span><br><span class="line">            evutil_fast_socket_closeonexec(fd[<span class="number">0</span>]) &lt; <span class="number">0</span> || evutil_fast_socket_closeonexec(fd[<span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">            fd[<span class="number">0</span>] = fd[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> event_warn(<span class="string">&quot;%s: pipe&quot;</span>, __func__);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL_SOCKETPAIR_AF AF_UNIX</span></span><br><span class="line">    <span class="keyword">if</span> (evutil_socketpair(LOCAL_SOCKETPAIR_AF, SOCK_STREAM, <span class="number">0</span>, fd) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (evutil_fast_socket_nonblocking(fd[<span class="number">0</span>]) &lt; <span class="number">0</span> || evutil_fast_socket_nonblocking(fd[<span class="number">1</span>]) &lt; <span class="number">0</span> ||</span><br><span class="line">            evutil_fast_socket_closeonexec(fd[<span class="number">0</span>]) &lt; <span class="number">0</span> || evutil_fast_socket_closeonexec(fd[<span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            evutil_closesocket(fd[<span class="number">0</span>]);</span><br><span class="line">            evutil_closesocket(fd[<span class="number">1</span>]);</span><br><span class="line">            fd[<span class="number">0</span>] = fd[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd[<span class="number">0</span>] = fd[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>pipe2</code> 方式创建的管道代码最为简单，而通过 <code>pipe</code> 和 <code>socketpair</code> 创建的管道涉及到 <code>4</code> 个 <code>libevent</code> 封装的函数 <code>evutil_socketpair</code>/<code>evutil_fast_socket_nonblocking</code>/<code>evutil_fast_socket_closeonexec</code>/<code>evutil_closesocket</code> ，我们依次进行分析。</p>
<h4 id="evutil-socketpair"><a href="#evutil-socketpair" class="headerlink" title="evutil_socketpair"></a>evutil_socketpair</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_socketpair</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">evutil_socket_t</span> fd[<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evutil_ersatz_socketpair_(family, type, protocol, fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_ersatz_socketpair_</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">evutil_socket_t</span> fd[<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR(e) e</span></span><br><span class="line">    <span class="keyword">evutil_socket_t</span> listener = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">evutil_socket_t</span> connector = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">evutil_socket_t</span> acceptor = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">listen_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">connect_addr</span>;</span></span><br><span class="line">    <span class="keyword">ev_socklen_t</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">int</span> saved_errno = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> family_test;</span><br><span class="line"></span><br><span class="line">    family_test = family != AF_INET;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AF_UNIX</span></span><br><span class="line">    family_test = family_test &amp;&amp; (family != AF_UNIX);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (protocol || family_test) &#123;</span><br><span class="line">        EVUTIL_SET_SOCKET_ERROR(ERR(EAFNOSUPPORT));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fd) &#123;</span><br><span class="line">        EVUTIL_SET_SOCKET_ERROR(ERR(EINVAL));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listener = socket(AF_INET, type, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listener &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;listen_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(listen_addr));</span><br><span class="line">    listen_addr.sin_family = AF_INET;</span><br><span class="line">    listen_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);</span><br><span class="line">    listen_addr.sin_port = <span class="number">0</span>;   <span class="comment">/* kernel chooses port.  */</span></span><br><span class="line">    <span class="keyword">if</span> (bind(listener, (struct sockaddr *) &amp;listen_addr, <span class="keyword">sizeof</span> (listen_addr)) == <span class="number">-1</span>) <span class="keyword">goto</span> tidy_up_and_fail;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listener, <span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> tidy_up_and_fail;</span><br><span class="line"></span><br><span class="line">    connector = socket(AF_INET, type, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (connector &lt; <span class="number">0</span>) <span class="keyword">goto</span> tidy_up_and_fail;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;connect_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(connect_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We want to find out the port number to connect to.  */</span></span><br><span class="line">    <span class="built_in">size</span> = <span class="keyword">sizeof</span>(connect_addr);</span><br><span class="line">    <span class="keyword">if</span> (getsockname(listener, (struct sockaddr *) &amp;connect_addr, &amp;<span class="built_in">size</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> tidy_up_and_fail;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> != <span class="keyword">sizeof</span> (connect_addr)) <span class="keyword">goto</span> abort_tidy_up_and_fail;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(connector, (struct sockaddr *) &amp;connect_addr, <span class="keyword">sizeof</span>(connect_addr)) == <span class="number">-1</span>) <span class="keyword">goto</span> tidy_up_and_fail;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">size</span> = <span class="keyword">sizeof</span>(listen_addr);</span><br><span class="line">    acceptor = accept(listener, (struct sockaddr *) &amp;listen_addr, &amp;<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (acceptor &lt; <span class="number">0</span>) <span class="keyword">goto</span> tidy_up_and_fail;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> != <span class="keyword">sizeof</span>(listen_addr)) <span class="keyword">goto</span> abort_tidy_up_and_fail;</span><br><span class="line">    <span class="comment">/* Now check we are talking to ourself by matching port and host on the</span></span><br><span class="line"><span class="comment">       two sockets.  */</span></span><br><span class="line">    <span class="keyword">if</span> (getsockname(connector, (struct sockaddr *) &amp;connect_addr, &amp;<span class="built_in">size</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> tidy_up_and_fail;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> != <span class="keyword">sizeof</span> (connect_addr) || listen_addr.sin_family != connect_addr.sin_family</span><br><span class="line">        || listen_addr.sin_addr.s_addr != connect_addr.sin_addr.s_addr || listen_addr.sin_port != connect_addr.sin_port)</span><br><span class="line">        <span class="keyword">goto</span> abort_tidy_up_and_fail;</span><br><span class="line">    evutil_closesocket(listener);</span><br><span class="line">    fd[<span class="number">0</span>] = connector;</span><br><span class="line">    fd[<span class="number">1</span>] = acceptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> abort_tidy_up_and_fail:</span><br><span class="line">    saved_errno = ERR(ECONNABORTED);</span><br><span class="line"> tidy_up_and_fail:</span><br><span class="line">    <span class="keyword">if</span> (saved_errno &lt; <span class="number">0</span>) saved_errno = EVUTIL_SOCKET_ERROR();</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="number">-1</span>) evutil_closesocket(listener);</span><br><span class="line">    <span class="keyword">if</span> (connector != <span class="number">-1</span>) evutil_closesocket(connector);</span><br><span class="line">    <span class="keyword">if</span> (acceptor != <span class="number">-1</span>) evutil_closesocket(acceptor);</span><br><span class="line"></span><br><span class="line">    EVUTIL_SET_SOCKET_ERROR(saved_errno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ERR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，创建 <code>socketpair</code> 需要进行以下操作：</p>
<p>先创建一个 <code>listener</code>，监听本地环回端口，相当于服务端。创建一个 <code>connector</code> 作为客户端向 <code>listener</code> 发起连接，<code>listener</code> 通过 <code>accept</code> 函数与 <code>connecotr</code> 建立连接，新连接套接字为 <code>acceptor</code>，此时 <code>acceptor</code> 和 <code>connector</code> 就可以互发消息，成为一对全双工 <code>socketpair</code>，流程图如下所示</p>
<pre class="mermaid">sequenceDiagram
participant connector
participant listener
Note over listener : socket, bind, listen
Note over connector : socket, getsockname
connector ->> listener : connect
Note over listener : accept
activate listener
listener -->> connector : send
Note over connector : select, poll, epoll
deactivate listener</pre>

<h4 id="其他三个函数"><a href="#其他三个函数" class="headerlink" title="其他三个函数"></a>其他三个函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evutil_fast_socket_nonblocking</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, O_NONBLOCK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        event_warn(<span class="string">&quot;fcntl(%d, F_SETFL)&quot;</span>, fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evutil_fast_socket_closeonexec</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFD, FD_CLOEXEC) == <span class="number">-1</span>) &#123;</span><br><span class="line">        event_warn(<span class="string">&quot;fcntl(%d, F_SETFD)&quot;</span>, fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_closesocket</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">close</span>(sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个函数对应三个功能：</p>
<ol>
<li>将套接字设置为非阻塞属性<ul>
<li>如果 <code>recv</code> 调用没有可读取的数据, 或者如果 <code>send</code> 操作将阻塞, <code>recv</code> 或 <code>send</code> 调用返回 <code>-1</code> 和 <code>EAGAIN</code> 错误</li>
</ul>
</li>
<li>将套接字设置为在 exec 时 关闭：<ul>
<li><code>FD_CLOEXEC</code> 表示当程序执行 <code>exec</code> 函数时本 <code>fd</code> 将被系统自动关闭, 表示不传递给 <code>exec</code> 创建的新进程, 如果设置为 <code>fcntl(fd, F_SETFD, 0);</code> 那么 <code>fd</code> 将保持打开状态复制到 <code>exec</code> 创建的新进程中</li>
</ul>
</li>
<li>关闭套接字</li>
</ol>
<h3 id="初始化事件结构体"><a href="#初始化事件结构体" class="headerlink" title="初始化事件结构体"></a>初始化事件结构体</h3><p>调用 <code>event_assign()</code> 函数，设置 <code>ev_signal</code> 的监听对象就是这对套接字之一，并且监听读事件，回调函数为 <code>evsig_cb</code>。有关回调函数的细节在 <a href="# 信号事件的处理">信号事件的处理</a> 小节讲解，最后就是将信号处理后端函数结构体绑定到 <code>event_base</code> 中的 <code>evsigsel</code> 上。</p>
<blockquote>
<p>有关 <code>event_assign()</code> 的分析参见：<a href="/post/2020/afa6fb2f/" title="源码阅读 libevent - 结构体：event">源码阅读 libevent - 结构体：event</a></p>
</blockquote>
<h2 id="创建信号-event"><a href="#创建信号-event" class="headerlink" title="创建信号 event"></a>创建信号 event</h2><p>创建一个 <code>io event</code> 的函数是 <code>event_new()</code>，如果要创建信号 <code>event</code>，一种方法是直接设置 <code>event_new()</code> 的参数为 <code>EV_SIGNAL</code>，不过这种方法对于用户来说是非常不友好的。为此，<code>libevent</code> 在 <code>event.h</code> 中进行了如下的宏定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_add(ev, tv)                event_add((ev), (tv))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_assign(ev, b, x, cb, arg)  event_assign((ev), (b), (x), EV_SIGNAL|EV_PERSIST, cb, (arg))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_new(b, x, cb, arg)         event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_del(ev)                    event_del(ev)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_pending(ev, tv)            event_pending((ev), EV_SIGNAL, (tv))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_initialized(ev)            event_initialized(ev)</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里实际上对 <code>io event</code> 的相关函数的参数进行了特殊化处理，最终得到了信号 <code>event</code> 的相关函数。此时，就可以通过 <code>evsignal_new</code> 函数来创建一个信号 <code>event</code> 了，实际上就是创建了一个 <code>EV_SIGNAL|EV_PERSIST</code> 的永久信号事件。而该函数内部实际上又会调用 <code>event_assign</code> 函数。需要注意的是，创建普通 <code>event</code> 时第二个参数传入的是需要监听的的文件描述符，而这里创建信号 <code>event</code> 时传入的第二个参数则应当是需要监听的信号值了，比如说需要监听的信号是 <code>SIGUSR1</code>，那么调用 <code>evsignal_new</code> 时，传入的第二个参数就应该直接使用 <code>SIGUSR1</code>。<code>evsignal_new</code> 的第三个参数 <code>cb</code> 自然就应当是用户需要监听的信号发生后，期待调用的函数。</p>
<h2 id="添加信号-event"><a href="#添加信号-event" class="headerlink" title="添加信号 event"></a>添加信号 event</h2><p>如上所述，添加一个信号 <code>event</code> 使用 <code>evsignal_add()</code> 函数，实际上就是 <code>event_add()</code> 函数。前面创建的信号 <code>event</code>，其 <code>events</code> 成员已经被设置为了 <code>EV_SIGNAL|EV_PERSIST</code>。因此，<code>event_add()</code> 函数中会调用 <code>evmap_signal_add()</code> 函数将该 <code>event</code> 添加到 <code>event_signal_map</code> 中。</p>
<blockquote>
<p><code>event_add()</code> 相关说明参见：<a href="/post/2020/afa6fb2f/" title="源码阅读 libevent - 结构体：event">源码阅读 libevent - 结构体：event</a><br><code>evmap_signal_add()</code> 和 <code>event_signal_map</code> 相关说明参见：<a href="#">Post not found: 源码阅读 libevent - event_signal_map</a></p>
</blockquote>
<h3 id="evmap-signal-add"><a href="#evmap-signal-add" class="headerlink" title="evmap_signal_add"></a>evmap_signal_add</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evmap_signal_add_</span><span class="params">(struct event_base *base, <span class="keyword">int</span> sig, struct event *ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> = <span class="title">base</span>-&gt;<span class="title">evsigsel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_signal_map</span> *<span class="title">map</span> = &amp;<span class="title">base</span>-&gt;<span class="title">sigmap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evmap_signal</span> *<span class="title">ctx</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sig &lt; <span class="number">0</span> || sig&gt;= NSIG) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sig&gt;= <span class="built_in">map</span>-&gt;nentries)</span><br><span class="line">        <span class="keyword">if</span> (evmap_make_space(<span class="built_in">map</span>, sig, <span class="keyword">sizeof</span>(struct evmap_signal *)) == <span class="number">-1</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    GET_SIGNAL_SLOT_AND_CTOR(ctx, <span class="built_in">map</span>, sig, evmap_signal, evmap_signal_init, base-&gt;evsigsel-&gt;fdinfo_len);</span><br><span class="line">    <span class="keyword">if</span> (LIST_EMPTY(&amp;ctx-&gt;events))</span><br><span class="line">        <span class="keyword">if</span> (evsel-&gt;add(base, ev-&gt;ev_fd, <span class="number">0</span>, EV_SIGNAL, <span class="literal">NULL</span>) == <span class="number">-1</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    LIST_INSERT_HEAD(&amp;ctx-&gt;events, ev, ev_signal_next);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evmap_signal_add()</code> 除了将该 <code>event</code> 添加到 <code>event_signal_map</code> 中，还调用了 <code>evsel-&gt;add</code> 回调函数，其真正的实现函数为 <code>evsig_add()</code></p>
<h3 id="evsig-add"><a href="#evsig-add" class="headerlink" title="evsig_add"></a>evsig_add</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evsig_add</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> evsignal, <span class="keyword">short</span> old, <span class="keyword">short</span> events, <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evsig_info</span> *<span class="title">sig</span> = &amp;<span class="title">base</span>-&gt;<span class="title">sig</span>;</span></span><br><span class="line">    EVUTIL_ASSERT(evsignal&gt;= <span class="number">0</span> &amp;&amp; evsignal &lt; NSIG);</span><br><span class="line">    evsig_base = base;</span><br><span class="line">    evsig_base_n_signals_added = ++sig-&gt;ev_n_signals_added;</span><br><span class="line">    evsig_base_fd = base-&gt;sig.ev_signal_pair[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (evsig_set_handler_(base, (<span class="keyword">int</span>)evsignal, evsig_handler) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sig-&gt;ev_signal_added) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event_add_nolock_(&amp;sig-&gt;ev_signal, <span class="literal">NULL</span>, <span class="number">0</span>)) <span class="keyword">goto</span> err;</span><br><span class="line">        sig-&gt;ev_signal_added = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">err:</span><br><span class="line">    --evsig_base_n_signals_added;</span><br><span class="line">    --sig-&gt;ev_n_signals_added;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从后面的那个 <code>if</code> 语句可以得知，当 <code>sig-&gt;ev_signal_added</code> 变量为 <code>0</code> 时 (即用户第一次监听一个信号)，就会将 <code>ev_signal</code> 这个 <code>event</code> 加入到 <code>event_base</code> 中。从前面的统一事件源可以得知，这个 <code>ev_signal</code> 的作用就是通知 <code>event_base</code>，有信号发生了。只需一个 <code>event</code> 即可完成工作，即使用户要监听多个不同的信号，因为这个 <code>event</code> 已经和 <code>socketpair</code> 的读端相关联了。如果要监听多个信号，那么就在信号处理函数中往这个 <code>socketpair</code> 写入不同的值即可。<code>event_base</code> 能监听到可读，并可以从读到的内容可以判断是哪个信号发生了。</p>
<p>从代码中也可得知，<code>libevent</code> 并不会为每一个信号监听创建一个 <code>event</code>。它只会创建一个全局的专门用于监听信号的 <code>event</code>。这个也是统一事件源的工作原理。</p>
<h3 id="evsig-set-handler"><a href="#evsig-set-handler" class="headerlink" title="evsig_set_handler_"></a>evsig_set_handler_</h3><p><code>evsig_add()</code> 函数还调用了 <code>_evsig_set_handler()</code> 函数完成设置 <code>libevent</code> 内部的信号捕抓函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evsig_set_handler_</span><span class="params">(struct event_base *base, <span class="keyword">int</span> evsignal, <span class="keyword">void</span> (__cdecl *handler)(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evsig_info</span> *<span class="title">sig</span> = &amp;<span class="title">base</span>-&gt;<span class="title">sig</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (evsignal&gt;= sig-&gt;sh_old_max) &#123;</span><br><span class="line">        <span class="keyword">int</span> new_max = evsignal + <span class="number">1</span>;</span><br><span class="line">        event_debug((<span class="string">&quot;%s: evsignal (%d) &gt;= sh_old_max (%d), resizing&quot;</span>, __func__, evsignal, sig-&gt;sh_old_max));</span><br><span class="line">        p = mm_realloc(sig-&gt;sh_old, new_max * <span class="keyword">sizeof</span>(*sig-&gt;sh_old));</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">char</span> *)p + sig-&gt;sh_old_max * <span class="keyword">sizeof</span>(*sig-&gt;sh_old), <span class="number">0</span>, (new_max - sig-&gt;sh_old_max) * <span class="keyword">sizeof</span>(*sig-&gt;sh_old));</span><br><span class="line">        sig-&gt;sh_old_max = new_max;</span><br><span class="line">        sig-&gt;sh_old = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate space for previous handler out of dynamic array */</span></span><br><span class="line">    sig-&gt;sh_old[evsignal] = mm_malloc(<span class="keyword">sizeof</span> *sig-&gt;sh_old[evsignal]);</span><br><span class="line">    <span class="keyword">if</span> (sig-&gt;sh_old[evsignal] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        event_warn(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* save previous handler and setup new handler */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    sa.sa_flags |= SA_RESTART;</span><br><span class="line">    sigfillset(&amp;sa.sa_mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(evsignal, &amp;sa, sig-&gt;sh_old[evsignal]) == <span class="number">-1</span>) &#123;</span><br><span class="line">        event_warn(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        mm_free(sig-&gt;sh_old[evsignal]);</span><br><span class="line">        sig-&gt;sh_old[evsignal] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="evsig-handler"><a href="#evsig-handler" class="headerlink" title="evsig_handler"></a>evsig_handler</h3><p><code>_evsig_set_handler()</code> 函数设置 <code>libevent</code> 内部的信号捕抓函数为 <code>evsig_handler()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __cdecl <span class="title">evsig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> save_errno = errno;</span><br><span class="line">    <span class="keyword">ev_uint8_t</span> msg;</span><br><span class="line">    <span class="keyword">if</span> (evsig_base == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* Wake up our notification mechanism */</span></span><br><span class="line">    msg = sig;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">write</span>(evsig_base_fd, (<span class="keyword">char</span>*)&amp;msg, <span class="number">1</span>);</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要功能是发送一字节到管道或 <code>socket</code>。</p>
<h2 id="信号-event-的处理"><a href="#信号-event-的处理" class="headerlink" title="信号 event 的处理"></a>信号 event 的处理</h2><h3 id="回调函数-evsig-cb"><a href="#回调函数-evsig-cb" class="headerlink" title="回调函数 evsig_cb"></a>回调函数 evsig_cb</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Callback for when the signal handler write a byte to our signaling socket */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evsig_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> what, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">ev_ssize_t</span> n;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ncaught[NSIG];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line"></span><br><span class="line">    base = arg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ncaught, <span class="number">0</span>, <span class="keyword">sizeof</span>(ncaught));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n = <span class="built_in">read</span>(fd, signals, <span class="keyword">sizeof</span>(signals));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> err = evutil_socket_geterror(fd);</span><br><span class="line">            <span class="keyword">if</span> (! EVUTIL_ERR_RW_RETRIABLE(err)) event_sock_err(<span class="number">1</span>, fd, <span class="string">&quot;%s: recv&quot;</span>, __func__);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">ev_uint8_t</span> sig = signals[i];</span><br><span class="line">            <span class="keyword">if</span> (sig &lt; NSIG) ncaught[sig]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NSIG; ++i)</span><br><span class="line">        <span class="keyword">if</span> (ncaught[i]) evmap_signal_active_(base, i, ncaught[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evsig_cb()</code> 会从读端套接字中读取数据到 <code>signals</code> 数组中，读出的每一个字节都代表一个发生的信号值，用 <code>ncaught</code> 数组来存储每个信号发生的次数，并且对于每个发生的信号，都调用 <code>evmap_signal_active</code> 进行处理：</p>
<h3 id="evmap-signal-active"><a href="#evmap-signal-active" class="headerlink" title="evmap_signal_active_"></a>evmap_signal_active_</h3><p><code>evmap_signal_active</code> 主要是找到 <code>event_signal_map</code> 中，监听信号值为 <code>sig</code> 的那一个 <code>evmap_signal</code>，在这个 <code>evmap_signal</code> 中，包含了所有监听信号值为 <code>sig</code> 的 <code>event</code> 组成的双向链表，然后直接遍历这个双向链表，把每个元素都按照 <code>EV_SIGNAL</code> 的激活方式调用 <code>event_active_nolock</code> 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evmap_signal_active_</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> sig, <span class="keyword">int</span> ncalls)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_signal_map</span> *<span class="title">map</span> = &amp;<span class="title">base</span>-&gt;<span class="title">sigmap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evmap_signal</span> *<span class="title">ctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sig &lt; <span class="number">0</span> || sig&gt;= <span class="built_in">map</span>-&gt;nentries) <span class="keyword">return</span>;</span><br><span class="line">    GET_SIGNAL_SLOT(ctx, <span class="built_in">map</span>, sig, evmap_signal);</span><br><span class="line">    <span class="keyword">if</span> (!ctx) <span class="keyword">return</span>;</span><br><span class="line">    LIST_FOREACH(ev, &amp;ctx-&gt;events, ev_signal_next)</span><br><span class="line">    event_active_nolock_(ev, EV_SIGNAL, ncalls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>event_active_nolock</code> 函数来说，主要任务是调用 <code>event_callback_activate_nolock_</code> 把传入的 <code>event</code> 添加到激活队列中，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_active_nolock_</span><span class="params">(struct event *ev, <span class="keyword">int</span> res, <span class="keyword">short</span> ncalls)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    event_callback_activate_nolock_(base, event_to_event_callback(ev));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_callback_activate_nolock_</span><span class="params">(struct event_base *base, struct event_callback *evcb)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    event_queue_insert_active(base, evcb);</span><br><span class="line">    <span class="keyword">if</span> (EVBASE_NEED_NOTIFY(base)) evthread_notify_base(base);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，用来监听用户指定的信号值的那个信号 <code>event</code> 就被添加到了激活队列中，接下来，就等待主循环 <code>event_base_loop()</code> 处理激活队列时去处理那个信号 <code>event</code>。</p>
<h3 id="event-signal-closure"><a href="#event-signal-closure" class="headerlink" title="event_signal_closure"></a>event_signal_closure</h3><p>激活处理的过程就是 <code>event_base_loop()</code> —&gt; <code>event_process_active()</code> —&gt; <code>event_process_active_single_queue()</code>，在 <code>event_process_active_single_queue</code> 函数中，会判断激活处理事件的回调关闭方式 <code>ev_closure</code>，而对于信号 <code>event</code> 来说，在 <code>evsignal_new()</code> 时由于传入的参数为 <code>EV_SIGNAL|EV_PERSIST</code>，因此 <code>evsignal_new()</code> 内部调用的 <code>event_assign()</code> 会直接设置信号 <code>event</code> 的 <code>ev_closure</code> 为 <code>EV_CLOSURE_SIGNAL</code>，也就是说，处理激活的信号 <code>event</code> 最终是通过 <code>event_signal_closure()</code> 函数实现的，该函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &quot;closure&quot; function called when processing active signal events */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">event_signal_closure</span><span class="params">(struct event_base *base, struct event *ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">short</span> ncalls;</span><br><span class="line">    <span class="keyword">int</span> should_break;</span><br><span class="line">    ncalls = ev-&gt;ev_ncalls;</span><br><span class="line">    <span class="keyword">if</span> (ncalls != <span class="number">0</span>) ev-&gt;ev_pncalls = &amp;ncalls;</span><br><span class="line">    EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">    <span class="keyword">while</span> (ncalls) &#123;</span><br><span class="line">        ncalls--;</span><br><span class="line">        ev-&gt;ev_ncalls = ncalls;</span><br><span class="line">        <span class="keyword">if</span> (ncalls == <span class="number">0</span>) ev-&gt;ev_pncalls = <span class="literal">NULL</span>;</span><br><span class="line">        (*ev-&gt;ev_callback)(ev-&gt;ev_fd, ev-&gt;ev_res, ev-&gt;ev_arg);</span><br><span class="line"></span><br><span class="line">        EVBASE_ACQUIRE_LOCK(base, th_base_lock);</span><br><span class="line">        should_break = base-&gt;event_break;</span><br><span class="line">        EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (should_break) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ncalls != <span class="number">0</span>) ev-&gt;ev_pncalls = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>ncalls</code>，实际上就是 <code>evsig_cb</code> 函数中记录的信号值 <code>sig</code> 的发生次数，信号 <code>event</code> 激活时只处理一次，但是在这一次中会根据信号发生的次数来决定调用多少次回调函数，而这里的回调函数就是用户最开始设定的当信号发生时应当调用的函数了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
<li>[2] <a href="https://github.com/KelvinYin/libevent-src-analysis/blob/master/libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">libevent-src-analysis/libevent 源码分析. md at master · KelvinYin/libevent-src-analysis</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 内存管理</title>
    <url>/post/2020/58deb66e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>libevent</code> 的内存管理模块的头文件为 <code>mm-internal.h</code>，而相关函数的定义在文件 <code>event_mm_malloc_</code> 中。</p>
<p>从头文件名就可以看出，同日志模块一样，<code>libevent</code> 的内存管理相关函数也只提供 <code>libevent</code> 内部使用，并不提供外部接口。</p>
<p>同时，也同日志模块一样，<code>libevent</code> 的内存管理模块也向用户提供了设置回调函数的接口，以方便用户自行实现内存管理函数。</p>
<a id="more"></a>
<h2 id="内存管理函数"><a href="#内存管理函数" class="headerlink" title="内存管理函数"></a>内存管理函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>从 <code>mm-internal.h</code> 文件中可以得到内存管理模块函数的声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> *<span class="title">event_mm_malloc_</span><span class="params">(<span class="keyword">size_t</span> sz)</span></span>;</span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> *<span class="title">event_mm_calloc_</span><span class="params">(<span class="keyword">size_t</span> count, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">char</span> *<span class="title">event_mm_strdup_</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> *<span class="title">event_mm_realloc_</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> sz)</span></span>;</span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">event_mm_free_</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_malloc(sz) event_mm_malloc_(sz)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_calloc(count, size) event_mm_calloc_((count), (size))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_strdup(s) event_mm_strdup_(s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_realloc(p, sz) event_mm_realloc_((p), (sz))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_free(p) event_mm_free_(p)</span></span><br></pre></td></tr></table></figure>
<p>注意，以上声明是在 <code>libevent</code> 编译时没有使用 <code>--disable-malloc-replacement</code> 参数的声明，如果 <code>libevent</code> 编译时使用了 <code>--disable-malloc-replacement</code> 参数，即：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># disable support for replacing the memory mgt functions</span></span><br><span class="line">./configure --<span class="built_in">disable</span>-malloc-replacement</span><br></pre></td></tr></table></figure>
<p>则 <code>libevent</code> 的内存管理函数使用系统的内存管理函数，即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_malloc(sz) malloc(sz)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_calloc(n, sz) calloc((n), (sz))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_strdup(s) strdup(s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_realloc(p, sz) realloc((p), (sz))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_free(p) free(p)</span></span><br></pre></td></tr></table></figure>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><h4 id="mm-malloc-amp-mm-free-amp-mm-realloc"><a href="#mm-malloc-amp-mm-free-amp-mm-realloc" class="headerlink" title="mm_malloc &amp; mm_free &amp; mm_realloc"></a>mm_malloc &amp; mm_free &amp; mm_realloc</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_malloc(sz) event_mm_malloc_(sz)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_free(p) event_mm_free_(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mm_realloc(p, sz) event_mm_realloc_((p), (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_mm_malloc_</span><span class="params">(<span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sz == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (mm_malloc_fn_) <span class="keyword">return</span> mm_malloc_fn_(sz);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">malloc</span>(sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_mm_free_</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mm_free_fn_) mm_free_fn_(ptr);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_mm_realloc_</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mm_realloc_fn_) <span class="keyword">return</span> mm_realloc_fn_(ptr, sz);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">realloc</span>(ptr, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mm_malloc</code> &amp; <code>mm_free</code> &amp; <code>mm_realloc</code> 的实现最为简单，实现方式是有回调函数调用回调函数，没有回调函数直接调用系统函数。</p>
<h3 id="mm-strdup"><a href="#mm-strdup" class="headerlink" title="mm_strdup"></a>mm_strdup</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">event_mm_strdup_</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm_malloc_fn_) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> ln = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (ln == EV_SIZE_MAX) <span class="keyword">goto</span> error;</span><br><span class="line">        p = mm_malloc_fn_(ln+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="keyword">return</span> <span class="built_in">memcpy</span>(p, str, ln+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> strdup(str);</span><br><span class="line">error:</span><br><span class="line">    errno = ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>strdup</code> 的功能：<code>strdup</code> 是指新开辟一段空间，并将传入的字符串复制到新开辟的空间中，并返回这段空间的指针。</p>
<p>该函数的实现在 <code>_mm_malloc_fn</code> 为空的情形下调用系统函数 <code>strdup()</code> 来实现 <code>strdup</code> 功能。</p>
<p>而在 <code>_mm_malloc_fn</code> 不为空时的实现的方法是：先获取字符串长度，再加上一个终止符作为总长度，开辟该长度的空间，并取得指向该空间的指针，然后将字符串复制到这段空间。</p>
<h3 id="mm-calloc"><a href="#mm-calloc" class="headerlink" title="mm_calloc"></a>mm_calloc</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_mm_calloc_</span><span class="params">(<span class="keyword">size_t</span> count, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span> || <span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm_malloc_fn_) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> sz = count * <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (count&gt; EV_SIZE_MAX / <span class="built_in">size</span>) <span class="keyword">goto</span> error;</span><br><span class="line">        p = mm_malloc_fn_(sz);</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="keyword">return</span> <span class="built_in">memset</span>(p, <span class="number">0</span>, sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *p = <span class="built_in">calloc</span>(count, <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">error:</span><br><span class="line">    errno = ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>calloc</code> 功能：<code>calloc</code> 和 <code>malloc</code> 函数相似，都是开辟一段连续的空间，不同点在于 <code>calloc</code> 函数需要传入 <code>count</code> 和 <code>size</code> 两个参数，用来开辟 <code>count</code> 个大小为 <code>size</code> 的连续空间 (总大小为 <code>count*size</code>)，并且为这些空间全部赋值为 <code>0</code>。然后返回指向这段空间的泛型指针。</p>
<p>该函数的实现在 <code>_mm_malloc_fn</code> 为空的情形下调用系统函数 <code>calloc()</code> 来实现 <code>calloc</code> 功能。</p>
<p>而在 <code>_mm_malloc_fn</code> 不为空时的实现的方法是：先计算开辟空间总大小 <code>sz</code>，然后调用 <code>_mm_malloc_fn</code> 所指向的函数，而调用的函数也应当实现 <code>malloc</code> 的效果，开辟一段空间，然后再用 <code>memset</code> 对这段空间初始化为 <code>0</code>，并返回指向这段空间的泛型指针。</p>
<h2 id="定制内存管理函数接口"><a href="#定制内存管理函数接口" class="headerlink" title="定制内存管理函数接口"></a>定制内存管理函数接口</h2><p><code>libevent</code> 库提供了修改 <code>mm_malloc</code> &amp; <code>mm_free</code> &amp; <code>mm_realloc</code> 内存管理方式的函数 <code>event_set_mem_functions</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_mem_functions</span><span class="params">(<span class="keyword">void</span> *(*malloc_fn)(<span class="keyword">size_t</span> sz),</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> *(*realloc_fn)(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> sz),</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> (*free_fn)(<span class="keyword">void</span> *ptr))</span> </span>&#123;</span><br><span class="line">    mm_malloc_fn_ = malloc_fn;</span><br><span class="line">    mm_realloc_fn_ = realloc_fn;</span><br><span class="line">    mm_free_fn_ = free_fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>event_set_mem_functions</code> 的声明位于文件 <code>event.h</code>，故可以被用户调用。</p>
<p>通过 <code>event_set_mem_functions</code> 函数，设置 <code>mm_malloc_fn_</code>，<code>mm_realloc_fn_</code>，<code>mm_free_fn_</code>，后，可以由用户自行对内存使用进行管理，比如使用内存池等。</p>
<p>在自行定制内存管理函数时应当注意以下问题：</p>
<ul>
<li>替换内存管理函数影响 <code>libevent</code> 随后的所有分配、调整大小和释放内存操作。所以必须保证在调用任何其他 <code>libevent</code> <code>函数之前进行定制。否则，libevent</code> 可能用定制的 <code>free</code> 函数释放 <code>C</code> 语言库的 <code>malloc</code> 函数分配的内存</li>
<li><code>malloc</code> 和 <code>realloc</code> 函数返回的内存块应该具有和 <code>C</code> 库返回的内存块一样的地址对齐</li>
<li><code>realloc</code> 函数应该正确处理 <code>realloc(NULL, sz)</code>（也就是当作 <code>malloc(sz)</code> 处理）</li>
<li><code>realloc</code> 函数应该正确处理 <code>realloc(ptr, 0)</code>（也就是当作 <code>free(ptr)</code> 处理）</li>
<li>如果在多个线程中使用 <code>libevent</code>，替代的内存管理函数需要是线程安全的</li>
<li>如果要释放由 <code>libevent</code> 函数分配的内存，并且已经定制了 <code>malloc</code> 和 <code>realloc</code> 函数，那么就应该使用定制的 <code>free</code> 函数释放。否则将会 <code>C</code> 语言标准库的 <code>free</code> 函数释放定制内存分配函数分配的内存，这将发生错误。所以三者要么全部不定制，要么全部定制。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/luotuo44/article/details/38334979">Libevent 源码分析 - 内存分配_luotuo44 的专栏 - CSDN 博客</a></li>
<li>[2] <a href="http://www.wangafu.net/~nickm/libevent-book/Ref1_libsetup.html">http://www.wangafu.net/~nickm/libevent-book/Ref1_libsetup.html</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 创建 event_base</title>
    <url>/post/2020/1a2a4fe3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>要实现 <code>libevent</code> 的事件处理，最关键的就是 <code>event_base</code>，<code>event_base</code> 就像是一棵树，而需要进行处理的事件 <code>event</code> 就像是树上的果子，因此，在分析 <code>libevent</code> 的事件处理之前，先来分析一下 <code>event_base</code>。</p>
<p>由于 <code>event_base</code> 结构体中包含了三十多个成员，直接去分析每个成员是在当前没有对了 libevent 代码做足够深入理解的话是很难分析每个成员的作用，因此我们先从 <code>event_base</code> 的使用中去了解 <code>event_base</code> 各个结构体成员的作用会比较好，本文先来看看 <code>event_base</code> 的创建。</p>
<blockquote>
<a href="#">Post not found: 源码阅读 libevent - 结构体：event_base</a>
</blockquote>
<a id="more"></a>
<h2 id="默认方式创建-event-base"><a href="#默认方式创建-event-base" class="headerlink" title="默认方式创建 event_base"></a>默认方式创建 event_base</h2><p>通常我们获取 <code>event_base</code> 都是通过 <code>event_base_new</code> 这个无参函数。使用这个无参函数，只能得到一个默认配置的 <code>event_base</code> 结构体。</p>
<p><code>event_base_new</code> 函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct event_base * <span class="title">event_base_new</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_config</span> *<span class="title">cfg</span> = <span class="title">event_config_new</span>();</span></span><br><span class="line">    <span class="keyword">if</span> (cfg) &#123;</span><br><span class="line">        base = event_base_new_with_config(cfg);</span><br><span class="line">        event_config_free(cfg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其先创建了一个 <code>event_config</code> 结构体，并用 <code>cfg</code> 指针指向之，然后再用这个变量作为参数调用 <code>event_base_new_with_config</code>。因为并没有对 <code>cfg</code> 进行任何的设置，所以得到的是默认配置的 <code>event_base</code>。</p>
<h2 id="定制-event-base"><a href="#定制-event-base" class="headerlink" title="定制 event_base"></a>定制 event_base</h2><p>从以上分析也可以知道，如果要对 <code>event_base</code> 进行配置，那么对 <code>cfg</code> 变量进行配置即可。现在我们的目光从 <code>event_base</code> 结构体转到 <code>event_config</code> 结构体。</p>
<p><code>event_config</code> 结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_config</span> &#123;</span></span><br><span class="line">    TAILQ_HEAD(event_configq, event_config_entry) entries;</span><br><span class="line">    <span class="keyword">int</span> n_cpus_hint;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">max_dispatch_interval</span>;</span></span><br><span class="line">    <span class="keyword">int</span> max_dispatch_callbacks;</span><br><span class="line">    <span class="keyword">int</span> limit_callbacks_after_prio;</span><br><span class="line">    <span class="keyword">enum</span> event_method_feature require_features;</span><br><span class="line">    <span class="keyword">enum</span> event_base_config_flag flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>event_config</code> 结构体中定义了 7 个变量，对应了 <code>event_base</code> 的 5 中配置选项：</p>
<ol>
<li><code>entries</code> - 拒绝使用某个多路 <code>IO</code> 复用函数</li>
<li><code>n_cpus_hint</code> - 指明 <code>CPU</code> 的数量，以便 <code>libevent</code> 内部进行 <code>CPU</code> 优化</li>
<li><code>max_dispatch_interval</code>/<code>max_dispatch_callbacks</code>/<code>limit_callbacks_after_prio</code> 联合限制 libevent 的事件回调频率</li>
<li><code>require_features</code> - 指明多路 <code>I/O</code> 复用函数需要具有的特征</li>
<li><code>flags</code> - 其他的一些特征标志位</li>
</ol>
<h3 id="拒绝使用某个多路-IO-复用函数"><a href="#拒绝使用某个多路-IO-复用函数" class="headerlink" title="拒绝使用某个多路 IO 复用函数"></a>拒绝使用某个多路 <code>IO</code> 复用函数</h3><p>第一个成员 <code>entries</code>，其结构是一个队列，队列元素的类型就是 <code>event_config_entry</code>，可以用来存储一个字符串指针。它对应的设置函数为 <code>event_config_avoid_method</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_config_entry</span> &#123;</span></span><br><span class="line">    TAILQ_ENTRY(event_config_entry) next;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *avoid_method;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_avoid_method</span><span class="params">(struct event_config *cfg, <span class="keyword">const</span> <span class="keyword">char</span> *method)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_config_entry</span> *<span class="title">entry</span> = <span class="title">mm_malloc</span>(<span class="title">sizeof</span>(*<span class="title">entry</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">NULL</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((entry-&gt;avoid_method = mm_strdup(method)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mm_free(entry);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;cfg-&gt;entries, entry, next);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>libevent</code> 是跨平台的 <code>Reactor</code>，对于事件监听，其内部是使用多路 <code>IO</code> 复用函数。比较通用的多路 <code>IO</code> 复用函数是 <code>select</code> 和 <code>poll</code>。而很多平台都提出了自己的高效多路 <code>IO</code> 复用函数，比如：<code>epoll</code>、<code>devpoll</code>、<code>kqueue</code>。<code>libevent</code> 对于这些多路 <code>IO</code> 复用函数都进行包装，供自己使用。<code>event_config_avoid_method</code> 函数就是指出，避免使用指定的多路 <code>IO</code> 复用函数。其是通过字符串的方式指定的，即参数 <code>method</code>。这个字符串将由队列元素 <code>event_config_entry</code> 的 <code>avoid_method</code> 成员变量存储 (由于是指针，所以更准确来说是指向)。</p>
<p>查看 <code>libevent</code> 源码包里的文件，可以发现有诸如 <code>epoll.c</code>、<code>select.c</code>、<code>poll.c</code>、<code>devpoll.c</code>、<code>kqueue.c</code> 这些文件。打开这些文件就可以发现在文件内容的前面都会定义一个 <code>struct eventop</code> 类型变量。该结构体的第一个成员必然是一个字符串。这个字符串就描述了对应的多路 <code>IO</code> 复用函数的名称。所以是可以通过名称来禁用某种多路 <code>IO</code> 复用函数的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* select.c */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> <span class="title">selectops</span> = &#123;</span></span><br><span class="line">    <span class="string">&quot;select&quot;</span>,</span><br><span class="line">    select_init,</span><br><span class="line">    select_add,</span><br><span class="line">    select_del,</span><br><span class="line">    select_dispatch,</span><br><span class="line">    select_dealloc,</span><br><span class="line">    <span class="number">0</span>, <span class="comment">/* doesn&#x27;t need reinit. */</span></span><br><span class="line">    EV_FEATURE_FDS,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="智能调整-CPU-个数"><a href="#智能调整-CPU-个数" class="headerlink" title="智能调整 CPU 个数"></a>智能调整 CPU 个数</h3><p>第二个成员变量 <code>n_cpus_hint</code>。从名字来看是指明 <code>CPU</code> 的数量。是通过函数 <code>event_config_set_num_cpus_hint</code> 来设置的。其作用是告诉 <code>event_config</code>，系统中有多少个 <code>CPU</code>，以便作一些对线程池作一些调整来获取更高的效率。目前，仅仅 <code>Window</code> 系统的 <code>IOCP</code>(<code>Windows</code> 的 <code>IOCP</code> 能够根据 <code>CPU</code> 的个数智能调整)，该函数的设置才有用。在以后，<code>libevent</code> 可能会将之应用于其他系统。</p>
<p>正如其名字中的 <code>hint</code>，这仅仅是一个提示。就如同 <code>C++</code> 中的 <code>inline</code>。<code>event_base</code> 实际使用的 <code>CPU</code> 个数不一定等于提示的个数。</p>
<h3 id="规定多路-IO-复用函数需满足的特征"><a href="#规定多路-IO-复用函数需满足的特征" class="headerlink" title="规定多路 IO 复用函数需满足的特征"></a>规定多路 <code>IO</code> 复用函数需满足的特征</h3><p>第六个成员变量 <code>require_features</code>。从其名称来看是要求的特征。不错，这个变量指定 多路 <code>IO</code> 复用函数应该满足哪些特征。所有的特征定义在一个枚举类型中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> event_method_feature &#123;</span><br><span class="line">    EV_FEATURE_ET = <span class="number">0x01</span>, <span class="comment">/* 支持边沿触发 */</span></span><br><span class="line">    EV_FEATURE_O1 = <span class="number">0x02</span>, <span class="comment">/* 添加、删除、或者确定哪个事件激活这些动作的时间复杂度都为 O(1) */</span></span><br><span class="line">    EV_FEATURE_FDS = <span class="number">0x04</span>, <span class="comment">/* 支持任意的文件描述符，而不能仅仅支持套接字 */</span></span><br><span class="line">    EV_FEATURE_EARLY_CLOSE = <span class="number">0x08</span> <span class="comment">/* 支持在不读取接收缓冲区数据时，检测连接关闭 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>比如 epoll.c 中定义了 epoll 满足的特性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> <span class="title">epollops</span> = &#123;</span></span><br><span class="line">    <span class="string">&quot;epoll&quot;</span>,</span><br><span class="line">    epoll_init,</span><br><span class="line">    epoll_nochangelist_add,</span><br><span class="line">    epoll_nochangelist_del,</span><br><span class="line">    epoll_dispatch,</span><br><span class="line">    epoll_dealloc,</span><br><span class="line">    <span class="number">1</span>, <span class="comment">/* need reinit */</span></span><br><span class="line">    EV_FEATURE_ET|EV_FEATURE_O1|EV_FEATURE_EARLY_CLOSE,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="其他配置标志位"><a href="#其他配置标志位" class="headerlink" title="其他配置标志位"></a>其他配置标志位</h3><p><code>event_config</code> 的第四个成员 <code>flags</code>，代表了一些 <code>event_base</code> 对象的特征，其通过标志位来进行表示。</p>
<p>可用的标志位可参见枚举类型 <code>event_base_config_flag</code>，该枚举类型定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> event_base_config_flag &#123;</span><br><span class="line">    <span class="comment">/** 不要为 event_base 分配锁。</span></span><br><span class="line"><span class="comment">    *** 设置这个选项可以为 event_base 节省一点加锁和解锁的时间，但是当多个线程访问 event_base 会变得不安全 */</span></span><br><span class="line">    EVENT_BASE_FLAG_NOLOCK = <span class="number">0x01</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 选择多路 IO 复用函数时，不检测 EVENT_* 环境变量。</span></span><br><span class="line"><span class="comment">    *** 使用这个标志要考虑清楚：因为这会使得用户更难调试程序与 libevent 之间的交互 */</span></span><br><span class="line">    EVENT_BASE_FLAG_IGNORE_ENV = <span class="number">0x02</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 仅用于 Windows。这使得 libevent 在启动时就启用任何必需的 IOCP 分发逻辑，而不是按需启用。</span></span><br><span class="line"><span class="comment">    *** 如果设置了这个宏，那么 evconn_listener_new 和 bufferevent_socket_new 函数的内部将使用 IOCP */</span></span><br><span class="line">    EVENT_BASE_FLAG_STARTUP_IOCP = <span class="number">0x04</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 在执行 event_base_loop 的时候没有 cache 时间。</span></span><br><span class="line"><span class="comment">    *** 该函数的 while 循环会经常取系统时间，如果有 cache 时间，那么就取 cache 的。如果没有的话，就只能通过系统提供的函数来获取系统时间。这将更耗时 */</span></span><br><span class="line">    EVENT_BASE_FLAG_NO_CACHE_TIME = <span class="number">0x08</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 告知 Libevent，如果决定使用 epoll 这个多路 IO 复用函数，可以安全地使用更快的基于 changelist 的多路 IO 复用函数：epollchangelist</span></span><br><span class="line"><span class="comment">    *** 多路 IO 复用可以在多路 IO 复用函数调用之间，同样的 fd 多次修改其状态的情况下，避免不必要的系统调用</span></span><br><span class="line"><span class="comment">    *** 但是如果传递任何使用 dup() 或者其变体克隆的 fd 给 libevent，epollchangelist 多路 IO 复用函数会触发一个内核 bug，导致不正确的结果</span></span><br><span class="line"><span class="comment">    *** 在不使用 epoll 这个多路 IO 复用函数的情况下，这个标志是没有效果的。也可以通过设置 EVENT_EPOLL_USE_CHANGELIST 环境变量来打开 epollchangelist 选项 */</span></span><br><span class="line">    EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = <span class="number">0x10</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通常，libevent 使用我们拥有的最快的单调计时器实现其时间和超时代码。</span></span><br><span class="line"><span class="comment">    *** 如果设置了此标志，libevent 将使用一个存在的且效率较低的更精确的计时器。 */</span></span><br><span class="line">    EVENT_BASE_FLAG_PRECISE_TIMER = <span class="number">0x20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="根据配置创建-event-base"><a href="#根据配置创建-event-base" class="headerlink" title="根据配置创建 event_base"></a>根据配置创建 event_base</h2><p>将以上我们定制好的 <code>event_config</code> 类型的参数 <code>cfg</code> 传入到 <code>event_base_new_with_config</code> 中，即可根据 <code>cfg</code> 中的配置来创建符合条件的 <code>event_base</code>，<code>event_base_new_with_config</code> 中部分关键代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct event_base * <span class="title">event_base_new_with_config</span><span class="params">(<span class="keyword">const</span> struct event_config *cfg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="keyword">int</span> should_check_environment;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EVENT__DISABLE_DEBUG_MODE</span></span><br><span class="line">    event_debug_mode_too_late = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((base = mm_calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct event_base))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        event_warn(<span class="string">&quot;%s: calloc&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cfg) base-&gt;flags = cfg-&gt;flags;</span><br><span class="line"></span><br><span class="line">    should_check_environment = !(cfg &amp;&amp; (cfg-&gt;flags &amp; EVENT_BASE_FLAG_IGNORE_ENV));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    base-&gt;evbase = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cfg) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;base-&gt;max_dispatch_time, &amp;cfg-&gt;max_dispatch_interval, <span class="keyword">sizeof</span>(struct timeval));</span><br><span class="line">        base-&gt;limit_callbacks_after_prio = cfg-&gt;limit_callbacks_after_prio;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        base-&gt;max_dispatch_time.tv_sec = <span class="number">-1</span>;</span><br><span class="line">        base-&gt;limit_callbacks_after_prio = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cfg &amp;&amp; cfg-&gt;max_dispatch_callbacks &gt;= <span class="number">0</span>) base-&gt;max_dispatch_callbacks = cfg-&gt;max_dispatch_callbacks;</span><br><span class="line">    <span class="keyword">else</span> base-&gt;max_dispatch_callbacks = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;max_dispatch_callbacks == INT_MAX &amp;&amp; base-&gt;max_dispatch_time.tv_sec == <span class="number">-1</span>)</span><br><span class="line">        base-&gt;limit_callbacks_after_prio = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; eventops[i] &amp;&amp; !base-&gt;evbase; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cfg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* determine if this backend should be avoided */</span></span><br><span class="line">            <span class="keyword">if</span> (event_config_is_avoided_method(cfg, eventops[i]-&gt;name)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((eventops[i]-&gt;features &amp; cfg-&gt;require_features) != cfg-&gt;require_features) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* also obey the environment variables */</span></span><br><span class="line">        <span class="keyword">if</span> (should_check_environment &amp;&amp; event_is_method_disabled(eventops[i]-&gt;name)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        base-&gt;evsel = eventops[i];</span><br><span class="line">        base-&gt;evbase = base-&gt;evsel-&gt;init(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;evbase == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        event_warnx(<span class="string">&quot;%s: no event mechanism available&quot;</span>, __func__);</span><br><span class="line">        base-&gt;evsel = <span class="literal">NULL</span>;</span><br><span class="line">        event_base_free(base);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (evutil_getenv_(<span class="string">&quot;EVENT_SHOW_METHOD&quot;</span>)) event_msgx(<span class="string">&quot;libevent using: %s&quot;</span>, base-&gt;evsel-&gt;name);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，<code>event_base_new_with_config</code> 做的最重要的一个工作就是选择一个合适的多路 <code>IO</code> 复用函数。</p>
<h3 id="多路-IO-复用函数的选择"><a href="#多路-IO-复用函数的选择" class="headerlink" title="多路 IO 复用函数的选择"></a>多路 IO 复用函数的选择</h3><p>多路 <code>IO</code> 复用函数方法也比较简单：</p>
<p><code>libevent</code> 根据宏定义判断当前的 <code>OS</code> 环境是否有某个多路 <code>IO</code> 复用函数。如果有，那么就把与之对应的 <code>struct eventop</code> 结构体指针放到一个全局数组 <code>eventops</code> 中。有了这个数组，就只需遍历这个数组，并将其中某个符合条件的元素赋值给 <code>event_base.evsel</code> 变量即可。</p>
<p><code>eventops</code> 数组和 <code>event_base.evsel</code> 都是一个结构体指针，结构体类型为 <code>struct eventop</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">void</span> *(*init)(struct event_base *);</span><br><span class="line">    <span class="keyword">int</span> (*add)(struct event_base *, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> old, <span class="keyword">short</span> events, <span class="keyword">void</span> *fdinfo);</span><br><span class="line">    <span class="keyword">int</span> (*del)(struct event_base *, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> old, <span class="keyword">short</span> events, <span class="keyword">void</span> *fdinfo);</span><br><span class="line">    <span class="keyword">int</span> (*dispatch)(struct event_base *, struct timeval *);</span><br><span class="line">    <span class="keyword">void</span> (*dealloc)(struct event_base *);</span><br><span class="line">    <span class="keyword">int</span> need_reinit;</span><br><span class="line">    <span class="keyword">enum</span> event_method_feature features;</span><br><span class="line">    <span class="keyword">size_t</span> fdinfo_len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中各参数的作用为（<code>libevent</code> 中 <code>backend</code>，直译为“后端”，在 <code>libevent</code> 中与多路 <code>IO</code> 复用函数意义相同，下文中会混用两个概念）：</p>
<ol>
<li><code>name</code>：多路 <code>IO</code> 复用函数名称</li>
<li><code>init</code>：用于设置 <code>event_base</code> 以使用此后端的函数。它应该创建一个新结构，其中包含运行后端并返回它所需的所有信息。返回的指针将由 <code>event_init</code> 存储到 <code>event_base.evbase</code> 字段中。失败时，此函数应返回 <code>NULL</code></li>
<li><code>add</code>：启用对给定 <code>fd</code> 或信号的读取 / 写入。 <code>events</code> 将是我们要启用的事件：<code>EV_READ</code>，<code>EV_WRITE</code>，<code>EV_SIGNAL</code> 和 <code>EV_ET</code> 中的一个或多个。 <code>old</code> 是先前在此 <code>fd</code> 上启用了那些事件。 <code>fdinfo</code> 将是 <code>evmap</code> 与 <code>fd</code> 相关联的结构；它的大小由下面的 <code>fdinfo</code> 字段定义。首次添加 <code>fd</code> 时，它将设置为 <code>0</code>。该函数成功返回 <code>0</code>，错误返回 <code>-1</code>。</li>
<li><code>del</code>：与添加相对应，禁用我们要排除的事件。</li>
<li><code>dispatch</code>：函数实现事件循环的核心。它必须查看添加哪些 <code>events</code> 已经处于准备状态，并为每个活动事件调用 <code>event_active</code>（通常通过 <code>event_io_active</code> 等）。成功返回 <code>0</code>，错误返回 <code>-1</code>。</li>
<li><code>dealloc</code>：用于从 <code>event_base</code> 中清除并释放数据的函数。</li>
<li><code>need_reinit</code>：标志：设置我们是否需要在 <code>fork</code> 后重新初始化事件库。</li>
<li><code>features</code>：按位表示此多路 <code>IO</code> 复用函数可以提供的受支持的 <code>event_method_features</code> 特性。</li>
<li><code>fdinfo_len</code>：我们应该为具有一个或多个活动事件的每个 <code>fd</code> 记录的额外信息的长度。此信息记录为每个 <code>fd</code> 的 <code>evmap</code> 条目的一部分，并作为参数传递给上面的 <code>add</code> 和 <code>del</code> 函数。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
<li>[2] <a href="https://github.com/KelvinYin/libevent-src-analysis/blob/master/libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">libevent-src-analysis/libevent 源码分析. md at master · KelvinYin/libevent-src-analysis</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 初识 Hello World</title>
    <url>/post/2020/a867e274/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="初识-libevent"><a href="#初识-libevent" class="headerlink" title="初识 libevent"></a>初识 libevent</h2><h3 id="libevent-概述"><a href="#libevent-概述" class="headerlink" title="libevent 概述"></a>libevent 概述</h3><p><code>Libevent</code> 有几个显著的亮点：</p>
<ul>
<li>事件驱动（<code>event-driven</code>），高性能;</li>
<li>轻量级，专注于网络，不如 ACE 那么臃肿庞大；</li>
<li>源代码相当精炼、易读；</li>
<li>跨平台，支持 Windows、Linux、*BSD 和 Mac Os；</li>
<li>支持多种 <code>I/O</code> 多路复用技术， <code>epoll</code>、<code>poll</code>、<code>dev/poll</code>、<code>select</code> 和 <code>kqueue</code> 等；</li>
<li>支持 <code>I/O</code>，定时器和信号等事件；</li>
<li>注册事件优先级；</li>
</ul>
<p><code>Libevent</code> 已经被广泛的应用，作为底层的网络库；比如 <code>memcached</code>、<code>Vomit</code>、<code>Nylon</code>、<code>Netchat</code> 等等。</p>
<a id="more"></a>
<blockquote>
<p><a href="https://leanote.com/api/file/getAttach?fileId=577e1ad9ab644133ed002c8a">libevent 源码深度剖析</a> page5</p>
</blockquote>
<h2 id="从-Hello-World-开始"><a href="#从-Hello-World-开始" class="headerlink" title="从 Hello World 开始"></a>从 Hello World 开始</h2><p><code>hello-world</code> 是 <code>libevent</code> 自带的一个例子，这个例子的作用是启动后监听一个端口，对于所有通过这个端口连接上服务器的程序发送一段字符：hello-world，然后关闭连接。</p>
<blockquote>
<p>源码链接: <a href="https://github.com/libevent/libevent/blob/master/sample/hello-world.c">https://github.com/libevent/libevent/blob/master/sample/hello-world.c</a></p>
</blockquote>
<p>下面就通过分析这个例子来看一下 libevent 对于 IO 事件是如何处理的：</p>
<h3 id="模块代码分析"><a href="#模块代码分析" class="headerlink" title="模块代码分析"></a>模块代码分析</h3><p>1、调用 <code>event_base_new</code> 获得 <code>event_base</code> 对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">base = event_base_new();</span><br><span class="line"><span class="keyword">if</span> (!base) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not initialize libevent!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、调用 <code>evconnlistener_new_bind</code>，返回一个 <code>struct evconnlistener</code> 对象指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">listener = evconnlistener_new_bind(</span><br><span class="line">    base,                                           <span class="comment">// 所属的 event_base 对象</span></span><br><span class="line">    listener_cb,                                    <span class="comment">// 监听回调函数</span></span><br><span class="line">    (<span class="keyword">void</span> *)base,                                   <span class="comment">// 回调函数的参数</span></span><br><span class="line">    LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE,        <span class="comment">// 标志：地址可复用，调用 exec 的时候关闭套接字</span></span><br><span class="line">    <span class="number">-1</span>,                                             <span class="comment">// 是否在后台打印日志</span></span><br><span class="line">    (struct sockaddr*)&amp;<span class="built_in">sin</span>,                         <span class="comment">// 地址</span></span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)                                     <span class="comment">// 地址长度</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!listener) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not create a listener!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、调用 <code>evsignal_new</code> 函数获取一个信号事件对象, 并将事件处理器添加到 <code>event_base</code> 的事件处理器注册队列中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">signal_event = evsignal_new(</span><br><span class="line">    base,                       <span class="comment">// 所属的 event_base 对象</span></span><br><span class="line">    SIGINT,                     <span class="comment">// 信号处理器处理的信号 这里处理的信号是 SIGINT</span></span><br><span class="line">    signal_cb,                  <span class="comment">// 处理信号的回调函数</span></span><br><span class="line">    (<span class="keyword">void</span> *)base                <span class="comment">// 回调函数的参数</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!signal_event || event_add(signal_event, <span class="literal">NULL</span>)&lt;<span class="number">0</span>) &#123;     <span class="comment">// 将事件处理器添加到 event_base 的事件处理器注册队列中</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not create/add a signal event!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、调用 <code>event_base_dispatch</code> 函数进入事件循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">event_base_dispatch(base);          <span class="comment">// 进入事件循环</span></span><br></pre></td></tr></table></figure>
<p>5、对象的释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">evconnlistener_free(listener);</span><br><span class="line">event_free(signal_event);</span><br><span class="line">event_base_free(base);</span><br></pre></td></tr></table></figure>
<p>6、在创建 <code>evconnlistener</code> 对象时传入了一个回调函数：<code>listener_cb</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">listener_cb(struct evconnlistener *listener, <span class="keyword">evutil_socket_t</span> fd,</span><br><span class="line">    struct sockaddr *sa, <span class="keyword">int</span> socklen, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">user_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span>                <span class="comment">// 缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 基于套接字创建一个缓冲区（套接字接收到数据之后存放在缓冲区中，套接字在发送数据之前先将数据存放在缓冲区中） */</span></span><br><span class="line">    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line">    <span class="keyword">if</span> (!bev) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error constructing bufferevent!&quot;</span>);</span><br><span class="line">        event_base_loopbreak(base);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置回调函数 */</span></span><br><span class="line">    bufferevent_setcb(</span><br><span class="line">        bev,                <span class="comment">// 缓冲区</span></span><br><span class="line">        <span class="literal">NULL</span>,               <span class="comment">// 读事件回调函数（设置为空）</span></span><br><span class="line">        conn_writecb,       <span class="comment">// 写事件回调函数  typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);</span></span><br><span class="line">        conn_eventcb,       <span class="comment">// 事件处理回调函数  typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short what, void *ctx);</span></span><br><span class="line">        <span class="literal">NULL</span>                <span class="comment">// 回调函数的最后一个参数</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    bufferevent_enable(bev, EV_WRITE);      <span class="comment">// 启用缓存区的写功能</span></span><br><span class="line">    bufferevent_disable(bev, EV_READ);      <span class="comment">// 禁用缓冲区的读功能</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将要发送的数据写入到该缓冲区 */</span></span><br><span class="line">    bufferevent_write(bev, MESSAGE, <span class="built_in">strlen</span>(MESSAGE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、 回调函数 <code>listener_cb</code> 又注册了写事件回调函数 <code>conn_writecb</code> 和 事件处理回调函数 <code>conn_eventcb</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">conn_writecb(struct bufferevent *bev, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">output</span> = <span class="title">bufferevent_get_output</span>(<span class="title">bev</span>);</span>      <span class="comment">// 发送缓冲器中的数据</span></span><br><span class="line">    <span class="keyword">if</span> (evbuffer_get_length(output) == <span class="number">0</span>) &#123;                     <span class="comment">// 判断数据是否已经发送成功 为 0 代表发送成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;flushed answer\n&quot;</span>);</span><br><span class="line">        bufferevent_free(bev);                                  <span class="comment">// 释放缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">conn_eventcb(struct bufferevent *bev, <span class="keyword">short</span> events, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; BEV_EVENT_EOF) &#123;                           <span class="comment">// 客户端关闭</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connection closed.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; BEV_EVENT_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got an error on the connection: %s\n&quot;</span>,      <span class="comment">// 链接产生错误</span></span><br><span class="line">            strerror(errno));<span class="comment">/*XXX win32*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* None of the other events can happen here, since we haven&#x27;t enabled</span></span><br><span class="line"><span class="comment">     * timeouts */</span></span><br><span class="line">    bufferevent_free(bev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8、 <code>evsignal_new</code> 函数注册了信号处理函数 <code>signal_cb</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">signal_cb(<span class="keyword">evutil_socket_t</span> sig, <span class="keyword">short</span> events, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">user_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">delay</span> = &#123;</span><span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught an interrupt signal; exiting cleanly in two seconds.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    event_base_loopexit(base, &amp;<span class="built_in">delay</span>);              <span class="comment">// 退出事件循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整体逻辑梳理"><a href="#整体逻辑梳理" class="headerlink" title="整体逻辑梳理"></a>整体逻辑梳理</h3><p>对于这个 <code>Demo</code>，整体的逻辑如下：</p>
<ol>
<li><p>新建一个 <code>event_base</code> ，然后在其上绑定一个 <code>listener</code> 来监听特定端口 <code>9995</code>;</p>
</li>
<li><p>新建一个处理信号的事件 <code>signal_event</code>，并与上一步中的 <code>event_base</code> 绑定；</p>
</li>
<li><p>调用 <code>event_base_dispatch</code> 来监控两个事件，包括指定的 <code>TCP</code> 连接及 <code>SIGINT</code> 信号;</p>
</li>
<li><p>当监听到一个连接时，<code>libevent</code> 会触发 <code>listener_cb</code> 函数，该函数首先基于底层的 <code>socket</code> 建立一个 <code>bufferevent</code> ，并设置为可写不可读，最后调用 <code>bufferevent_write</code> 函数向其中缓存区写;</p>
</li>
<li><p><code>bufferevent_write</code> 函数写后回触发写回调函数 <code>conn_writecb</code>，由于该例子中不需要其他操作，所以 <code>conn_writecb</code> 函数直接释放这个连接;</p>
</li>
<li><p>当中断信号 <code>Ctrl+C</code> 出现时，<code>libevent</code> 会触发 <code>signal_event</code> 的回调函数 <code>signal_cb</code>，该函数会在 2 秒后停止 <code>event_base</code> 的监听，并退回到主函数；</p>
</li>
<li><p>主函数依次释放 <code>listener</code>，<code>signal_event</code> 和 <code>event_base</code> 的资源，结束。</p>
</li>
</ol>
<h3 id="运行演示"><a href="#运行演示" class="headerlink" title="运行演示"></a>运行演示</h3><ol>
<li><p>服务器端编译并运行</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_0_6_centos sample]<span class="comment"># ./hello-world</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再开一个终端执行:</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_0_6_centos ~]<span class="comment"># ncat 127.0.0.1 9995</span></span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端显示:</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_0_6_centos sample]<span class="comment"># ./hello-world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ol>
<li>Github: <a href="https://github.com/libevent/libevent">https://github.com/libevent/libevent</a></li>
<li>官方网站: <a href="https://libevent.org/">https://libevent.org/</a></li>
</ol>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol>
<li><code>libevent</code> 源码深度剖析: <a href="https://leanote.com/api/file/getAttach?fileId=577e1ad9ab644133ed002c8a">https://leanote.com/api/file/getAttach?fileId=577e1ad9ab644133ed002c8a</a></li>
<li>Programming with Libevent: <a href="http://www.wangafu.net/~nickm/libevent-book/">http://www.wangafu.net/~nickm/libevent-book/</a></li>
</ol>
<h3 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h3><ol>
<li><code>libevent</code> 从入门到掌握 - 飞翔的猪: <a href="https://zhuanlan.zhihu.com/p/87562010">https://zhuanlan.zhihu.com/p/87562010</a></li>
<li><code>libevent</code> 笔记 2：Hello_World - 孙敏铭: <a href="https://www.cnblogs.com/sunminming/p/11862914.html">https://www.cnblogs.com/sunminming/p/11862914.html</a></li>
</ol>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 多线程：调试锁</title>
    <url>/post/2020/a26c1bab/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>调试锁是 <code>libevent</code> 中用户可选的一种模式，它不仅可以调用前面设置的锁函数和条件变量函数，还可以捕获使用锁时的典型错误：重新锁定一个已锁定的非递归锁、解锁一个并未持有的锁。</p>
<a id="more"></a>
<h2 id="开启调试锁"><a href="#开启调试锁" class="headerlink" title="开启调试锁"></a>开启调试锁</h2><p>开启调试锁的函数 <code>evthread_enable_lock_debuging</code> 或 <code>evthread_enable_lock_debugging，用户可直接调用，其定义如下：</code></p>
<blockquote>
<p><code>evthread_enable_lock_debuging</code> 函数为 <code>evthread_enable_lock_debugging</code> 函数的拼写错误版本。因兼容性原因进行保留。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLOBAL <span class="keyword">int</span> evthread_lock_debugging_enabled_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evthread_enable_lock_debuging</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    evthread_enable_lock_debugging();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evthread_enable_lock_debugging</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evthread_lock_callbacks</span> <span class="title">cbs</span> = &#123;</span></span><br><span class="line">        EVTHREAD_LOCK_API_VERSION,</span><br><span class="line">        EVTHREAD_LOCKTYPE_RECURSIVE,</span><br><span class="line">        debug_lock_alloc,</span><br><span class="line">        debug_lock_free,</span><br><span class="line">        debug_lock_lock,</span><br><span class="line">        debug_lock_unlock</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (evthread_lock_debugging_enabled_) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;original_lock_fns_, &amp;evthread_lock_fns_, <span class="keyword">sizeof</span>(struct evthread_lock_callbacks));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evthread_lock_fns_, &amp;cbs, <span class="keyword">sizeof</span>(struct evthread_lock_callbacks));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;original_cond_fns_, &amp;evthread_cond_fns_, <span class="keyword">sizeof</span>(struct evthread_condition_callbacks));</span><br><span class="line">    evthread_cond_fns_.wait_condition = debug_cond_wait;</span><br><span class="line">    evthread_lock_debugging_enabled_ = <span class="number">1</span>;</span><br><span class="line">    event_global_setup_locks_(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该函数中做了如下工作：</p>
<ol>
<li>定义了一个锁函数结构体 <code>cbs</code>，其中已经设定好了一系列的调试锁相关的锁函数。</li>
<li>判断 <code>_evthread_lock_debugging_enabled</code> 是否为真<ul>
<li>如果 <code>_evthread_lock_debugging_enabled</code> 是否为真，说明已经开启了调试锁，该函数直接返回</li>
<li>如果 <code>_evthread_lock_debugging_enabled</code> 是否为假，则继续以下工作</li>
</ul>
</li>
<li>备份全局锁和条件变量结构体：<ul>
<li>将 <code>evthread_lock_fns_</code> 拷贝至 <code>original_lock_fns_</code></li>
<li>将 <code>evthread_cond_fns_</code> 拷贝至 <code>original_cond_fns_</code></li>
</ul>
</li>
<li>重新设置全局锁和条件变量结构体：<ul>
<li>将 <code>cbs</code> 拷贝至 <code>evthread_lock_fns_</code></li>
<li>将 <code>evthread_cond_fns_.wait_condition</code> 赋值为 <code>debug_cond_wait</code></li>
</ul>
</li>
</ol>
<h2 id="调试锁结构"><a href="#调试锁结构" class="headerlink" title="调试锁结构"></a>调试锁结构</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">debug_lock</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> signature;</span><br><span class="line">    <span class="keyword">unsigned</span> locktype;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> held_by;</span><br><span class="line">    <span class="comment">/* XXXX if we ever use read-write locks, we will need a separate lock to protect count. */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">void</span> *lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调试锁结构体中有 5 个成员：</p>
<ul>
<li><code>signature</code>：对调试锁结构进行签名，符合签名的才被认为是合法的调试锁结构</li>
<li><code>locktype</code>：来保存用户申请的锁类型，因为调试锁中所有的锁都增加了递归属性，所以需要对原始锁类型进行保存</li>
<li><code>count</code>：对加锁次数进行计数，如果 <code>count</code> 大于 <code>1</code> 说明多次加锁，如果 <code>count</code> 小于 <code>0</code> 说明多次解锁</li>
<li><code>held_by</code>：记录持有锁的线程</li>
<li><code>lock</code>：锁变量</li>
</ul>
<h2 id="调试锁函数"><a href="#调试锁函数" class="headerlink" title="调试锁函数"></a>调试锁函数</h2><h3 id="debug-lock-alloc"><a href="#debug-lock-alloc" class="headerlink" title="debug_lock_alloc"></a>debug_lock_alloc</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">debug_lock_alloc</span><span class="params">(<span class="keyword">unsigned</span> locktype)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">debug_lock</span> *<span class="title">result</span> = <span class="title">mm_malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">debug_lock</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (original_lock_fns_.alloc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(result-&gt;lock = original_lock_fns_.alloc(locktype|EVTHREAD_LOCKTYPE_RECURSIVE))) &#123;</span><br><span class="line">            mm_free(result);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> result-&gt;lock = <span class="literal">NULL</span>;</span><br><span class="line">    result-&gt;signature = DEBUG_LOCK_SIG;</span><br><span class="line">    result-&gt;locktype = locktype;</span><br><span class="line">    result-&gt;count = <span class="number">0</span>;</span><br><span class="line">    result-&gt;held_by = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>debug_lock_alloc</code> 函数用来初始化一个调试锁，其主要工作分为三部分：</p>
<ol>
<li>申请调试锁结构体内存空间</li>
<li>调用用户定制的锁初始化函数初始化一个锁（注意此时初始化的锁增加了递归属性）</li>
<li>对调试锁结构体中的每个参数进行初始化</li>
</ol>
<h3 id="debug-lock-free"><a href="#debug-lock-free" class="headerlink" title="debug_lock_free"></a>debug_lock_free</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debug_lock_free</span><span class="params">(<span class="keyword">void</span> *lock_, <span class="keyword">unsigned</span> locktype)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">debug_lock</span> *<span class="title">lock</span> = <span class="title">lock_</span>;</span></span><br><span class="line">    EVUTIL_ASSERT(lock-&gt;count == <span class="number">0</span>);</span><br><span class="line">    EVUTIL_ASSERT(locktype == lock-&gt;locktype);</span><br><span class="line">    EVUTIL_ASSERT(DEBUG_LOCK_SIG == lock-&gt;signature);</span><br><span class="line">    <span class="keyword">if</span> (original_lock_fns_.<span class="built_in">free</span>) &#123;</span><br><span class="line">        original_lock_fns_.<span class="built_in">free</span>(lock-&gt;lock, lock-&gt;locktype|EVTHREAD_LOCKTYPE_RECURSIVE);</span><br><span class="line">    &#125;</span><br><span class="line">    lock-&gt;lock = <span class="literal">NULL</span>;</span><br><span class="line">    lock-&gt;count = <span class="number">-100</span>;</span><br><span class="line">    lock-&gt;signature = <span class="number">0x12300fda</span>;</span><br><span class="line">    mm_free(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>debug_lock_alloc</code> 函数用来销毁一个调试锁，其主要工作分为三部分：</p>
<ol>
<li>调试锁参数的检查<blockquote>
<p>调试锁参数的检查过程中调用了 <code>EVUTIL_ASSERT</code> 宏，该宏是 <code>libevent</code> 对 <code>assert</code> 函数的一个封装，功能类似。</p>
</blockquote>
</li>
<li>调用用户定制的锁销毁函数销毁一个锁（注意此时销毁的锁增加了递归属性）</li>
<li>释放调试锁结构体内存空间</li>
</ol>
<h3 id="debug-lock-lock"><a href="#debug-lock-lock" class="headerlink" title="debug_lock_lock"></a>debug_lock_lock</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">debug_lock_lock</span><span class="params">(<span class="keyword">unsigned</span> mode, <span class="keyword">void</span> *lock_)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">debug_lock</span> *<span class="title">lock</span> = <span class="title">lock_</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lock-&gt;locktype &amp; EVTHREAD_LOCKTYPE_READWRITE) EVUTIL_ASSERT(mode &amp; (EVTHREAD_READ|EVTHREAD_WRITE));</span><br><span class="line">    <span class="keyword">else</span> EVUTIL_ASSERT((mode &amp; (EVTHREAD_READ|EVTHREAD_WRITE)) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (original_lock_fns_.lock) res = original_lock_fns_.lock(mode, lock-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (!res) evthread_debug_lock_mark_locked(mode, lock);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>debug_lock_lock</code> 函数用来对一个调试锁执行加锁操作，其主要工作分为三部分：</p>
<ol>
<li>参数的检查：<ul>
<li>如果锁模式是读写锁，则 <code>mode</code> 类型必须携带 <code>EVTHREAD_READ</code> 或 <code>EVTHREAD_WRITE</code> 标志位</li>
<li>如果锁模式是非读写锁，则 <code>mode</code> 类型不能携带 <code>EVTHREAD_READ</code> 和 <code>EVTHREAD_WRITE</code> 标志位</li>
</ul>
</li>
<li>调用用户定制的加锁函数进行加锁</li>
<li>如果加锁成功则调用 <code>evthread_debug_lock_mark_locked</code> 函数检测加锁错误并对调试锁结构体进行修改</li>
</ol>
<h4 id="evthread-debug-lock-mark-locked"><a href="#evthread-debug-lock-mark-locked" class="headerlink" title="evthread_debug_lock_mark_locked"></a>evthread_debug_lock_mark_locked</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evthread_debug_lock_mark_locked</span><span class="params">(<span class="keyword">unsigned</span> mode, struct debug_lock *lock)</span> </span>&#123;</span><br><span class="line">    EVUTIL_ASSERT(DEBUG_LOCK_SIG == lock-&gt;signature);</span><br><span class="line">    ++lock-&gt;count;</span><br><span class="line">    <span class="keyword">if</span> (!(lock-&gt;locktype &amp; EVTHREAD_LOCKTYPE_RECURSIVE)) EVUTIL_ASSERT(lock-&gt;count == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (evthread_id_fn_) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> me;</span><br><span class="line">        me = evthread_id_fn_();</span><br><span class="line">        <span class="keyword">if</span> (lock-&gt;count &gt; <span class="number">1</span>) EVUTIL_ASSERT(lock-&gt;held_by == me);</span><br><span class="line">        lock-&gt;held_by = me;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evthread_debug_lock_mark_locked</code> 函数有两个作用：检测加锁错误并对调试锁结构体进行修改。</p>
<p>检测的加锁错误有以下三种：</p>
<ol>
<li>初始化检测 / 锁变量检测：调试锁签名不正确</li>
<li>重复加锁检测：对于非递归锁，加锁后 <code>count</code> 值不为 <code>1</code></li>
<li>不同线程申请同一递归锁检测：<code>count</code> 值大于 <code>1</code> 的情况下，<code>held_by</code> 的线程 <code>id</code> 和当前线程 <code>id</code> 不一致</li>
</ol>
<p>修改调试锁结构体：</p>
<ol>
<li><code>count</code> 值自增</li>
<li><code>held_by</code> 值设置为当前线程 <code>id</code></li>
</ol>
<h3 id="debug-lock-unlock"><a href="#debug-lock-unlock" class="headerlink" title="debug_lock_unlock"></a>debug_lock_unlock</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">debug_lock_unlock</span><span class="params">(<span class="keyword">unsigned</span> mode, <span class="keyword">void</span> *lock_)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">debug_lock</span> *<span class="title">lock</span> = <span class="title">lock_</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    evthread_debug_lock_mark_unlocked(mode, lock);</span><br><span class="line">    <span class="keyword">if</span> (original_lock_fns_.unlock) res = original_lock_fns_.unlock(mode, lock-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试锁的解锁函数也是会调用用户定制的解锁函数，需要注意调试锁的解锁与加锁流程区别：调试锁的解锁操作会在调用用户定制的解锁函数之前，先调用 <code>evthread_debug_lock_mark_unlocked</code> 函数进行解锁检测，而调试锁的加锁操作是在调用用户定制的加锁函数后调用加锁检测函数。</p>
<h4 id="evthread-debug-lock-mark-unlocked"><a href="#evthread-debug-lock-mark-unlocked" class="headerlink" title="evthread_debug_lock_mark_unlocked"></a>evthread_debug_lock_mark_unlocked</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evthread_debug_lock_mark_unlocked</span><span class="params">(<span class="keyword">unsigned</span> mode, struct debug_lock *lock)</span> </span>&#123;</span><br><span class="line">    EVUTIL_ASSERT(DEBUG_LOCK_SIG == lock-&gt;signature);</span><br><span class="line">    <span class="keyword">if</span> (lock-&gt;locktype &amp; EVTHREAD_LOCKTYPE_READWRITE) EVUTIL_ASSERT(mode &amp; (EVTHREAD_READ|EVTHREAD_WRITE));</span><br><span class="line">    <span class="keyword">else</span> EVUTIL_ASSERT((mode &amp; (EVTHREAD_READ|EVTHREAD_WRITE)) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (evthread_id_fn_) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> me;</span><br><span class="line">        me = evthread_id_fn_();</span><br><span class="line">        EVUTIL_ASSERT(lock-&gt;held_by == me);</span><br><span class="line">        <span class="keyword">if</span> (lock-&gt;count == <span class="number">1</span>) lock-&gt;held_by = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --lock-&gt;count;</span><br><span class="line">    EVUTIL_ASSERT(lock-&gt;count &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evthread_debug_lock_mark_unlocked</code> 函数作用与 <code>evthread_debug_lock_mark_locked</code> 函数类似：检测解锁错误并对调试锁结构体进行修改。</p>
<p>检测的解锁错误有以下四种：</p>
<ol>
<li>初始化检测 / 锁变量检测：调试锁签名不正确</li>
<li>解锁模式的检测：加锁时对加锁模式的检测是在 <code>debug_lock_lock</code> 函数中</li>
<li>解锁线程的检测：加解锁必须为同一个线程</li>
<li>加锁次数检测：未加锁的锁禁止解锁</li>
</ol>
<p>修改调试锁结构体：</p>
<ol>
<li><code>count</code> 值自减</li>
<li>如果解锁后该锁完全解锁，则将 <code>held_by</code> 值设置 <code>0</code></li>
</ol>
<h3 id="debug-cond-wait"><a href="#debug-cond-wait" class="headerlink" title="debug_cond_wait"></a>debug_cond_wait</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">debug_cond_wait</span><span class="params">(<span class="keyword">void</span> *cond_, <span class="keyword">void</span> *lock_, <span class="keyword">const</span> struct timeval *tv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">debug_lock</span> *<span class="title">lock</span> = <span class="title">lock_</span>;</span></span><br><span class="line">    EVUTIL_ASSERT(lock);</span><br><span class="line">    EVUTIL_ASSERT(DEBUG_LOCK_SIG == lock-&gt;signature);</span><br><span class="line">    EVLOCK_ASSERT_LOCKED(lock_);</span><br><span class="line">    evthread_debug_lock_mark_unlocked(<span class="number">0</span>, lock);</span><br><span class="line">    r = original_cond_fns_.wait_condition(cond_, lock-&gt;lock, tv);</span><br><span class="line">    evthread_debug_lock_mark_locked(<span class="number">0</span>, lock);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条件变量函数中，<code>alloc</code>、<code>free</code>、<code>wait</code>、<code>signal</code> 四个函数，其中 <code>alloc</code>、<code>free</code>、<code>signal</code> 都仅仅涉及到条件变量的操作，而 <code>wait</code> 函数却不同，<code>wait</code> 函数需要将已加锁的锁先进行解锁然后阻塞，直到等到唤醒消息时再重新持有锁，所以在调试锁时，有必要对 <code>wait</code> 函数进行修改。</p>
<p><code>debug_cond_wait</code> 函数的作用比较简单：</p>
<ol>
<li>对基本参数进行检测</li>
<li>调用 <code>evthread_debug_lock_mark_unlocked</code> 检测解锁错误并对调试锁结构体进行修改</li>
<li>调用用户定制的条件变量 <code>wait</code> 函数等待条件唤醒</li>
<li>调用 <code>evthread_debug_lock_mark_locked</code> 检测加锁错误并对调试锁结构体进行修改</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/qq_28114615/article/details/90451936">libevent 源码学习（4）：线程锁、条件变量（二）（调试锁）_HerofH_的博客 - CSDN 博客</a></li>
<li>[2] <a href="https://blog.csdn.net/luotuo44/article/details/38360525">Libevent 源码分析 - 多线程、锁、条件变量 (二)_luotuo44 的专栏 - CSDN 博客</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 多线程：锁和条件变量</title>
    <url>/post/2020/52b3bda8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>libevent</code> 的多线程接口文件相比日志模块和内存管理模块文件较多，可大致分为三部分：</p>
<ol>
<li>内部接口所在头文件：<code>evthread-internal.h</code></li>
<li>外部接口所在头文件：<code>thread.h</code></li>
<li>接口实现所在文件：<code>evthread.c</code> &amp; <code>evthread_pthread.c</code> &amp; <code>evthread_win32.c</code></li>
</ol>
<a id="more"></a>
<h2 id="开启多线程"><a href="#开启多线程" class="headerlink" title="开启多线程"></a>开启多线程</h2><p><code>libevent</code> 的多线程模块与日志模块和内存管理模块不同，在默认的情况下并没有进行实现，而是仅仅提供了函数接口，即 <code>libevent</code> 在默认情况下是不支持多线程的。</p>
<p>如果要让 <code>libevent</code> 支持多线程，则需要在使用 <code>libevent</code> 之前，即在调用 <code>event_base_new</code> 函数之前调用 <code>evthread_use_windows_threads()</code> 或 <code>evthread_use_pthreads()</code> 或 <code>evthread_set_lock_callbacks</code> 函数定制自己的多线程、锁、条件变量才会开启多线程功能。</p>
<p>以上三个线程定制函数均定义在 <code>thread.h</code>，而线程的使用接口定义在 <code>evthread-internal.h</code>，即对于用户来说，只能定制 <code>libevent</code> 的线程函数，而这些函数的使用方式还是由 <code>libevent</code> 自行管理的。</p>
<h2 id="锁和条件变量结构体"><a href="#锁和条件变量结构体" class="headerlink" title="锁和条件变量结构体"></a>锁和条件变量结构体</h2><p><code>libevent</code> 允许用户定制自己的锁和条件变量。其实现原理和日志和内存分配一样，都是内部有一个全局变量，全局变量中保存着自己定制的相关功能实现函数。而要定制自己的锁和条件变量，就是对这个全局变量进行赋值。</p>
<p><code>libevent</code> 中锁和条件变量定制对应的全局变量如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evthread_lock_callbacks</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> lock_api_version;</span><br><span class="line">    <span class="keyword">unsigned</span> supported_locktypes;</span><br><span class="line">    <span class="keyword">void</span> *(*alloc)(<span class="keyword">unsigned</span> locktype);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *lock, <span class="keyword">unsigned</span> locktype);</span><br><span class="line">    <span class="keyword">int</span> (*lock)(<span class="keyword">unsigned</span> mode, <span class="keyword">void</span> *lock);</span><br><span class="line">    <span class="keyword">int</span> (*unlock)(<span class="keyword">unsigned</span> mode, <span class="keyword">void</span> *lock);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evthread_condition_callbacks</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> condition_api_version;</span><br><span class="line">    <span class="keyword">void</span> *(*alloc_condition)(<span class="keyword">unsigned</span> condtype);</span><br><span class="line">    <span class="keyword">void</span> (*free_condition)(<span class="keyword">void</span> *cond);</span><br><span class="line">    <span class="keyword">int</span> (*signal_condition)(<span class="keyword">void</span> *cond, <span class="keyword">int</span> broadcast);</span><br><span class="line">    <span class="keyword">int</span> (*wait_condition)(<span class="keyword">void</span> *cond, <span class="keyword">void</span> *lock, <span class="keyword">const</span> struct timeval *timeout);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GLOBAL <span class="class"><span class="keyword">struct</span> <span class="title">evthread_lock_callbacks</span> <span class="title">evthread_lock_fns_</span> = &#123;</span><span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">GLOBAL <span class="class"><span class="keyword">struct</span> <span class="title">evthread_condition_callbacks</span> <span class="title">evthread_cond_fns_</span> = &#123;</span><span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>该全局变量结构体中每个参数意义如下:</p>
<ol>
<li><code>evthread_lock_fns_</code><ul>
<li><code>.lock_api_version</code> 锁函数的版本</li>
<li><code>.supported_locktypes</code> 指示支持的锁类型</li>
<li><code>.alloc</code> 初始化（申请）一个锁</li>
<li><code>.free</code> 反初始化（销毁）一个锁</li>
<li><code>.lock</code> 加锁</li>
<li><code>.unlock</code> 解锁</li>
</ul>
</li>
<li><code>evthread_cond_fns_</code><ul>
<li><code>.condition_api_version</code> 条件变量函数版本</li>
<li><code>.alloc_condition</code> 初始化（申请）一个条件变量</li>
<li><code>.free_condition</code> 反初始化（销毁）一个条件变量</li>
<li><code>.signal_condition</code> 通知</li>
<li><code>.wait_condition</code> 等待通知</li>
</ul>
</li>
</ol>
<h2 id="libevent-提供的多线程函数"><a href="#libevent-提供的多线程函数" class="headerlink" title="libevent 提供的多线程函数"></a>libevent 提供的多线程函数</h2><p>对于用户来说，如果想让 <code>libevent</code> 支持多线程。<code>Windows</code> 用户直接调用 <code>evthread_use_windows_threads()</code>，遵循 <code>POSIX</code> 标准的系统直接调用 <code>evthread_use_pthreads()</code> 就可以了。</p>
<p>在 <code>Linux 2.6</code> 以上版本中，已经对 <code>pthread</code> 线程有了完善的支持，以下我们就分析一下 <code>libevent</code> 提供的多线程函数 <code>evthread_use_pthreads()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVTHREAD_LOCK_API_VERSION 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVTHREAD_LOCKTYPE_RECURSIVE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVTHREAD_CONDITION_API_VERSION 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutexattr_t</span> attr_recursive;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_use_pthreads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evthread_lock_callbacks</span> <span class="title">cbs</span> = &#123;</span></span><br><span class="line">        EVTHREAD_LOCK_API_VERSION,</span><br><span class="line">        EVTHREAD_LOCKTYPE_RECURSIVE,</span><br><span class="line">        evthread_posix_lock_alloc,</span><br><span class="line">        evthread_posix_lock_free,</span><br><span class="line">        evthread_posix_lock,</span><br><span class="line">        evthread_posix_unlock</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evthread_condition_callbacks</span> <span class="title">cond_cbs</span> = &#123;</span></span><br><span class="line">        EVTHREAD_CONDITION_API_VERSION,</span><br><span class="line">        evthread_posix_cond_alloc,</span><br><span class="line">        evthread_posix_cond_free,</span><br><span class="line">        evthread_posix_cond_signal,</span><br><span class="line">        evthread_posix_cond_wait</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* Set ourselves up to get recursive locks. */</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutexattr_init(&amp;attr_recursive)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pthread_mutexattr_settype(&amp;attr_recursive, PTHREAD_MUTEX_RECURSIVE)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    evthread_set_lock_callbacks(&amp;cbs);</span><br><span class="line">    evthread_set_condition_callbacks(&amp;cond_cbs);</span><br><span class="line">    evthread_set_id_callback(evthread_posix_get_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可看出，<code>evthread_use_pthreads</code> 函数主要有三个步骤：</p>
<ol>
<li>定义并初始化了一个 <code>evthread_lock_callbacks</code> 结构体和一个 <code>evthread_condition_callbacks</code> 结构体，以便后续定制修改全局锁和条件变量结构体</li>
<li>初始化全局变量 <code>attr_recursive</code>，这个变量会在初始化锁时被传递，代表需要申请锁的属性，在该函数里其被设置成为递归属性。</li>
<li>调用全局锁和条件变量结构体的 <code>set</code> 函数将步骤 1 中的结构体赋值到全局变量中。</li>
</ol>
<h3 id="锁相关函数"><a href="#锁相关函数" class="headerlink" title="锁相关函数"></a>锁相关函数</h3><h4 id="evthread-posix-lock-alloc"><a href="#evthread-posix-lock-alloc" class="headerlink" title="evthread_posix_lock_alloc"></a>evthread_posix_lock_alloc</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">evthread_posix_lock_alloc</span><span class="params">(<span class="keyword">unsigned</span> locktype)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> *attr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> *lock = mm_malloc(<span class="keyword">sizeof</span>(<span class="keyword">pthread_mutex_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (!lock) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (locktype &amp; EVTHREAD_LOCKTYPE_RECURSIVE) attr = &amp;attr_recursive;</span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_init(lock, attr)) &#123;</span><br><span class="line">        mm_free(lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evthread_posix_lock_alloc</code> 函数封装了 <code>pthread_mutex_init</code> 函数，根据传入参数 <code>locktype</code> 不同，创建不同类型的锁：</p>
<ul>
<li><code>locktype == 0</code> ：创建普通互斥锁</li>
<li><code>locktype == EVTHREAD_LOCKTYPE_RECURSIVE</code> ：创建递归锁</li>
<li><code>locktype == EVTHREAD_LOCKTYPE_READWRITE</code> ：创建读写锁（<code>evthread_posix_lock_alloc</code> 函数中未实现）</li>
</ul>
<h4 id="evthread-posix-lock-free"><a href="#evthread-posix-lock-free" class="headerlink" title="evthread_posix_lock_free"></a>evthread_posix_lock_free</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evthread_posix_lock_free</span><span class="params">(<span class="keyword">void</span> *lock_, <span class="keyword">unsigned</span> locktype)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> *lock = lock_;</span><br><span class="line">    pthread_mutex_destroy(lock);</span><br><span class="line">    mm_free(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evthread_posix_lock_free</code> 函数对 <code>pthread_mutex_destroy</code> 函数进行了封装。</p>
<h4 id="evthread-posix-lock"><a href="#evthread-posix-lock" class="headerlink" title="evthread_posix_lock"></a>evthread_posix_lock</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evthread_posix_lock</span><span class="params">(<span class="keyword">unsigned</span> mode, <span class="keyword">void</span> *lock_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> *lock = lock_;</span><br><span class="line">    <span class="keyword">if</span> (mode &amp; EVTHREAD_TRY) <span class="keyword">return</span> pthread_mutex_trylock(lock);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> pthread_mutex_lock(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evthread_posix_lock</code> 对 <code>pthread</code> 的 <code>lock</code> 相关函数进行了封装：</p>
<ul>
<li>当 <code>mode == 0</code> 时，相当于调用 <code>pthread_mutex_lock</code> 函数</li>
<li>当 <code>mode == EVTHREAD_TRY</code> 时，相当于调用 <code>pthread_mutex_trylock</code> 函数</li>
</ul>
<h4 id="evthread-posix-unlock"><a href="#evthread-posix-unlock" class="headerlink" title="evthread_posix_unlock"></a>evthread_posix_unlock</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evthread_posix_unlock</span><span class="params">(<span class="keyword">unsigned</span> mode, <span class="keyword">void</span> *lock_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> *lock = lock_;</span><br><span class="line">    <span class="keyword">return</span> pthread_mutex_unlock(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evthread_posix_unlock</code> 函数对 <code>pthread_mutex_unlock</code> 函数进行了封装。</p>
<h3 id="条件变量相关函数"><a href="#条件变量相关函数" class="headerlink" title="条件变量相关函数"></a>条件变量相关函数</h3><h4 id="evthread-posix-cond-alloc"><a href="#evthread-posix-cond-alloc" class="headerlink" title="evthread_posix_cond_alloc"></a>evthread_posix_cond_alloc</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">evthread_posix_cond_alloc</span><span class="params">(<span class="keyword">unsigned</span> condflags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> *cond = mm_malloc(<span class="keyword">sizeof</span>(<span class="keyword">pthread_cond_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (!cond) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pthread_cond_init(cond, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        mm_free(cond);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cond;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evthread_posix_cond_alloc</code> 函数对 <code>pthread_cond_init</code> 函数进行了封装。</p>
<h4 id="evthread-posix-cond-free"><a href="#evthread-posix-cond-free" class="headerlink" title="evthread_posix_cond_free"></a>evthread_posix_cond_free</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evthread_posix_cond_free</span><span class="params">(<span class="keyword">void</span> *cond_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> *cond = cond_;</span><br><span class="line">    pthread_cond_destroy(cond);</span><br><span class="line">    mm_free(cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evthread_posix_cond_free</code> 函数对 <code>pthread_cond_destroy</code> 函数进行了封装。</p>
<h4 id="evthread-posix-cond-signal"><a href="#evthread-posix-cond-signal" class="headerlink" title="evthread_posix_cond_signal"></a>evthread_posix_cond_signal</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evthread_posix_cond_signal</span><span class="params">(<span class="keyword">void</span> *cond_, <span class="keyword">int</span> broadcast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> *cond = cond_;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (broadcast) r = pthread_cond_broadcast(cond);</span><br><span class="line">    <span class="keyword">else</span> r = pthread_cond_signal(cond);</span><br><span class="line">    <span class="keyword">return</span> r ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evthread_posix_cond_signal</code> 函数对 <code>pthread</code> 的通知相关函数进行了封装：</p>
<ul>
<li>当 <code>broadcast == 0</code> 时，相当于调用 <code>pthread_cond_signal</code> 函数</li>
<li>当 <code>broadcast != 0</code> 时，相当于调用 <code>pthread_cond_broadcast</code> 函数</li>
</ul>
<h4 id="evthread-posix-cond-wait"><a href="#evthread-posix-cond-wait" class="headerlink" title="evthread_posix_cond_wait"></a>evthread_posix_cond_wait</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evthread_posix_cond_wait</span><span class="params">(<span class="keyword">void</span> *cond_, <span class="keyword">void</span> *lock_, <span class="keyword">const</span> struct timeval *tv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> *cond = cond_;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> *lock = lock_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tv) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>, <span class="title">abstime</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">        evutil_gettimeofday(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">        evutil_timeradd(&amp;now, tv, &amp;abstime);</span><br><span class="line">        ts.tv_sec = abstime.tv_sec;</span><br><span class="line">        ts.tv_nsec = abstime.tv_usec*<span class="number">1000</span>;</span><br><span class="line">        r = pthread_cond_timedwait(cond, lock, &amp;ts);</span><br><span class="line">        <span class="keyword">if</span> (r == ETIMEDOUT) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = pthread_cond_wait(cond, lock);</span><br><span class="line">        <span class="keyword">return</span> r ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evthread_posix_cond_signal</code> 函数对 <code>pthread</code> 的等待通知相关函数进行了封装：</p>
<ul>
<li>当 <code>tv == 0</code> 时，相当于调用 <code>pthread_cond_wait</code> 函数</li>
<li>当 <code>tv != 0</code> 时，相当于调用 <code>pthread_cond_timedwait</code> 函数<blockquote>
<p>需要注意的是：<code>evthread_posix_cond_wait</code> 的时间参数是相对时间，而 <code>pthread_cond_timedwait</code> 函数的时间参数是绝对时间，<code>evthread_posix_cond_wait</code> 在内部对两种时间进行了转换，要注意在调用 <code>evthread_posix_cond_wait</code> 时不要使用绝对时间！</p>
</blockquote>
</li>
</ul>
<h3 id="定制函数设置相关函数"><a href="#定制函数设置相关函数" class="headerlink" title="定制函数设置相关函数"></a>定制函数设置相关函数</h3><h4 id="evthread-set-lock-callbacks-和-evthread-set-condition-callbacks"><a href="#evthread-set-lock-callbacks-和-evthread-set-condition-callbacks" class="headerlink" title="evthread_set_lock_callbacks 和 evthread_set_condition_callbacks"></a>evthread_set_lock_callbacks 和 evthread_set_condition_callbacks</h4><p><code>evthread_set_lock_callbacks</code> 和 <code>evthread_set_condition_callbacks</code> 函数实现极其相似，本文中给出 <code>evthread_set_lock_callbacks</code> 的实现代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">evthread_set_lock_callbacks(<span class="keyword">const</span> struct evthread_lock_callbacks *cbs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evthread_lock_callbacks</span> *<span class="title">target</span> = <span class="title">evthread_get_lock_callbacks</span>();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event_debug_mode_on_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event_debug_created_threadable_ctx_) &#123;</span><br><span class="line">            event_errx(<span class="number">1</span>, <span class="string">&quot;evthread initialization must be called BEFORE anything else!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target-&gt;alloc)</span><br><span class="line">            event_warnx(<span class="string">&quot;Trying to disable lock functions after they have been set up will probaby not work.&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(target, <span class="number">0</span>, <span class="keyword">sizeof</span>(evthread_lock_fns_));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target-&gt;alloc) &#123;</span><br><span class="line">        <span class="comment">/* Uh oh; we already had locking callbacks set up.*/</span></span><br><span class="line">        <span class="keyword">if</span> (target-&gt;lock_api_version == cbs-&gt;lock_api_version &amp;&amp;</span><br><span class="line">            target-&gt;supported_locktypes == cbs-&gt;supported_locktypes &amp;&amp;</span><br><span class="line">            target-&gt;alloc == cbs-&gt;alloc &amp;&amp;</span><br><span class="line">            target-&gt;<span class="built_in">free</span> == cbs-&gt;<span class="built_in">free</span> &amp;&amp;</span><br><span class="line">            target-&gt;lock == cbs-&gt;lock &amp;&amp;</span><br><span class="line">            target-&gt;unlock == cbs-&gt;unlock) &#123;</span><br><span class="line">            <span class="comment">/* no change -- allow this. */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        event_warnx(<span class="string">&quot;Can&#x27;t change lock callbacks once they have been initialized.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cbs-&gt;alloc &amp;&amp; cbs-&gt;<span class="built_in">free</span> &amp;&amp; cbs-&gt;lock &amp;&amp; cbs-&gt;unlock) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(target, cbs, <span class="keyword">sizeof</span>(evthread_lock_fns_));</span><br><span class="line">        <span class="keyword">return</span> event_global_setup_locks_(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出 <code>evthread_set_lock_callbacks</code> 函数做了以下工作：</p>
<ol>
<li>获取全局锁结构体地址：<code>evthread_get_lock_callbacks()</code><blockquote>
<p>全局锁结构体在开启、关闭调试锁时所对应的变量不同，具体可参考：<a href="/post/2020/a26c1bab/" title="源码阅读 libevent - 多线程：调试锁">源码阅读 libevent - 多线程：调试锁</a></p>
<pre><code> * 如果没有开启调试锁，全局锁结构体对应全局变量 evthread_lock_fns_
 * 如果开启调试锁，全局锁结构体对应全局变量 original_lock_fns_
</code></pre></blockquote>
</li>
<li>如果传入定制函数结构体指针为空：<ul>
<li>如果当前全局锁结构体未设置，则对该结构体进行清 0 操作</li>
<li>如果当前全局锁结构体已设置，则会先输出警告日志后，对该结构体进行清 0 操作</li>
</ul>
</li>
<li>如果传入的结构体指针不为空<ul>
<li>如果当前全局锁结构体未设置<ul>
<li>结构体中所有函数指针均指向非空，设置全局锁结构体成功</li>
<li>结构体中所有函数指针存在空指针，设置全局锁结构体失败</li>
</ul>
</li>
<li>如果当前全局锁结构体已设置<ul>
<li>传入的结构体与当前全局锁结构体完全一致，设置全局锁结构体成功</li>
<li>传入的结构体与当前全局锁结构体不完全一致，设置全局锁结构体失败</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="evthread-set-id-callback"><a href="#evthread-set-id-callback" class="headerlink" title="evthread_set_id_callback"></a>evthread_set_id_callback</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evthread_set_id_callback</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> (*id_fn)(<span class="keyword">void</span>))</span> </span>&#123;</span><br><span class="line">    evthread_id_fn_ = id_fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evthread_set_id_callback</code> 函数看上去非常简单，就是让 <code>_evthread_id_fn</code> 这个全局变量指向了传入的函数指针参数，在 <code>evthread_use_pthreads</code> 函数的实现中，传入参数为 <code>evthread_posix_get_id</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">evthread_posix_get_id</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> thr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> EVENT__SIZEOF_PTHREAD_T &gt; EVENT__SIZEOF_LONG</span></span><br><span class="line">        <span class="keyword">ev_uint64_t</span> id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; r;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> EVENT__SIZEOF_PTHREAD_T &lt; EVENT__SIZEOF_LONG</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;r, <span class="number">0</span>, <span class="keyword">sizeof</span>(r));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    r.thr = pthread_self();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)r.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evthread_posix_get_id</code> 函数中 <code>r</code> 是一个联合体，有两个成员 <code>thr</code> 和 <code>id</code>，联合体的特点是联合体内部的成员地址是相同的，然后看到 <code>r.thr = pthread_self()</code>，这是获取当前线程的 <code>id</code> 然后放到 <code>thr</code> 中，由于 <code>r.id</code> 与 <code>r.thr</code> 地址相同，而 <code>pthread_t</code> 本身就是 <code>unsigned long</code> 类型，因此实际上返回的 <code>r.id</code> 就等于获取到的线程 <code>id</code>。</p>
<p>由此也可以知道：<code>evthread_set_id_callback</code> 函数就是用来指定获取当前线程 <code>id</code> 的函数。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/luotuo44/article/details/38350633">Libevent 源码分析 - 多线程、锁、条件变量 (一)_luotuo44 的专栏 - CSDN 博客</a></li>
<li>[2] <a href="http://www.wangafu.net/~nickm/libevent-book/Ref1_libsetup.html">http://www.wangafu.net/~nickm/libevent-book/Ref1_libsetup.html</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 工作流程分析</title>
    <url>/post/2020/dd5b304b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前的小节讲了很多 <code>libevent</code> 的基础构件，现在以一个实际例子来初步探究 <code>libevent</code> 的基本工作流程。</p>
<a id="more"></a>
<h2 id="libevent-工作流程分析"><a href="#libevent-工作流程分析" class="headerlink" title="libevent 工作流程分析"></a>libevent 工作流程分析</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmd_cb</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">short</span> events, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in the cmd_cb\n&quot;</span>);</span><br><span class="line">    <span class="built_in">read</span>(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    evthread_use_pthreads();</span><br><span class="line">    <span class="comment">// 使用默认的 event_base 配置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">event_base_new</span>();</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">cmd_ev</span> = <span class="title">event_new</span>(<span class="title">base</span>, <span class="title">STDIN_FILENO</span>,</span></span><br><span class="line"><span class="class">                                     <span class="title">EV_READ</span> | <span class="title">EV_PERSIST</span>, <span class="title">cmd_cb</span>, <span class="title">NULL</span>);</span></span><br><span class="line">    event_add(cmd_ev, <span class="literal">NULL</span>); <span class="comment">// 没有超时</span></span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子非常简单，却已经包含了 <code>libevent</code> 的基础工作流程：</p>
<ol>
<li><code>event_base_new()</code></li>
<li><code>event_new()</code></li>
<li><code>event_add()</code></li>
<li><code>event_base_dispatch()</code></li>
</ol>
<h3 id="evthread-use-pthreads"><a href="#evthread-use-pthreads" class="headerlink" title="evthread_use_pthreads"></a>evthread_use_pthreads</h3><p><code>evthread_use_pthreads()</code> 开启多线程支持。</p>
<blockquote>
<p>参见：<a href="/post/2020/52b3bda8/" title="源码阅读 libevent - 多线程：锁和条件变量">源码阅读 libevent - 多线程：锁和条件变量</a></p>
</blockquote>
<h3 id="event-base-new"><a href="#event-base-new" class="headerlink" title="event_base_new"></a>event_base_new</h3><p><code>event_base_new()</code> 构造一个 <code>event_base</code> 对象。</p>
<blockquote>
<p>参见：<a href="/post/2020/1a2a4fe3/" title="源码阅读 libevent - 创建 event_base">源码阅读 libevent - 创建 event_base</a></p>
</blockquote>
<h3 id="event-new"><a href="#event-new" class="headerlink" title="event_new"></a>event_new</h3><p><code>event_new()</code> 创建一个 <code>event</code> 事件。</p>
<h3 id="event-add"><a href="#event-add" class="headerlink" title="event_add"></a>event_add</h3><p><code>event_add()</code> 将 <code>event</code> 事件加入到 <code>event_base</code> 对象中。</p>
<blockquote>
<p>参见：<a href="/post/2020/afa6fb2f/" title="源码阅读 libevent - 结构体：event">源码阅读 libevent - 结构体：event</a></p>
</blockquote>
<h3 id="event-base-dispatch"><a href="#event-base-dispatch" class="headerlink" title="event_base_dispatch"></a>event_base_dispatch</h3><p><code>event_base_dispatch()</code> 开始监听 <code>event</code> 事件发生。</p>
<blockquote>
<p>参见：<a href="/post/2020/f65e9050/" title="源码阅读 libevent - 事件主循环">源码阅读 libevent - 事件主循环</a></p>
</blockquote>
<h2 id="源码学习流程"><a href="#源码学习流程" class="headerlink" title="源码学习流程"></a>源码学习流程</h2><h3 id="该博客文章建议阅读顺序"><a href="#该博客文章建议阅读顺序" class="headerlink" title="该博客文章建议阅读顺序"></a>该博客文章建议阅读顺序</h3><ul>
<li><a href="/post/2020/a867e274/" title="源码阅读 libevent - 初识 Hello World">源码阅读 libevent - 初识 Hello World</a></li>
<li><a href="/post/2020/5f35962e/" title="源码阅读 libevent - 日志模块">源码阅读 libevent - 日志模块</a></li>
<li><a href="/post/2020/58deb66e/" title="源码阅读 libevent - 内存管理">源码阅读 libevent - 内存管理</a></li>
<li><a href="/post/2020/52b3bda8/" title="源码阅读 libevent - 多线程：锁和条件变量">源码阅读 libevent - 多线程：锁和条件变量</a></li>
<li><a href="/post/2020/a26c1bab/" title="源码阅读 libevent - 多线程：调试锁">源码阅读 libevent - 多线程：调试锁</a></li>
<li><a href="/post/2020/ee7292d/" title="源码阅读 libevent - 数据结构：双向链表">源码阅读 libevent - 数据结构：双向链表</a></li>
<li><a href="/post/2020/e6338d04/" title="源码阅读 libevent - 数据结构：尾队列">源码阅读 libevent - 数据结构：尾队列</a></li>
<li><a href="/post/2020/542e4e52/" title="源码阅读 libevent - 数据结构：哈希表">源码阅读 libevent - 数据结构：哈希表</a></li>
<li><a href="/post/2020/517d2de7/" title="源码阅读 libevent - 结构体：event_io_map">源码阅读 libevent - 结构体：event_io_map</a></li>
<li><a href="/post/2020/a24039d7/" title="源码阅读 libevent - 结构体：event_signal_map">源码阅读 libevent - 结构体：event_signal_map</a></li>
<li><a href="/post/2020/1a2a4fe3/" title="源码阅读 libevent - 创建 event_base">源码阅读 libevent - 创建 event_base</a></li>
<li><a href="/post/2020/afa6fb2f/" title="源码阅读 libevent - 结构体：event">源码阅读 libevent - 结构体：event</a></li>
<li><a href="/post/2020/c8f9ab4c/" title="源码阅读 libevent - 结构体：event_once">源码阅读 libevent - 结构体：event_once</a></li>
<li><a href="/post/2020/f65e9050/" title="源码阅读 libevent - 事件主循环">源码阅读 libevent - 事件主循环</a></li>
<li><a href="/post/2020/3a941cca/" title="源码阅读 libevent - 数据结构：小根堆">源码阅读 libevent - 数据结构：小根堆</a></li>
<li><a href="/post/2020/97886769/" title="源码阅读 libevent - 超时管理：min_heap">源码阅读 libevent - 超时管理：min_heap</a></li>
<li><a href="/post/2020/89de67d/" title="源码阅读 libevent - 信号事件处理">源码阅读 libevent - 信号事件处理</a></li>
<li><a href="/post/2020/dd5b304b/" title="源码阅读 libevent - 工作流程分析">源码阅读 libevent - 工作流程分析</a></li>
<li><a href="/post/2020/27de5435/" title="源码阅读 libevent - 优先级管理">源码阅读 libevent - 优先级管理</a></li>
<li><a href="/post/2020/39d8a9e7/" title="源码阅读 libevent - 时间管理">源码阅读 libevent - 时间管理</a>
</li>
</ul>
<h3 id="待完成文章"><a href="#待完成文章" class="headerlink" title="待完成文章"></a>待完成文章</h3><p>因为有新系列文章计划，该系列文章仍会持续更新，但不会很频繁了。</p>
<ul>
<li>源码阅读 libevent - 超时管理：common timeout</li>
<li>源码阅读 libevent - 通知机制</li>
<li>未完待续</li>
</ul>
<h3 id="其他资料整理"><a href="#其他资料整理" class="headerlink" title="其他资料整理"></a>其他资料整理</h3><p>本文是我在阅读源码过程中，对自己学习情况的一个记录，学习过程中参考了很多资料，也对所有资料的作者表示感谢：</p>
<ul>
<li><a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
<li><a href="https://github.com/KelvinYin/libevent-src-analysis/blob/master/libevent%E6%BA%9090%E7%A0%81%E5%88%86%E6%9E%90.md">libevent-src-analysis/libevent 源码分析. md at master · KelvinYin/libevent-src-analysis</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 数据结构：双向链表</title>
    <url>/post/2020/ee7292d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>libevent</code> 源码中有一个 <code>queue.h</code> 文件，该文件里面定义了 5 种数据结构：</p>
<ul>
<li><code>SLIST</code> - 单向链表</li>
<li><code>LIST</code> - 双向链表</li>
<li><code>SIMPLEQ</code> - 简单队列</li>
<li><code>TAILQ</code> - 尾队列</li>
<li><code>CIRCLEQ</code> - 环形队列</li>
</ul>
<p>其中 <code>SLIST</code>/<code>SIMPLEQ</code>/<code>CIRCLEQ</code> 在 <code>libevent</code> 源码中没有被使用，所以本系列文章针对 <code>LIST</code>/<code>TAILQ</code> 进行一下分析。</p>
<p>本文分析的数据结构为 <code>LIST</code> 双向链表。</p>
<a id="more"></a>
<blockquote>
<p>数据结构 <code>TAILQ</code> 尾队列的分析详见：<a href="/post/2020/e6338d04/" title="源码阅读 libevent - 数据结构：尾队列">源码阅读 libevent - 数据结构：尾队列</a></p>
</blockquote>
<p>libevent 中，5 种数据结构的各类操作均通过宏定义实现，且所有宏定义按功能分成了三部分：</p>
<ol>
<li>数据结构定义宏</li>
<li>数据结构访问宏</li>
<li>数据结构操作宏</li>
</ol>
<h2 id="双向链表的定义"><a href="#双向链表的定义" class="headerlink" title="双向链表的定义"></a>双向链表的定义</h2><h3 id="双向链表的定义宏"><a href="#双向链表的定义宏" class="headerlink" title="双向链表的定义宏"></a>双向链表的定义宏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD(name, type)                       \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>                                       \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">lh_first</span>;</span>  <span class="comment">/* first element */</span>     \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_ENTRY(type)                            \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>                                            \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">le_next</span>;</span>   <span class="comment">/* next element */</span>      \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">le_prev</span>;</span>  <span class="comment">/* address of previous next element */</span>      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向链表的定义宏的作用"><a href="#双向链表的定义宏的作用" class="headerlink" title="双向链表的定义宏的作用"></a>双向链表的定义宏的作用</h3><p>先来猜测一下这两个宏定义的作用。在宏定义 <code>LIST_HEAD</code> 下的结构体中，只包含了一个结构体成员 <code>lh_first</code>，从成员名就能推测，<code>lh_first</code> 应当是和链表第一个元素有关。再来看宏定义 <code>LIST_ENTRY</code>，其中也包含了两个结构体成员 <code>le_next</code> 和 <code>le_prev</code>，从变量名就会发现，二者应当与前后元素相关。因此，就可以推断，宏定义中所需输入的参数 <code>type</code> 实际上就是节点类型，这个节点类型应该包含但不限于 <code>LIST_ENTRY</code> 所定义的结构，而 <code>LIST_HEAD</code> 则是对于整个双向链表而言的，用于找到首节点元素，因此 <code>LIST_HEAD</code> 中的 <code>type</code> 也应该是与 <code>LIST_ENTRY</code> 中相同的节点类型。</p>
<p>那么这里为什么 <code>LIST_HEAD</code> 还需要一个参数 <code>name</code> 呢？前面说了，<code>LIST_ENTRY</code> 应当包含在节点类型的定义中，节点类型一旦定义好了并定义了一个节点，那么自然而然 <code>le_next</code> 和 <code>le_prev</code> 就都包含在该节点中了，此时 <code>LIST_ENTRY</code> 结构体作为一个匿名结构体即可，因此无需指定 <code>name</code> 来定义 <code>LIST_ENTRY</code> 结构体的名称；而对于 <code>LIST_HEAD</code> 来说，它是独立的数据类型，用来描述了双向链表的首尾节点，需要用 <code>LIST_HEAD</code> 来定义一个具体的结构体来存放首尾节点指针，因此这里必须指明结构体名 <code>name</code>。</p>
<p>根据前面的推测，现在来正式分析一下 <code>LIST_HEAD</code> 与 <code>LIST_ENTRY</code> 中各成员的含义。</p>
<p>对于 <code>LIST_HEAD</code> 宏定义，其中的 <code>lh_first</code> 为一级指针，也就是说，<code>lh_first</code> 指向一个 <code>struct type</code> 类型的节点。<code>TAILQ_ENTRY</code> 中的 le_next 也是类似，<code>le_prev</code> 则是指向一个指向一个 <code>struct type</code> 类型的节点的指针。</p>
<p>我们可以写一个测试程序来看看该双向链表的结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    LIST_ENTRY(Node) node;</span><br><span class="line">&#125; Node;</span><br><span class="line">LIST_HEAD(Head, Node);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Head</span> <span class="title">listHead</span>;</span></span><br><span class="line">    LIST_INIT(&amp;listHead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Node* new_item = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        new_item-&gt;val = i;</span><br><span class="line">        LIST_INSERT_HEAD(&amp;listHead, new_item, node); <span class="comment">// 头插法插入新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[HEAD] %20p [HEAD ADDR] %20p\n\n&quot;</span>,listHead.lh_first, &amp;listHead);</span><br><span class="line">    LIST_FOREACH(p, &amp;listHead, node) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[NODE] %20d [NODE ADDR] %20p\n&quot;</span>, p-&gt;val, p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[NEXT] %20p [NEXT ADDR] %20p\n&quot;</span>, p-&gt;node.le_next, &amp;p-&gt;node.le_next);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[PREV] %20p [PREV ADDR] %20p\n\n&quot;</span>, p-&gt;node.le_prev, &amp;p-&gt;node.le_prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该程序中，定义了节点类型为 <code>Node</code> 类型，其中包含了一个 <code>int</code> 型的 <code>val</code> 变量以及 <code>LIST_ENTRY</code> 所定义的结构体。可以看到，调用 <code>LIST_HEAD</code> 宏函数时，传入的 <code>name</code> 参数 <code>Head</code> 最终就成为了 <code>LIST_HEAD</code> 下结构体类型名。然后用 <code>struct Head</code> 来定义一个 <code>listHead</code> 变量，其中保存的即是双向链表中的首节点信息了。接着就是以头插法形式插入三个节点，然后遍历输出各个节点中关键成员的值与地址，结果如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201025200734.jpg" alt="libevent 双向链表"></p>
<p>从代码结果种可得出链表结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      Head                   Node1                   Node2                   Node3</span><br><span class="line">+--------------+    +--&gt;+--------------+    +--&gt;+--------------+    +--&gt;+--------------+</span><br><span class="line">|   lh_first   |----+   |    value     |    |   |    value     |    |   |    value     |</span><br><span class="line">|              |&lt;--+    +--------------+    |   +--------------+    |   +--------------+</span><br><span class="line">+--------------+   |    |   le_next    |----+   |   le_next    |----+   |   le_next    |-----+</span><br><span class="line">                   |    |              |&lt;--+    |              |&lt;--+    |              |     |</span><br><span class="line">                   |    +--------------+   |    +--------------+   |    +--------------+   -----</span><br><span class="line">                   +----|   le_prev    |   +----|   le_prev    |   +----|   le_prev    |    ---</span><br><span class="line">                        +--------------+        +--------------+        +--------------+     -</span><br></pre></td></tr></table></figure>
<h2 id="双向链表的访问"><a href="#双向链表的访问" class="headerlink" title="双向链表的访问"></a>双向链表的访问</h2><h3 id="双向链表的访问宏"><a href="#双向链表的访问宏" class="headerlink" title="双向链表的访问宏"></a>双向链表的访问宏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_FIRST(head)        ((head)-&gt;lh_first)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_END(head)          NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_EMPTY(head)        (LIST_FIRST(head) == LIST_END(head))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_NEXT(elm, field)   ((elm)-&gt;field.le_next)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_FOREACH(var, head, field)              \</span></span><br><span class="line">    <span class="keyword">for</span> ((var) = LIST_FIRST(head); (var)!= LIST_END(head); (var) = LIST_NEXT(var, field))</span><br></pre></td></tr></table></figure>
<h3 id="双向链表的访问宏的作用"><a href="#双向链表的访问宏的作用" class="headerlink" title="双向链表的访问宏的作用"></a>双向链表的访问宏的作用</h3><p>从宏定义名即可看出每个宏的作用：</p>
<ul>
<li><code>LIST_FIRST</code>：获取双向链表的首节点</li>
<li><code>LIST_END</code>：双向链表的末尾，值恒为 <code>NULL</code></li>
<li><code>LIST_EMPTY</code>：判断双向链表是否为空，为空时返回真</li>
<li><code>LIST_NEXT</code>：获取双向链表的下一个节点的地址</li>
<li><code>LIST_FOREACH</code>：遍历双向链表</li>
</ul>
<blockquote>
<p>注意：在使用 <code>LIST_FOREACH</code> 遍历双向链表时要避免链表的初始化、删除、替换操作！</p>
</blockquote>
<h3 id="双向链表的访问过程"><a href="#双向链表的访问过程" class="headerlink" title="双向链表的访问过程"></a>双向链表的访问过程</h3><h4 id="双向链表的遍历"><a href="#双向链表的遍历" class="headerlink" title="双向链表的遍历"></a>双向链表的遍历</h4><p><code>libevent</code> 的双向链表只支持从首节点向尾节点遍历。</p>
<p>要想完成遍历操作，有三个关键点：遍历的起始节点，遍历的下一节点的获取，遍历的结束条件。</p>
<p>通过以上对双向链表结构的分析轻易得出以上内容，即可完成链表的遍历操作：</p>
<ul>
<li>遍历的起始节点：可以通过头节点指向的地址获取</li>
<li>遍历的下一节点的获取：可以通过当前节点的 <code>le_next</code> 元素指向的地址获取</li>
<li>遍历的结束条件：<code>le_next</code> 元素指向的地址为空</li>
</ul>
<h2 id="双向链表操作"><a href="#双向链表操作" class="headerlink" title="双向链表操作"></a>双向链表操作</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="初始化宏"><a href="#初始化宏" class="headerlink" title="初始化宏"></a>初始化宏</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT(head) do &#123;                        \</span></span><br><span class="line">    LIST_FIRST(head) = LIST_END(head);              \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><p>链表的初始化实际上只是初始化了头节点，由于头节点的 <code>lh_first</code> 与首节点相连，而此时链表为空，因此将头节点的 <code>lh_first</code> 置为 <code>NULL</code>。</p>
<h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><h4 id="头插法宏"><a href="#头插法宏" class="headerlink" title="头插法宏"></a>头插法宏</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INSERT_HEAD(head, elm, field) do &#123;     \</span></span><br><span class="line">    <span class="keyword">if</span> (((elm)-&gt;field.le_next = (head)-&gt;lh_first) != <span class="literal">NULL</span>)              \</span><br><span class="line">        (head)-&gt;lh_first-&gt;field.le_prev = &amp;(elm)-&gt;field.le_next;        \</span><br><span class="line">    (head)-&gt;lh_first = (elm);                       \</span><br><span class="line">    (elm)-&gt;field.le_prev = &amp;(head)-&gt;lh_first;       \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="头插法步骤"><a href="#头插法步骤" class="headerlink" title="头插法步骤"></a>头插法步骤</h4><p>头插法适用于已知头节点时，在首节点前插入新节点，不用关心首节点的有无，操作步骤如下：</p>
<ol>
<li>将新节点的 <code>next</code> 指向原来的首节点</li>
<li>将原来的首节点的 prev 从指向 first 改为指向新节点的 <code>next</code> 指针</li>
<li>将 <code>first</code> 指针从指向原来首节点改为指向新节点</li>
<li>将新节点的 <code>prev</code> 指针指向 <code>first</code></li>
</ol>
<p>注意：</p>
<ul>
<li>必须保证步骤 1 在步骤 3 之前。</li>
</ul>
<h3 id="前插法"><a href="#前插法" class="headerlink" title="前插法"></a>前插法</h3><h4 id="前插法宏"><a href="#前插法宏" class="headerlink" title="前插法宏"></a>前插法宏</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INSERT_BEFORE(listelm, elm, field) do &#123;                    \</span></span><br><span class="line">    (elm)-&gt;field.le_prev = (listelm)-&gt;field.le_prev;                    \</span><br><span class="line">    (elm)-&gt;field.le_next = (listelm);               \</span><br><span class="line">    *(listelm)-&gt;field.le_prev = (elm);              \</span><br><span class="line">    (listelm)-&gt;field.le_prev = &amp;(elm)-&gt;field.le_next;                   \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="前插法步骤"><a href="#前插法步骤" class="headerlink" title="前插法步骤"></a>前插法步骤</h4><p>前插法适用于已知非头节点时，在已知节点前插入新节点，不用关心头节点是否已知，操作步骤如下：</p>
<ol>
<li>将新节点的 <code>prev</code> 指向已知节点的 <code>prev</code> 指向的位置</li>
<li>将新节点的 <code>next</code> 指向已知节点的地址</li>
<li>将已知节点的 <code>prev</code> 指向的地址的指向改为新节点的地址</li>
<li>将已知节点的 <code>prev</code> 指向的地址指向新节点的 <code>next</code> 指针</li>
</ol>
<p>注意：</p>
<ul>
<li>必须保证步骤 1 在步骤 3 之前，必须保证步骤 3 在步骤 4 之前。</li>
</ul>
<h3 id="后插法"><a href="#后插法" class="headerlink" title="后插法"></a>后插法</h3><h4 id="后插法宏"><a href="#后插法宏" class="headerlink" title="后插法宏"></a>后插法宏</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field) do &#123;                     \</span></span><br><span class="line">    <span class="keyword">if</span> (((elm)-&gt;field.le_next = (listelm)-&gt;field.le_next) != <span class="literal">NULL</span>)      \</span><br><span class="line">        (listelm)-&gt;field.le_next-&gt;field.le_prev = &amp;(elm)-&gt;field.le_next;\</span><br><span class="line">    (listelm)-&gt;field.le_next = (elm);               \</span><br><span class="line">    (elm)-&gt;field.le_prev = &amp;(listelm)-&gt;field.le_next;                   \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="后插法步骤"><a href="#后插法步骤" class="headerlink" title="后插法步骤"></a>后插法步骤</h4><p>前插法适用于已知非头节点时，在已知节点后插入新节点，操作步骤如下：</p>
<ol>
<li>将新节点的 <code>next</code> 指向已知节点的 <code>next</code> 指向的位置</li>
<li>将已知节点的 <code>next</code> 指向的节点的 prev 指向新节点的 <code>next</code> 元素地址</li>
<li>将已知节点的 <code>next</code> 指向新节点的地址</li>
<li>将新节点的 <code>prev</code> 指向的地址指向已知节点的 <code>next</code> 指针</li>
</ol>
<p>注意：</p>
<ul>
<li>必须保证步骤 1 或步骤 2 在步骤 3 之前，因为要保证能找到已知节点的后一个节点。</li>
</ul>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><h4 id="删除节点宏"><a href="#删除节点宏" class="headerlink" title="删除节点宏"></a>删除节点宏</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_REMOVE(elm, field) do &#123;                \</span></span><br><span class="line">    <span class="keyword">if</span> ((elm)-&gt;field.le_next != <span class="literal">NULL</span>)               \</span><br><span class="line">        (elm)-&gt;field.le_next-&gt;field.le_prev = (elm)-&gt;field.le_prev;     \</span><br><span class="line">    *(elm)-&gt;field.le_prev = (elm)-&gt;field.le_next;   \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="删除节点步骤"><a href="#删除节点步骤" class="headerlink" title="删除节点步骤"></a>删除节点步骤</h4><p>删除节点只需要对待删除节点的前后（可能包括头节点）节点进行操作：</p>
<ol>
<li>如果存在后继节点，则将后继节点的 <code>prev</code> 赋值为待删除节点的 <code>prev</code></li>
<li>将待删除节点的 <code>prev</code> 指向的指针赋值为待删除节点的 <code>next</code></li>
</ol>
<blockquote>
<p>注意：libevent 中实现的双向链表，删除操作不需要知道表头信息，仅需要直到待删除节点信息</p>
</blockquote>
<h3 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h3><h4 id="替换节点宏"><a href="#替换节点宏" class="headerlink" title="替换节点宏"></a>替换节点宏</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_REPLACE(elm, elm2, field) do &#123;         \</span></span><br><span class="line">    <span class="keyword">if</span> (((elm2)-&gt;field.le_next = (elm)-&gt;field.le_next) != <span class="literal">NULL</span>)         \</span><br><span class="line">        (elm2)-&gt;field.le_next-&gt;field.le_prev = &amp;(elm2)-&gt;field.le_next;  \</span><br><span class="line">    (elm2)-&gt;field.le_prev = (elm)-&gt;field.le_prev;   \</span><br><span class="line">    *(elm2)-&gt;field.le_prev = (elm2);                \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="替换节点步骤"><a href="#替换节点步骤" class="headerlink" title="替换节点步骤"></a>替换节点步骤</h4><ol>
<li>将新节点的 <code>next</code> 指向旧节点的 <code>next</code> 指向的位置</li>
<li>将旧节点的 <code>next</code> 指向的节点的 <code>prev</code> 指向新节点指 next 地址</li>
<li>将新节点的 <code>prev</code> 指向旧节点的 <code>prev</code> 指向的位置</li>
<li>将新节点的 <code>prev</code> 指向的地址指向新节点地址</li>
</ol>
<blockquote>
<p>注意：libevent 中实现的双向链表，替换操作不需要知道表头信息，仅需要直到待替换节点信息和新节点信息</p>
</blockquote>
<h2 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h2><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><p>Q1：节点的 <code>le_prev</code> 指针为什么不指向前一节点的首地址，而是指向前一节点的 <code>le_next</code> 指针或头节点的 <code>lh_first</code> 指针</p>
<p>A1：节点的 <code>le_prev</code> 指针为一个二级之指针，其指向前一节点的 <code>le_next</code> 指针或头节点的 <code>lh_first</code> 指针的原因有两点：</p>
<ol>
<li><p>节点中存在一个和其余节点结构不一致的头节点，<code>le_prev</code> 在指向头节点时无法指向头节点的首地址，否则在头节点中包含其他结构元素时，增加了寻找头节点中 <code>lh_first</code> 难度，故直接指向头节点中 <code>lh_first</code> 所在地址。</p>
</li>
<li><p>如果节点的 <code>le_prev</code> 指向前一节点的首地址，在进行前插法、删除节点、替换节点时就必须知道头节点的地址，因为前插法在首节点前插入、删除首节点、替换首节点时需要修改头节点的 lh_first 指针，这样增加了参数的传递个数。而指向前一节点的 <code>le_next</code> 指针或头节点的 <code>lh_first</code> 指针在进行以上操作时，只需要简单地修改 <code>le_prev</code> 指针指向位置的值即可，大大降低使用以上接口进行链表操作的难度。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 数据结构：哈希表</title>
    <url>/post/2020/542e4e52/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>libevent</code> 源码中除了 <code>queue.h</code> 文件中定义了 5 种数据结构，在 <code>ht-internal.h</code> 文件中定义了另一个重要的数据结构：哈希表。</p>
<blockquote>
<p>本系列大部分文章介绍 <code>linux</code> 系统下 <code>libevent</code> 的源码，但 <code>libevent</code> 在 <code>linux</code> 环境下并没有用到哈希表结构，但学习 <code>libevent</code> 中哈希表的实现非常有助于对哈希表结构的理解。</p>
</blockquote>
<a id="more"></a>
<h2 id="哈希表定义"><a href="#哈希表定义" class="headerlink" title="哈希表定义"></a>哈希表定义</h2><h3 id="哈希表定义宏"><a href="#哈希表定义宏" class="headerlink" title="哈希表定义宏"></a>哈希表定义宏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HT_HEAD(name, type)                         \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>                                   \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">hth_table</span>;</span> <span class="comment">/* The hash table itself. */</span>               \</span><br><span class="line">        <span class="keyword">unsigned</span> hth_table_length; <span class="comment">/* How long is the hash table? */</span>        \</span><br><span class="line">        <span class="keyword">unsigned</span> hth_n_entries; <span class="comment">/* How many elements does the table contain? */</span>                         \</span><br><span class="line">        <span class="keyword">unsigned</span> hth_load_limit; <span class="comment">/* How many elements will we allow in the table before resizing it? */</span> \</span><br><span class="line">        <span class="keyword">int</span> hth_prime_idx; <span class="comment">/* Position of hth_table_length in the primes table. */</span>                      \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HT_ENTRY(type)                              \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span>                                        \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">hte_next</span>;</span>                      \</span><br><span class="line">        <span class="keyword">unsigned</span> hte_hash; <span class="comment">/* Hash cache */</span>         \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈希表结构"><a href="#哈希表结构" class="headerlink" title="哈希表结构"></a>哈希表结构</h3><p>与双向链表一样，我们通过测试程序来看哈希表在内存中的结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ht-internal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    HT_ENTRY(Node) map_node;</span><br><span class="line">&#125; Node;</span><br><span class="line">HT_HEAD(INT_MAP, Node);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">hashfn</span><span class="params">(struct Node *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> h = (<span class="keyword">unsigned</span>) e-&gt;key;</span><br><span class="line">    h += (h&gt;&gt; <span class="number">2</span>) | (h &lt;&lt; <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">eqfn</span><span class="params">(struct Node *e1, struct Node *e2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1-&gt;key == e2-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HT_PROTOTYPE(INT_MAP, Node, map_node, hashfn, eqfn)</span><br><span class="line">HT_GENERATE(INT_MAP, Node, map_node, hashfn, eqfn, <span class="number">0.5</span>, <span class="built_in">malloc</span>, <span class="built_in">realloc</span>, <span class="built_in">free</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">INT_MAP</span> <span class="title">table</span>;</span></span><br><span class="line">    HT_INIT(INT_MAP, &amp;table);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>) + a % <span class="number">1000003</span>);</span><br><span class="line">        a = rand() % <span class="number">1000003</span>;</span><br><span class="line">        Node* new_item = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        new_item-&gt;key = a;</span><br><span class="line">        new_item-&gt;value = i;</span><br><span class="line">        HT_INSERT(INT_MAP, &amp;table, new_item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n[HEAD]: **hth_table      = %p\n&quot;</span></span><br><span class="line">            <span class="string">&quot;hth_table_length = %d\n&quot;</span></span><br><span class="line">            <span class="string">&quot;hth_n_entries    = %d\n&quot;</span></span><br><span class="line">            <span class="string">&quot;hth_load_limit   = %d\n&quot;</span></span><br><span class="line">            <span class="string">&quot;hth_prime_idx    = %d\n\n&quot;</span>,</span><br><span class="line">            table.hth_table, table.hth_table_length, table.hth_n_entries, table.hth_load_limit, table.hth_prime_idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.hth_table_length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table.hth_table[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[TABLE]: [%03d] - [%p]&quot;</span>, i, table.hth_table[i]);</span><br><span class="line">            Node* item = table.hth_table[i]-&gt;map_node.hte_next;</span><br><span class="line">            <span class="keyword">while</span> (item) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--&gt; [%p]&quot;</span>, item);</span><br><span class="line">                item = item-&gt;map_node.hte_next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node** item;</span><br><span class="line">    HT_FOREACH(item, INT_MAP, &amp;table) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[NODE]: Key = %-8d Value = %-5d Next = %-10p Addr = %-10p\n&quot;</span>,</span><br><span class="line">            (*item)-&gt;key, (*item)-&gt;value, (*item)-&gt;map_node.hte_next, *item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201028223901.png" alt="libevent 哈希表"></p>
<h3 id="哈希表头"><a href="#哈希表头" class="headerlink" title="哈希表头"></a>哈希表头</h3><p>可以看出，<code>libevent</code> 中定义的哈希表头结构体意义如下：</p>
<ul>
<li><code>hth_table</code>：哈希表的存储位置</li>
<li><code>hth_table_length</code>：哈希表的长度</li>
<li><code>hth_n_entries</code>：哈希表的元素个数</li>
<li><code>hth_load_limit</code>：哈希表元素限制，超过限制后需要进行哈希表扩容</li>
<li><code>hth_prime_idx</code>：哈希表容量等级，libevent 的哈希表存在 26 个容量等级</li>
</ul>
<h3 id="哈希冲突的解决"><a href="#哈希冲突的解决" class="headerlink" title="哈希冲突的解决"></a>哈希冲突的解决</h3><p><code>libevent</code> 的哈希表是使用链地址法解决冲突问题的，这一点可以从 <code>hth_talbe</code> 成员变量看到。它是一个二级指针，其指向了哈希表的元素所在的地址。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p><code>libevent</code> 中的哈希函数由使用者定义，上述测试代码中使用了和 <code>libevent</code> 中一样的哈希函数：模 (%)。</p>
<blockquote>
<p><code>libevent</code> 中哈希表的代码存在大量的宏定义，可读性低，本文通过 <code>gcc</code> 的 <code>-E</code> 选项结合 <code>AStyle</code> 将上文中的测试程序转化为了可读性较好的代码，以下分析均采用转化后的代码片段。</p>
</blockquote>
<h2 id="哈希表的访问"><a href="#哈希表的访问" class="headerlink" title="哈希表的访问"></a>哈希表的访问</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct Node ** <span class="title">INT_MAP_HT_FIND_P_</span><span class="params">(struct INT_MAP *head, struct Node *elm)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> **<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!head-&gt;hth_table) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    p = &amp;((head)-&gt;hth_table[((elm)-&gt;map_node.hte_hash) % head-&gt;hth_table_length]);</span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eqfn(*p, elm)) <span class="keyword">return</span> p;</span><br><span class="line">        p = &amp;(*p)-&gt;map_node.hte_next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct Node * <span class="title">INT_MAP_HT_FIND</span><span class="params">(<span class="keyword">const</span> struct INT_MAP *head, struct Node *elm)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> **<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">INT_MAP</span> *<span class="title">h</span> = (<span class="title">struct</span> <span class="title">INT_MAP</span> *) <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        (elm)-&gt;map_node.hte_hash = hashfn(elm);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    p = INT_MAP_HT_FIND_P_(h, elm);</span><br><span class="line">    <span class="keyword">return</span> p ? *p : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>INT_MAP_HT_FIND_P_</code> 和 <code>INT_MAP_HT_FIND</code> 均为哈希表的查找函数，两者的区别是：</p>
<ol>
<li>返回数据类型不同：<ul>
<li><code>INT_MAP_HT_FIND_P_</code> 返回值是 Node**，是一个二级指针，指向的是保存被查找哈希元素的地址的指针变量<blockquote>
<p>比如：<code>hth_table[1]</code> 中保存着带查找元素的地址，该函数则返回的是 <code>hth_table[1]</code> 的地址信息。</p>
</blockquote>
</li>
<li><code>INT_MAP_HT_FIND</code> 返回值是 Node*，指向查找到的哈希元素</li>
</ul>
</li>
<li>查找步骤差别：<ul>
<li><code>INT_MAP_HT_FIND_P_</code> 直接使用计算过的哈希值进行查找</li>
<li><code>INT_MAP_HT_FIND</code> 重新使用哈希函数计算哈希值后进行查找</li>
</ul>
</li>
<li>判断查找成功与否方式不同：<ul>
<li><code>INT_MAP_HT_FIND_P_</code> 返回值始终非空，需要判断其返回值指向的数据是否为 <code>NULL</code> 来确认查找结果</li>
<li><code>INT_MAP_HT_FIND_P_</code> 查找失败时，返回的地址可以作为该元素插入的地址进行插入操作</li>
<li><code>INT_MAP_HT_FIND</code> 未查找到对应元素时返回值为 <code>NULL</code></li>
</ul>
</li>
</ol>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct Node ** <span class="title">INT_MAP_HT_START</span><span class="params">(struct INT_MAP *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &lt; head-&gt;hth_table_length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;hth_table[b]) <span class="keyword">return</span> &amp;head-&gt;hth_table[b];</span><br><span class="line">        ++b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct Node ** <span class="title">INT_MAP_HT_NEXT</span><span class="params">(struct INT_MAP *head, struct Node **elm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*elm)-&gt;map_node.hte_next) <span class="keyword">return</span> &amp;(*elm)-&gt;map_node.hte_next;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> b = (((*elm)-&gt;map_node.hte_hash) % head-&gt;hth_table_length)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; head-&gt;hth_table_length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;hth_table[b]) <span class="keyword">return</span> &amp;head-&gt;hth_table[b];</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历的三要素：</p>
<ol>
<li>遍历的起始节点<ul>
<li>依次查找哈希表数组中的每一个元素，首个非空的元素即为起始节点</li>
</ul>
</li>
<li>下一个节点的获取<ul>
<li>如果当前节点的 <code>next</code> 指针非空，则 <code>next</code> 指针指向的位置为下一个节点</li>
<li>如果当前节点的 <code>next</code> 指针为空，则继续遍历哈希表数组中的元素</li>
</ul>
</li>
<li>遍历的结束条件<ul>
<li>如果遍历完哈希表数组遍历完成（根据哈希表长度值 <code>hth_table_length</code> 判断），则遍历结束</li>
</ul>
</li>
</ol>
<h2 id="哈希表的操作"><a href="#哈希表的操作" class="headerlink" title="哈希表的操作"></a>哈希表的操作</h2><h3 id="哈希表的基础操作"><a href="#哈希表的基础操作" class="headerlink" title="哈希表的基础操作"></a>哈希表的基础操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 哈希表的判空 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HT_EMPTY(head) ((head)-&gt;hth_n_entries == 0)</span></span><br><span class="line"><span class="comment">/* 哈希表的表数组大小 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HT_SIZE(head) ((head)-&gt;hth_n_entries)</span></span><br><span class="line"><span class="comment">/* 哈希表的表占用的内存大小 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HT_MEM_USAGE(head) (sizeof(*head) + (head)-&gt;hth_table_length * sizeof(void*))</span></span><br></pre></td></tr></table></figure>
<p>以上接口较为简单，不进行过多说明。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INT_MAP_HT_INIT</span><span class="params">(struct INT_MAP *head)</span> </span>&#123;</span><br><span class="line">    head-&gt;hth_table_length = <span class="number">0</span>;</span><br><span class="line">    head-&gt;hth_table = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;hth_n_entries = <span class="number">0</span>;</span><br><span class="line">    head-&gt;hth_load_limit = <span class="number">0</span>;</span><br><span class="line">    head-&gt;hth_prime_idx = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈希表的初始化其实就是对表头数据进行初始化。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INT_MAP_HT_INSERT</span><span class="params">(struct INT_MAP *head, struct Node *elm)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> **<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!head-&gt;hth_table || head-&gt;hth_n_entries &gt;= head-&gt;hth_load_limit)</span><br><span class="line">        INT_MAP_HT_GROW(head, head-&gt;hth_n_entries + <span class="number">1</span>);</span><br><span class="line">    ++head-&gt;hth_n_entries;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        (elm)-&gt;map_node.hte_hash = hashfn(elm);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    p = &amp;((head)-&gt;hth_table[((elm)-&gt;map_node.hte_hash) % head-&gt;hth_table_length]);</span><br><span class="line">    elm-&gt;map_node.hte_next = *p;</span><br><span class="line">    *p = elm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入操作可分为 <code>3</code> ~ <code>4</code> 个步骤：</p>
<ol>
<li>判断当前哈希表是否需要扩容</li>
<li>调用哈希函数计算新插入数据的哈希值</li>
<li>*(需要时) 解决哈希冲突</li>
<li>头插法插入新数据（后插入的数据在链表头）</li>
</ol>
<blockquote>
<p>需要注意的是：<code>libevent</code> 的插入函数 <code>INT_MAP_HT_INSERT</code> 并没有对重复的哈希 <code>key</code> 进行判断，所以根据不同的应用场景，可能会有不同的应用方式。</p>
</blockquote>
<h3 id="修改-amp-插入"><a href="#修改-amp-插入" class="headerlink" title="修改 &amp; 插入"></a>修改 &amp; 插入</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct Node * <span class="title">INT_MAP_HT_REPLACE</span><span class="params">(struct INT_MAP *head, struct Node *elm)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> **<span class="title">p</span>, *<span class="title">r</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!head-&gt;hth_table || head-&gt;hth_n_entries &gt;= head-&gt;hth_load_limit)</span><br><span class="line">        INT_MAP_HT_GROW(head, head-&gt;hth_n_entries + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        (elm)-&gt;map_node.hte_hash = hashfn(elm);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    p = INT_MAP_HT_FIND_P_(head, elm);</span><br><span class="line">    r = *p;</span><br><span class="line">    *p = elm;</span><br><span class="line">    <span class="keyword">if</span> (r &amp;&amp; (r!=elm)) &#123;</span><br><span class="line">        elm-&gt;map_node.hte_next = r-&gt;map_node.hte_next;</span><br><span class="line">        r-&gt;map_node.hte_next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ++head-&gt;hth_n_entries;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>INT_MAP_HT_REPLACE</code> 函数相比 <code>INT_MAP_HT_INSERT</code>，多了对于重复数据的查找和替换。</p>
<blockquote>
<p>需要注意的是：<code>INT_MAP_HT_REPLACE</code> 在插入时返回值为 <code>NULL</code>，而在替换时返回值为被替换元素的地址，如果被替换元素空间是通过 <code>malloc</code> 等内存申请函数申请得到的，需要调用 <code>free</code> 等函数对空间进行释放。</p>
</blockquote>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct Node * <span class="title">INT_MAP_HT_REMOVE</span><span class="params">(struct INT_MAP *head, struct Node *elm)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> **<span class="title">p</span>, *<span class="title">r</span>;</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        (elm)-&gt;map_node.hte_hash = hashfn(elm);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    p = INT_MAP_HT_FIND_P_(head,elm);</span><br><span class="line">    <span class="keyword">if</span> (!p || !*p) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    r = *p;</span><br><span class="line">    *p = r-&gt;map_node.hte_next;</span><br><span class="line">    r-&gt;map_node.hte_next = <span class="literal">NULL</span>;</span><br><span class="line">    --head-&gt;hth_n_entries;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct Node ** <span class="title">INT_MAP_HT_NEXT_RMV</span><span class="params">(struct INT_MAP *head, struct Node **elm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> h = ((*elm)-&gt;map_node.hte_hash);</span><br><span class="line">    *elm = (*elm)-&gt;map_node.hte_next;</span><br><span class="line">    --head-&gt;hth_n_entries;</span><br><span class="line">    <span class="keyword">if</span> (*elm) <span class="keyword">return</span> elm;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> b = (h % head-&gt;hth_table_length)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; head-&gt;hth_table_length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;hth_table[b]) <span class="keyword">return</span> &amp;head-&gt;hth_table[b];</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除操作本质就是一次查找与一次数组或链表操作，两个删除函数作用类似，但返回值存在区别：</p>
<ul>
<li><code>INT_MAP_HT_REMOVE</code> 和 <code>INT_MAP_HT_REPLACE</code> 类似，返回值是被删除元素的地址。</li>
<li><code>INT_MAP_HT_NEXT_RMV</code> 和 <code>INT_MAP_HT_FIND_P_</code> 类似，返回的是一个二级指针，指向的是保存被删除哈希元素的下一个元素地址的指针变量。<blockquote>
<p>比如：<code>hth_table[0]</code> 中保存着被删除元素的地址，<code>hth_table[3]</code> 中保存着被删除元素的下一个元素地址，则该函数会删除 <code>hth_table[0]</code> 所指向元素的地址，并返回的 <code>hth_table[3]</code> 的地址信息。</p>
</blockquote>
</li>
</ul>
<p>两个删除操作均不会进行被删除元素的内存释放操作：</p>
<ul>
<li><code>INT_MAP_HT_REMOVE</code> 返回被删除元素的地址，可通过返回值释放内存。</li>
<li><code>INT_MAP_HT_NEXT_RMV</code> 需要在删除前保存被删除元素的地址信息，然后在删除操作之后释放内存。</li>
</ul>
<h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INT_MAP_HT_FOREACH_FN</span><span class="params">(struct INT_MAP *head, <span class="keyword">int</span> (*fn)(struct Node *, <span class="keyword">void</span> *), <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> **<span class="title">p</span>, **<span class="title">nextp</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!head-&gt;hth_table) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (idx=<span class="number">0</span>; idx &lt; head-&gt;hth_table_length; ++idx) &#123;</span><br><span class="line">        p = &amp;head-&gt;hth_table[idx];</span><br><span class="line">        <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">            nextp = &amp;(*p)-&gt;map_node.hte_next;</span><br><span class="line">            next = *nextp;</span><br><span class="line">            <span class="keyword">if</span> (fn(*p, data)) &#123;</span><br><span class="line">                --head-&gt;hth_n_entries;</span><br><span class="line">                *p = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> p = nextp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>fn</code> 函数检查每个哈希表中的元素，如果 <code>fn</code> 函数返回值非 <code>0</code>，则删除对应的元素。</p>
<blockquote>
<p>注：如有需要，<code>fn</code> 函数中应对被删除元素进行内存释放</p>
</blockquote>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INT_MAP_HT_CLEAR</span><span class="params">(struct INT_MAP *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;hth_table) <span class="built_in">free</span>(head-&gt;hth_table);</span><br><span class="line">    INT_MAP_HT_INIT(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数需要在哈希表清空后使用，否则会丢失哈希表中元素信息，导致一些 <code>malloc</code> 的空间无法释放，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 自定义函数，非 libenent 宏定义生成函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INT_MAP_HT_CLEAR_ALL</span><span class="params">(struct INT_MAP * head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> **<span class="title">ent</span>, **<span class="title">next</span>, *<span class="title">this</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (ent = HT_START(INT_MAP, head); ent; ent = next) &#123;</span><br><span class="line">        <span class="keyword">this</span> = *ent;</span><br><span class="line">        next = HT_NEXT_RMV(INT_MAP, head, ent);</span><br><span class="line">        mm_free(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    HT_CLEAR(INT_MAP, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> INT_MAP_PRIMES[] = &#123;</span><br><span class="line">    <span class="number">53</span>, <span class="number">97</span>, <span class="number">193</span>, <span class="number">389</span>, <span class="number">769</span>, <span class="number">1543</span>, <span class="number">3079</span>, <span class="number">6151</span>, <span class="number">12289</span>, <span class="number">24593</span>,</span><br><span class="line">    <span class="number">49157</span>, <span class="number">98317</span>, <span class="number">196613</span>, <span class="number">393241</span>, <span class="number">786433</span>, <span class="number">1572869</span>, <span class="number">3145739</span>, <span class="number">6291469</span>, <span class="number">12582917</span>, <span class="number">25165843</span>,</span><br><span class="line">    <span class="number">50331653</span>, <span class="number">100663319</span>, <span class="number">201326611</span>, <span class="number">402653189</span>, <span class="number">805306457</span>, <span class="number">1610612741</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> INT_MAP_N_PRIMES = (<span class="keyword">unsigned</span>)(<span class="keyword">sizeof</span>(INT_MAP_PRIMES)/<span class="keyword">sizeof</span>(INT_MAP_PRIMES[<span class="number">0</span>]));</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">INT_MAP_HT_GROW</span><span class="params">(struct INT_MAP *head, <span class="keyword">unsigned</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> new_len, new_load_limit;</span><br><span class="line">    <span class="keyword">int</span> prime_idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> **<span class="title">new_table</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;hth_prime_idx == (<span class="keyword">int</span>)INT_MAP_N_PRIMES - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;hth_load_limit &gt; <span class="built_in">size</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    prime_idx = head-&gt;hth_prime_idx;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        new_len = INT_MAP_PRIMES[++prime_idx];</span><br><span class="line">        new_load_limit = (<span class="keyword">unsigned</span>)(<span class="number">0.5</span>*new_len); <span class="comment">/* 0.5 为装载因子 */</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (new_load_limit &lt;= <span class="built_in">size</span> &amp;&amp; prime_idx &lt; (<span class="keyword">int</span>)INT_MAP_N_PRIMES);</span><br><span class="line">    <span class="keyword">if</span> ((new_table = <span class="built_in">malloc</span>(new_len*<span class="keyword">sizeof</span>(struct Node*)))) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> b;</span><br><span class="line">        <span class="built_in">memset</span>(new_table, <span class="number">0</span>, new_len*<span class="keyword">sizeof</span>(struct Node*));</span><br><span class="line">        <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; head-&gt;hth_table_length; ++b) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">elm</span>, *<span class="title">next</span>;</span></span><br><span class="line">            <span class="keyword">unsigned</span> b2;</span><br><span class="line">            elm = head-&gt;hth_table[b];</span><br><span class="line">            <span class="keyword">while</span> (elm) &#123;</span><br><span class="line">                next = elm-&gt;map_node.hte_next;</span><br><span class="line">                b2 = ((elm)-&gt;map_node.hte_hash) % new_len;</span><br><span class="line">                elm-&gt;map_node.hte_next = new_table[b2];</span><br><span class="line">                new_table[b2] = elm;</span><br><span class="line">                elm = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;hth_table) <span class="built_in">free</span>(head-&gt;hth_table);</span><br><span class="line">        head-&gt;hth_table = new_table;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> b, b2;</span><br><span class="line">        new_table = <span class="built_in">realloc</span>(head-&gt;hth_table, new_len*<span class="keyword">sizeof</span>(struct Node*));</span><br><span class="line">        <span class="keyword">if</span> (!new_table) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(new_table + head-&gt;hth_table_length, <span class="number">0</span>, (new_len - head-&gt;hth_table_length)*<span class="keyword">sizeof</span>(struct Node*));</span><br><span class="line">        <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; head-&gt;hth_table_length; ++b) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">e</span>, **<span class="title">pE</span>;</span></span><br><span class="line">            <span class="keyword">for</span> (pE = &amp;new_table[b], e = *pE; e != <span class="literal">NULL</span>; e = *pE) &#123;</span><br><span class="line">                b2 = ((e)-&gt;map_node.hte_hash) % new_len;</span><br><span class="line">                <span class="keyword">if</span> (b2 == b) pE = &amp;e-&gt;map_node.hte_next;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    *pE = e-&gt;map_node.hte_next;</span><br><span class="line">                    e-&gt;map_node.hte_next = new_table[b2];</span><br><span class="line">                    new_table[b2] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;hth_table = new_table;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;hth_table_length = new_len;</span><br><span class="line">    head-&gt;hth_prime_idx = prime_idx;</span><br><span class="line">    head-&gt;hth_load_limit = new_load_limit;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈希表的扩容分为以下几个步骤：</p>
<ol>
<li>根据装载因子、当前容量、当前数据量判断是否需要扩容</li>
<li>获取当前容量等级并计算需要扩容的等级</li>
<li>申请新的哈希表空间</li>
<li>重建哈希表，并释放旧空间</li>
<li>更新哈希表头信息</li>
</ol>
<blockquote>
<p><code>libevent</code> 采用的扩容方法方法的缺点是，容量扩张是一次完成的，期间要花很长时间一次转移 <code>hash</code> 表中的所有元素。这样在 hash 表每次扩容时，往里边插入一个元素将会等候很长的时间。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 数据结构：小根堆</title>
    <url>/post/2020/3a941cca/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <code>libevent</code> 中，使用 <code>min_heap</code> 这一数据结构来管理各个 <code>event</code> 的超时，也就是小根堆，整个堆是根据各个 <code>event</code> 的超时时间来构成的，因此堆顶肯定就对应超时时间最小的 <code>event</code>，这样就可以按照超时顺序进行处理了。</p>
<a id="more"></a>
<h2 id="堆的数组实现"><a href="#堆的数组实现" class="headerlink" title="堆的数组实现"></a>堆的数组实现</h2><p>堆 (Heap) 是一种数据结构，其由两个特点：</p>
<ul>
<li>堆中某个节点的值总是不大于或不小于其父节点的值<ul>
<li>大根堆（大顶堆）：堆中节点的值总是不大于其父节点的值</li>
<li>小根堆（小顶堆）：堆中节点的值总是不小于其父节点的值</li>
</ul>
</li>
<li>堆总是一棵完全二叉树</li>
</ul>
<p>而完全二叉树由于其特性，通常由数组来实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 已知一个节点所在数组下标，获取其左子节点、右子节点、父节点的数组下标 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GetLeftChild(index)     ((index) * 2 + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GetRightChild(index)    ((index) * 2 + 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GetParent(index)        (((index) - 1) / 2)</span></span><br><span class="line"><span class="comment">/* 已知一个节点所在数组下标和二叉树节点个数，获取其左子节点、右子节点、父节点是否存在 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hasLeftChild(index, size)   (GetLeftChild(index) &lt; (size))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hasRightChild(index, size)  (hasRightChild(index) &lt; (size))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hasParent(index, size)      ((index) &gt; 0)</span></span><br></pre></td></tr></table></figure>
<h2 id="min-heap-的定义"><a href="#min-heap-的定义" class="headerlink" title="min_heap 的定义"></a>min_heap 的定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">min_heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span>** <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> n, a;</span><br><span class="line">&#125; <span class="keyword">min_heap_t</span>;</span><br></pre></td></tr></table></figure>
<p>各成员变量意义如下：</p>
<ol>
<li><code>p</code>：二级指针，指向小根堆的首地址，小根堆为一个数组，数组元素结构为 <code>struct event*</code></li>
<li><code>n</code>：数组中 <code>struct event*</code> 有效元素个数</li>
<li><code>a</code>：<code>struct event*</code> 小根堆的容量，即数组的容量</li>
</ol>
<h2 id="min-heap-的优先级对比"><a href="#min-heap-的优先级对比" class="headerlink" title="min_heap 的优先级对比"></a>min_heap 的优先级对比</h2><p>要实现堆，必须要定义队中节点优先级的比较方式，<code>libevent</code> 中 min_heap 中保存的是每个 <code>event</code> 的超时时间，因此需要根据超时顺序进行排列，其中 <code>min_heap_elem_greater</code> 就是用来比较两个 <code>event</code> 的超时时间的函数。</p>
<p><code>min_heap_elem_greater</code> 函数传入两个 <code>event</code> 参数，用来判断第一个参数 <code>event</code> 的超时结构体是否大于第二参数的超时结构体，如果大于则返回 <code>1</code>，否则返回 <code>0</code>。比较两个超时结构体先比较秒数，再比较微妙数，函数中调用了宏函数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timercmp(tvp, uvp, cmp)                  \</span></span><br><span class="line">    (((tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec) ? ((tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec) : ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min_heap_elem_greater(a, b) (evutil_timercmp(&amp;(a)-&gt;ev_timeout, &amp;(b)-&gt;ev_timeout, &gt;))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">int</span> min_heap_idx;</span><br><span class="line">    &#125; ev_timeout_pos;</span><br></pre></td></tr></table></figure>
<h2 id="min-heap-的初始化"><a href="#min-heap-的初始化" class="headerlink" title="min_heap 的初始化"></a>min_heap 的初始化</h2><p>虽然说 <code>C</code> 语言中没有构造函数和析构函数，但是 <code>min_heap</code> 也将这种思想进行了体现在了 <code>min_heap_ctor</code> 函数和 <code>min_heap_dtor</code> 函数上，从函数名上看就是 <code>constructor</code> 和 <code>destructor</code> 的简写，各自定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_ctor_</span><span class="params">(<span class="keyword">min_heap_t</span>* s)</span> </span>&#123; s-&gt;p = <span class="number">0</span>; s-&gt;n = <span class="number">0</span>; s-&gt;a = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_dtor_</span><span class="params">(<span class="keyword">min_heap_t</span>* s)</span> </span>&#123; <span class="keyword">if</span> (s-&gt;p) mm_free(s-&gt;p); &#125;</span><br></pre></td></tr></table></figure>
<p><code>min_heap_elem_init</code> 函数用来初始化小根堆中的 <code>event</code>，将 <code>event</code> 的堆索引初始化为 <code>-1</code>。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_elem_init_</span><span class="params">(struct event* e)</span> </span>&#123; e-&gt;ev_timeout_pos.min_heap_idx = <span class="number">-1</span>; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="min-heap-的重要操作"><a href="#min-heap-的重要操作" class="headerlink" title="min_heap 的重要操作"></a>min_heap 的重要操作</h2><p>一个最小堆数据结构体，其最重要的操作就是实现 <code>push</code>/<code>pop</code>/<code>peek</code>：</p>
<ul>
<li><code>push</code>：将一个新的节点放入堆中</li>
<li><code>pop</code>：将堆中最小节点弹出</li>
<li><code>peek</code>：获取堆中最小节点</li>
</ul>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>首先来看下向堆中插入节点的一般实现步骤：</p>
<ol>
<li>在堆的最后新建一个节点</li>
<li>将数值赋予新节点</li>
<li>将其与父节点比较</li>
<li>如果新节点优先级比父节点高，则调换父子节点位置</li>
<li>重复步骤 3 和步骤 4 直至堆特性被满足</li>
</ol>
<p>接下来我们再分析下 <code>libevent</code> 向堆中插入一个新节点的过程，其由 <code>min_heap_push_</code> 函数实现，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_heap_push_</span><span class="params">(<span class="keyword">min_heap_t</span>* s, struct event* e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;n == UINT32_MAX || min_heap_reserve_(s, s-&gt;n + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    min_heap_shift_up_(s, s-&gt;n++, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中涉及到调用两个函数 <code>min_heap_reserve_</code> 和 <code>min_heap_shift_up_</code>，函数功能如下：</p>
<ol>
<li><code>min_heap_reserve_</code>：为新插入元素分配足够大小的堆内存，为上述五个步骤开辟空间</li>
<li><code>min_heap_shift_up_</code>：堆元素上浮操作，其中包含了上述五个步骤中的步骤 3 到步骤 5</li>
</ol>
<blockquote>
<p>步骤 1 和步骤 2 由用户开辟空间并进行赋值</p>
</blockquote>
<h4 id="分配堆空间"><a href="#分配堆空间" class="headerlink" title="分配堆空间"></a>分配堆空间</h4><p><code>min_heap</code> 是在插入新的 <code>event</code> 时，如果空间不足是可以自动扩容的，该函数需要传入 <code>n</code> 表明需要让堆装下 <code>n</code> 个元素。由函数 <code>min_heap_reserve_</code> 实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_heap_reserve_</span><span class="params">(<span class="keyword">min_heap_t</span>* s, <span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;a &lt; n) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event</span>** <span class="title">p</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> a = s-&gt;a ? s-&gt;a * <span class="number">2</span> : <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; n) a = n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (SIZE_MAX == UINT32_MAX)</span></span><br><span class="line">        <span class="keyword">if</span> (a&gt; SIZE_MAX / <span class="keyword">sizeof</span> *p) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (!(p = (struct event**)mm_realloc(s-&gt;p, a * <span class="keyword">sizeof</span> *p))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        s-&gt;p = p;</span><br><span class="line">        s-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面说过，<code>min_heap</code> 的成员变量 <code>a</code> 描述的是堆最大所能容纳的元素数目，也就是堆的容量。如果传入的 <code>n</code> 本身小于 <code>a</code>，说明当前堆完全可以装下 <code>n</code> 个元素，因此无需再扩容了。</p>
<p>如果传入的 <code>n</code> 不小于 <code>a</code>，说明此时的堆刚刚能装下或者装不下 <code>n</code> 个元素，此时就需要对堆进行扩容。<code>min_heap</code> 这里分了两种情况：如果堆本身为空，那么就直接为堆分配 <code>8</code> 个元素的空间；如果堆本身不为空，那么就先将堆原本的空间加倍，作为堆的新容量，如果堆非空时加倍之后或者堆空时分配 <code>8</code> 个元素空间还放不下 <code>n</code> 个元素，那么就直接把 <code>n</code> 作为堆的新容量。这样做的好处是不用每次插入一个新的 <code>event</code> 都去重新分配空间。</p>
<p>此外，如果 <code>min_heap</code> 需要分配更大的空间，这里使用的是 <code>realloc</code> 函数，会先调用 <code>malloc</code> 函数进行指定大小空间的分配，再把原来的内存数据复制到新空间中。</p>
<h4 id="堆元素的上浮"><a href="#堆元素的上浮" class="headerlink" title="堆元素的上浮"></a>堆元素的上浮</h4><p>在小根堆中，当堆中元素需要进行调整时，就会对相应的元素进行上浮或者下沉，之所以要这样做，是因为堆中元素调整后不一定还满足小根堆的性质，因此就要重新进行调整，让堆重新满足原来的特性，其对应着上述五个步骤中的步骤 3 到步骤 5。</p>
<p><code>min_heap</code> 的堆元素上浮是通过 <code>min_heap_shift_up_</code> 函数实现的，该函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_shift_up_</span><span class="params">(<span class="keyword">min_heap_t</span>* s, <span class="keyword">unsigned</span> hole_index, struct event* e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> parent = (hole_index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (hole_index &amp;&amp; min_heap_elem_greater(s-&gt;p[parent], e)) &#123;</span><br><span class="line">        (s-&gt;p[hole_index] = s-&gt;p[parent])-&gt;ev_timeout_pos.min_heap_idx = hole_index;</span><br><span class="line">        hole_index = parent;</span><br><span class="line">        parent = (hole_index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (s-&gt;p[hole_index] = e)-&gt;ev_timeout_pos.min_heap_idx = hole_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>首先来看下向堆中弹出节点的一般实现步骤：</p>
<ol>
<li>移除根节点</li>
<li>将最后一个节点移到根节点处</li>
<li>将子节点优先级较高者与父节点比较</li>
<li>如果父节点优先级比子节点低，则调换父子节点位置</li>
<li>重复步骤 3 和步骤 4 直至堆特性被满足</li>
</ol>
<p>接下来我们再分析下 <code>libevent</code> 向堆中弹出一个新节点的过程，，其由 <code>min_heap_pop_</code> 函数实现，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct event* <span class="title">min_heap_pop_</span><span class="params">(<span class="keyword">min_heap_t</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;n) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">e</span> = *<span class="title">s</span>-&gt;<span class="title">p</span>;</span></span><br><span class="line">        min_heap_shift_down_(s, <span class="number">0u</span>, s-&gt;p[--s-&gt;n]);</span><br><span class="line">        e-&gt;ev_timeout_pos.min_heap_idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆元素的下沉"><a href="#堆元素的下沉" class="headerlink" title="堆元素的下沉"></a>堆元素的下沉</h4><p>与堆元素的上浮相似，由 <code>min_heap_shift_down_</code> 函数实现，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_shift_down_</span><span class="params">(<span class="keyword">min_heap_t</span>* s, <span class="keyword">unsigned</span> hole_index, struct event* e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> min_child = <span class="number">2</span> * (hole_index + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (min_child &lt;= s-&gt;n) &#123;</span><br><span class="line">        min_child -= min_child == s-&gt;n || min_heap_elem_greater(s-&gt;p[min_child], s-&gt;p[min_child - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!(min_heap_elem_greater(e, s-&gt;p[min_child]))) <span class="keyword">break</span>;</span><br><span class="line">        (s-&gt;p[hole_index] = s-&gt;p[min_child])-&gt;ev_timeout_pos.min_heap_idx = hole_index;</span><br><span class="line">        hole_index = min_child;</span><br><span class="line">        min_child = <span class="number">2</span> * (hole_index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    (s-&gt;p[hole_index] = e)-&gt;ev_timeout_pos.min_heap_idx = hole_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><p>根据堆的特性，<code>peek</code> 操作只需要返回非空数组的首个元素即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct event* <span class="title">min_heap_top</span><span class="params">(<span class="keyword">min_heap_t</span>* s)</span> </span>&#123; <span class="keyword">return</span> s-&gt;n ? *s-&gt;p : <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="min-heap-的其他操作"><a href="#min-heap-的其他操作" class="headerlink" title="min_heap 的其他操作"></a>min_heap 的其他操作</h2><p><code>min_heap_elt_is_top</code> 函数用于判断 <code>event</code> 是否在堆顶。显然，如果 <code>event</code> 的堆索引为 <code>0</code>，那么这个 <code>event</code> 就在堆顶了。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_heap_elt_is_top_</span><span class="params">(<span class="keyword">const</span> struct event *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;ev_timeout_pos.min_heap_idx == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断堆是否为空及堆大小"><a href="#判断堆是否为空及堆大小" class="headerlink" title="判断堆是否为空及堆大小"></a>判断堆是否为空及堆大小</h3><p>前面说了 <code>min_heap</code> 中的成员变量 <code>n</code> 描述堆中实际存在的元素数目，因此直接判断 <code>n</code> 是否为 <code>0</code> 即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_heap_empty</span><span class="params">(<span class="keyword">min_heap_t</span>* s)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0u</span> == s-&gt;n; &#125;   <span class="comment">// 堆是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">min_heap_size</span><span class="params">(<span class="keyword">min_heap_t</span>* s)</span> </span>&#123; <span class="keyword">return</span> s-&gt;n; &#125;   <span class="comment">// 堆大小</span></span><br></pre></td></tr></table></figure>
<h3 id="堆删除元素"><a href="#堆删除元素" class="headerlink" title="堆删除元素"></a>堆删除元素</h3><p>需要注意的一点是，由于堆末尾的元素对于整个堆来说，删除它对于堆是没有任何影响的，因此，如果要对堆中的任意一个元素进行删除，就可以将需要删除的元素先和堆尾元素互换，然后不考虑需要删除的元素，对互换后的堆进行调整，最终得到的堆就是删除了该元素的堆了。由 <code>min_heap_erase_</code> 实现，由于其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_heap_erase_</span><span class="params">(<span class="keyword">min_heap_t</span>* s, struct event* e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> != e-&gt;ev_timeout_pos.min_heap_idx) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">last</span> = <span class="title">s</span>-&gt;<span class="title">p</span>[--<span class="title">s</span>-&gt;<span class="title">n</span>];</span></span><br><span class="line">        <span class="keyword">unsigned</span> parent = (e-&gt;ev_timeout_pos.min_heap_idx - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;ev_timeout_pos.min_heap_idx &gt; <span class="number">0</span> &amp;&amp; min_heap_elem_greater(s-&gt;p[parent], last))</span><br><span class="line">            min_heap_shift_up_unconditional_(s, e-&gt;ev_timeout_pos.min_heap_idx, last);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            min_heap_shift_down_(s, e-&gt;ev_timeout_pos.min_heap_idx, last);</span><br><span class="line">        e-&gt;ev_timeout_pos.min_heap_idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap_shift_up_unconditional_</span><span class="params">(<span class="keyword">min_heap_t</span>* s, <span class="keyword">unsigned</span> hole_index, struct event* e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> parent = (hole_index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        (s-&gt;p[hole_index] = s-&gt;p[parent])-&gt;ev_timeout_pos.min_heap_idx = hole_index;</span><br><span class="line">        hole_index = parent;</span><br><span class="line">        parent = (hole_index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (hole_index &amp;&amp; min_heap_elem_greater(s-&gt;p[parent], e));</span><br><span class="line">    (s-&gt;p[hole_index] = e)-&gt;ev_timeout_pos.min_heap_idx = hole_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
<li>[2] <a href="https://blog.csdn.net/qq_28114615/article/details/95342338">libevent 源码学习（10）：min_heap 数据结构解析_HerofH_的博客 - CSDN 博客</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 数据结构：尾队列</title>
    <url>/post/2020/e6338d04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文分析的数据结构为 <code>TAILQ</code> 尾队列。</p>
<p><code>libevent</code> 中 <code>TAILQ</code> 尾队列其实就是升级版的 <code>LIST</code> 双向链表。</p>
<a id="more"></a>
<blockquote>
<p>数据结构 <code>LIST</code> 双向链表的分析详见：<a href="/post/2020/ee7292d/" title="源码阅读 libevent - 数据结构：双向链表">源码阅读 libevent - 数据结构：双向链表</a></p>
</blockquote>
<h2 id="尾队列的定义"><a href="#尾队列的定义" class="headerlink" title="尾队列的定义"></a>尾队列的定义</h2><h3 id="尾队列的定义宏"><a href="#尾队列的定义宏" class="headerlink" title="尾队列的定义宏"></a>尾队列的定义宏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_HEAD(name, type)                      \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>                                       \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">tqh_first</span>;</span> <span class="comment">/* first element */</span>                         \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">tqh_last</span>;</span> <span class="comment">/* addr of last next element */</span>             \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_ENTRY(type)                           \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>                                            \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">tqe_next</span>;</span>  <span class="comment">/* next element */</span>      \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">tqe_prev</span>;</span> <span class="comment">/* address of previous next element */</span>      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="尾队列的节点结构"><a href="#尾队列的节点结构" class="headerlink" title="尾队列的节点结构"></a>尾队列的节点结构</h3><p>同双向链表一样，我们通过代码来分析尾队列的节点结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TAILQ_ENTRY(Node) node;</span><br><span class="line">&#125; Node;</span><br><span class="line">TAILQ_HEAD(Head, Node);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Head</span> <span class="title">tailQHead</span>;</span></span><br><span class="line">    TAILQ_INIT(&amp;tailQHead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Node* new_item = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        new_item-&gt;val = i;</span><br><span class="line">        TAILQ_INSERT_HEAD(&amp;tailQHead, new_item, node); <span class="comment">// 头插法插入新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[HEAD] %20p [HEAD ADDR] %20p\n\n&quot;</span>,tailQHead.tqh_first, &amp;tailQHead);</span><br><span class="line">    TAILQ_FOREACH(p, &amp;tailQHead, node) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[NODE] %20d [NODE ADDR] %20p\n&quot;</span>, p-&gt;val, p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[NEXT] %20p [NEXT ADDR] %20p\n&quot;</span>, p-&gt;node.tqe_next, &amp;p-&gt;node.tqe_next);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[PREV] %20p [PREV ADDR] %20p\n\n&quot;</span>, p-&gt;node.tqe_prev, &amp;p-&gt;node.tqe_prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[TAIL] %20p [HEAD ADDR] %20p\n\n&quot;</span>,tailQHead.tqh_last, &amp;tailQHead);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该程序中，定义了节点类型为 <code>Node</code> 类型，其中包含了一个 <code>int</code> 型的 <code>val</code> 变量以及 <code>TAILQ_ENTRY</code> 所定义的结构体。可以看到，调用 <code>TAILQ_HEAD</code> 宏函数时，传入的 <code>name</code> 参数 <code>Head</code> 最终就成为了 <code>TAILQ_HEAD</code> 下结构体类型名。然后用 <code>struct Head</code> 来定义一个 <code>tailQHead</code> 变量作为尾队列的头节点，其中保存的即是尾队列中的首尾节点信息了。接着就是以头插法形式插入三个节点，然后遍历输出各个节点中关键成员的值与地址，结果如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201025215558.png" alt="libevent 尾队列"></p>
<p>从代码结果种可得出尾队列结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      Head                       Node1                   Node2                   Node3</span><br><span class="line">+--------------+    +-----&gt;+--------------+    +--&gt;+--------------+    +--&gt;+--------------+</span><br><span class="line">|   tqh_first  |----+      |    value     |    |   |    value     |    |   |    value     |</span><br><span class="line">|              |&lt;-----+    +--------------+    |   +--------------+    |   +--------------+</span><br><span class="line">+--------------+      |    |   tqe_next   |----+   |   tqe_next   |----+   |   tqe_next   |-----------+</span><br><span class="line">|   tqh_last   |---+  |    |              |&lt;--+    |              |&lt;--+    |              |&lt;---+      |</span><br><span class="line">+--------------+   |  |    +--------------+   |    +--------------+   |    +--------------+    |    -----</span><br><span class="line">                   |  +----|   tqe_prev   |   +----|   tqe_prev   |   +----|   tqe_prev   |    |     ---</span><br><span class="line">                   |       +--------------+        +--------------+        +--------------+    |      -</span><br><span class="line">                   |                                                                           |</span><br><span class="line">                   +---------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="尾队列的访问"><a href="#尾队列的访问" class="headerlink" title="尾队列的访问"></a>尾队列的访问</h2><h3 id="尾队列的访问宏"><a href="#尾队列的访问宏" class="headerlink" title="尾队列的访问宏"></a>尾队列的访问宏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_FIRST(head)           ((head)-&gt;tqh_first)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_END(head)             NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_NEXT(elm, field)      ((elm)-&gt;field.tqe_next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_LAST(head, headname)  (*(((struct headname *)((head)-&gt;tqh_last))-&gt;tqh_last))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_PREV(elm, headname, field)    (*(((struct headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_EMPTY(head)           (TAILQ_FIRST(head) == TAILQ_END(head))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_FOREACH(var, head, field)             \</span></span><br><span class="line">    <span class="keyword">for</span>((var) = TAILQ_FIRST(head); (var) != TAILQ_END(head); (var) = TAILQ_NEXT(var, field))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_FOREACH_REVERSE(var, head, headname, field)       \</span></span><br><span class="line">    <span class="keyword">for</span>((var) = TAILQ_LAST(head, headname); (var) != TAILQ_END(head); (var) = TAILQ_PREV(var, headname, field))</span><br></pre></td></tr></table></figure>
<h3 id="尾队列的访问宏的作用"><a href="#尾队列的访问宏的作用" class="headerlink" title="尾队列的访问宏的作用"></a>尾队列的访问宏的作用</h3><p>从宏定义名即可看出每个宏的作用：</p>
<ul>
<li><code>TAILQ_FIRST</code>：获取尾队列的首节点</li>
<li><code>TAILQ_END</code>：尾队列的末尾，值恒为 <code>NULL</code></li>
<li><code>TAILQ_NEXT</code>：获取尾队列的后继节点的地址</li>
<li><code>TAILQ_LAST</code>：获取尾队列的最后一个节点的地址</li>
<li><code>TAILQ_PREV</code>：获取尾队列的前继节点的地址</li>
<li><code>TAILQ_EMPTY</code>：判断尾队列是否为空，为空时返回真</li>
<li><code>TAILQ_FOREACH</code>：遍历尾队列</li>
<li><code>TAILQ_FOREACH_REVERSE</code>：反向遍历尾队列</li>
</ul>
<blockquote>
<p>注意：在使用 <code>TAILQ_FOREACH</code> 或 <code>TAILQ_FOREACH_REVERSE</code> 遍历尾队列时要避免尾队列的初始化、删除、替换操作！</p>
</blockquote>
<h3 id="尾队列的访问过程"><a href="#尾队列的访问过程" class="headerlink" title="尾队列的访问过程"></a>尾队列的访问过程</h3><h4 id="尾队列的正向遍历"><a href="#尾队列的正向遍历" class="headerlink" title="尾队列的正向遍历"></a>尾队列的正向遍历</h4><p><code>libevent</code> 的尾队列正向遍历方式与双向链表遍历方式一致，可参见：<a href="/post/2020/ee7292d/" title="源码阅读 libevent - 数据结构：双向链表">源码阅读 libevent - 数据结构：双向链表</a>。</p>
<h4 id="尾队列的尾节点获取"><a href="#尾队列的尾节点获取" class="headerlink" title="尾队列的尾节点获取"></a>尾队列的尾节点获取</h4><p>尾队列的尾节点获取方式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_LAST(head, headname)  (*(((struct headname *)((head)-&gt;tqh_last))-&gt;tqh_last))</span></span><br></pre></td></tr></table></figure>
<p>由尾队列结构结合下图可知，尾队列的尾节点获取可通过以下步骤获取：</p>
<ol>
<li>通过 <code>last</code> 指针获得尾结点的 <code>next</code> 指针的地址</li>
<li>通过尾结点的 <code>next</code> 指针的地址加上偏移可以直到尾节点的 <code>prev</code> 指针地址</li>
<li>通过 <code>prev</code> 指针指向的地址获取尾节点的前一个节点的 <code>next</code> 指针地址</li>
<li>前一个节点的 <code>next</code> 指针指向的地址即为尾节点的地址</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      Head                       Node1                   Node2                   Node3</span><br><span class="line">+--------------+    +-----&gt;+--------------+    +--&gt;+--------------+    +&gt;&gt;&gt;+--------------+</span><br><span class="line">|   tqh_first  |----+      |    value     |    |   |    value     |    ③   |    value     |</span><br><span class="line">|              |&lt;-----+    +--------------+    |   +--------------+    |   +--------------+</span><br><span class="line">+--------------+      |    |   tqe_next   |----+   |   tqe_next   |&gt;&gt;&gt;&gt;+   |   tqe_next   |-----------+</span><br><span class="line">|   tqh_last   |&gt;&gt;&gt;+  |    |              |&lt;--+    |              |&lt;&lt;&lt;+    |              |&lt;&lt;&lt;&lt;+      |</span><br><span class="line">+--------------+   |  |    +--------------+   |    +--------------+   ②    +--------------+    |    -----</span><br><span class="line">                   |  +----|   tqe_prev   |   +----|   tqe_prev   |   +&lt;&lt;&lt;&lt;|   tqe_prev   |    |     ---</span><br><span class="line">                   |       +--------------+        +--------------+        +--------------+    |      -</span><br><span class="line">                   |                                                                           |</span><br><span class="line">                   +&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;①&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+</span><br></pre></td></tr></table></figure>
<p>而 <code>TAILQ_LAST</code> 在实现时，为了屏蔽头节点和其他节点结构体上的区别，利用了头节点 <code>first</code>/<code>last</code> 两个指针和其他节点 <code>next</code>/<code>prev</code> 指针在内存中结构一致的特点，将 <code>next</code>/<code>prev</code> 结构体强转为了 <code>first</code>/<code>last</code> 结构体统一了头节点和其他节点在地址查找上的差异。</p>
<h4 id="尾队列的前继节点获取"><a href="#尾队列的前继节点获取" class="headerlink" title="尾队列的前继节点获取"></a>尾队列的前继节点获取</h4><p>尾队列的前继节点获取方式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_PREV(elm, headname, field)    (*(((struct headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last))</span></span><br></pre></td></tr></table></figure>
<p>尾队列的前继节点获取和尾队列的尾节点获取原理一致，可参考下图进行理解（获取 <code>Node3</code> 的前继节点）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      Head                       Node1                   Node2                   Node3</span><br><span class="line">+--------------+    +-----&gt;+--------------+    +&gt;&gt;&gt;+--------------+    +--&gt;+--------------+</span><br><span class="line">|   tqh_first  |----+      |    value     |    ③   |    value     |    |   |    value     |</span><br><span class="line">|              |&lt;-----+    +--------------+    |   +--------------+    |   +--------------+</span><br><span class="line">+--------------+      |    |   tqe_next   |&gt;&gt;&gt;&gt;+   |   tqe_next   |----+   |   tqe_next   |-----------+</span><br><span class="line">|   tqh_last   |---+  |    |              |&lt;&lt;&lt;+    |              |&lt;&lt;&lt;+    |              |&lt;---+      |</span><br><span class="line">+--------------+   |  |    +--------------+   ②    +--------------+   ①    +--------------+    |    -----</span><br><span class="line">                   |  +----|   tqe_prev   |   +&lt;&lt;&lt;&lt;|   tqe_prev   |   +&lt;&lt;&lt;&lt;|   tqe_prev   |    |     ---</span><br><span class="line">                   |       +--------------+        +--------------+        +--------------+    |      -</span><br><span class="line">                   |                                                                           |</span><br><span class="line">                   +---------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h4 id="尾队列的反向遍历"><a href="#尾队列的反向遍历" class="headerlink" title="尾队列的反向遍历"></a>尾队列的反向遍历</h4><p>反向遍历操作同样有三个关键点：遍历的起始节点，遍历的下一节点的获取，遍历的结束条件。</p>
<ul>
<li>遍历的起始节点：参考尾队列的尾节点获取</li>
<li>遍历的下一节点的获取：参考尾队列的前继节点获取</li>
<li><p>遍历的结束条件：<code>TAILQ_PREV</code> 获取地址为空，下图为反向遍历到最后一个节点的情况：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      Head                       Node1                   Node2                   Node3</span><br><span class="line">+--------------+    +-----&gt;+--------------+    +--&gt;+--------------+    +--&gt;+--------------+</span><br><span class="line">|   tqh_first  |----+      |    value     |    |   |    value     |    |   |    value     |</span><br><span class="line">|              |&lt;&lt;&lt;&lt;&lt;&lt;+    +--------------+    |   +--------------+    |   +--------------+</span><br><span class="line">+--------------+      |    |   tqe_next   |----+   |   tqe_next   |----+   |   tqe_next   |&gt;&gt;&gt;&gt;&gt;&gt;③&gt;&gt;&gt;&gt;+</span><br><span class="line">|   tqh_last   |&gt;&gt;&gt;+  ①    |              |&lt;--+    |              |&lt;--+    |              |&lt;&lt;&lt;&lt;+      |</span><br><span class="line">+--------------+   |  |    +--------------+   |    +--------------+   |    +--------------+    |    -----</span><br><span class="line">                   |  +&lt;&lt;&lt;&lt;|   tqe_prev   |   +----|   tqe_prev   |   +----|   tqe_prev   |    |     ---</span><br><span class="line">                   |       +--------------+        +--------------+        +--------------+    |      -</span><br><span class="line">                   |                                                                           |</span><br><span class="line">                   +&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;②&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="尾队列操作"><a href="#尾队列操作" class="headerlink" title="尾队列操作"></a>尾队列操作</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_INIT(head) do &#123;                       \</span></span><br><span class="line">    (head)-&gt;tqh_first = <span class="literal">NULL</span>;                       \</span><br><span class="line">    (head)-&gt;tqh_last = &amp;(head)-&gt;tqh_first;          \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_INSERT_HEAD(head, elm, field) do &#123;    \</span></span><br><span class="line">    <span class="keyword">if</span> (((elm)-&gt;field.tqe_next = (head)-&gt;tqh_first) != <span class="literal">NULL</span>)    \</span><br><span class="line">        (head)-&gt;tqh_first-&gt;field.tqe_prev = &amp;(elm)-&gt;field.tqe_next;             \</span><br><span class="line">    <span class="keyword">else</span> (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next; \</span><br><span class="line">    (head)-&gt;tqh_first = (elm);                      \</span><br><span class="line">    (elm)-&gt;field.tqe_prev = &amp;(head)-&gt;tqh_first;     \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_INSERT_TAIL(head, elm, field) do &#123;    \</span></span><br><span class="line">    (elm)-&gt;field.tqe_next = <span class="literal">NULL</span>;                   \</span><br><span class="line">    (elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;       \</span><br><span class="line">    *(head)-&gt;tqh_last = (elm);                      \</span><br><span class="line">    (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;      \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="后插法"><a href="#后插法" class="headerlink" title="后插法"></a>后插法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_INSERT_AFTER(head, listelm, elm, field) do &#123;                      \</span></span><br><span class="line">    <span class="keyword">if</span> (((elm)-&gt;field.tqe_next = (listelm)-&gt;field.tqe_next) != <span class="literal">NULL</span>)            \</span><br><span class="line">        (elm)-&gt;field.tqe_next-&gt;field.tqe_prev = &amp;(elm)-&gt;field.tqe_next;         \</span><br><span class="line">    <span class="keyword">else</span> (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;                             \</span><br><span class="line">    (listelm)-&gt;field.tqe_next = (elm);              \</span><br><span class="line">    (elm)-&gt;field.tqe_prev = &amp;(listelm)-&gt;field.tqe_next;                         \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="前插法"><a href="#前插法" class="headerlink" title="前插法"></a>前插法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_INSERT_BEFORE(listelm, elm, field) do &#123;                           \</span></span><br><span class="line">    (elm)-&gt;field.tqe_prev = (listelm)-&gt;field.tqe_prev;                          \</span><br><span class="line">    (elm)-&gt;field.tqe_next = (listelm);              \</span><br><span class="line">    *(listelm)-&gt;field.tqe_prev = (elm);             \</span><br><span class="line">    (listelm)-&gt;field.tqe_prev = &amp;(elm)-&gt;field.tqe_next;                         \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_REMOVE(head, elm, field) do &#123;         \</span></span><br><span class="line">    <span class="keyword">if</span> (((elm)-&gt;field.tqe_next) != <span class="literal">NULL</span>)            \</span><br><span class="line">        (elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;          \</span><br><span class="line">    <span class="keyword">else</span> (head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;  \</span><br><span class="line">    *(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next; \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_REPLACE(head, elm, elm2, field) do &#123;                              \</span></span><br><span class="line">    <span class="keyword">if</span> (((elm2)-&gt;field.tqe_next = (elm)-&gt;field.tqe_next) != <span class="literal">NULL</span>)               \</span><br><span class="line">        (elm2)-&gt;field.tqe_next-&gt;field.tqe_prev = &amp;(elm2)-&gt;field.tqe_next;       \</span><br><span class="line">    <span class="keyword">else</span> (head)-&gt;tqh_last = &amp;(elm2)-&gt;field.tqe_next;                            \</span><br><span class="line">    (elm2)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev; \</span><br><span class="line">    *(elm2)-&gt;field.tqe_prev = (elm2);               \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 日志模块</title>
    <url>/post/2020/5f35962e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>libevent</code> 的日志模块的文件为 <code>log.c</code> 和 <code>log-internal.h</code>。</p>
<p>从头文件名就可以看出，<code>libevent</code> 的日志函数只提供 <code>libevent</code> 内部使用，并不提供外部接口。</p>
<p>这些内部日志接口会在运行过程中一些异常情况时被调用，从而将这些异常的情况打印出来，告知用户。而在这些接口不满足用户的需求时，<code>libevent</code> 仍提供了回调函数设置接口方便用户自行修改日志模块的处理方式。</p>
<a id="more"></a>
<h2 id="日志模块函数"><a href="#日志模块函数" class="headerlink" title="日志模块函数"></a>日志模块函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>从 <code>log-internal.h</code> 文件中即可看到 <code>libevnet</code> 的日志相关函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_CHECK_FMT(a,b) __attribute__((format(printf, a, b)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_NORETURN __attribute__((noreturn))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT2_EXPORT_SYMBOL __attribute__ ((visibility(<span class="meta-string">&quot;default&quot;</span>)))</span></span><br><span class="line"></span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">event_err</span><span class="params">(<span class="keyword">int</span> eval, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="title">EV_CHECK_FMT</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span> EV_NORETURN</span>;</span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">event_warn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="title">EV_CHECK_FMT</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">event_sock_err</span><span class="params">(<span class="keyword">int</span> eval, <span class="keyword">evutil_socket_t</span> sock, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="title">EV_CHECK_FMT</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span> EV_NORETURN</span>;</span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">event_sock_warn</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="title">EV_CHECK_FMT</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">event_errx</span><span class="params">(<span class="keyword">int</span> eval, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="title">EV_CHECK_FMT</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span> EV_NORETURN</span>;</span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">event_warnx</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="title">EV_CHECK_FMT</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">event_msgx</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="title">EV_CHECK_FMT</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">event_debugx_</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="title">EV_CHECK_FMT</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">EVENT2_EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">event_logv_</span><span class="params">(<span class="keyword">int</span> severity, <span class="keyword">const</span> <span class="keyword">char</span> *errstr, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> <span class="title">EV_CHECK_FMT</span><span class="params">(<span class="number">3</span>,<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="attribute"><a href="#attribute" class="headerlink" title="__attribute__"></a>__attribute__</h3><p>从上述源码中可以发现，所有的日志 API 均被一些宏定义所修饰，这些宏定义有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_CHECK_FMT(a,b) __attribute__((format(printf, a, b)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_NORETURN __attribute__((noreturn))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT2_EXPORT_SYMBOL __attribute__ ((visibility(<span class="meta-string">&quot;default&quot;</span>)))</span></span><br></pre></td></tr></table></figure>
<p>其意义如下：</p>
<ol>
<li><p><code>__attribute__((format(printf, a, b)))</code></p>
<p> <code>format</code> 属性可以给被声明的函数加上类似 <code>printf</code> 或者 <code>scanf</code> 的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。<code>format</code> 属性告诉编译器，按照 <code>printf</code>，<code>scanf</code> 等标准 <code>C</code> 函数参数格式规则对该函数的参数进行检查。</p>
<p> 如 <code>EV_CHECK_FMT(2,3);</code> 就提示编译器按照 <code>printf</code> 函数格式化的形式来对函数进行编译，并且从第 <code>3</code> 个参数开始按照第 <code>2</code> 个参数字符串的格式进行格式化。</p>
</li>
<li><p><code>__attribute__((noreturn))</code></p>
<p> <code>noreturn</code> 属性告诉编译器此函数不会返回（注意：是不会返回，而不是没有返回值）。 <code>C</code> 库函数 <code>abort()</code> 和 <code>exit()</code> 都使用此属性声明。</p>
</li>
<li><p><code>__attribute__ ((visibility(&quot;default&quot;)))</code></p>
<p> <code>visibility</code> 属性可以控制共享文件导出符号。<code>&quot;default&quot;</code>：用它定义的符号将被导出，动态库中的函数默认是可见的。<code>&quot;hidden&quot;</code>：用它定义的符号将不被导出，并且不能从其它对象进行使用，动态库中的函数是被隐藏的。<code>default</code> 意味着该方法对其它模块是可见的。而 <code>hidden</code> 表示该方法符号不会被放到动态符号表里，所以其它模块 (可执行文件或者动态库) 不可以通过符号表访问该方法。</p>
</li>
</ol>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p><code>libevnet</code> 的日志 <code>API</code> 的函数定义较为简单，下面列出几个示例，其余函数定义可详见源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_err</span><span class="params">(<span class="keyword">int</span> eval, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    event_logv_(EVENT_LOG_ERR, strerror(errno), fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    event_exit(eval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_sock_err</span><span class="params">(<span class="keyword">int</span> eval, <span class="keyword">evutil_socket_t</span> sock, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">int</span> err = evutil_socket_geterror(sock);</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    event_logv_(EVENT_LOG_ERR, evutil_socket_error_to_string(err), fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    event_exit(eval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_debugx_</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    event_logv_(EVENT_LOG_DEBUG, <span class="literal">NULL</span>, fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上述定义中可以发现，这些函数调用的函数为：</p>
<ol>
<li><code>event_logv_</code></li>
<li><code>evutil_socket_geterror</code> 和 <code>evutil_socket_error_to_string</code></li>
<li><code>event_exit</code></li>
</ol>
<h4 id="event-logv"><a href="#event-logv" class="headerlink" title="event_logv_"></a>event_logv_</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">event_log</span><span class="params">(<span class="keyword">int</span> severity, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (log_fn) log_fn(severity, msg);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *severity_str;</span><br><span class="line">        <span class="keyword">switch</span> (severity) &#123;</span><br><span class="line">        <span class="keyword">case</span> EVENT_LOG_DEBUG:</span><br><span class="line">            severity_str = <span class="string">&quot;debug&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EVENT_LOG_MSG:</span><br><span class="line">            severity_str = <span class="string">&quot;msg&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EVENT_LOG_WARN:</span><br><span class="line">            severity_str = <span class="string">&quot;warn&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EVENT_LOG_ERR:</span><br><span class="line">            severity_str = <span class="string">&quot;err&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            severity_str = <span class="string">&quot;???&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (<span class="keyword">void</span>)<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[%s] %s\n&quot;</span>, severity_str, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_logv_</span><span class="params">(<span class="keyword">int</span> severity, <span class="keyword">const</span> <span class="keyword">char</span> *errstr, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DEBUG 等级日志需要在 DEBUG 打开是才能输出 */</span></span><br><span class="line">    <span class="keyword">if</span> (severity == EVENT_LOG_DEBUG &amp;&amp; !event_debug_get_logging_mask_()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fmt != <span class="literal">NULL</span>) evutil_vsnprintf(buf, <span class="keyword">sizeof</span>(buf), fmt, ap);</span><br><span class="line">    <span class="keyword">else</span> buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errstr) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="keyword">sizeof</span>(buf) - <span class="number">3</span>) evutil_snprintf(buf + len, <span class="keyword">sizeof</span>(buf) - len, <span class="string">&quot;: %s&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event_log(severity, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源代码中可以看出 <code>event_logv_</code> 的功能较为简单，其根本上是调用 <code>fprintf</code> 将错误日志打印到 <code>stderr</code>，并且也提供了函数指针 <code>log_fn</code> 以供用户自行替换打印日志函数，替换打印日志函数可调用 <code>event_set_log_callback</code> 函数实现，该函数的声明位于 <code>event.h</code>，实现位于 <code>log.c</code>，可以被用户调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> event_log_cb log_fn = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*event_log_cb)</span><span class="params">(<span class="keyword">int</span> severity, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_log_callback</span><span class="params">(event_log_cb cb)</span> </span>&#123;</span><br><span class="line">    log_fn = cb;</span><br><span class="line">&#125;：</span><br></pre></td></tr></table></figure>
<p><code>libevent</code> 默认的日志处理行为是打印在终端屏幕，这往往不符合我们真正的需求。如果我们想按照自己的方式进行日志处理，那么就可以自定义一个日志处理函数（比如说将错误或警告信息输出到文件中），再将该函数名作为参数调用 <code>event_set_log_callback</code> 即可，如果想再恢复默认的日志处理行为，那么再次调用 <code>event_set_log_callback</code> 函数传入 <code>NULL</code> 即可。</p>
<h4 id="evutil-socket-geterror"><a href="#evutil-socket-geterror" class="headerlink" title="evutil_socket_geterror"></a>evutil_socket_geterror</h4><p><code>evutil_socket_geterror</code> 函数实现在 <code>GNU</code> 编译环境下非常简单，仅仅是对 <code>errno</code> 和 <code>strerror(errno)</code> 的封装，定义该函数的目的是区分不同平台的不同编译环境，如果各位读者有兴趣可自行学习该函数在 <code>Window</code> 平台下的实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_socket_geterror(sock) (errno)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_socket_error_to_string(errcode) (strerror(errcode))</span></span><br></pre></td></tr></table></figure>
<h4 id="event-exit"><a href="#event-exit" class="headerlink" title="event_exit"></a>event_exit</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">event_exit</span><span class="params">(<span class="keyword">int</span> errcode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fatal_fn) &#123;</span><br><span class="line">        fatal_fn(errcode);</span><br><span class="line">        <span class="built_in">exit</span>(errcode);  <span class="comment">/* should never be reached */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errcode == EVENT_ERR_ABORT_)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">exit</span>(errcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>event_exit</code> 的功能也较为简单，其根本上是调用 <code>abort()</code> 或者 <code>exit()</code> 退出程序运行。 当然，<code>event_exit</code> 也和 <code>event_logv_</code> 一样，提供了函数指针 <code>fatal_fn</code> 以供用户自行替换退出程序的方式，替换退出程序函数可调用 <code>event_set_fatal_callback</code> 函数实现，该函数的声明位于 <code>event.h</code>，实现位于 <code>log.c</code>，可以被用户调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*event_fatal_cb)</span><span class="params">(<span class="keyword">int</span> err)</span></span>;</span><br><span class="line"><span class="keyword">static</span> event_fatal_cb fatal_fn = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_fatal_callback</span><span class="params">(event_fatal_cb cb)</span> </span>&#123;</span><br><span class="line">    fatal_fn = cb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>libevent</code> 的错误处理仅在发生 <code>error</code> 的时候进行，在进行错误处理之前会先进行日志处理，默认的错误处理行为是直接 <code>abort</code> 或者 <code>exit</code>。如果想在发生错误后，程序退出之前做一些其他处理，那么就可以自定义一个错误处理函数，并将该函数名作为参数调用 <code>event_set_fatal_callback</code> 即可，如果想再恢复默认的错误处理行为，那么再次调用 <code>event_set_fatal_callback</code> 函数传入 <code>NULL</code> 即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/qq_28114615/article/details/89194018#%E6%97%A5%E5%BF%97%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">libevent 源码学习（1）：日志及错误处理_HerofH_的博客 - CSDN 博客</a></li>
<li>[2] <a href="https://blog.csdn.net/luotuo44/article/details/38317797">Libevent 源码分析 - 日志和错误处理_luotuo44 的专栏 - CSDN 博客</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 结构体：event</title>
    <url>/post/2020/afa6fb2f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <a href="#">Post not found: 源码阅读 libevent - event_io_map</a> 和 <a href="#">Post not found: 源码阅读 libevent - event_signal_map</a> 中，无论是哈希表还是普通数组，都是将一个 fd 或者 sig 映射到了一个双向链表的表头上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LIST_HEAD (event_dlist, event);</span><br><span class="line"><span class="comment">/* 以上宏定义展开后结果为如下所示 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_dlist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">lh_first</span>;</span>  <span class="comment">/* first element */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该双向量表的表头为结构体 <code>struct event_dlist</code>，链表中元素的结构体为 <code>struct event</code>，其中每个 <code>struct event</code> 链表元素代表着一个事件，本文主要分析这个事件结构体：<code>struct event</code>。</p>
<a id="more"></a>
<h2 id="struct-event-的定义"><a href="#struct-event-的定义" class="headerlink" title="struct event 的定义"></a>struct event 的定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_callback</span> <span class="title">ev_evcallback</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123; <span class="comment">/* for managing timeouts */</span></span><br><span class="line">        TAILQ_ENTRY(event) ev_next_with_common_timeout;</span><br><span class="line">        <span class="keyword">int</span> min_heap_idx;</span><br><span class="line">    &#125; ev_timeout_pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">evutil_socket_t</span> ev_fd; <span class="comment">/* 对于 `I/O` 事件是文件描述符，对于 `signal` 事件是信号值 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">ev_base</span>;</span> <span class="comment">/* 与 event 对应的 event_base */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* used for io events */</span></span><br><span class="line">            LIST_ENTRY (event) ev_io_next;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span></span><br><span class="line">        &#125; ev_io;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* used by signal events */</span></span><br><span class="line">            LIST_ENTRY (event) ev_signal_next;</span><br><span class="line">            <span class="keyword">short</span> ev_ncalls;</span><br><span class="line">            <span class="keyword">short</span> *ev_pncalls; <span class="comment">/* Allows deletes in callback */</span></span><br><span class="line">        &#125; ev_signal;</span><br><span class="line">    &#125; ev_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> ev_events; <span class="comment">/* 关注的事件类型 超时、读、写、永久 */</span></span><br><span class="line">    <span class="keyword">short</span> ev_res;    <span class="comment">/* result passed to event callback 事件激活的类型 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span> <span class="comment">/* 超时时间，存储的是一个绝对超时值（从 1970 年 1 月 1 日开始） */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从结构体定义中可以发现，其中有几个我们之前文章提过的结构，如：<code>TAILQ_ENTRY</code>、<code>LIST_ENTRY</code>，这代表同一个 event 结构体可能会出现在多个不同的链表或队列中。</p>
<p>下面我们分块了解下每个结构体成员：</p>
<h3 id="ev-evcallback"><a href="#ev-evcallback" class="headerlink" title="ev_evcallback"></a>ev_evcallback</h3><p><code>ev_evcallback</code> 的定义为：<code>struct event_callback ev_evcallback;</code>，其中 <code>struct event_callback</code> 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_callback</span> &#123;</span></span><br><span class="line">    TAILQ_ENTRY(event_callback) evcb_active_next;</span><br><span class="line">    <span class="keyword">short</span> evcb_flags;</span><br><span class="line">    <span class="keyword">ev_uint8_t</span> evcb_pri;    <span class="comment">/* smaller numbers are higher priority */</span></span><br><span class="line">    <span class="keyword">ev_uint8_t</span> evcb_closure;</span><br><span class="line">    <span class="comment">/* allows us to adopt for different types of events */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> (*evcb_callback)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *);</span><br><span class="line">        <span class="keyword">void</span> (*evcb_selfcb)(struct event_callback *, <span class="keyword">void</span> *);</span><br><span class="line">        <span class="keyword">void</span> (*evcb_evfinalize)(struct event *, <span class="keyword">void</span> *);</span><br><span class="line">        <span class="keyword">void</span> (*evcb_cbfinalize)(struct event_callback *, <span class="keyword">void</span> *);</span><br><span class="line">    &#125; evcb_cb_union;</span><br><span class="line">    <span class="keyword">void</span> *evcb_arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>evcb_active_next</code>：尾队列的成员，保存其在尾队列中的位置等信息（注意，该尾队列的元素类型为 <code>struct event_callback</code>，而非 <code>struct event</code> ）</li>
<li><p><code>evcb_flags</code>：反映 <code>event</code> 目前的状态，是处于超时队列、已添加队列、激活队列、信号队列等</p>
<ul>
<li><p>描述 <code>event</code> 的状态，由 <code>libevent</code> 内部设置。比如说 <code>event</code> 被初始化，那么 <code>flags</code> 就会设置为 <code>EVLIST_INIT</code>，有如下几种状态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLIST_TIMEOUT      0x01    <span class="comment">// event 在 time min_heap 中</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLIST_INSERTED     0x02    <span class="comment">// event 在已注册事件链表中</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLIST_SIGNAL       0x04    <span class="comment">// event 属于信号队列</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLIST_ACTIVE       0x08    <span class="comment">// event 在激活链表中</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLIST_INTERNAL     0x10    <span class="comment">// event 为内部使用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLIST_ACTIVE_LATER 0x20    <span class="comment">// event 在下一次激活链表中</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLIST_FINALIZING   0x40    <span class="comment">// event 已经终止</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLIST_INIT         0x80    <span class="comment">// event 已被初始化，但是哪儿都不在</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLIST_ALL          0xff    <span class="comment">// 包含所有事件状态，用于判断合法性</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>evcb_pri</code>：回调优先级，数字越小优先级越高，实际上就是 <code>event</code> 激活时在激活队列中的索引值</p>
</li>
<li><p><code>evcb_closure</code>：描述 event 在激活时的处理方式。</p>
<ul>
<li><p>对于永久事件来说就需要重新添加到定时器中并调用回调函数，而对于一般的事件来说则是直接调用回调函数。<code>ev_closure</code> 可以设置为以下几种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_CLOSURE_EVENT                0   <span class="comment">// 常规事件，使用 evcb_callback 回调</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_CLOSURE_EVENT_SIGNAL         1   <span class="comment">// 信号事件；使用 evcb_callback 回调</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_CLOSURE_EVENT_PERSIST        2   <span class="comment">// 永久性非信号事件；使用 evcb_callback 回调</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_CLOSURE_CB_SELF              3   <span class="comment">// 简单回调，使用 evcb_selfcb 回调</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_CLOSURE_CB_FINALIZE          4   <span class="comment">// 结束的回调，使用 evcb_cbfinalize 回调</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_CLOSURE_EVENT_FINALIZE       5   <span class="comment">// 结束事件回调，使用 evcb_evfinalize 回调</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_CLOSURE_EVENT_FINALIZE_FREE  6   <span class="comment">// 结束事件之后应该释放，使用 evcb_evfinalize 回调</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>evcb_cb_union</code>：回调函数联合体，其中根据不同的事件类型决定其回调函数的类型</p>
</li>
<li><code>evcb_arg</code>：传给回调函数的参数</li>
</ol>
<h3 id="ev-timeout-pos"><a href="#ev-timeout-pos" class="headerlink" title="ev_timeout_pos"></a>ev_timeout_pos</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123; <span class="comment">/* for managing timeouts */</span></span><br><span class="line">    TAILQ_ENTRY(event) ev_next_with_common_timeout;</span><br><span class="line">    <span class="keyword">int</span> min_heap_idx;</span><br><span class="line">&#125; ev_timeout_pos;</span><br></pre></td></tr></table></figure>
<p><code>libevent</code> 有两种超时管理机制：</p>
<ul>
<li><code>min_heap</code> 机制：使用 <code>min_heap_idx</code>，</li>
<li><code>min_heap</code>+<code>common_timeout</code> 机制：使用 <code>ev_next_with_common_timeout</code></li>
</ul>
<p>上述两种机制只会使用其中一个，使用联合体存储更加节约空间。</p>
<h3 id="ev-base"><a href="#ev-base" class="headerlink" title="ev_base"></a>ev_base</h3><p><code>ev_base</code> 是一个指向 <code>event_base</code> 的指针，用于描述该 <code>event</code> 所属的 <code>event_base</code>。</p>
<p>在 <code>libevent</code> 中，每一个 <code>event_base</code> 都定义了以下几种事件集合：已添加事件队列 <code>eventqueue</code>、已激活事件队列 <code>activequeues</code>、定时器 <code>min_heap</code>、公用超时事件队列 <code>common_timeout_queues</code>、<code>io</code> 事件集合以及 <code>signal</code> 事件集合，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/** An array of nactivequeues queues for active events (ones that</span></span><br><span class="line"><span class="comment">        * have triggered, and whose callbacks need to be called).  Low</span></span><br><span class="line"><span class="comment">        * priority numbers are more important, and stall higher ones.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_list</span> *<span class="title">activequeues</span>;</span>   <span class="comment">// 激活的事件队列</span></span><br><span class="line">    <span class="comment">/** An array of common_timeout_list* for all of the common timeout</span></span><br><span class="line"><span class="comment">        * values we know. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">common_timeout_list</span> **<span class="title">common_timeout_queues</span>;</span> <span class="comment">// 公用超时事件队列</span></span><br><span class="line">    <span class="comment">/** Mapping from file descriptors to enabled (added) events */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_io_map</span> <span class="title">io</span>;</span> <span class="comment">//io 事件集合</span></span><br><span class="line">    <span class="comment">/** Mapping from signal numbers to enabled (added) events. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_signal_map</span> <span class="title">sigmap</span>;</span> <span class="comment">//signal 事件集合</span></span><br><span class="line">    <span class="comment">/** All events that have been enabled (added) in this event_base */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_list</span> <span class="title">eventqueue</span>;</span> <span class="comment">// 已添加事件队列</span></span><br><span class="line">    <span class="comment">/** Priority queue of events with timeouts. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">min_heap</span> <span class="title">timeheap</span>;</span> <span class="comment">// 定时器</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>激活事件队列：所有感兴趣事件发生或者已经超时的 <code>event</code> 的集合</li>
<li>公用超时事件队列：具有相同超时时长的 <code>event</code> 的集合</li>
<li><code>io</code> 事件集合：所有已添加的读写 <code>event</code> 的集合</li>
<li><code>signal</code> 事件集合：所有已添加的信号 <code>event</code> 的集合</li>
<li>已添加事件队列：所有调用了 <code>event_add</code> 进行添加的 <code>event</code> 的集合</li>
<li>定时器：所有添加了并设置超时时间的 <code>event</code> 集合</li>
</ul>
<p>任何一个 <code>event</code>，一旦通过 <code>event_add</code> 进行了添加，那么它就会存在于以上几个集合中的一个或多个中。</p>
<h3 id="ev"><a href="#ev" class="headerlink" title="ev_"></a>ev_</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* used for io events */</span></span><br><span class="line">        LIST_ENTRY (event) ev_io_next;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span></span><br><span class="line">    &#125; ev_io;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* used by signal events */</span></span><br><span class="line">        LIST_ENTRY (event) ev_signal_next;</span><br><span class="line">        <span class="keyword">short</span> ev_ncalls;</span><br><span class="line">        <span class="keyword">short</span> *ev_pncalls; <span class="comment">/* Allows deletes in callback */</span></span><br><span class="line">    &#125; ev_signal;</span><br><span class="line">&#125; ev_;</span><br></pre></td></tr></table></figure>
<p>这个联合体中有两个结构体，分别对应了 <code>IO</code> 事件和 <code>Signal</code> 事件，由于同一个 <code>fd</code> 二者不会同时触发，故可用联合体保存两个事件的信息：</p>
<ul>
<li><code>ev_io</code>：保存 <code>IO</code> 事件信息<ol>
<li><code>ev_io_next</code>：该 <code>event</code> 在 <code>event_io_map</code> 中的双向链表中的位置</li>
<li><code>ev_timeout</code>：如果 <code>event</code> 是永久事件，那么该变量就存储设置的超时时长，这是一个相对超时值</li>
</ol>
</li>
<li><code>ev_signal</code>：保存 <code>Signal</code> 事件信息<ol>
<li><code>ev_signal_next</code>：该 <code>event</code> 在 <code>event_signal_map</code> 中的双向链表中的位置</li>
<li><code>ev_ncalls</code>：当 <code>signal</code> 事件激活时，调用回调函数的次数</li>
<li><code>ev_pncalls</code>：指向 <code>ev_ncalls</code></li>
</ol>
</li>
</ul>
<blockquote>
<p>为什么同一个 <code>fd</code> 不会同时触发  <code>IO</code> 事件和 <code>Signal</code> 事件？参见：<a href="/post/2020/89de67d/" title="源码阅读 libevent - 信号事件处理">源码阅读 libevent - 信号事件处理</a></p>
</blockquote>
<h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><p><code>ev_events</code>：<code>event</code> 感兴趣的事件类型，可以定义为以下组合：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_TIMEOUT  0x01    <span class="comment">// 超时事件</span></span></span><br><span class="line"><span class="comment">/** Wait for a socket or FD to become readable */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_READ     0x02    <span class="comment">// 读事件</span></span></span><br><span class="line"><span class="comment">/** Wait for a socket or FD to become writeable */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WRITE    0x04    <span class="comment">// 写事件</span></span></span><br><span class="line"><span class="comment">/** Wait for a POSIX signal to be raised*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_SIGNAL   0x08    <span class="comment">// 信号事件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_PERSIST  0x10    <span class="comment">// 永久事件，激活执行后会重新加到队列中等待下一次激活，否则激活执行后会自动移除</span></span></span><br><span class="line"><span class="comment">/** Select edge-triggered behavior, if supported by the backend. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ET       0x20    <span class="comment">// 边沿触发，一般需要后端方法支持</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_FINALIZE 0x40    <span class="comment">// 终止事件，如果设置这个选项，则 event_del 不会阻塞，需要使用 event_finalize 或者 event_free_finalize 以保证多线程安全 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_CLOSED   0x80    <span class="comment">// 关闭事件，可以使用这个选项来检测链接是否关闭，而不需要读取此链接所有未决数据；</span></span></span><br></pre></td></tr></table></figure>
<p><code>ev_timeout</code>：与前面的 <code>ev_io</code> 中的 <code>ev_timeout</code> 不同，<code>ev_io</code> 中的 <code>ev_timeout</code> 保存的是相对超时时长，而这里的 <code>ev_timeout</code> 保存的是绝对超时时间。比如说现在 <code>8:00</code>，设置 <code>event</code> 的超时时长为 <code>3</code> 分钟中，那么这个 <code>3</code> 分钟实际上是相对于现在来说的 <code>3</code> 分钟，也就是相对超时时长，而 <code>event</code> 最终会在 <code>8:03</code> 时超时，这个 <code>8:03</code> 就是绝对超时时间。<code>libevent</code> 中绝对超时时间是相对于 <code>1970</code> 年 <code>1</code> 月 <code>1</code> 日 <code>0</code> 时来说的。</p>
<p><code>ev_res</code>：<code>event</code> 的激活类型，由 <code>libevent</code> 内部设置。比如说 <code>event</code> 可以设置为 <code>EV_READ|EV_WRITE</code> 来监听读和写事件，如果最终 <code>event</code> 被读事件激活，那么 <code>ev_res</code> 就是 <code>EV_READ</code>。</p>
<h2 id="event-的生命周期"><a href="#event-的生命周期" class="headerlink" title="event 的生命周期"></a>event 的生命周期</h2><p>前面提到的中文翻译的文档里，有一张图完美的诠释了 <code>event</code> 的生命周期，带箭头实线表示函数调用，实线矩形表示 <code>event</code> 的状态，虚线矩形表示用来检测事件状态的函数：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128204050.png" alt="event 的生命周期"></p>
<p>由于 <code>event</code> 结构体是 <code>libevent</code> 事件处理的核心，涉及问题较多，本文先对图中上半部分进行解析。</p>
<h2 id="创建-event"><a href="#创建-event" class="headerlink" title="创建 event"></a>创建 event</h2><p>通过前面 <code>event</code> 的结构可以知道，<code>event</code> 结构体成员分为两类：一类是 <code>event</code> 本身的属性，另一类则是用于描述 <code>event</code> 在某些 <code>event</code> 集合中的位置。前者既然是属性，那么就应当在 <code>event</code> 创建时就制定好，而后者则应该是当 <code>event</code> 被添加到 <code>event_base</code> 之后才进行设置的。那么现在就来看看 <code>event</code> 的创建。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *</span></span><br><span class="line"><span class="class"><span class="title">event_new</span>(<span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>, <span class="title">evutil_socket_t</span> <span class="title">fd</span>, <span class="title">short</span> <span class="title">events</span>, <span class="title">void</span> (*<span class="title">cb</span>)(<span class="title">evutil_socket_t</span>, <span class="title">short</span>, <span class="title">void</span> *), <span class="title">void</span> *<span class="title">arg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></span><br><span class="line">    ev = mm_malloc(<span class="keyword">sizeof</span>(struct event));</span><br><span class="line">    <span class="keyword">if</span> (ev == <span class="literal">NULL</span>) <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (event_assign(ev, base, fd, events, cb, arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        mm_free(ev);</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做了 <code>2</code> 个事情：分配内存、初始化结构。</p>
<p>首先通过 <code>mm_malloc()</code> 先从堆上分配 <code>struct event</code> 的空间，为了监听这个事件，要保证这个事件一直在整个事件循环的过程中是存在的，因此只能从堆上分配。</p>
<p>分配内存后的 <code>event</code> 通过 <code>event_assign()</code> 根据参数对其各个字段初始化，<code>event_assign()</code> 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_assign</span><span class="params">(struct event *ev, struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">void</span> (*callback)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!base) base = current_base;</span><br><span class="line">    <span class="keyword">if</span> (arg == &amp;event_self_cbarg_ptr_) arg = ev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(events &amp; EV_SIGNAL)) event_debug_assert_socket_nonblocking_(fd);</span><br><span class="line">    event_debug_assert_not_added_(ev);</span><br><span class="line"></span><br><span class="line">    ev-&gt;ev_base = base;</span><br><span class="line">    ev-&gt;ev_callback = callback;</span><br><span class="line">    ev-&gt;ev_arg = arg;</span><br><span class="line">    ev-&gt;ev_fd = fd;</span><br><span class="line">    ev-&gt;ev_events = events;</span><br><span class="line">    ev-&gt;ev_res = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;ev_flags = EVLIST_INIT;</span><br><span class="line">    ev-&gt;ev_ncalls = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;ev_pncalls = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (events &amp; EV_SIGNAL) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((events &amp; (EV_READ|EV_WRITE|EV_CLOSED)) != <span class="number">0</span>) &#123;</span><br><span class="line">            event_warnx(<span class="string">&quot;%s: EV_SIGNAL is not compatible with EV_READ, EV_WRITE or EV_CLOSED&quot;</span>, __func__);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ev-&gt;ev_closure = EV_CLOSURE_EVENT_SIGNAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (events &amp; EV_PERSIST) &#123;</span><br><span class="line">            evutil_timerclear(&amp;ev-&gt;ev_io_timeout);</span><br><span class="line">            ev-&gt;ev_closure = EV_CLOSURE_EVENT_PERSIST;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ev-&gt;ev_closure = EV_CLOSURE_EVENT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    min_heap_elem_init_(ev);</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">NULL</span>) ev-&gt;ev_pri = base-&gt;nactivequeues / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    event_debug_note_setup_(ev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>event_assign()</code> 实际上就是通过传入的参数对 <code>event</code> 进行了设置，并且对一些值进行了初始化：<code>signal</code> 事件的激活处理方式为 <code>EV_CLOSURE_SIGNAL</code>，永久事件的激活处理方式为 <code>EV_CLOSURE_PERSIST</code>，一般的 <code>IO</code> 事件激活处理方式则为 <code>EV_CLOSURE_NONE</code>。需要注意的是，如果一个 <code>event</code> 的感兴趣事件类型设置为了 <code>EV_SIGNAL</code>，那么它就不能再同时设置读或写事件为感兴趣事件，反之亦然。</p>
<p>如果是要创建超时事件，<code>fd</code> 和 <code>events</code> 的值分别设置为 <code>-1</code> 和 <code>0</code>，<code>libevent</code> 用一个宏来表示，超时事件的创建：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_new(b, cb, arg) event_new((b), -1, 0, (cb), (arg))</span></span><br></pre></td></tr></table></figure>
<p>此时新创建的 <code>event</code> 处于 <code>non-pending</code> 状态，<code>event_assign()</code> 为其设置超时的时间，这个步骤会推迟到 <code>event</code> 被添加到 <code>reactor</code> 中的时候。跟着箭头向下，<code>event_add()</code> 会将 <code>non-pending</code> 的 <code>event</code> 添加到 <code>reactor</code> 中，同时为其设置超时时间。</p>
<ul>
<li><p><code>event_assign()</code> 中使用了宏来对 <code>event</code> 中的参数赋值，所以看起来像赋值了很多 <code>event</code> 中没有的成员，部分宏定义如下：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_ncalls       ev_.ev_signal.ev_ncalls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_pncalls      ev_.ev_signal.ev_pncalls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_pri          ev_evcallback.evcb_pri</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_flags        ev_evcallback.evcb_flags</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_closure      ev_evcallback.evcb_closure</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_callback     ev_evcallback.evcb_cb_union.evcb_callback</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ev_arg          ev_evcallback.evcb_arg</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建好一个 <code>event</code> 之后，接着就需要将其添加到 <code>event_base</code> 中的相关集合中，以供后续进行监听和处理：</p>
<h2 id="添加-event-到-event-base"><a href="#添加-event-到-event-base" class="headerlink" title="添加 event 到 event_base"></a>添加 event 到 event_base</h2><p><code>libevent</code> 向用户提供的添加接口是 <code>event_add()</code> 函数，实际上这个函数内部主要是调用 <code>event_add_nolock_()</code> 函数来完成 <code>event</code> 的添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (EVUTIL_FAILURE_CHECK(!ev-&gt;ev_base)) &#123;</span><br><span class="line">        event_warnx(<span class="string">&quot;%s: event has no event_base set.&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EVBASE_ACQUIRE_LOCK(ev-&gt;ev_base, th_base_lock);</span><br><span class="line">    res = event_add_nolock_(ev, tv, <span class="number">0</span>);</span><br><span class="line">    EVBASE_RELEASE_LOCK(ev-&gt;ev_base, th_base_lock);</span><br><span class="line">    <span class="keyword">return</span> (res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>event_add</code> 并不做实际的工作，而是获得锁之后，将任务交给 <code>event_add_nolock_()</code> 来完成，关于 <code>libevent</code> 线程安全的内容暂且不说，后边单独开一篇来讨论。</p>
<h3 id="event-add-nolock"><a href="#event-add-nolock" class="headerlink" title="event_add_nolock_()"></a>event_add_nolock_()</h3><p><code>event_add_nolock_()</code> 干的活儿非常多，为了深入理解这里也不会一一展开，同样也需要留到后边剖析 (事件管理框架，超时时间管理)，这里仅仅摘出一条主线，省略其他干扰项：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add_nolock_</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv, <span class="keyword">int</span> tv_is_absolute)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_CLOSED|EV_SIGNAL)) &amp;&amp;</span><br><span class="line">        !(ev-&gt;ev_flags &amp; (EVLIST_INSERTED|EVLIST_ACTIVE|EVLIST_ACTIVE_LATER))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_CLOSED))</span><br><span class="line">            res = evmap_io_add_(base, ev-&gt;ev_fd, ev);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_SIGNAL)</span><br><span class="line">            res = evmap_signal_add_(base, (<span class="keyword">int</span>)ev-&gt;ev_fd, ev);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">            event_queue_insert_inserted(base, ev);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* evmap says we need to notify the main thread. */</span></span><br><span class="line">            notify = <span class="number">1</span>;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    event_queue_insert_timeout(base, ev);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前的文章提到过：<code>libevent</code> 分别利用两个数组分别管理 <code>I/O</code> 事件和信号事件（<code>Windows</code> 上使用 <code>hashmap</code> 管理 <code>I/O</code> 事件），利用 <code>min_heap</code> 管理超时事件。<code>event</code> 变量正是通过 <code>event_add_nolock_</code> 函数被调加到对应的数据结构上，分别是 <code>evmap_io_add_()</code>、<code>evmap_signal_add_()</code> 和 <code>event_queue_insert_timeout()</code> 三个函数。</p>
<p>至此，<code>event</code> 的状态就变为了 <code>pending</code> 状态，可以通过 <code>event_pending</code> 函数获取。事件循环开始工作后，<code>event</code> 就处于被监听的状态了。</p>
<h2 id="从-event-base-删除-event"><a href="#从-event-base-删除-event" class="headerlink" title="从 event_base 删除 event"></a>从 event_base 删除 event</h2><p><code>libevent</code> 同样提供了接口让我们取消监听 <code>event</code>，和 <code>event_add()</code> 类似，<code>event_del()</code> 也是讲任务交给 <code>event_del_nolock_()</code> 来完成。取消监听和监听是逆操作，这在代码里边也有体现, 同样地，只摘出了主线：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del_nolock_</span><span class="params">(struct event *ev, <span class="keyword">int</span> blocking)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_TIMEOUT) event_queue_remove_timeout(base, ev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_ACTIVE) event_queue_remove_active(base, event_to_event_callback(ev));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_ACTIVE_LATER) event_queue_remove_active_later(base, event_to_event_callback(ev));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_flags &amp; EVLIST_INSERTED) &#123;</span><br><span class="line">        event_queue_remove_inserted(base, ev);</span><br><span class="line">        <span class="keyword">if</span> (ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_CLOSED)) res = evmap_io_del_(base, ev-&gt;ev_fd, ev);</span><br><span class="line">        <span class="keyword">else</span> res = evmap_signal_del_(base, (<span class="keyword">int</span>)ev-&gt;ev_fd, ev);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">1</span>) &#123;</span><br><span class="line">            notify = <span class="number">1</span>; <span class="comment">/* evmap says we need to notify the main thread. */</span></span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>event</code> 的回调函数可能在其他线程正在运行着，为了线程安全，<code>blocking</code> 参数是必要的。</p>
<p><code>event_del_nolock_()</code> 主要做的事情正和 <code>event_add_nolock_()</code> 相反，它把定时器从超时事件最小堆上移除，然后将其从信号或者 <code>I/O</code> 的 <code>hashmap</code> 上移除。额外地，还需要将就绪的回调函数从待处理的回调函数链表上摘除，也就是说如果这个 event 已经触发，顺利调用了 <code>event_del()</code> 之后，它的回调函数不会被运行。</p>
<p><code>event</code> 的状态会从 <code>pending</code> 回到 <code>non-pending</code> 状态。</p>
<h2 id="释放-event"><a href="#释放-event" class="headerlink" title="释放 event"></a>释放 event</h2><p>和 <code>event_new()</code> 对应，<code>event_free()</code> 先取消监听 <code>event</code>，然后释放其内存：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_free</span><span class="params">(struct event *ev)</span> </span>&#123;</span><br><span class="line">    event_del(ev);</span><br><span class="line">    mm_free(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然简单，但是却很重要，尤其不要忘记释放内存，造成内存泄漏。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
<li>[2] <a href="https://blog.csdn.net/qq_28114615/article/details/96864601">libevent 源码学习（9）：事件 event_HerofH_的博客 - CSDN 博客</a></li>
<li>[3] <a href="http://www.ilovecpp.com/2018/05/01/libevent-event-analyze/">抽丝剥茧 libevent——初识 event | Baixiangcpp’s Blog</a></li>
<li>[4] <a href="https://www.gitbook.com/book/aceld/libevent">Libevent 深入浅出 · libevent 深入浅出</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 时间管理</title>
    <url>/post/2020/39d8a9e7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了支持定时器，<code>libevent</code> 必须和系统时间打交道，z 在 <code>event_add</code> 时，用户制定了一个超时时间，这个超时时间是一个相对时间，但在 <code>event_add</code> 函数内部，<code>libevent</code> 将其转换为了绝对时间，这就带来了一个问题：在系统时间改变时，<code>libevent</code> 需要修改 <code>event</code> 的绝对时间，为此 <code>libevent</code> 内部有以下几种解决方案：</p>
<ol>
<li>使用单调时间 <code>monotonic time</code></li>
<li>使用系统时间生成 <code>fake monotonic time</code></li>
<li>使用系统时间（已弃用）</li>
</ol>
<a id="more"></a>
<h2 id="使用-monotonic-时间"><a href="#使用-monotonic-时间" class="headerlink" title="使用 monotonic 时间"></a>使用 monotonic 时间</h2><h3 id="什么是-monotonic-时间"><a href="#什么是-monotonic-时间" class="headerlink" title="什么是 monotonic 时间"></a>什么是 monotonic 时间</h3><p><code>monotonic time</code> 字面意思是单调时间，实际上它指的是系统启动以后流逝的时间，这是由变量 <code>jiffies</code> 来记录的。</p>
<p>系统每次启动时 <code>jiffies</code> 初始化为 0，每来一个 <code>timer interrupt</code>，<code>jiffies</code> 加 <code>1</code>，也就是说它代表系统启动后流逝的 <code>tick</code> 数</p>
<h3 id="是否使用-monotonic-时间"><a href="#是否使用-monotonic-时间" class="headerlink" title="是否使用 monotonic 时间"></a>是否使用 monotonic 时间</h3><p>决定 <code>libevent</code> 是否使用 <code>monotonic</code> 时间取决于系统是否支持 <code>monotonic</code> 时间，<code>libevent</code> 对其有两处判断，一处在编译时判断，一处在运行时判断：</p>
<h4 id="编译时判断"><a href="#编译时判断" class="headerlink" title="编译时判断"></a>编译时判断</h4><p>通过 <code>Cmake</code> 判断系统环境，来确定获取 <code>monotonic</code> 时间的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CMakeLists.txt:</span></span><br><span class="line">CHECK_FUNCTION_EXISTS_EX(clock_gettime EVENT__HAVE_CLOCK_GETTIME)</span><br><span class="line">CHECK_FUNCTION_EXISTS_EX(mach_absolute_time EVENT__HAVE_MACH_ABSOLUTE_TIME)</span><br><span class="line"></span><br><span class="line"><span class="comment">// time-internal.h:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(EVENT__HAVE_CLOCK_GETTIME) &amp;&amp; defined(CLOCK_MONOTONIC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_POSIX_MONOTONIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(EVENT__HAVE_MACH_ABSOLUTE_TIME)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MACH_MONOTONIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_WIN32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_WIN32_MONOTONIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_FALLBACK_MONOTONIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>根据 <code>time-internal.h</code> 中的四个不同的宏定义，<code>libevent</code> 定义了四个 <code>evutil_configure_monotonic_time_</code> 函数，本文主要分析 <code>HAVE_POSIX_MONOTONIC</code> 宏定义下的 <code>evutil_configure_monotonic_time_</code> 函数。</p>
<h4 id="运行时判断"><a href="#运行时判断" class="headerlink" title="运行时判断"></a>运行时判断</h4><p><code>libevent</code> 会在 <code>event_base</code> 创建时对 <code>monotonic</code> 时间的支持进行判断，判断方式为：调用不同平台下的 <code>monotonic</code> 时间获取函数，如果能正确返回，则代表该平台支持 <code>monotonic</code> 时间，<code>libevent</code> 后续使用 <code>gettime</code> 获取时间均会使用 <code>monotonic</code> 时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The POSIX clock_gettime() interface provides a few ways to get at a monotonic clock.</span></span><br><span class="line"><span class="comment">   CLOCK_MONOTONIC is most widely supported.</span></span><br><span class="line"><span class="comment">   Linux also provides a CLOCK_MONOTONIC_COARSE with accuracy of about 1-4 msec.</span></span><br><span class="line"><span class="comment">   On all platforms I&#x27;m aware of, CLOCK_MONOTONIC really is monotonic.</span></span><br><span class="line"><span class="comment">   Platforms don&#x27;t agree about whether it should jump on a sleep/resume. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_configure_monotonic_time_</span><span class="params">(struct evutil_monotonic_timer *base, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* CLOCK_MONOTONIC exists on FreeBSD, Linux, and Solaris.  You need to check for it at runtime,</span></span><br><span class="line"><span class="comment">     * because some older kernel versions won&#x27;t have it working. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> fallback = flags &amp; EV_MONOT_FALLBACK;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fallback &amp;&amp; clock_gettime(CLOCK_MONOTONIC, &amp;ts) == <span class="number">0</span>) &#123;</span><br><span class="line">        base-&gt;monotonic_clock = CLOCK_MONOTONIC;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CLOCK_MONOTONIC &lt; <span class="number">0</span>) event_errx(<span class="number">1</span>,<span class="string">&quot;I didn&#x27;t expect CLOCK_MONOTONIC to be &lt; 0&quot;</span>);</span><br><span class="line">    base-&gt;monotonic_clock = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>libevent</code> 所在的系统支持 <code>monotonic</code> 时间，那么根本就不用考虑用户手动修改系统时间这坑爹的事情。但如果所在的系统没有支持 <code>monotonic</code> 时间，那么 <code>libevent</code> 就只能使用 <code>evutil_gettimeofday</code> 获取一个用户能修改的时间。</p>
<h2 id="使用-fake-monotonic-时间"><a href="#使用-fake-monotonic-时间" class="headerlink" title="使用 fake monotonic 时间"></a>使用 fake monotonic 时间</h2><p>从上述分析中可以看到，在平台不支持 <code>base-&gt;monotonic_clock</code> 会被 <code>libevent</code> 置为 <code>-1</code>，此时调用 <code>gettime</code> 就会调用 <code>evutil_gettimeofday</code> 来获取系统时间，并通过 <code>adjust_monotonic_time</code> 将获取到的系统时间调整为一个单调递增的时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_gettime_monotonic_</span><span class="params">(struct evutil_monotonic_timer *base, struct timeval *tp)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;monotonic_clock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (evutil_gettimeofday(tp, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// evutil_gettimeofday 调用 gettimeofday 函数</span></span><br><span class="line">        adjust_monotonic_time(base, tp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clock_gettime(base-&gt;monotonic_clock, &amp;ts) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    tp-&gt;tv_sec = ts.tv_sec;</span><br><span class="line">    tp-&gt;tv_usec = ts.tv_nsec / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gettime</span><span class="params">(struct event_base *base, struct timeval *tp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;tv_cache.tv_sec) &#123;</span><br><span class="line">        *tp = base-&gt;tv_cache;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (evutil_gettime_monotonic_(&amp;base-&gt;monotonic_timer, tp) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="系统时间到-fake-monotonic-时间的转化"><a href="#系统时间到-fake-monotonic-时间的转化" class="headerlink" title="系统时间到 fake monotonic 时间的转化"></a>系统时间到 fake monotonic 时间的转化</h3><p><code>libevent</code> 获取到系统时间后，会调用 <code>adjust_monotonic_time</code> 生成 <code>fake monotonic</code> 时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This function assumes it&#x27;s called repeatedly with a not-actually-so-monotonic time source whose outputs</span></span><br><span class="line"><span class="comment">   are in &#x27;tv&#x27;. It implements a trivial ratcheting mechanism so that the values never go backwards. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjust_monotonic_time</span><span class="params">(struct evutil_monotonic_timer *base, struct timeval *tv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* tv 输入的是 real time，输出为 fake monotonic time */</span></span><br><span class="line">    evutil_timeradd(tv, &amp;base-&gt;adjust_monotonic_clock, tv); <span class="comment">// evutil_timeradd(a,b,c) &lt;--&gt; c = a + b</span></span><br><span class="line">    <span class="comment">// 如果 tv &lt; last_time 表明用户向前调整时间了，需要校正时间</span></span><br><span class="line">    <span class="keyword">if</span> (evutil_timercmp(tv, &amp;base-&gt;last_time, &lt;)) &#123; <span class="comment">// evutil_timercmp(a,b,op) &lt;--&gt; a op b</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">adjust</span>;</span> <span class="comment">// 保存差值</span></span><br><span class="line">        evutil_timersub(&amp;base-&gt;last_time, tv, &amp;adjust); <span class="comment">// evutil_timersub(a,b,c) &lt;--&gt; c = a - b</span></span><br><span class="line">        evutil_timeradd(&amp;adjust, &amp;base-&gt;adjust_monotonic_clock, &amp;base-&gt;adjust_monotonic_clock);</span><br><span class="line">        *tv = base-&gt;last_time;</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;last_time = *tv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码中可以看出，如果用户没有向前调整时间，则 <code>adjust_monotonic_time</code> 函数返回的就是真实的时间，如果用户向前调整了时间，<code>libevent</code> 会将用户向前调整的时间累计到 <code>base-&gt;adjust_monotonic_clock</code> 参数中，再之后获取的时间就都会被 <code>adjust_monotonic_time</code> 函数加上 <code>base-&gt;adjust_monotonic_clock</code> 再返回出来，从而实现时间的单调递增，即 <code>fake monotonic</code> 时间</p>
<h2 id="使用系统时间"><a href="#使用系统时间" class="headerlink" title="使用系统时间"></a>使用系统时间</h2><p>该部分内容已被 <code>libevent</code> 于 <code>2012</code> 年弃用，如读者有兴趣，可以查看 <a href="https://blog.csdn.net/luotuo44/article/details/38661787">参考资料[2]</a> 中的分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Revision: f5e4eb05e5bdf61b0a1b11f99effaf835a8796ce</span><br><span class="line">Author: Nick Mathewson &lt;nickm@torproject.org&gt;</span><br><span class="line">Date: 2012&#x2F;4&#x2F;21 1:14:10</span><br><span class="line">Message:</span><br><span class="line">Refactor monotonic timer handling into a new type and set of functions; add a gettimeofday-based ratcheting implementation</span><br><span class="line">Now, event.c can always assume that we have a monotonic timer; thismakes event.c easier to write.</span><br><span class="line">----</span><br><span class="line">Modified: event-internal.h</span><br><span class="line">Modified: event.c</span><br><span class="line">Modified: evutil_time.c</span><br><span class="line">Modified: time-internal.h</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
<li>[2] <a href="https://blog.csdn.net/luotuo44/article/details/38661787">Libevent 源码分析 - Libevent 时间管理 luotuo44 的专栏 - CSDN 博客</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 结构体：event_once</title>
    <url>/post/2020/c8f9ab4c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于只需要触发一次的事件，<code>libevent</code> 提供了一种方案：<code>event_once</code>，让使用者不需要手动管理 <code>event</code>，并且也保证了事件被触发后，内存会被自动被释放。</p>
<a id="more"></a>
<h2 id="struct-event-once-的定义"><a href="#struct-event-once-的定义" class="headerlink" title="struct event_once 的定义"></a>struct event_once 的定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_once</span> &#123;</span></span><br><span class="line">    LIST_ENTRY(event_once) next_once;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*cb)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">void</span> *arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="创建-event-once"><a href="#创建-event-once" class="headerlink" title="创建 event_once"></a>创建 event_once</h2><p>并没有 <code>event_once_new()</code> 之类的函数用于创建 <code>event_once</code>，要使用它要到一个新的函数 <code>event_base_once()</code>, 它将 <code>event_new()</code> 和 <code>event_add()</code> 两个步骤合成了一个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Schedules an event once */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_once</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*callback)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">const</span> struct timeval *tv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((eonce = mm_calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct event_once))) == <span class="literal">NULL</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    eonce-&gt;cb = callback;</span><br><span class="line">    eonce-&gt;arg = arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((events &amp; (EV_TIMEOUT|EV_SIGNAL|EV_READ|EV_WRITE|EV_CLOSED)) == EV_TIMEOUT) &#123;</span><br><span class="line">        evtimer_assign(&amp;eonce-&gt;ev, base, event_once_cb, eonce);</span><br><span class="line">        <span class="keyword">if</span> (tv == <span class="literal">NULL</span> || ! evutil_timerisset(tv)) activate = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; (EV_READ|EV_WRITE|EV_CLOSED)) &#123;</span><br><span class="line">        events &amp;= EV_READ|EV_WRITE|EV_CLOSED;</span><br><span class="line">        event_assign(&amp;eonce-&gt;ev, base, fd, events, event_once_cb, eonce);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mm_free(eonce);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (activate) event_active_nolock_(&amp;eonce-&gt;ev, EV_TIMEOUT, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> res = event_add_nolock_(&amp;eonce-&gt;ev, tv, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">            mm_free(eonce);</span><br><span class="line">            <span class="keyword">return</span> (res);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LIST_INSERT_HEAD(&amp;base-&gt;once_events, eonce, next_once);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>event_base_once()</code> 的参数也和 <code>event_new()</code> 一样，功能也是一样，不做额外的解释，主要看一下 <code>event_once()</code> 里边的多出来的回调函数用来干了什么事情。</p>
<p>我们用 <code>event_once-&gt;cb</code> 和 <code>event-&gt;cb</code> 分别表示 <code>event_once</code> 和 <code>event</code> 里的回调函数。首先函数入口处直接把参数里的 <code>callback</code> 赋值给了 <code>event_once-&gt;cb</code>，它用来负责实际的事件回调。然后调用 <code>event_assign</code> 新建一个 <code>event</code> 初始化 <code>event_once-&gt;event</code> 的同时，传入了一个 <code>event_once_cb()</code> 回调函数。这个函数才是事件发生时会被回调的函数，也是一次性事件的秘密所在。</p>
<h2 id="event-once-的回调和销毁"><a href="#event-once-的回调和销毁" class="headerlink" title="event_once 的回调和销毁"></a>event_once 的回调和销毁</h2><p>上文中说到，<code>event_once_cb()</code> 是一次性事件的真正回调函数，我们来看下该函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">event_once_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_once</span> *<span class="title">eonce</span> = <span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">    (*eonce-&gt;cb)(fd, events, eonce-&gt;arg);</span><br><span class="line">    EVBASE_ACQUIRE_LOCK(eonce-&gt;ev.ev_base, th_base_lock);</span><br><span class="line">    LIST_REMOVE(eonce, next_once);</span><br><span class="line">    EVBASE_RELEASE_LOCK(eonce-&gt;ev.ev_base, th_base_lock);</span><br><span class="line">    event_debug_unassign(&amp;eonce-&gt;ev);</span><br><span class="line">    mm_free(eonce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>event_once_cb()</code> 这个函数被回调时，会马上调用 <code>event_once-&gt;cb</code>, 然后把他从一次性事件的链表里移除，最后释放掉整个 <code>event_once</code> 所分配的内存。</p>
<p>要是这个事件不触发，那么他的回调函数就不会被释放，<code>event_once</code> 所占用的内存就得不到释放，我们无法获得它的指针对其 <code>free</code>。一次性事件链表就是为了解决这个问题的，他是 <code>event_base</code> 里的一个结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LIST_HEAD(once_event_list, event_once) once_events;</span><br></pre></td></tr></table></figure>
<p>所有的 <code>event_once</code> 在释放之前都会保留在这个链表里，除了 <code>event_once_cb()</code> 触发时会被移除，在 <code>event_base</code> 被释放时，也会将所有 <code>once_events</code> 里的 <code>event_once</code> 逐个释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">event_base_free_</span><span class="params">(struct event_base *base, <span class="keyword">int</span> run_finalizers)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> (LIST_FIRST(&amp;base-&gt;once_events)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_once</span> *<span class="title">eonce</span> = <span class="title">LIST_FIRST</span>(&amp;<span class="title">base</span>-&gt;<span class="title">once_events</span>);</span></span><br><span class="line">        LIST_REMOVE(eonce, next_once);</span><br><span class="line">        mm_free(eonce);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
<li>[2] <a href="http://www.ilovecpp.com/2018/05/01/libevent-event-analyze/">抽丝剥茧 libevent——初识 event | Baixiangcpp’s Blog</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 结构体：event_io_map</title>
    <url>/post/2020/517d2de7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前的文章 <a href="/post/2020/542e4e52/" title="源码阅读 libevent - 数据结构：哈希表">源码阅读 libevent - 数据结构：哈希表</a> 分析了 <code>libevent</code> 中哈希表的实现，本文我们分析 <code>libevent</code> 中的利用哈希表实现的结构体：<code>event_io_map</code>。</p>
<blockquote>
<p>本系列大部分文章介绍 <code>linux</code> 系统下 <code>libevent</code> 的源码，但 <code>event_io_map</code> 在 <code>linux</code> 环境下与 <code>event_signal_map</code> 一致，而且其在 <code>Windows</code> 下的实现更值得学习。</p>
</blockquote>
<a id="more"></a>
<h2 id="event-io-map-的定义"><a href="#event-io-map-的定义" class="headerlink" title="event_io_map 的定义"></a>event_io_map 的定义</h2><p><code>libevent</code> 中的哈希表只会用于 <code>Windows</code> 系统，像遵循 <code>POSIX</code> 标准的 <code>OS</code> 是不会用到哈希表的。从下面的定义可以看到这一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVMAP_USE_HT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> EVMAP_USE_HT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HT_NO_CACHE_HASH_VALUES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ht-internal.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_map_entry</span>;</span></span><br><span class="line">HT_HEAD(event_io_map, event_map_entry);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> event_io_map event_signal_map</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_signal_map</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> **entries; <span class="comment">/* An array of evmap_io * or of evmap_signal *; empty entries are set to NULL. */</span></span><br><span class="line">    <span class="keyword">int</span> nentries;   <span class="comment">/* The number of entries available in entries */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为在 <code>Windows</code> 系统里面，文件描述符是一个比较大的值，不适合放到 <code>event_signal_map</code> 结构中。而通过哈希 (模上一个小的值)，就可以变得比较小，这样就可以放到哈希表的数组中了。而遵循 <code>POSIX</code> 标准的文件描述符是从 <code>0</code> 开始递增的，一般都不会太大，适用于 <code>event_signal_map</code>，此时 <code>event_io_map</code> 被定义为了 <code>event_signal_map</code> 结构体。</p>
<p>本文分析的是 <code>event_io_map</code> 的哈希实现方式。</p>
<h2 id="event-io-map-结构"><a href="#event-io-map-结构" class="headerlink" title="event_io_map 结构"></a>event_io_map 结构</h2><p><code>event_io_map</code> 结构几个重要结构体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LIST_HEAD (event_dlist, event);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evmap_io</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_dlist</span> <span class="title">events</span>;</span> <span class="comment">/* LIST_HEAD (event_dlist, event); */</span></span><br><span class="line">    <span class="keyword">ev_uint16_t</span> nread;</span><br><span class="line">    <span class="keyword">ev_uint16_t</span> nwrite;</span><br><span class="line">    <span class="keyword">ev_uint16_t</span> nclose;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_map_entry</span> &#123;</span></span><br><span class="line">    HT_ENTRY(event_map_entry) map_node;</span><br><span class="line">    <span class="keyword">evutil_socket_t</span> fd;</span><br><span class="line">    <span class="keyword">union</span> &#123; <span class="comment">/* This is a union in case we need to make more things that can be in the hashtable. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">evmap_io</span> <span class="title">evmap_io</span>;</span></span><br><span class="line">    &#125; ent;</span><br><span class="line">&#125;;</span><br><span class="line">HT_HEAD(event_io_map, event_map_entry);</span><br></pre></td></tr></table></figure>
<p>从之前的文章（参见：<a href="/post/2020/542e4e52/" title="源码阅读 libevent - 数据结构：哈希表">源码阅读 libevent - 数据结构：哈希表</a>）分析可知：</p>
<ul>
<li>哈希表的表头为 <code>event_io_map</code> 类型</li>
<li>哈希表中的桶为 <code>event_map_entry*</code> 类型的数组</li>
<li>哈希表中的元素为 <code>event_map_entry</code> 类型</li>
<li><code>event_map_entry</code> 类型中的 <code>Hash Key</code> 为 <code>evutil_socket_t fd</code></li>
<li><code>event_map_entry</code> 类型中的 <code>Hash Value</code> 为 <code>struct evmap_io evmap_io</code></li>
<li><code>struct evmap_io</code> 类型中有一个双向链表（参见：<a href="/post/2020/ee7292d/" title="源码阅读 libevent - 数据结构：双向链表">源码阅读 libevent - 数据结构：双向链表</a>）</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>event_base_new_with_config</code> 函数中会调用 <code>evmap_io_initmap_</code> 函数对每个 <code>event_base</code> 中的 <code>event_io_map</code> 进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** file: event.c</span></span><br><span class="line"><span class="comment">*** function: event_base_new_with_config */</span></span><br><span class="line">evmap_io_initmap_(&amp;base-&gt;io);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evmap_io_initmap_</span><span class="params">(struct event_io_map *ctx)</span> </span>&#123;</span><br><span class="line">    HT_INIT(event_io_map, ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evmap_io_add_</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, struct event *ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> = <span class="title">base</span>-&gt;<span class="title">evsel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_io_map</span> *<span class="title">io</span> = &amp;<span class="title">base</span>-&gt;<span class="title">io</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evmap_io</span> *<span class="title">ctx</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> nread, nwrite, nclose, retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">short</span> res = <span class="number">0</span>, old = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">old_ev</span>;</span></span><br><span class="line">    EVUTIL_ASSERT(fd == ev-&gt;ev_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    GET_IO_SLOT_AND_CTOR(ctx, io, fd, evmap_io, evmap_io_init, evsel-&gt;fdinfo_len);</span><br><span class="line"></span><br><span class="line">    nread = ctx-&gt;nread;</span><br><span class="line">    nwrite = ctx-&gt;nwrite;</span><br><span class="line">    nclose = ctx-&gt;nclose;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nread) old |= EV_READ;</span><br><span class="line">    <span class="keyword">if</span> (nwrite) old |= EV_WRITE;</span><br><span class="line">    <span class="keyword">if</span> (nclose) old |= EV_CLOSED;</span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_READ) <span class="keyword">if</span> (++nread == <span class="number">1</span>) res |= EV_READ;</span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_WRITE) <span class="keyword">if</span> (++nwrite == <span class="number">1</span>) res |= EV_WRITE;</span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_CLOSED) <span class="keyword">if</span> (++nclose == <span class="number">1</span>) res |= EV_CLOSED;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="keyword">void</span> *extra = ((<span class="keyword">char</span>*)ctx) + <span class="keyword">sizeof</span>(struct evmap_io);</span><br><span class="line">        <span class="keyword">if</span> (evsel-&gt;add(base, ev-&gt;ev_fd, old, (ev-&gt;ev_events &amp; EV_ET) | res, extra) == <span class="number">-1</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;nread = (<span class="keyword">ev_uint16_t</span>) nread;</span><br><span class="line">    ctx-&gt;nwrite = (<span class="keyword">ev_uint16_t</span>) nwrite;</span><br><span class="line">    ctx-&gt;nclose = (<span class="keyword">ev_uint16_t</span>) nclose;</span><br><span class="line">    LIST_INSERT_HEAD(&amp;ctx-&gt;events, ev, ev_io_next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GET-IO-SLOT-AND-CTOR"><a href="#GET-IO-SLOT-AND-CTOR" class="headerlink" title="GET_IO_SLOT_AND_CTOR"></a>GET_IO_SLOT_AND_CTOR</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GET_IO_SLOT_AND_CTOR(ctx, io, fd, evmap_io, evmap_io_init, evsel-&gt;fdinfo_len);</span><br><span class="line"><span class="comment">/* 以上宏定义展开后结果为如下所示 */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_map_entry</span> <span class="title">key_</span>, *<span class="title">ent_</span>;</span></span><br><span class="line">    key_.fd = fd;</span><br><span class="line">    HT_FIND_OR_INSERT_(event_io_map, map_node, hashsocket, io, event_map_entry, &amp;key_, ptr,</span><br><span class="line">        &#123;</span><br><span class="line">            ent_ = *ptr;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            ent_ = event_mm_calloc_((<span class="number">1</span>), (<span class="keyword">sizeof</span>(struct event_map_entry) + evsel-&gt;fdinfo_len));</span><br><span class="line">            <span class="keyword">if</span> (EVUTIL_UNLIKELY(ent_ == <span class="literal">NULL</span>)) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">            ent_-&gt;fd = fd; (evmap_io_init)(&amp;ent_-&gt;ent.evmap_io);</span><br><span class="line">            HT_FOI_INSERT_(map_node, io, &amp;key_, ent_, ptr)</span><br><span class="line">        &#125;);</span><br><span class="line">    (ctx) = &amp;ent_-&gt;ent.evmap_io;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>其中 <code>HT_FIND_OR_INSERT_</code> 宏和 <code>HT_FOI_INSERT_</code> 宏共同实现了 <code>Find or Insert</code> 功能：</p>
<ul>
<li>如果被查找的 <code>fd</code> 在哈希表中，则 <code>ctx</code> 被赋值为该 <code>fd</code> 对应的 <code>evmap_io</code> 双向链表头所在地址</li>
<li>如果被查找的 <code>fd</code> 没有在哈希表中，则申请双向链表头，初始化后插入到哈希表中，并返回该双向链表头所在地址</li>
</ul>
<p>双向链表的初始化函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evmap_io_init</span><span class="params">(struct evmap_io *entry)</span> </span>&#123;</span><br><span class="line">    LIST_INIT(&amp;entry-&gt;events);</span><br><span class="line">    entry-&gt;nread = <span class="number">0</span>;</span><br><span class="line">    entry-&gt;nwrite = <span class="number">0</span>;</span><br><span class="line">    entry-&gt;nclose = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="event-base-evsel-gt-add"><a href="#event-base-evsel-gt-add" class="headerlink" title="event_base.evsel-&gt;add"></a>event_base.evsel-&gt;add</h3><p><code>event_base.evsel-&gt;add</code> 其实是个函数指针（参见：<a href="/post/2020/1a2a4fe3/" title="源码阅读 libevent - 创建 event_base">源码阅读 libevent - 创建 event_base</a>），其根据 <code>event_base</code> 选择的不同后端来调用不同的函数来执行事件添加操作，以 <code>select</code> 后端为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">select_add</span><span class="params">(struct event_base *base, <span class="keyword">int</span> fd, <span class="keyword">short</span> old, <span class="keyword">short</span> events, <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">selectop</span> *<span class="title">sop</span> = <span class="title">base</span>-&gt;<span class="title">evbase</span>;</span> <span class="comment">/* event_base.evbase 是 init 返回的结构体指针 */</span></span><br><span class="line">    EVUTIL_ASSERT((events &amp; EV_SIGNAL) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sop-&gt;event_fds &lt; fd) &#123;</span><br><span class="line">        <span class="keyword">int</span> fdsz = sop-&gt;event_fdsz;</span><br><span class="line">        <span class="keyword">if</span> (fdsz &lt; (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(fd_mask)) fdsz = (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(fd_mask);</span><br><span class="line">        <span class="keyword">while</span> (fdsz &lt; (<span class="keyword">int</span>) SELECT_ALLOC_SIZE(fd + <span class="number">1</span>)) fdsz *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fdsz != sop-&gt;event_fdsz)</span><br><span class="line">            <span class="keyword">if</span> (select_resize(sop, fdsz)) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        sop-&gt;event_fds = fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EV_READ) FD_SET(fd, sop-&gt;event_readset_in);</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EV_WRITE) FD_SET(fd, sop-&gt;event_writeset_in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码来看，<code>event_base.evsel-&gt;add</code> 本质上是调用了对应后端的函数集中对应的函数来实现事件的添加操作，如 <code>select</code> 就是调用 <code>FD_SET</code> 来实现事件的添加操作。</p>
<h3 id="LIST-INSERT-HEAD"><a href="#LIST-INSERT-HEAD" class="headerlink" title="LIST_INSERT_HEAD"></a>LIST_INSERT_HEAD</h3><p>在 <code>GET_IO_SLOT_AND_CTOR</code> 宏返回了双向链表头所在地址后，通过 <code>LIST_INSERT_HEAD</code> 宏将新事件 <code>ev</code> 插入到双向链表中。</p>
<blockquote>
<p>有关 <code>LIST_INSERT_HEAD</code> 的实现，参见：post_link “源码阅读 libevent - 数据结构：双向链表” %}</p>
</blockquote>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evmap_io_del_</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, struct event *ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> = <span class="title">base</span>-&gt;<span class="title">evsel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_io_map</span> *<span class="title">io</span> = &amp;<span class="title">base</span>-&gt;<span class="title">io</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evmap_io</span> *<span class="title">ctx</span>;</span></span><br><span class="line">    <span class="keyword">int</span> nread, nwrite, nclose, retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">short</span> res = <span class="number">0</span>, old = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    EVUTIL_ASSERT(fd == ev-&gt;ev_fd);</span><br><span class="line">    GET_IO_SLOT(ctx, io, fd, evmap_io);</span><br><span class="line"></span><br><span class="line">    nread = ctx-&gt;nread;</span><br><span class="line">    nwrite = ctx-&gt;nwrite;</span><br><span class="line">    nclose = ctx-&gt;nclose;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nread) old |= EV_READ;</span><br><span class="line">    <span class="keyword">if</span> (nwrite) old |= EV_WRITE;</span><br><span class="line">    <span class="keyword">if</span> (nclose) old |= EV_CLOSED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_READ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--nread == <span class="number">0</span>) res |= EV_READ;</span><br><span class="line">        EVUTIL_ASSERT(nread&gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_WRITE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--nwrite == <span class="number">0</span>) res |= EV_WRITE;</span><br><span class="line">        EVUTIL_ASSERT(nwrite&gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_CLOSED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--nclose == <span class="number">0</span>) res |= EV_CLOSED;</span><br><span class="line">        EVUTIL_ASSERT(nclose&gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="keyword">void</span> *extra = ((<span class="keyword">char</span>*)ctx) + <span class="keyword">sizeof</span>(struct evmap_io);</span><br><span class="line">        <span class="keyword">if</span> (evsel-&gt;del(base, ev-&gt;ev_fd, old, (ev-&gt;ev_events &amp; EV_ET) | res, extra) == <span class="number">-1</span>) retval = <span class="number">-1</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> retval = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;nread = nread;</span><br><span class="line">    ctx-&gt;nwrite = nwrite;</span><br><span class="line">    ctx-&gt;nclose = nclose;</span><br><span class="line">    LIST_REMOVE(ev, ev_io_next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GET-IO-SLOT"><a href="#GET-IO-SLOT" class="headerlink" title="GET_IO_SLOT"></a>GET_IO_SLOT</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GET_IO_SLOT(ctx, io, fd, evmap_io);</span><br><span class="line"><span class="comment">/* 以上宏定义展开后结果为如下所示 */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_map_entry</span> <span class="title">key_</span>, *<span class="title">ent_</span>;</span></span><br><span class="line">    key_.fd = fd;</span><br><span class="line">    ent_ = HT_FIND(event_io_map, io, &amp;key_);</span><br><span class="line">    (ctx) = ent_ ? &amp;ent_-&gt;ent.evmap_io : <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>该宏定义与直接调用 <code>HT_FIND</code> 的区别是：<code>HT_FIND</code> 宏 <code>find</code> 的结果是 哈希表中的元素地址，这里的元素包括哈希表的 <code>Key/Value/Next</code>，而 <code>GET_IO_SLOT</code> 是调用 <code>HT_FIND</code> 查找到需要的元素地址后，仅仅是将需要用的到 <code>Value</code> 的地址赋值给 <code>ctx</code> 变量，这里需要用到的 <code>Value</code> 是一个 <code>struct evmap_io*</code> 类型的指针，该类型在上文中已经描述，此处不再重复，需要注意的是其中保存有一个双向链表的表头。</p>
<h3 id="event-base-evsel-gt-del"><a href="#event-base-evsel-gt-del" class="headerlink" title="event_base.evsel-&gt;del"></a>event_base.evsel-&gt;del</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">select_del</span><span class="params">(struct event_base *base, <span class="keyword">int</span> fd, <span class="keyword">short</span> old, <span class="keyword">short</span> events, <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">selectop</span> *<span class="title">sop</span> = <span class="title">base</span>-&gt;<span class="title">evbase</span>;</span></span><br><span class="line">    EVUTIL_ASSERT((events &amp; EV_SIGNAL) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sop-&gt;event_fds &lt; fd) <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EV_READ) FD_CLR(fd, sop-&gt;event_readset_in);</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EV_WRITE) FD_CLR(fd, sop-&gt;event_writeset_in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 <code>event_base.evsel-&gt;add</code> 一样，<code>event_base.evsel-&gt;del</code> 也是调用了对应后端的函数集中对应的函数来实现事件的删除操作，如 <code>select</code> 就是调用 <code>FD_CLR</code> 来实现事件的删除操作。</p>
<h3 id="LIST-REMOVE"><a href="#LIST-REMOVE" class="headerlink" title="LIST_REMOVE"></a>LIST_REMOVE</h3><p>将 <code>ev</code> 事件从链表中删除。</p>
<blockquote>
<p>有关 <code>LIST_REMOVE</code> 的实现，参见：post_link “源码阅读 libevent - 数据结构：双向链表” %}</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
<li>[2] <a href="https://github.com/KelvinYin/libevent-src-analysis/blob/master/libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">libevent-src-analysis/libevent 源码分析. md at master · KelvinYin/libevent-src-analysis</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 结构体：event_signal_map</title>
    <url>/post/2020/a24039d7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在之前的文章中提到过：<code>libevent</code> 中的哈希表只会用于 <code>Windows</code> 系统，像遵循 <code>POSIX</code> 标准的 <code>OS</code> 是不会用到哈希表的。那么在遵循 <code>POSIX</code> 标准的 <code>OS</code> 中 event_io_map 是怎么实现的呢？答案就在下面的宏定义中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> event_io_map event_signal_map</span></span><br></pre></td></tr></table></figure>
<p>从该宏定义中可以看出，此时 <code>event_io_map</code> 被定义为了 <code>event_signal_map</code> 结构体。本文就分析一下 <code>event_signal_map</code> 结构体。</p>
<a id="more"></a>
<h2 id="event-signal-map-的定义"><a href="#event-signal-map-的定义" class="headerlink" title="event_signal_map 的定义"></a>event_signal_map 的定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_signal_map</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> **entries; <span class="comment">/* evmap_io * 或 evmap_signal * 型数组 */</span></span><br><span class="line">    <span class="keyword">int</span> nentries; <span class="comment">/* 数组有效长度 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>event_signal_map</code> 结构体中仅有两个元素，其意义如下：</p>
<ol>
<li><code>entries</code>：一个二级指针，其实是一个数组，数组中元素为指针类型（<code>evmap_io*</code> 型或 <code>evmap_signal*</code> 型）</li>
<li><code>nentries</code>：表明 <code>entries</code> 数组的有效长度，以防止访问溢出。</li>
</ol>
<p>在 <a href="#">Post not found: 源码阅读 libevent - event_io_map</a> 文章中已经分析过 <code>evmap_io</code> 结构体，本文侧重分析 <code>evmap_signal</code> 结构体。</p>
<h3 id="evmap-signal"><a href="#evmap-signal" class="headerlink" title="evmap_signal"></a>evmap_signal</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evmap_signal</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_dlist</span> <span class="title">events</span>;</span> <span class="comment">/* LIST_HEAD (event_dlist, event); */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>evmap_signal</code> 结构体也极其简单，其中仅有一个元素，是一个双向链表的表头。</p>
<h2 id="event-signal-map-的结构"><a href="#event-signal-map-的结构" class="headerlink" title="event_signal_map 的结构"></a>event_signal_map 的结构</h2><p>从上述定义分析就可看出 <code>event_signal_map</code> 的结构较为简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">event_signal_map        Array of struct evmap_signal*       struct event             struct event</span><br><span class="line">+--------------+        +----------------------------+      +-------------+          +-------------+</span><br><span class="line">|   entries    |-------&gt;| event_dlist (DList Header) |-----&gt;|   DList A   |-- ... --&gt;|   DList N   |-----&gt; NULL</span><br><span class="line">+--------------+        +----------------------------+      +-------------+          +-------------+</span><br><span class="line">|   nentries   |        | event_dlist (DList Header) |-----&gt; NULL</span><br><span class="line">+--------------+        +----------------------------+</span><br><span class="line">                        | event_dlist (DList Header) |-----&gt; NULL</span><br><span class="line">                        +----------------------------+</span><br><span class="line">                                    ......</span><br><span class="line">                        +----------------------------+      +-------------+</span><br><span class="line">                        | event_dlist (DList Header) |-----&gt;|   DList X   |-----&gt; NULL</span><br><span class="line">                        +----------------------------+      +-------------+</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evmap_signal_initmap_</span><span class="params">(struct event_signal_map *ctx)</span> </span>&#123;</span><br><span class="line">    ctx-&gt;nentries = <span class="number">0</span>;</span><br><span class="line">    ctx-&gt;entries = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Emmm… 不知道该说点什么…</p>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evmap_signal_add_</span><span class="params">(struct event_base *base, <span class="keyword">int</span> sig, struct event *ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> = <span class="title">base</span>-&gt;<span class="title">evsigsel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_signal_map</span> *<span class="title">map</span> = &amp;<span class="title">base</span>-&gt;<span class="title">sigmap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evmap_signal</span> *<span class="title">ctx</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sig &lt; <span class="number">0</span> || sig&gt;= NSIG) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sig&gt;= <span class="built_in">map</span>-&gt;nentries)</span><br><span class="line">        <span class="keyword">if</span> (evmap_make_space(<span class="built_in">map</span>, sig, <span class="keyword">sizeof</span>(struct evmap_signal *)) == <span class="number">-1</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    GET_SIGNAL_SLOT_AND_CTOR(ctx, <span class="built_in">map</span>, sig, evmap_signal, evmap_signal_init, base-&gt;evsigsel-&gt;fdinfo_len);</span><br><span class="line">    <span class="keyword">if</span> (LIST_EMPTY(&amp;ctx-&gt;events))</span><br><span class="line">        <span class="keyword">if</span> (evsel-&gt;add(base, ev-&gt;ev_fd, <span class="number">0</span>, EV_SIGNAL, <span class="literal">NULL</span>) == <span class="number">-1</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    LIST_INSERT_HEAD(&amp;ctx-&gt;events, ev, ev_signal_next);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可分为 4 个步骤：</p>
<ol>
<li>evmap_make_space</li>
<li>GET_SIGNAL_SLOT_AND_CTOR</li>
<li>event_base.evsel-&gt;add</li>
<li>LIST_INSERT_HEAD</li>
</ol>
<p>其中步骤 3 和步骤 4 在 <a href="#">Post not found: 源码阅读 libevent - event_io_map</a> 文章中已讲解过，下面分析前两个步骤：</p>
<h3 id="evmap-make-space"><a href="#evmap-make-space" class="headerlink" title="evmap_make_space"></a>evmap_make_space</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evmap_make_space</span><span class="params">(struct event_signal_map *<span class="built_in">map</span>, <span class="keyword">int</span> slot, <span class="keyword">int</span> msize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;nentries &lt;= slot) &#123;</span><br><span class="line">        <span class="keyword">int</span> nentries = <span class="built_in">map</span>-&gt;nentries ? <span class="built_in">map</span>-&gt;nentries : <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">void</span> **tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slot&gt; INT_MAX / <span class="number">2</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (nentries &lt;= slot) nentries &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nentries&gt; INT_MAX / msize) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        tmp = (<span class="keyword">void</span> **)mm_realloc(<span class="built_in">map</span>-&gt;entries, nentries * msize);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;tmp[<span class="built_in">map</span>-&gt;nentries], <span class="number">0</span>, (nentries - <span class="built_in">map</span>-&gt;nentries) * msize);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>-&gt;nentries = nentries;</span><br><span class="line">        <span class="built_in">map</span>-&gt;entries = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evmap_make_space</code> 函数会在数组长度不足时对数组进行拓展：</p>
<ol>
<li>如果数组没有初始化，则初始化数组长度为 <code>32</code></li>
<li>如果数组长度不足，则将数组长度乘 <code>2</code>，直至满足要求</li>
<li><code>realloc</code> 数组空间，并将新开辟出来的空间清 <code>0</code></li>
<li>保存新数组的地址信息和长度信息</li>
</ol>
<h3 id="GET-SIGNAL-SLOT-AND-CTOR"><a href="#GET-SIGNAL-SLOT-AND-CTOR" class="headerlink" title="GET_SIGNAL_SLOT_AND_CTOR"></a>GET_SIGNAL_SLOT_AND_CTOR</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GET_SIGNAL_SLOT_AND_CTOR(ctx, <span class="built_in">map</span>, sig, evmap_signal, evmap_signal_init, base-&gt;evsigsel-&gt;fdinfo_len);</span><br><span class="line"><span class="comment">/* 以上宏定义展开后结果为如下所示 */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">map</span>)-&gt;entries[sig] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        (<span class="built_in">map</span>)-&gt;entries[sig] = mm_calloc(<span class="number">1</span>,<span class="keyword">sizeof</span>(struct evmap_signal)+base-&gt;evsigsel-&gt;fdinfo_len);</span><br><span class="line">        <span class="keyword">if</span> (EVUTIL_UNLIKELY((<span class="built_in">map</span>)-&gt;entries[sig] == <span class="literal">NULL</span>)) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        (evmap_signal_init)((struct evmap_signal *)(<span class="built_in">map</span>)-&gt;entries[sig]);</span><br><span class="line">    &#125;</span><br><span class="line">    (ctx) = (struct evmap_signal *)((<span class="built_in">map</span>)-&gt;entries[sig]);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>GET_SIGNAL_SLOT_AND_CTOR</code> 宏找到当前 <code>sig</code> 对应的数组元素：</p>
<ul>
<li>如果该元素为空，则新建一个双向链表的表头，存入链表，并将该表头地址赋值给 ctx 变量</li>
<li>如果该元素非空，则其指向的是一个双向链表的表头，将该元素赋值给 ctx 变量</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evmap_signal_del_</span><span class="params">(struct event_base *base, <span class="keyword">int</span> sig, struct event *ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> = <span class="title">base</span>-&gt;<span class="title">evsigsel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_signal_map</span> *<span class="title">map</span> = &amp;<span class="title">base</span>-&gt;<span class="title">sigmap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evmap_signal</span> *<span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sig &lt; <span class="number">0</span> || sig&gt;= <span class="built_in">map</span>-&gt;nentries) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    GET_SIGNAL_SLOT(ctx, <span class="built_in">map</span>, sig, evmap_signal);</span><br><span class="line">    LIST_REMOVE(ev, ev_signal_next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LIST_FIRST(&amp;ctx-&gt;events) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">if</span> (evsel-&gt;del(base, ev-&gt;ev_fd, <span class="number">0</span>, EV_SIGNAL, <span class="literal">NULL</span>) == <span class="number">-1</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GET-SIGNAL-SLOT"><a href="#GET-SIGNAL-SLOT" class="headerlink" title="GET_SIGNAL_SLOT"></a>GET_SIGNAL_SLOT</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GET_SIGNAL_SLOT(ctx, <span class="built_in">map</span>, sig, evmap_signal);</span><br><span class="line"><span class="comment">/* 以上宏定义展开后结果为如下所示 */</span></span><br><span class="line">(ctx) = (struct evmap_signal *)((<span class="built_in">map</span>)-&gt;entries[sig])</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
<li>[2] <a href="https://github.com/KelvinYin/libevent-src-analysis/blob/master/libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">libevent-src-analysis/libevent 源码分析. md at master · KelvinYin/libevent-src-analysis</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 libevent - 超时管理：min_heap</title>
    <url>/post/2020/97886769/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>libevent</code> 允许创建一个超时 <code>event</code>，使用 <code>evtimer_new</code> 宏。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_new(b, cb, arg)     event_new((b), -1, 0, (cb), (arg))</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>从宏的实现来看，它一样是用到了一般的 <code>event_new</code>，并且不使用任何的文件描述符。从超时 <code>event</code> 宏的实现来看，无论是 <code>evtimer</code> 创建的 <code>event</code> 还是一般 <code>event_new</code> 创建的 <code>event</code>，都能使得 <code>libevent</code> 进行超时监听。</p>
<p>使得 <code>libevent</code> 对一个 <code>event</code> 进行超时监听的原因是：在调用 <code>int event_add(struct event *ev, const struct timeval *tv)</code> 的时候，第二参数不能为 <code>NULL</code>，要设置一个超时值。如果为 <code>NULL</code>，那么 <code>libevent</code> 将不会为这个 <code>event</code> 监听超时。下文统一称设置了超时值的 <code>event</code> 为超时 <code>event</code>。</p>
<h2 id="超时-event-的原理"><a href="#超时-event-的原理" class="headerlink" title="超时 event 的原理"></a>超时 event 的原理</h2><p><code>libevent</code> 对超时进行监听的原理不同于之前讲到的对信号的监听，<code>libevent</code> 对超时的监听的原理是，多路 <code>IO</code> 复用函数都是有一个超时值。如果用户需要 <code>libevent</code> 同时监听多个超时 <code>event</code>，那么 <code>libevent</code> 就把超时值最小的那个作为多路 <code>IO</code> 复用函数的超时值。自然，当时间一到，就会从多路 <code>IO</code> 复用函数返回。此时对超时 <code>event</code> 进行处理即可。</p>
<p><code>libevent</code> 运行用户同时监听多个超时 <code>event</code>，那么就必须要对这个超时值进行管理。<code>libevent</code> 提供了小根堆 <code>min_heap</code> 和通用超时 <code>common timeout</code> 两种管理方式。本文首先分析小根堆 <code>min_heap</code> 超时管理机制。</p>
<h2 id="设置超时值"><a href="#设置超时值" class="headerlink" title="设置超时值"></a>设置超时值</h2><p>首先调用 event_add 时要设置一个超时值，这样才能成为一个超时 event。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    res = event_add_nolock_(ev, tv, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add_nolock_</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv, <span class="keyword">int</span> tv_is_absolute)</span> </span>&#123;</span><br><span class="line">    ...... <span class="comment">/* common timeout 相关代码没有展示 */</span></span><br><span class="line">    <span class="comment">/* tv 不为 NULL, 就说明是一个超时 event, 在小根堆中为其留一个位置 */</span></span><br><span class="line">    <span class="keyword">if</span> (tv != <span class="literal">NULL</span> &amp;&amp; !(ev-&gt;ev_flags &amp; EVLIST_TIMEOUT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min_heap_reserve_(&amp;base-&gt;timeheap, <span class="number">1</span> + min_heap_size_(&amp;base-&gt;timeheap)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);  <span class="comment">/* ENOMEM == errno */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...... <span class="comment">/* 将 IO 或者信号 event 插入到对应的队列中 */</span></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">-1</span> &amp;&amp; tv != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">        <span class="comment">/* 用户把这个 event 设置成 EV_PERSIST。即永久 event 如果没有这样设置的话，那么只会超时一次</span></span><br><span class="line"><span class="comment">        ** 设置了，那么就可以超时多次。那么就要记录用户设置的超时值。 */</span></span><br><span class="line">        <span class="keyword">if</span> (ev-&gt;ev_closure == EV_CLOSURE_EVENT_PERSIST &amp;&amp; !tv_is_absolute)</span><br><span class="line">            ev-&gt;ev_io_timeout = *tv;</span><br><span class="line">        <span class="comment">/* 因为可以在次线程调用 event_add。而主线程刚好在执行 event_base_dispatch */</span></span><br><span class="line">        <span class="keyword">if</span> ((ev-&gt;ev_flags &amp; EVLIST_ACTIVE) &amp;&amp; (ev-&gt;ev_res &amp; EV_TIMEOUT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ev-&gt;ev_events &amp; EV_SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ev-&gt;ev_ncalls &amp;&amp; ev-&gt;ev_pncalls) &#123; <span class="comment">/* Abort loop */</span></span><br><span class="line">                    *ev-&gt;ev_pncalls = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 从超时队列中删除这个 event。因为下次会再次加入。多次对同一个超时 event 调用 event_add, 那么只能保留最后的那个。 */</span></span><br><span class="line">            event_queue_remove_active(base, event_to_event_callback(ev));</span><br><span class="line">        &#125;</span><br><span class="line">        gettime(base, &amp;now); <span class="comment">/* 获取现在的时间 */</span></span><br><span class="line">        <span class="comment">/* 虽然用户在 event_add 时只需用一个相对时间，但实际上在 Libevent 内部还是要把这个时间转换成绝对时间。</span></span><br><span class="line"><span class="comment">        ** 从存储的角度来说，存绝对时间只需一个变量。而相对时间则需两个，一个存相对值，另一个存参照物。 */</span></span><br><span class="line">        <span class="keyword">if</span> (tv_is_absolute) ev-&gt;ev_timeout = *tv; <span class="comment">/* 该参数指明时间是否为一个绝对时间 */</span></span><br><span class="line">        <span class="keyword">else</span> evutil_timeradd(&amp;now, tv, &amp;ev-&gt;ev_timeout); <span class="comment">/* 参照时间 + 相对时间  ev_timeout 存的是绝对时间 */</span></span><br><span class="line">        event_queue_insert_timeout(base, ev); <span class="comment">/* 将该超时 event 插入到超时队列中 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">top</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="comment">/* 本次插入的超时值，是所有超时中最小的。那么此时就需要通知主线程。. */</span></span><br><span class="line">        <span class="keyword">if</span> (min_heap_elt_is_top_(ev)) notify = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((top = min_heap_top_(&amp;base-&gt;timeheap)) != <span class="literal">NULL</span> &amp;&amp; evutil_timercmp(&amp;top-&gt;ev_timeout, &amp;now, &lt;))</span><br><span class="line">            notify = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果代码逻辑中是需要通知的。并且本线程不是主线程。那么就通知主线程 */</span></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">-1</span> &amp;&amp; notify &amp;&amp; EVBASE_NEED_NOTIFY(base)) evthread_notify_base(base);</span><br><span class="line">    <span class="keyword">return</span> (res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于同一个 <code>event</code>，如果是 <code>IO event</code> 或者 <code>sigal event</code>，那么将无法多次添加。但如果是一个超时 <code>event</code>，那么是可以多次添加的。并且对应超时值会使用最后添加时指明的那个，之前的统统不要，即替换掉之前的超时值。</p>
<h2 id="调用多路-IO-复用函数等待超时"><a href="#调用多路-IO-复用函数等待超时" class="headerlink" title="调用多路 IO 复用函数等待超时"></a>调用多路 IO 复用函数等待超时</h2><h3 id="event-base-loop"><a href="#event-base-loop" class="headerlink" title="event_base_loop"></a>event_base_loop</h3><p>现在来看一下 <code>event_base_loop</code> 函数，看其是怎么处理超时 <code>event</code> 的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 非超时相关代码没有展示 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span> = <span class="title">base</span>-&gt;<span class="title">evsel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">tv_p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res, done, retval = <span class="number">0</span>;</span><br><span class="line">    done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        tv_p = &amp;tv;</span><br><span class="line">        <span class="keyword">if</span> (!N_ACTIVE_CALLBACKS(base) &amp;&amp; !(flags &amp; EVLOOP_NONBLOCK)) &#123;</span><br><span class="line">            <span class="comment">/* 根据 Timer 事件计算 evsel-&gt;dispatch 的最大等待时间（超时值最小） */</span></span><br><span class="line">            timeout_next(base, &amp;tv_p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* if we have active events, we just poll new events without waiting. */</span></span><br><span class="line">            evutil_timerclear(&amp;tv);</span><br><span class="line">        &#125;</span><br><span class="line">        res = evsel-&gt;dispatch(base, tv_p);</span><br><span class="line">        <span class="comment">/* 处理超时事件，将超时事件插入到激活链表中 */</span></span><br><span class="line">        timeout_process(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">return</span> (retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>event_base_loop()</code> 中有关超时管理方面工作不多，最主要的工作有两部分：</p>
<ol>
<li><p>设置 <code>dispatch</code> 回调的第二个参数 <code>tv</code>，这个参数如果为 <code>0</code>, 则无论是否有事件发生，都会立即返回。</p>
<ol>
<li><p>如果设置了 <code>EVLOOP_NONBLOCK</code> 标志位，则会调用 <code>evutil_timerclear()</code> 将 <code>tv</code> 设置为 <code>0</code></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不会阻塞，它仅仅是查看是否已经有 event ready. 有则运行其 callback. 然后退出 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVLOOP_NONBLOCK 0x02</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timerclear(tvp)  (tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不存在激活的 <code>event</code>，也会调用 <code>evutil_timerclear()</code> 将 <code>tv</code> 设置为 <code>0</code></p>
</li>
<li>如果存在激活的 <code>event</code> 且没有设置 <code>EVLOOP_NONBLOCK</code> 标志位，则需要调用 <code>timeout_next()</code> 获取最近的超时 <code>event</code>，并作为等待事件的时间传给 <code>dispatch</code> 回调函数</li>
</ol>
</li>
<li><p>调用 <code>timeout_process()</code> 函数将超时了的 <code>event</code> 加入激活队列。</p>
</li>
</ol>
<h3 id="timeout-next"><a href="#timeout-next" class="headerlink" title="timeout_next"></a>timeout_next</h3><p><code>timeout_next()</code> 用来计算出本次调用多路 <code>IO</code> 复用函数的等待时间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">timeout_next</span><span class="params">(struct event_base *base, struct timeval **tv_p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Caller must hold th_base_lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">tv</span> = *<span class="title">tv_p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 堆的首元素具有最小的超时值，这个是小根堆的性质。 */</span></span><br><span class="line">    ev = min_heap_top_(&amp;base-&gt;timeheap);</span><br><span class="line">    <span class="keyword">if</span> (ev == <span class="literal">NULL</span>) &#123; *tv_p = <span class="literal">NULL</span>; <span class="keyword">goto</span> out; &#125; <span class="comment">/* 堆中没有元素 */</span></span><br><span class="line">    <span class="keyword">if</span> (gettime(base, &amp;now) == <span class="number">-1</span>) &#123; res = <span class="number">-1</span>; <span class="keyword">goto</span> out; &#125; <span class="comment">/* /* 获取当前时间 */</span></span><br><span class="line">    <span class="comment">/* 如果超时时间 &lt;= 当前时间，不能等待，需要立即返回</span></span><br><span class="line"><span class="comment">    ** 因为 ev_timeout 这个时间是由 event_add 调用时的绝对时间 + 相对时间。所以 ev_timeout 是绝对时间。</span></span><br><span class="line"><span class="comment">    ** 可能在调用 event_add 之后，过了一段时间才调用 event_base_diapatch, 所以现在可能都过了用户设置的超时时间。 */</span></span><br><span class="line">    <span class="keyword">if</span> (evutil_timercmp(&amp;ev-&gt;ev_timeout, &amp;now, &lt;=)) &#123; evutil_timerclear(tv); <span class="keyword">goto</span> out; &#125;</span><br><span class="line">    <span class="comment">/* 计算等待的时间 = 当前时间 - 最小的超时时间 */</span></span><br><span class="line">    evutil_timersub(&amp;ev-&gt;ev_timeout, &amp;now, tv);</span><br><span class="line">    event_debug((<span class="string">&quot;timeout_next: event: %p, in %d seconds, %d useconds&quot;</span>, ev, (<span class="keyword">int</span>)tv-&gt;tv_sec, (<span class="keyword">int</span>)tv-&gt;tv_usec));</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> (res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="timeout-process"><a href="#timeout-process" class="headerlink" title="timeout_process"></a>timeout_process</h3><p><code>timeout_process()</code> 函数将超时了的 <code>event</code> 加入激活队列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeout_process</span><span class="params">(struct event_base *base)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (min_heap_empty_(&amp;base-&gt;timeheap)) <span class="keyword">return</span>;</span><br><span class="line">    gettime(base, &amp;now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历小根堆的元素。之所以不是只取堆顶那一个元素，是因为当主线程调用多路 IO 复用函数进入等待时，次线程可能添加了多个超时值更小的 event */</span></span><br><span class="line">    <span class="keyword">while</span> ((ev = min_heap_top_(&amp;base-&gt;timeheap))) &#123;</span><br><span class="line">        <span class="comment">/* ev-&gt;ev_timeout 存的是绝对时间，超时时间比此刻时间大，说明该 event 还没超时。那么余下的小根堆元素更不用检查了。 */</span></span><br><span class="line">        <span class="keyword">if</span> (evutil_timercmp(&amp;ev-&gt;ev_timeout, &amp;now, &gt;)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 下面说到的 del 是等同于调用 event_del. 把 event 从这个 event_base 中 (所有的队列都) 删除。event_base 不再监听之。</span></span><br><span class="line"><span class="comment">        ** 这里是 timeout_process 函数。所以对于有超时的 event，才会被 del 掉。</span></span><br><span class="line"><span class="comment">        ** 对于有 EV_PERSIST 选项的 event，在处理激活 event 的时候，会再次添加进 event_base 的。</span></span><br><span class="line"><span class="comment">        ** 这样做的一个好处就是，再次添加的时候，又可以重新计算该 event 的超时时间 (绝对时间)。 */</span></span><br><span class="line">        event_del_nolock_(ev, EVENT_DEL_NOBLOCK);</span><br><span class="line">        <span class="comment">/* 把这个 event 加入到 event_base 的激活队列中。event_base 的激活队列又有该 event 了。</span></span><br><span class="line"><span class="comment">        ** 如果该 event 是 EV_PERSIST 的，可以再次添加进该 event_base */</span></span><br><span class="line">        event_active_nolock_(ev, EV_TIMEOUT, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当从多路 <code>IO</code> 复用函数返回时，就检查时间小根堆，看有多少个 <code>event</code> 已经超时了。如果超时了，那就把这个 <code>event</code> 加入到 <code>event_base</code> 的激活队列中。并且把这个超时删除掉。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz">libevent-2.1.11-stable.tar.gz (Released 2019-08-01)</a></li>
<li>[2] <a href="https://github.com/KelvinYin/libevent-src-analysis/blob/master/libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">libevent-src-analysis/libevent 源码分析. md at master · KelvinYin/libevent-src-analysis</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 rtmpdump - 主函数解析</title>
    <url>/post/2020/e7a6677c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>main</code> 函数位于源码文件 <code>rtmpdump.c</code> 中，是 <code>rtmpdump</code> 工具的入口函数。</p>
<a id="more"></a>
<h2 id="main-函数源码"><a href="#main-函数源码" class="headerlink" title="main 函数源码"></a>main 函数源码</h2><p>由于 <code>main</code> 函数较长，本文对其中部分内容进行了裁剪，比如以下不会走到的 <code>if</code>、<code>case</code> 分支等。</p>
<p>假设我们执行的命令为：<code>rtmpdump -r rtmp://62.234.111.13:1935/mylive/1 -o Hello.flv</code>，该条命令涉及到的函数流程均进行保留，其他流程分支请参考源代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!InitSockets()) &#123;</span><br><span class="line">        RTMP_Log(RTMP_LOGERROR,</span><br><span class="line">        <span class="string">&quot;Couldn&#x27;t load sockets support on your platform, exiting!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> RD_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RTMP_Init(&amp;rtmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt_long(argc, argv,</span><br><span class="line">                <span class="string">&quot;hVveqzRr:s:t:i:p:a:b:f:o:u:C:n:c:l:y:Ym:k:d:A:B:T:w:x:W:X:S:#j:&quot;</span>,</span><br><span class="line">                longopts, <span class="literal">NULL</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                STR2AVAL(fullUrl, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">                flvFile = optarg;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(flvFile, <span class="string">&quot;-&quot;</span>)) bStdoutMode = FALSE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                RTMP_LogPrintf(<span class="string">&quot;unknown option: %c\n&quot;</span>, opt);</span><br><span class="line">                usage(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> RD_FAILED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">0</span> &amp;&amp; !fullUrl.av_len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol &amp; RTMP_FEATURE_SSL) port = <span class="number">443</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (protocol &amp; RTMP_FEATURE_HTTP) port = <span class="number">80</span>;</span><br><span class="line">        <span class="keyword">else</span> port = <span class="number">1935</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcUrl.av_len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tcUrl.av_len = <span class="built_in">strlen</span>(RTMPProtocolStringsLower[protocol]) +</span><br><span class="line">            hostname.av_len + app.av_len + <span class="keyword">sizeof</span>(<span class="string">&quot;://:65535/&quot;</span>);</span><br><span class="line">        tcUrl.av_val = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(tcUrl.av_len);</span><br><span class="line">        <span class="keyword">if</span> (!tcUrl.av_val) <span class="keyword">return</span> RD_FAILED;</span><br><span class="line">        tcUrl.av_len = <span class="built_in">snprintf</span>(tcUrl.av_val, tcUrl.av_len, <span class="string">&quot;%s://%.*s:%d/%.*s&quot;</span>,</span><br><span class="line">            RTMPProtocolStringsLower[protocol], hostname.av_len,</span><br><span class="line">            hostname.av_val, port, app.av_len, app.av_val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fullUrl.av_len) &#123;</span><br><span class="line">        RTMP_SetupStream(&amp;rtmp, protocol, &amp;hostname, port, &amp;sockshost, &amp;playpath,</span><br><span class="line">               &amp;tcUrl, &amp;swfUrl, &amp;pageUrl, &amp;app, &amp;auth, &amp;swfHash, swfSize,</span><br><span class="line">               &amp;flashVer, &amp;subscribepath, &amp;usherToken, dSeek, dStopOffset, bLiveStream, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (RTMP_SetupURL(&amp;rtmp, fullUrl.av_val) == FALSE) &#123;</span><br><span class="line">          RTMP_Log(RTMP_LOGERROR, <span class="string">&quot;Couldn&#x27;t parse URL: %s&quot;</span>, fullUrl.av_val);</span><br><span class="line">          <span class="keyword">return</span> RD_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bStdoutMode) &#123;</span><br><span class="line">            file = <span class="built_in">stdout</span>;</span><br><span class="line">            SET_BINMODE(file);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            file = fopen(flvFile, <span class="string">&quot;w+b&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (file == <span class="number">0</span>) &#123;</span><br><span class="line">                RTMP_LogPrintf(<span class="string">&quot;Failed to open file! %s\n&quot;</span>, flvFile);</span><br><span class="line">                <span class="keyword">return</span> RD_FAILED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!RTMP_ctrlC) &#123;</span><br><span class="line">        RTMP_Log(RTMP_LOGDEBUG, <span class="string">&quot;Setting buffer time to: %dms&quot;</span>, bufferTime);</span><br><span class="line">        RTMP_SetBufferMS(&amp;rtmp, bufferTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            first = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!RTMP_Connect(&amp;rtmp, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                nStatus = RD_NO_CONNECT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// User defined seek offset</span></span><br><span class="line">            <span class="keyword">if</span> (dStartOffset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Don&#x27;t need the start offset if resuming an existing file</span></span><br><span class="line">                <span class="keyword">if</span> (bResume) &#123;</span><br><span class="line">                    RTMP_Log(RTMP_LOGWARNING, <span class="string">&quot;Can&#x27;t seek a resumed stream, ignoring --start option&quot;</span>);</span><br><span class="line">                    dStartOffset = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dSeek = dStartOffset;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Calculate the length of the stream to still play</span></span><br><span class="line">            <span class="keyword">if</span> (dStopOffset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Quit if start seek is past required stop offset</span></span><br><span class="line">                <span class="keyword">if</span> (dStopOffset &lt;= dSeek) &#123;</span><br><span class="line">                    RTMP_LogPrintf(<span class="string">&quot;Already Completed\n&quot;</span>);</span><br><span class="line">                    nStatus = RD_SUCCESS;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!RTMP_ConnectStream(&amp;rtmp, dSeek)) &#123;</span><br><span class="line">                nStatus = RD_FAILED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nInitialFrameSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (retries) &#123;</span><br><span class="line">                RTMP_Log(RTMP_LOGERROR, <span class="string">&quot;Failed to resume the stream\n\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (!RTMP_IsTimedout(&amp;rtmp)) nStatus = RD_FAILED;</span><br><span class="line">                <span class="keyword">else</span> nStatus = RD_INCOMPLETE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RTMP_Log(RTMP_LOGINFO, <span class="string">&quot;Connection timed out, trying to resume.\n\n&quot;</span>);</span><br><span class="line">            <span class="comment">/* Did we already try pausing, and it still didn&#x27;t work? */</span></span><br><span class="line">            <span class="keyword">if</span> (rtmp.m_pausing == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">/* Only one try at reconnecting... */</span></span><br><span class="line">                retries = <span class="number">1</span>;</span><br><span class="line">                dSeek = rtmp.m_pauseStamp;</span><br><span class="line">                <span class="keyword">if</span> (dStopOffset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dStopOffset &lt;= dSeek) &#123;</span><br><span class="line">                        RTMP_LogPrintf(<span class="string">&quot;Already Completed\n&quot;</span>);</span><br><span class="line">                        nStatus = RD_SUCCESS;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!RTMP_ReconnectStream(&amp;rtmp, dSeek)) &#123;</span><br><span class="line">                    RTMP_Log(RTMP_LOGERROR, <span class="string">&quot;Failed to resume the stream\n\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!RTMP_IsTimedout(&amp;rtmp)) nStatus = RD_FAILED;</span><br><span class="line">                    <span class="keyword">else</span> nStatus = RD_INCOMPLETE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!RTMP_ToggleStream(&amp;rtmp)) &#123;</span><br><span class="line">                RTMP_Log(RTMP_LOGERROR, <span class="string">&quot;Failed to resume the stream\n\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (!RTMP_IsTimedout(&amp;rtmp)) nStatus = RD_FAILED;</span><br><span class="line">                <span class="keyword">else</span> nStatus = RD_INCOMPLETE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bResume = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nStatus = Download(&amp;rtmp, file, dSeek, dStopOffset, duration, bResume,</span><br><span class="line">                metaHeader, nMetaHeaderSize, initialFrame,</span><br><span class="line">                initialFrameType, nInitialFrameSize, nSkipKeyFrames,</span><br><span class="line">                bStdoutMode, bLiveStream, bRealtimeStream, bHashes,</span><br><span class="line">                bOverrideBufferTime, bufferTime, &amp;percent);</span><br><span class="line">        <span class="built_in">free</span>(initialFrame);</span><br><span class="line">        initialFrame = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we succeeded, we&#x27;re done. */</span></span><br><span class="line">        <span class="keyword">if</span> (nStatus != RD_INCOMPLETE || !RTMP_IsTimedout(&amp;rtmp) || bLiveStream)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nStatus == RD_SUCCESS)</span><br><span class="line">        RTMP_LogPrintf(<span class="string">&quot;Download complete\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nStatus == RD_INCOMPLETE)</span><br><span class="line">        RTMP_LogPrintf(<span class="string">&quot;Download may be incomplete (downloaded about %.2f%%), try resuming\n&quot;</span>, percent);</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    RTMP_Log(RTMP_LOGDEBUG, <span class="string">&quot;Closing connection.\n&quot;</span>);</span><br><span class="line">    RTMP_Close(&amp;rtmp);</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="number">0</span>) fclose(file);</span><br><span class="line">    CleanupSockets();</span><br><span class="line">    <span class="keyword">return</span> nStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main-函数流程"><a href="#main-函数流程" class="headerlink" title="main 函数流程"></a>main 函数流程</h2><p>从上述源码中可以看出，<code>main</code> 函数的大致流程为：</p>
<ol>
<li>InitSockets();</li>
<li>RTMP_Init();</li>
<li>RTMP_SetupStream()/RTMP_SetupURL();</li>
<li>fopen();</li>
<li>RTMP_Connect();</li>
<li>RTMP_ConnectStream()</li>
<li>Download();</li>
<li>RTMP_Close();</li>
<li>fclose();</li>
<li>CleanupSockets();</li>
</ol>
<p>其中 <code>InitSockets</code> 函数和 <code>CleanupSockets</code> 较为简单，在 <code>Windows</code> 平台下仅仅做了 <code>socket</code> 的初始化和反初始化工作，在 <code>Linux</code> 平台下甚至什么都没有做就 <code>return</code> 了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitSockets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line">    WORD version;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    version = MAKEWORD(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (WSAStartup(version, &amp;wsaData) == <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">CleanupSockets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line">    WSACleanup();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main-函数关键函数"><a href="#main-函数关键函数" class="headerlink" title="main 函数关键函数"></a>main 函数关键函数</h2><p>由 main 函数流程可知，以下函数是理解 RTMPDump 源码的关键：</p>
<ol>
<li>RTMP_Init();</li>
<li>RTMP_SetupStream()/RTMP_SetupURL();</li>
<li>RTMP_Connect();</li>
<li>RTMP_ConnectStream()</li>
<li>Download();</li>
<li>RTMP_Close();</li>
</ol>
<p>由于每个函数进行分析所占用篇幅较大，以上函数的解析会在后续文章中推出，欢迎持续关注本博客。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/12952977">RTMPdump 源代码分析 1： main()函数_雷霄骅(leixiaohua1020)的专栏-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>rtmpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 x264 - SPS &amp; PPS</title>
    <url>/post/2021/2633a00a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>x264</code> 中参数集初始化主要包括如下两个函数：</p>
<ul>
<li><code>x264_sps_init()</code>：根据输入参数生成 <code>H.264</code> 码流的 <code>SPS</code> 信息。</li>
<li><code>x264_pps_init()</code>：根据输入参数生成 <code>H.264</code> 码流的 <code>PPS</code> 信息。</li>
</ul>
<a id="more"></a>
<h3 id="x264-sps-init"><a href="#x264-sps-init" class="headerlink" title="x264_sps_init"></a>x264_sps_init</h3><p><code>x264_sps_init()</code> 会根据 <code>x264_param_t</code> 结构体中的参数来设置 <code>x264_sps_t</code> 结构体中的参数。</p>
<p>具体代码及注释如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                            初始化 SPS</span></span><br><span class="line"><span class="comment">* @param[out]       sps             x264_sps_t 结构体指针</span></span><br><span class="line"><span class="comment">* @param[in]        i_id            i_id</span></span><br><span class="line"><span class="comment">* @param[in]        param           x264_param_t 结构体指针</span></span><br><span class="line"><span class="comment">* @return                           x264_t 结构体指针</span></span><br><span class="line"><span class="comment">                                    # not nullptr   执行成功</span></span><br><span class="line"><span class="comment">*                                   # nullptr       执行失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_sps_init</span><span class="params">(<span class="keyword">x264_sps_t</span> *sps, <span class="keyword">int</span> i_id, <span class="keyword">x264_param_t</span> *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> csp = param-&gt;i_csp &amp; X264_CSP_MASK;</span><br><span class="line"></span><br><span class="line">    sps-&gt;i_id = i_id;</span><br><span class="line">    <span class="comment">/* 以宏块为单位的图像宽度 */</span></span><br><span class="line">    sps-&gt;i_mb_width = (param-&gt;i_width + <span class="number">15</span> ) / <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/* 以宏块为单位的图像高度 */</span></span><br><span class="line">    sps-&gt;i_mb_height= (param-&gt;i_height + <span class="number">15</span> ) / <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/* 所有图像均使用帧编码 */</span></span><br><span class="line">    sps-&gt;b_frame_mbs_only = !(param-&gt;b_interlaced || param-&gt;b_fake_interlaced);</span><br><span class="line">    <span class="keyword">if</span>(!sps-&gt;b_frame_mbs_only )</span><br><span class="line">        <span class="comment">/* 场编码时 以宏块为单位的图像高度为偶数 */</span></span><br><span class="line">        sps-&gt;i_mb_height = (sps-&gt;i_mb_height + <span class="number">1</span> ) &amp; ~<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 色度采样结构 yuv444 yuv422 yuv420 yuv400 */</span></span><br><span class="line">    sps-&gt;i_chroma_format_idc = csp &gt;= X264_CSP_I444 ? CHROMA_444 :</span><br><span class="line">                               csp &gt;= X264_CSP_I422 ? CHROMA_422 :</span><br><span class="line">                               csp &gt;= X264_CSP_I420 ? CHROMA_420 : CHROMA_400;</span><br><span class="line"></span><br><span class="line">    sps-&gt;b_qpprime_y_zero_transform_bypass = param-&gt;rc.i_rc_method == X264_RC_CQP &amp;&amp; param-&gt;rc.i_qp_constant == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据其他质量参数 设置 profile */</span></span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;b_qpprime_y_zero_transform_bypass || sps-&gt;i_chroma_format_idc == CHROMA_444 )</span><br><span class="line">        sps-&gt;i_profile_idc  = PROFILE_HIGH444_PREDICTIVE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sps-&gt;i_chroma_format_idc == CHROMA_422 )</span><br><span class="line">        sps-&gt;i_profile_idc  = PROFILE_HIGH422;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(BIT_DEPTH&gt; <span class="number">8</span> )</span><br><span class="line">        sps-&gt;i_profile_idc  = PROFILE_HIGH10;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;analyse.b_transform_8x8 || param-&gt;i_cqm_preset != X264_CQM_FLAT || sps-&gt;i_chroma_format_idc == CHROMA_400 )</span><br><span class="line">        sps-&gt;i_profile_idc  = PROFILE_HIGH;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;b_cabac || param-&gt;i_bframe &gt; <span class="number">0</span> || param-&gt;b_interlaced || param-&gt;b_fake_interlaced || param-&gt;analyse.i_weighted_pred &gt; <span class="number">0</span> )</span><br><span class="line">        sps-&gt;i_profile_idc  = PROFILE_MAIN;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sps-&gt;i_profile_idc  = PROFILE_BASELINE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constraint_set0 表示编码视频序列遵守 Baseline profile 的所有约束 */</span></span><br><span class="line">    sps-&gt;b_constraint_set0  = sps-&gt;i_profile_idc == PROFILE_BASELINE;</span><br><span class="line">    <span class="comment">/* constraint_set1 表示编码视频序列遵守 Main profile 的所有约束 */</span></span><br><span class="line">    <span class="comment">/* x264 不支持 baseline 中存在，却不存在 main 中的约束，包括 arbitrary_slice_order 和 slice_groups */</span></span><br><span class="line">    sps-&gt;b_constraint_set1  = sps-&gt;i_profile_idc &lt;= PROFILE_MAIN;</span><br><span class="line">    <span class="comment">/* Never set constraint_set2, it is not necessary and not used in real world. */</span></span><br><span class="line">    sps-&gt;b_constraint_set2  = <span class="number">0</span>;</span><br><span class="line">    sps-&gt;b_constraint_set3  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sps-&gt;i_level_idc = param-&gt;i_level_idc;</span><br><span class="line">    <span class="keyword">if</span>(param-&gt;i_level_idc == <span class="number">9</span> &amp;&amp; ( sps-&gt;i_profile_idc == PROFILE_BASELINE || sps-&gt;i_profile_idc == PROFILE_MAIN ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 在一些高级 profile 情况下，level_idc 值为 9 代表等级为 1b */</span></span><br><span class="line">        <span class="comment">/* 在 Baseline or Main profile，level_idc 值为 11 且 constraint_set3 值为 1 代表等级为 1b，（level_idc 值为 11 且 constraint_set3 值为 0 代表等级为 1.1）*/</span></span><br><span class="line">        sps-&gt;b_constraint_set3 = <span class="number">1</span>;</span><br><span class="line">        sps-&gt;i_level_idc      = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Intra profiles */</span></span><br><span class="line">    <span class="keyword">if</span>(param-&gt;i_keyint_max == <span class="number">1</span> &amp;&amp; sps-&gt;i_profile_idc &gt;= PROFILE_HIGH )</span><br><span class="line">        sps-&gt;b_constraint_set3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.i_num_reorder_frames = param-&gt;i_bframe_pyramid ? <span class="number">2</span> : param-&gt;i_bframe ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* extra slot with pyramid so that we don&#x27;t have to override the</span></span><br><span class="line"><span class="comment">     * order of forgetting old pictures */</span></span><br><span class="line">    sps-&gt;vui.i_max_dec_frame_buffering =</span><br><span class="line">    sps-&gt;i_num_ref_frames = X264_MIN(X264_REF_MAX, X264_MAX4(param-&gt;i_frame_reference, <span class="number">1</span> + sps-&gt;vui.i_num_reorder_frames,</span><br><span class="line">                            param-&gt;i_bframe_pyramid ? <span class="number">4</span> : <span class="number">1</span>, param-&gt;i_dpb_size));</span><br><span class="line">    sps-&gt;i_num_ref_frames -= param-&gt;i_bframe_pyramid == X264_B_PYRAMID_STRICT;</span><br><span class="line">    <span class="keyword">if</span>(param-&gt;i_keyint_max == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        sps-&gt;i_num_ref_frames = <span class="number">0</span>;</span><br><span class="line">        sps-&gt;vui.i_max_dec_frame_buffering = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* number of refs + current frame */</span></span><br><span class="line">    <span class="keyword">int</span> max_frame_num = sps-&gt;vui.i_max_dec_frame_buffering * (!!param-&gt;i_bframe_pyramid+<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Intra refresh cannot write a recovery time greater than max frame num-1 */</span></span><br><span class="line">    <span class="keyword">if</span>(param-&gt;b_intra_refresh )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> time_to_recovery = X264_MIN(sps-&gt;i_mb_width - <span class="number">1</span>, param-&gt;i_keyint_max ) + param-&gt;i_bframe - <span class="number">1</span>;</span><br><span class="line">        max_frame_num = X264_MAX(max_frame_num, time_to_recovery+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sps-&gt;i_log2_max_frame_num = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span> &lt;&lt; sps-&gt;i_log2_max_frame_num) &lt;= max_frame_num )</span><br><span class="line">        sps-&gt;i_log2_max_frame_num++;</span><br><span class="line"></span><br><span class="line">    sps-&gt;i_poc_type = param-&gt;i_bframe || param-&gt;b_interlaced || param-&gt;i_avcintra_class ? <span class="number">0</span> : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;i_poc_type == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> max_delta_poc = (param-&gt;i_bframe + <span class="number">2</span>) * (!!param-&gt;i_bframe_pyramid + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        sps-&gt;i_log2_max_poc_lsb = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">1</span> &lt;&lt; sps-&gt;i_log2_max_poc_lsb) &lt;= max_delta_poc * <span class="number">2</span> )</span><br><span class="line">            sps-&gt;i_log2_max_poc_lsb++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 默认带有 VUI 信息 */</span></span><br><span class="line">    sps-&gt;b_vui = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sps-&gt;b_gaps_in_frame_num_value_allowed = <span class="number">0</span>;</span><br><span class="line">    sps-&gt;b_mb_adaptive_frame_field = param-&gt;b_interlaced;</span><br><span class="line">    sps-&gt;b_direct8x8_inference = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    x264_sps_init_reconfigurable(sps, param);</span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.b_overscan_info_present = param-&gt;vui.i_overscan &gt; <span class="number">0</span> &amp;&amp; param-&gt;vui.i_overscan &lt;= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;vui.b_overscan_info_present )</span><br><span class="line">        sps-&gt;vui.b_overscan_info = (param-&gt;vui.i_overscan == <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.b_signal_type_present = <span class="number">0</span>;</span><br><span class="line">    sps-&gt;vui.i_vidformat = (param-&gt;vui.i_vidformat &gt;= <span class="number">0</span> &amp;&amp; param-&gt;vui.i_vidformat &lt;= <span class="number">5</span> ? param-&gt;vui.i_vidformat : <span class="number">5</span> );</span><br><span class="line">    sps-&gt;vui.b_fullrange = (param-&gt;vui.b_fullrange &gt;= <span class="number">0</span> &amp;&amp; param-&gt;vui.b_fullrange &lt;= <span class="number">1</span> ? param-&gt;vui.b_fullrange :</span><br><span class="line">                           (csp&gt;= X264_CSP_BGR ? <span class="number">1</span> : <span class="number">0</span> ) );</span><br><span class="line">    sps-&gt;vui.b_color_description_present = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.i_colorprim = (param-&gt;vui.i_colorprim &gt;= <span class="number">0</span> &amp;&amp; param-&gt;vui.i_colorprim &lt;= <span class="number">12</span> ? param-&gt;vui.i_colorprim : <span class="number">2</span> );</span><br><span class="line">    sps-&gt;vui.i_transfer  = (param-&gt;vui.i_transfer  &gt;= <span class="number">0</span> &amp;&amp; param-&gt;vui.i_transfer  &lt;= <span class="number">18</span> ? param-&gt;vui.i_transfer  : <span class="number">2</span> );</span><br><span class="line">    sps-&gt;vui.i_colmatrix = (param-&gt;vui.i_colmatrix &gt;= <span class="number">0</span> &amp;&amp; param-&gt;vui.i_colmatrix &lt;= <span class="number">14</span> ? param-&gt;vui.i_colmatrix :</span><br><span class="line">                           (csp&gt;= X264_CSP_BGR ? <span class="number">0</span> : <span class="number">2</span> ) );</span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;vui.i_colorprim != <span class="number">2</span> || sps-&gt;vui.i_transfer != <span class="number">2</span> || sps-&gt;vui.i_colmatrix != <span class="number">2</span> )</span><br><span class="line">        sps-&gt;vui.b_color_description_present = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;vui.i_vidformat != <span class="number">5</span> || sps-&gt;vui.b_fullrange || sps-&gt;vui.b_color_description_present )</span><br><span class="line">        sps-&gt;vui.b_signal_type_present = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">FIXME:</span> not sufficient for interlaced video */</span></span><br><span class="line">    sps-&gt;vui.b_chroma_loc_info_present = param-&gt;vui.i_chroma_loc &gt; <span class="number">0</span> &amp;&amp; param-&gt;vui.i_chroma_loc &lt;= <span class="number">5</span> &amp;&amp;</span><br><span class="line">                                         sps-&gt;i_chroma_format_idc == CHROMA_420;</span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;vui.b_chroma_loc_info_present )</span><br><span class="line">    &#123;</span><br><span class="line">        sps-&gt;vui.i_chroma_loc_top = param-&gt;vui.i_chroma_loc;</span><br><span class="line">        sps-&gt;vui.i_chroma_loc_bottom = param-&gt;vui.i_chroma_loc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.b_timing_info_present = param-&gt;i_timebase_num &gt; <span class="number">0</span> &amp;&amp; param-&gt;i_timebase_den &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;vui.b_timing_info_present )</span><br><span class="line">    &#123;</span><br><span class="line">        sps-&gt;vui.i_num_units_in_tick = param-&gt;i_timebase_num;</span><br><span class="line">        sps-&gt;vui.i_time_scale = param-&gt;i_timebase_den * <span class="number">2</span>;</span><br><span class="line">        sps-&gt;vui.b_fixed_frame_rate = !param-&gt;b_vfr_input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.b_vcl_hrd_parameters_present = <span class="number">0</span>; <span class="comment">// we don&#x27;t support VCL HRD</span></span><br><span class="line">    sps-&gt;vui.b_nal_hrd_parameters_present = !!param-&gt;i_nal_hrd;</span><br><span class="line">    sps-&gt;vui.b_pic_struct_present = param-&gt;b_pic_struct;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> HRD related parts of the SPS are initialised in x264_ratecontrol_init_reconfigurable</span></span><br><span class="line"></span><br><span class="line">    sps-&gt;vui.b_bitstream_restriction = !(sps-&gt;b_constraint_set3 &amp;&amp; sps-&gt;i_profile_idc &gt;= PROFILE_HIGH);</span><br><span class="line">    <span class="keyword">if</span>(sps-&gt;vui.b_bitstream_restriction )</span><br><span class="line">    &#123;</span><br><span class="line">        sps-&gt;vui.b_motion_vectors_over_pic_boundaries = <span class="number">1</span>;</span><br><span class="line">        sps-&gt;vui.i_max_bytes_per_pic_denom = <span class="number">0</span>;</span><br><span class="line">        sps-&gt;vui.i_max_bits_per_mb_denom = <span class="number">0</span>;</span><br><span class="line">        sps-&gt;vui.i_log2_max_mv_length_horizontal =</span><br><span class="line">        sps-&gt;vui.i_log2_max_mv_length_vertical = (<span class="keyword">int</span>)log2f( X264_MAX( <span class="number">1</span>, param-&gt;analyse.i_mv_range*<span class="number">4</span><span class="number">-1</span> ) ) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sps-&gt;b_avcintra = !!param-&gt;i_avcintra_class;</span><br><span class="line">    sps-&gt;i_cqm_preset = param-&gt;i_cqm_preset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="x264-pps-init"><a href="#x264-pps-init" class="headerlink" title="x264_pps_init"></a>x264_pps_init</h3><p><code>x264_pps_init()</code> 会根据 <code>x264_param_t</code> 结构体和 <code>x264_sps_t</code> 结构体对 <code>x264_pps_t</code> 进行设置。</p>
<p>具体代码及注释如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                            初始化 SPS</span></span><br><span class="line"><span class="comment">* @param[out]       sps             x264_sps_t 结构体指针</span></span><br><span class="line"><span class="comment">* @param[in]        i_id            i_id</span></span><br><span class="line"><span class="comment">* @param[in]        param           x264_param_t 结构体指针</span></span><br><span class="line"><span class="comment">* @param[in]        param           x264_sps_t 结构体指针</span></span><br><span class="line"><span class="comment">* @return                           x264_t 结构体指针</span></span><br><span class="line"><span class="comment">                                    # not nullptr   执行成功</span></span><br><span class="line"><span class="comment">*                                   # nullptr       执行失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_pps_init</span><span class="params">(<span class="keyword">x264_pps_t</span> *pps, <span class="keyword">int</span> i_id, <span class="keyword">x264_param_t</span> *param, <span class="keyword">x264_sps_t</span> *sps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pps-&gt;i_id = i_id;</span><br><span class="line">    pps-&gt;i_sps_id = sps-&gt;i_id;</span><br><span class="line">    pps-&gt;b_cabac = param-&gt;b_cabac;</span><br><span class="line"></span><br><span class="line">    pps-&gt;b_pic_order = !param-&gt;i_avcintra_class &amp;&amp; param-&gt;b_interlaced;</span><br><span class="line">    pps-&gt;i_num_slice_groups = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pps-&gt;i_num_ref_idx_l0_default_active = param-&gt;i_frame_reference;</span><br><span class="line">    pps-&gt;i_num_ref_idx_l1_default_active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pps-&gt;b_weighted_pred = param-&gt;analyse.i_weighted_pred &gt; <span class="number">0</span>;</span><br><span class="line">    pps-&gt;b_weighted_bipred = param-&gt;analyse.b_weighted_bipred ? <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pps-&gt;i_pic_init_qp = param-&gt;rc.i_rc_method == X264_RC_ABR || param-&gt;b_stitchable ? <span class="number">26</span> + QP_BD_OFFSET : SPEC_QP(param-&gt;rc.i_qp_constant );</span><br><span class="line">    pps-&gt;i_pic_init_qs = <span class="number">26</span> + QP_BD_OFFSET;</span><br><span class="line"></span><br><span class="line">    pps-&gt;i_chroma_qp_index_offset = param-&gt;analyse.i_chroma_qp_offset;</span><br><span class="line">    pps-&gt;b_deblocking_filter_control = <span class="number">1</span>;</span><br><span class="line">    pps-&gt;b_constrained_intra_pred = param-&gt;b_constrained_intra;</span><br><span class="line">    pps-&gt;b_redundant_pic_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pps-&gt;b_transform_8x8_mode = param-&gt;analyse.b_transform_8x8 ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>x264</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 x264 - 代价计算</title>
    <url>/post/2021/ae3a0f38/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>x264</code> 中 <code>x264_pixel_init</code> 函数中初始化了与代价计算有关的函数，本文分析部分代价计算函数的实现，包括 <code>SAD</code>、<code>SATD</code>、<code>SSD</code>、等</p>
<ul>
<li>SAD (Sum of Absolute Difference) = SAE(Sum of Absolute Error) 绝对误差和</li>
<li>SATD（Sum of Absolute Transformed Difference）即 hadamard 变换后再绝对值求和</li>
<li>SSD（Sum of Squared Difference）= SSE（Sum of Squared Error) 差值的平方和</li>
<li>MAD（Mean Absolute Difference）= MAE（Mean Absolute Error) 平均绝对差值</li>
<li>MSD（Mean Squared Difference）= MSE（Mean Squared Error）平均平方误差</li>
</ul>
<a id="more"></a>
<p>下面分别介绍 <code>SAD</code>、<code>SSD</code>、<code>SATD</code> 的实现过程。</p>
<h2 id="SAD-实现过程"><a href="#SAD-实现过程" class="headerlink" title="SAD 实现过程"></a>SAD 实现过程</h2><p>将 <code>x264_pixel_init</code> 函数中的 INIT8(sad,) 展开，可以得到如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pixf-&gt;sad[PIXEL_16x16] = x264_pixel_sad_16x16;</span><br><span class="line">pixf-&gt;sad[PIXEL_16x8]  = x264_pixel_sad_16x8;</span><br><span class="line">pixf-&gt;sad[PIXEL_8x16]  = x264_pixel_sad_8x16;</span><br><span class="line">pixf-&gt;sad[PIXEL_8x8]   = x264_pixel_sad_8x8;</span><br><span class="line">pixf-&gt;sad[PIXEL_8x4]   = x264_pixel_sad_8x4;</span><br><span class="line">pixf-&gt;sad[PIXEL_4x8]   = x264_pixel_sad_4x8;</span><br><span class="line">pixf-&gt;sad[PIXEL_4x4]   = x264_pixel_sad_4x4;</span><br><span class="line">pixf-&gt;sad[PIXEL_4x16]  = x264_pixel_sad_4x16;</span><br></pre></td></tr></table></figure>
<p>我们选取其中最简单的 <code>x264_pixel_sad_4x4</code> 继续展开，它是通过一个宏来定义的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_SAD_C(name, lx, ly) \</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">name</span><span class="params">( pixel *pix1, <span class="keyword">intptr_t</span> i_stride_pix1,  \</span></span></span><br><span class="line">                 pixel *pix2, intptr_t i_stride_pix2 ) \</span><br><span class="line">&#123;                                                   \</span><br><span class="line">    <span class="keyword">int</span> i_sum = <span class="number">0</span>;                                  \</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; ly; y++)                   \</span><br><span class="line">    &#123;                                               \</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; lx; x++)               \</span><br><span class="line">        &#123;                                           \</span><br><span class="line">            i_sum += <span class="built_in">abs</span>(pix1[x] - pix2[x] );      \</span><br><span class="line">        &#125;                                           \</span><br><span class="line">        pix1 += i_stride_pix1;                      \</span><br><span class="line">        pix2 += i_stride_pix2;                      \</span><br><span class="line">    &#125;                                               \</span><br><span class="line">    <span class="keyword">return</span> i_sum;                                   \</span><br><span class="line">&#125;</span><br><span class="line">PIXEL_SAD_C(x264_pixel_sad_4x4, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">/* 展开宏定义如下 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">x264_pixel_sad_4x4</span><span class="params">(<span class="keyword">uint8_t</span> *pix1, <span class="keyword">intptr_t</span> i_stride_pix1, <span class="keyword">uint8_t</span> *pix2, <span class="keyword">intptr_t</span> i_stride_pix2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">            i_sum += <span class="built_in">abs</span>(pix1[x] - pix2[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        pix1 += i_stride_pix1;</span><br><span class="line">        pix2 += i_stride_pix2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SSD-实现过程"><a href="#SSD-实现过程" class="headerlink" title="SSD 实现过程"></a>SSD 实现过程</h2><p>将 <code>x264_pixel_init</code> 函数中的 <code>INIT8(ssd,)</code> 展开，可以得到如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pixf-&gt;ssd[PIXEL_16x16] = x264_pixel_ssd_16x16;</span><br><span class="line">pixf-&gt;ssd[PIXEL_16x8]  = x264_pixel_ssd_16x8;</span><br><span class="line">pixf-&gt;ssd[PIXEL_8x16]  = x264_pixel_ssd_8x16;</span><br><span class="line">pixf-&gt;ssd[PIXEL_8x8]   = x264_pixel_ssd_8x8;</span><br><span class="line">pixf-&gt;ssd[PIXEL_8x4]   = x264_pixel_ssd_8x4;</span><br><span class="line">pixf-&gt;ssd[PIXEL_4x8]   = x264_pixel_ssd_4x8;</span><br><span class="line">pixf-&gt;ssd[PIXEL_4x4]   = x264_pixel_ssd_4x4;</span><br><span class="line">pixf-&gt;ssd[PIXEL_4x16]  = x264_pixel_ssd_4x16;</span><br></pre></td></tr></table></figure>
<p>我们选取其中最简单的 <code>x264_pixel_ssd_4x4</code> 继续展开，它也是通过一个宏来定义的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_SSD_C(name, lx, ly) \</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">x264_pixel_ssd_4x4</span><span class="params">( pixel *pix1, <span class="keyword">intptr_t</span> i_stride_pix1,  \</span></span></span><br><span class="line">                 pixel *pix2, intptr_t i_stride_pix2 ) \</span><br><span class="line">&#123;                                                   \</span><br><span class="line">    <span class="keyword">int</span> i_sum = <span class="number">0</span>;                                  \</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; ly; y++)                   \</span><br><span class="line">    &#123;                                               \</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; lx; x++)               \</span><br><span class="line">        &#123;                                           \</span><br><span class="line">            <span class="keyword">int</span> d = pix1[x] - pix2[x];              \</span><br><span class="line">            i_sum += d*d;                           \</span><br><span class="line">        &#125;                                           \</span><br><span class="line">        pix1 += i_stride_pix1;                      \</span><br><span class="line">        pix2 += i_stride_pix2;                      \</span><br><span class="line">    &#125;                                               \</span><br><span class="line">    <span class="keyword">return</span> i_sum;                                   \</span><br><span class="line">&#125;</span><br><span class="line">PIXEL_SSD_C(x264_pixel_ssd_4x4, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">/* 展开宏定义如下 */</span></span><br><span class="line"><span class="function">tatic <span class="keyword">int</span> <span class="title">name</span><span class="params">(<span class="keyword">uint8_t</span> *pix1, <span class="keyword">intptr_t</span> i_stride_pix1, <span class="keyword">uint8_t</span> *pix2, <span class="keyword">intptr_t</span> i_stride_pix2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = pix1[x] - pix2[x];</span><br><span class="line">            i_sum += d*d;</span><br><span class="line">        &#125;</span><br><span class="line">        pix1 += i_stride_pix1;</span><br><span class="line">        pix2 += i_stride_pix2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SATD-实现过程"><a href="#SATD-实现过程" class="headerlink" title="SATD 实现过程"></a>SATD 实现过程</h2><p>将 <code>x264_pixel_init</code> 函数中的 <code>INIT8(satd,)</code> 展开，可以得到如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pixf-&gt;satd[PIXEL_16x16] = x264_pixel_satd_16x16;</span><br><span class="line">pixf-&gt;satd[PIXEL_16x8]  = x264_pixel_satd_16x8;</span><br><span class="line">pixf-&gt;satd[PIXEL_8x16]  = x264_pixel_satd_8x16;</span><br><span class="line">pixf-&gt;satd[PIXEL_8x8]   = x264_pixel_satd_8x8;</span><br><span class="line">pixf-&gt;satd[PIXEL_8x4]   = x264_pixel_satd_8x4;</span><br><span class="line">pixf-&gt;satd[PIXEL_4x8]   = x264_pixel_satd_4x8;</span><br><span class="line">pixf-&gt;satd[PIXEL_4x4]   = x264_pixel_satd_4x4;</span><br><span class="line">pixf-&gt;satd[PIXEL_4x16]  = x264_pixel_satd_4x16;</span><br></pre></td></tr></table></figure>
<p>同样，选取最简单的 <code>x264_pixel_satd_4x4</code> 继续展开，它的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint8_t</span>  pixel;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">sum_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">sum2_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_SUM (8 * sizeof(sum_t))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HADAMARD4(d0, d1, d2, d3, s0, s1, s2, s3) &#123;\</span></span><br><span class="line">    <span class="keyword">sum2_t</span> t0 = s0 + s1;\</span><br><span class="line">    <span class="keyword">sum2_t</span> t1 = s0 - s1;\</span><br><span class="line">    <span class="keyword">sum2_t</span> t2 = s2 + s3;\</span><br><span class="line">    <span class="keyword">sum2_t</span> t3 = s2 - s3;\</span><br><span class="line">    d0 = t0 + t2;\</span><br><span class="line">    d2 = t0 - t2;\</span><br><span class="line">    d1 = t1 + t3;\</span><br><span class="line">    d3 = t1 - t3;\</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> NOINLINE <span class="keyword">int</span> <span class="title">x264_pixel_satd_4x4</span><span class="params">(pixel *pix1, <span class="keyword">intptr_t</span> i_pix1, pixel *pix2, <span class="keyword">intptr_t</span> i_pix2 )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sum2_t</span> tmp[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">sum2_t</span> a0, a1, a2, a3, b0, b1;</span><br><span class="line">    <span class="keyword">sum2_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++, pix1 += i_pix1, pix2 += i_pix2 ) &#123;</span><br><span class="line">        a0 = pix1[<span class="number">0</span>] - pix2[<span class="number">0</span>];</span><br><span class="line">        a1 = pix1[<span class="number">1</span>] - pix2[<span class="number">1</span>];</span><br><span class="line">        b0 = (a0+a1) + ((a0-a1)&lt;&lt;BITS_PER_SUM);</span><br><span class="line">        a2 = pix1[<span class="number">2</span>] - pix2[<span class="number">2</span>];</span><br><span class="line">        a3 = pix1[<span class="number">3</span>] - pix2[<span class="number">3</span>];</span><br><span class="line">        b1 = (a2+a3) + ((a2-a3)&lt;&lt;BITS_PER_SUM);</span><br><span class="line">        tmp[i][<span class="number">0</span>] = b0 + b1;</span><br><span class="line">        tmp[i][<span class="number">1</span>] = b0 - b1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ ) &#123;</span><br><span class="line">        HADAMARD4( a0, a1, a2, a3, tmp[<span class="number">0</span>][i], tmp[<span class="number">1</span>][i], tmp[<span class="number">2</span>][i], tmp[<span class="number">3</span>][i] );</span><br><span class="line">        a0 = abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);</span><br><span class="line">        sum += ((<span class="keyword">sum_t</span>)a0) + (a0&gt;&gt;BITS_PER_SUM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li>
<li>[2] <a href="http://lazybing.github.io/blog/2017/07/08/x264-pixel-init-function/">X264 源码解析之 x264_pixel_init 函数 - 懒人李冰</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>x264</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 x264 - 命令行工具</title>
    <url>/post/2020/3bc2314a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="命令行工具简介"><a href="#命令行工具简介" class="headerlink" title="命令行工具简介"></a>命令行工具简介</h2><p>x264 命令行工具执行流程如下：</p>
<ol>
<li>首先调用 parse() 解析输入的命令行参数<ol>
<li>parse()首先调用 x264_param_default() 为存储参数的结构体 x264_param_t 赋默认值</li>
<li>循环中调用 getopt_long() 逐个解析输入的参数，并作相应的处理</li>
<li>调用 select_output() 解析输出文件格式（例如 raw，flv，MP4…）</li>
<li>调用 select_input() 解析输入文件格式（例如 yuv，y4m…）</li>
</ol>
</li>
<li>然后调用 encode() 进行编码<ol>
<li>encode() 首先调用 x264_encoder_open() 打开 H.264 编码器</li>
<li>然后调用 x264_encoder_headers() 输出 H.264 码流的头信息（例如 SPS、PPS、SEI）</li>
<li>循环调用 encode_frame() 逐帧编码视频<ol>
<li>encode_frame()中调用了x264_encoder_encode()完成了具体的编码工作</li>
</ol>
</li>
<li>调用x264_encoder_close()关闭解码器</li>
</ol>
</li>
</ol>
<a id="more"></a>
<h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h2><p>main() 是 x264 控制台程序的入口函数，定义如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">REALIGN_STACK <span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">4</span> &amp;&amp; !<span class="built_in">strcmp</span>( argv[<span class="number">1</span>], <span class="string">&quot;--autocomplete&quot;</span> ) )</span><br><span class="line">        <span class="keyword">return</span> x264_cli_autocomplete(argv[<span class="number">2</span>], argv[<span class="number">3</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">x264_param_t</span> param;</span><br><span class="line">    <span class="keyword">cli_opt_t</span> opt = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    FAIL_IF_ERROR(x264_threading_init(), <span class="string">&quot;unable to initialize threading\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">    x264_param_default(&amp;param);</span><br><span class="line">    <span class="comment">/* Parse command line */</span></span><br><span class="line">    <span class="keyword">if</span>(parse( argc, argv, &amp;param, &amp;opt) &lt; <span class="number">0</span> )</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Control-C handler */</span></span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!ret)</span><br><span class="line">        ret = encode(&amp;param, &amp;opt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean up handles */</span></span><br><span class="line">    <span class="keyword">if</span>(filter.<span class="built_in">free</span>)</span><br><span class="line">        filter.<span class="built_in">free</span>(opt.hin);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opt.hin)</span><br><span class="line">        cli_input.close_file(opt.hin);</span><br><span class="line">    <span class="keyword">if</span>(opt.hout)</span><br><span class="line">        cli_output.close_file(opt.hout, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(opt.tcfile_out)</span><br><span class="line">        fclose(opt.tcfile_out);</span><br><span class="line">    <span class="keyword">if</span>(opt.qpfile)</span><br><span class="line">        fclose(opt.qpfile);</span><br><span class="line">    x264_param_cleanup(&amp;param);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出 main() 的定义很简单，它主要调用了两个函数：parse() 和 encode()。</p>
<p>main() 首先调用 parse() 对命令行进行解析并进行参数设置，然后调用 encode() 进行编码压缩。下面分别分析这两个函数。</p>
<h2 id="parse-函数"><a href="#parse-函数" class="headerlink" title="parse 函数"></a>parse 函数</h2><p>parse() 用于解析命令行输入的参数（存储于 argv[] 中），其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                    参数分析函数</span></span><br><span class="line"><span class="comment">* @param[in]        argc    参数个数</span></span><br><span class="line"><span class="comment">* @param[in]        argv    1 维数组指针，指向每个参数字符串首地址</span></span><br><span class="line"><span class="comment">* @param[in/out]    param   x264_param_t 结构体指针</span></span><br><span class="line"><span class="comment">* @param[in/out]    param   cli_opt_t 结构体指针</span></span><br><span class="line"><span class="comment">* @return                   # 0     执行成功</span></span><br><span class="line"><span class="comment">*                           # -1    执行失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parse</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">x264_param_t</span> *param, <span class="keyword">cli_opt_t</span> *opt)</span></span>;</span><br></pre></td></tr></table></figure>
<p>阅读源代码，可梳理出 parse() 函数的简单流程：</p>
<ol>
<li>调用 x264_param_default() 为存储参数的结构体 x264_param_t 赋默认值</li>
<li>调用 x264_param_default_preset() 为 x264_param_t 赋值</li>
<li>在一个大循环中调用 getopt_long() 逐个解析输入的参数，并作相应的处理。举几个例子：<ol>
<li>对于短选项，直接设置输出参数或调用其他函数进行处理。</li>
<li>对于长选项，统一调用 x264_param_parse() 进行处理。</li>
</ol>
</li>
<li>调用 select_output() 解析输出文件格式（例如 raw，flv，MP4…）</li>
<li>调用 select_input() 解析输入文件格式（例如 yuv，y4m…）</li>
</ol>
<blockquote>
<p>关于 x264_param_t 结构体和 cli_opt_t 结构体的说明，详见：<a href="/post/2020/e6d88726/" title="源码阅读 x264 - 常用结构体">源码阅读 x264 - 常用结构体</a></p>
</blockquote>
<p>parse() 中几个比较关键的函数：</p>
<h3 id="x264-param-default"><a href="#x264-param-default" class="headerlink" title="x264_param_default"></a>x264_param_default</h3><p>x264_param_default() 用于初始化 x264_param_t 类型变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                    x264_param_t 参数初始化函数</span></span><br><span class="line"><span class="comment">* @param[in/out]    param   x264_param_t 结构体指针</span></span><br><span class="line"><span class="comment">* @return                   void</span></span><br><span class="line"><span class="comment">* @note:    fill x264_param_t with default values and do CPU detection</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">REALIGN_STACK <span class="keyword">void</span> <span class="title">x264_param_default</span><span class="params">(<span class="keyword">x264_param_t</span> *param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>x264_param_default(x264_param_t*)，在 parse() 中声明了一个 x264_param_t 类型的局部变量 default，并调用此函数进行初始化，但是目前还不知道 default 的用途。</p>
<h3 id="x264-param-default-preset"><a href="#x264-param-default-preset" class="headerlink" title="x264_param_default_preset"></a>x264_param_default_preset</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                    根据 preset 和 tune 对 x264_param_t 参数进行初始化</span></span><br><span class="line"><span class="comment">* @param[in/out]    param   x264_param_t 结构体指针</span></span><br><span class="line"><span class="comment">* @param[in]        preset  字符串，指示预设编码类型</span></span><br><span class="line"><span class="comment">* @param[in]        tune    字符串，指示视频类型或视觉优化类型</span></span><br><span class="line"><span class="comment">* @return                   # 0          执行成功</span></span><br><span class="line"><span class="comment">*                           # negative   执行失败 (e.g. invalid preset/tune name)</span></span><br><span class="line"><span class="comment">* @note:    Multiple tunings can be used if separated by a delimiter in &quot;,./-+&quot;,</span></span><br><span class="line"><span class="comment">*           however multiple psy tunings cannot be used.</span></span><br><span class="line"><span class="comment">*           film, animation, grain, stillimage, psnr, and ssim are psy tunings.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">X264_API <span class="keyword">int</span> <span class="title">x264_param_default_preset</span><span class="params">(<span class="keyword">x264_param_t</span> *param, <span class="keyword">const</span> <span class="keyword">char</span> *preset, <span class="keyword">const</span> <span class="keyword">char</span> *tune)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>—preset 的参数主要调节编码速度和质量的平衡，有 ultrafast、superfast、veryfast、faster、fast、medium、slow、slower、veryslow、placebo 这 10 个选项，从快到慢。<br>—tune 的参数主要配合视频类型和视觉优化的参数，或特别的情况。如果视频的内容符合其中一个可用的调整值又或者有其中需要，则可以使用此选项，否则建议不使用。<br>tune 的值有： film、animation、grain、stillimage、psnr、ssim、fastdecode、zerolatency、touhou 这 9 个选项，部分选项可同时设置，可详见 param_apply_tune() 函数。</p>
</blockquote>
<p>x264_param_default_preset()，会首先调用 x264_param_default() 对 param 进行初始化，然后根据 preset 和 tune 的值再对 param 进行初始化。</p>
<h3 id="x264-param-parse"><a href="#x264-param-parse" class="headerlink" title="x264_param_parse"></a>x264_param_parse</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                    根据 name 和 value 对 x264_param_t 参数进行设置</span></span><br><span class="line"><span class="comment">* @param[in/out]    param   x264_param_t 结构体指针</span></span><br><span class="line"><span class="comment">* @param[in]        name    字符串，指示参数名称</span></span><br><span class="line"><span class="comment">* @param[in]        value   字符串，指示参数值</span></span><br><span class="line"><span class="comment">* @return                   # 0                                         执行成功</span></span><br><span class="line"><span class="comment">*                           #define X264_PARAM_BAD_NAME         (-1)    执行失败</span></span><br><span class="line"><span class="comment">*                           #define X264_PARAM_BAD_VALUE        (-2)    执行失败</span></span><br><span class="line"><span class="comment">*                           #define X264_PARAM_ALLOC_FAILED     (-3)    执行失败</span></span><br><span class="line"><span class="comment">* @note:    BAD_VALUE occurs only if it can&#x27;t even parse the value,</span></span><br><span class="line"><span class="comment">*           numerical range is not checked until x264_encoder_open() or x264_encoder_reconfig().</span></span><br><span class="line"><span class="comment">*           value=NULL means &quot;true&quot; for boolean options, but is a BAD_VALUE for non-booleans.</span></span><br><span class="line"><span class="comment">*           can allocate memory which should be freed by call of x264_param_cleanup.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">X264_API <span class="keyword">int</span> <span class="title">x264_param_parse</span><span class="params">(<span class="keyword">x264_param_t</span> *param, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value)</span></span>;</span><br></pre></td></tr></table></figure>
<p>x264_param_parse() 用来对命令行中的长选项进行解析，并完成 param 的设置。</p>
<h3 id="x264-param-apply-fastfirstpass"><a href="#x264-param-apply-fastfirstpass" class="headerlink" title="x264_param_apply_fastfirstpass"></a>x264_param_apply_fastfirstpass</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* x264_param_apply_fastfirstpass:</span></span><br><span class="line"><span class="comment"> *      If first-pass mode is set (rc.b_stat_read == 0, rc.b_stat_write == 1),</span></span><br><span class="line"><span class="comment"> *      modify the encoder settings to disable options generally not useful on</span></span><br><span class="line"><span class="comment"> *      the first pass.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">X264_API <span class="keyword">void</span> <span class="title">x264_param_apply_fastfirstpass</span><span class="params">(<span class="keyword">x264_param_t</span> *param)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="x264-param-apply-profile"><a href="#x264-param-apply-profile" class="headerlink" title="x264_param_apply_profile"></a>x264_param_apply_profile</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> x264_profile_names[] = &#123;</span><br><span class="line">    <span class="string">&quot;baseline&quot;</span>, <span class="string">&quot;main&quot;</span>, <span class="string">&quot;high&quot;</span>, <span class="string">&quot;high10&quot;</span>, <span class="string">&quot;high422&quot;</span>, <span class="string">&quot;high444&quot;</span>, <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                    根据 profile 对 x264_param_t 参数进行设置</span></span><br><span class="line"><span class="comment">* @param[in/out]    param   x264_param_t 结构体指针</span></span><br><span class="line"><span class="comment">* @param[in]        profile 字符串，指示 H264 配置文件</span></span><br><span class="line"><span class="comment">* @return                   # 0         执行成功</span></span><br><span class="line"><span class="comment">*                           # negative  执行失败 (e.g. invalid profile name)</span></span><br><span class="line"><span class="comment">* @note:    (can be NULL, in which case the function will do nothing)</span></span><br><span class="line"><span class="comment">*           Does NOT guarantee that the given profile will be used: if the restrictions</span></span><br><span class="line"><span class="comment">*           of &quot;High&quot; are applied to settings that are already Baseline-compatible, the</span></span><br><span class="line"><span class="comment">*           stream will remain baseline.  In short, it does not increase settings, only</span></span><br><span class="line"><span class="comment">*           decrease them.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">X264_API <span class="keyword">int</span> <span class="title">x264_param_apply_profile</span><span class="params">(<span class="keyword">x264_param_t</span> *param, <span class="keyword">const</span> <span class="keyword">char</span> *profile)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>x264_param_apply_profile() 根据 profile 对 param 进行设置，这里 profile 有 6 种选项，分别是 baseline/main/high/high10/high422/high444，如果选择无损压缩的话，profile 会被限制为 high444。</p>
<h3 id="select-output"><a href="#select-output" class="headerlink" title="select_output"></a>select_output</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                        根据文件名的后缀确定输出的文件格式（raw H264，flv，mp4...）</span></span><br><span class="line"><span class="comment">* @param[in]        muxer       字符串，指示输出文件的 muxer 格式</span></span><br><span class="line"><span class="comment">* @param[in]        filename    字符串，指示输出文件的文件名</span></span><br><span class="line"><span class="comment">* @param[in/out]    param       x264_param_t 结构体指针</span></span><br><span class="line"><span class="comment">* @return                       # 0         执行成功</span></span><br><span class="line"><span class="comment">*                               # negative  执行失败</span></span><br><span class="line"><span class="comment">* @note:    在指定 muxer 时以 muxer 为准，muxer 为 auto 时，以输出文件拓展名为准</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">select_output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *muxer, <span class="keyword">char</span> *filename, <span class="keyword">x264_param_t</span> *param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>select_output() 会从输入文件路径的字符串中提取出了扩展名，然后根据不同的扩展名设定不同的输出格式。</p>
<h3 id="select-input"><a href="#select-input" class="headerlink" title="select_input"></a>select_input</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                            根据文件名的后缀确定输出的文件格式（raw H264，flv，mp4...）</span></span><br><span class="line"><span class="comment">* @param[in]        demuxer         字符串，指示输入文件的 demuxer 格式</span></span><br><span class="line"><span class="comment">* @param[in]        used_demuxer    字符串，指示输入文件的 demuxer 格式</span></span><br><span class="line"><span class="comment">* @param[in]        filename        字符串，指示输入文件的文件名</span></span><br><span class="line"><span class="comment">* @param[out]       p_handle        hnd_t 结构体指针</span></span><br><span class="line"><span class="comment">* @param[out]       info            video_info_t 结构体指针，保存输入文件信息</span></span><br><span class="line"><span class="comment">* @param[out]       opt             cli_input_opt_t 结构体指针</span></span><br><span class="line"><span class="comment">* @return                           # 0         执行成功</span></span><br><span class="line"><span class="comment">*                                   # negative  执行失败</span></span><br><span class="line"><span class="comment">* @note:    在指定 demuxer 时以 demuxer 为准，demuxer 为 auto 时，以输入文件拓展名为准</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">select_input</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *demuxer, <span class="keyword">char</span> *used_demuxer, <span class="keyword">char</span> *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">hnd_t</span> *p_handle, <span class="keyword">video_info_t</span> *info, <span class="keyword">cli_input_opt_t</span> *opt )</span></span></span><br></pre></td></tr></table></figure>
<p>select_input() 首先获取输入文件名的扩展名；然后根据扩展名不同调用不用的 open_file 函数来设置不同的输入格式。</p>
<h2 id="encode-函数"><a href="#encode-函数" class="headerlink" title="encode 函数"></a>encode 函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                    开始进行编码</span></span><br><span class="line"><span class="comment">* @param[in]        param   x264_param_t 结构体指针</span></span><br><span class="line"><span class="comment">* @param[in]        opt     cli_opt_t 结构体指针</span></span><br><span class="line"><span class="comment">* @return                   # 0         执行成功</span></span><br><span class="line"><span class="comment">*                           # negative  执行失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">( <span class="keyword">x264_param_t</span> *param, <span class="keyword">cli_opt_t</span> *opt )</span></span>;</span><br></pre></td></tr></table></figure>
<p>从源代码可以梳理出来 encode() 的流程：</p>
<ol>
<li>调用 x264_encoder_open() 打开 H.264 编码器。</li>
<li>调用 x264_encoder_parameters() 获得当前的参数集 x264_param_t，用于后续步骤中的一些配置。</li>
<li>调用输出格式（H.264裸流、FLV、mp4 等）对应 cli_output_t 结构体的 set_param() 方法，为输出格式的封装器设定参数。其中参数源自于上一步骤得到的 x264_param_t。</li>
<li>如果不是在每个 keyframe 前面都增加 SPS/PPS/SEI 的话，就调用 x264_encoder_headers() 在整个码流前面加 SPS/PPS/SEI。</li>
<li>进入一个循环中进行一帧一帧的将 YUV 编码为 H.264：<ol>
<li>调用输入格式（YUV、Y4M 等）对应的 cli_vid_filter_t 结构体 get_frame() 方法，获取一帧 YUV 数据。</li>
<li>调用 encode_frame() 编码该帧 YUV 数据为 H.264 数据，并且输出出来。该函数内部调用 x264_encoder_encode() 完成编码工作，调用输出格式对应 cli_output_t 结构体的 write_frame() 完成了输出工作。</li>
<li>调用输入格式（YUV、Y4M 等）对应的 cli_vid_filter_t 结构体 release_frame() 方法，释放刚才获取的YUV 数据。</li>
<li>调用 print_status() 输出一些统计信息。</li>
</ol>
</li>
<li>编码即将结束的时候，进入另一个循环，输出编码器中缓存的视频帧：<ol>
<li>不再传递新的 YUV 数据，直接调用 encode_frame()，将编码器中缓存的剩余几帧数据编码输出出来。</li>
<li>调用 print_status() 输出一些统计信息。</li>
</ol>
</li>
<li>调用 x264_encoder_close() 关闭 H.264 编码器。</li>
</ol>
<p>encode() 的流程中涉及到 libx264 的几个关键的API，这些函数较为复杂，后续再进行分析：</p>
<ul>
<li>x264_encoder_open()：打开H.264编码器。</li>
<li>x264_encoder_headers()：输出SPS/PPS/SEI。</li>
<li>x264_encoder_encode()：编码一帧数据。</li>
<li>x264_encoder_close()：关闭H.264编码器。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45583217">x264源代码简单分析：x264命令行工具（x264.exe） 雷霄骅的专栏-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>x264</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 x264 - 去块效应滤波</title>
    <url>/post/2021/10604d20/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>x264_deblock_init()</code> 中初始化了一系列环路滤波函数。</p>
<ol>
<li>包含 “v” 的是垂直滤波器，用于处理水平边界；包含 “h” 的是水平滤波器，用于处理垂直边界。</li>
<li>包含 “luma” 的是亮度滤波器，包含 “chroma” 的是色度滤波器。</li>
<li>包含 “intra” 的是处理边界强度 Bs 为 4 的强滤波器，不包含 “intra” 的是普通滤波器。</li>
</ol>
<a id="more"></a>
<p><code>x264_deblock_init</code> 函数代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_deblock_init</span><span class="params">(<span class="keyword">uint32_t</span> cpu, <span class="keyword">x264_deblock_function_t</span> *pf, <span class="keyword">int</span> b_mbaff)</span> </span>&#123;</span><br><span class="line">    pf-&gt;deblock_luma[<span class="number">1</span>] = deblock_v_luma_c;</span><br><span class="line">    pf-&gt;deblock_luma[<span class="number">0</span>] = deblock_h_luma_c;</span><br><span class="line">    pf-&gt;deblock_chroma[<span class="number">1</span>] = deblock_v_chroma_c;</span><br><span class="line">    pf-&gt;deblock_h_chroma_420 = deblock_h_chroma_c;</span><br><span class="line">    pf-&gt;deblock_h_chroma_422 = deblock_h_chroma_422_c;</span><br><span class="line">    pf-&gt;deblock_luma_intra[<span class="number">1</span>] = deblock_v_luma_intra_c;</span><br><span class="line">    pf-&gt;deblock_luma_intra[<span class="number">0</span>] = deblock_h_luma_intra_c;</span><br><span class="line">    pf-&gt;deblock_chroma_intra[<span class="number">1</span>] = deblock_v_chroma_intra_c;</span><br><span class="line">    pf-&gt;deblock_h_chroma_420_intra = deblock_h_chroma_intra_c;</span><br><span class="line">    pf-&gt;deblock_h_chroma_422_intra = deblock_h_chroma_422_intra_c;</span><br><span class="line">    pf-&gt;deblock_luma_mbaff = deblock_h_luma_mbaff_c;</span><br><span class="line">    pf-&gt;deblock_chroma_420_mbaff = deblock_h_chroma_mbaff_c;</span><br><span class="line">    pf-&gt;deblock_luma_intra_mbaff = deblock_h_luma_intra_mbaff_c;</span><br><span class="line">    pf-&gt;deblock_chroma_420_intra_mbaff = deblock_h_chroma_intra_mbaff_c;</span><br><span class="line">    pf-&gt;deblock_strength = deblock_strength_c;</span><br><span class="line">    <span class="comment">/* 此处省略大量平台的汇编函数初始化代码 */</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="环路滤波分类"><a href="#环路滤波分类" class="headerlink" title="环路滤波分类"></a>环路滤波分类</h2><p>环路滤波器根据滤波的强度可以分为两种：</p>
<ol>
<li>普通滤波器。针对边界的 <code>Bs</code>（边界强度）为 1、2、3 的滤波器。</li>
<li>强滤波器。针对边界的 <code>Bs</code>（边界强度）为 4 的滤波器。</li>
</ol>
<h3 id="普通滤波器"><a href="#普通滤波器" class="headerlink" title="普通滤波器"></a>普通滤波器</h3><p>此时环路滤波涉及到方块边界周围的 6 个点（边界两边各 3 个点）：$p2,p1,p0,q0,q1,q2$<br>需要处理 4 个点（边界两边各 2 个点，只以 p 侧的点为例）：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210201221354.png" alt="描述一个 4x4 块横向或者纵向边界的样点的惯例"></p>
<pre><code>p0&#39; = p0 + (((q0 - p0) &lt;&lt; 2) + (p1 - q1) + 4) &gt;&gt; 3
p1&#39; = (p2 + ( ( p0 + q0 + 1) &gt;&gt; 1) – 2p1 ) &gt;&gt; 1
</code></pre><h3 id="强滤波器"><a href="#强滤波器" class="headerlink" title="强滤波器"></a>强滤波器</h3><p>此时环路滤波涉及到方块边界周围的 8 个点（边界两边各 4 个点）：$p3,p2,p1,p0,q0,q1,q2,q3$<br>需要处理 6 个点（边界两边各 3 个点，只以 p 侧的点为例）：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210201221354.png" alt="描述一个 4x4 块横向或者纵向边界的样点的惯例"></p>
<pre><code>p0&#39; = (p2 + 2*p1 + 2*p0 + 2*q0 + q1 + 4) &gt;&gt; 3
p1&#39; = (p2 + p1 + p0 + q0 + 2) &gt;&gt; 2
p2&#39; = (2*p3 + 3*p2 + p1 + p0 + q0 + 4) &gt;&gt; 3
</code></pre><blockquote>
<p>边界强度的计算和边界分析方法详见：<a href="/post/2021/e059d0/" title="编解码技术：H264 - 去块效应滤波">编解码技术：H264 - 去块效应滤波</a></p>
</blockquote>
<h2 id="普通滤波函数"><a href="#普通滤波函数" class="headerlink" title="普通滤波函数"></a>普通滤波函数</h2><h3 id="deblock-v-luma-c"><a href="#deblock-v-luma-c" class="headerlink" title="deblock_v_luma_c"></a>deblock_v_luma_c</h3><p><code>deblock_v_luma_c()</code> 是一个普通强度的垂直滤波器，用于处理边界强度 <code>Bs</code> 为 1，2，3 的水平边界。该函数的定义位于 <code>common/deblock.c</code>，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 去块效应滤波 - 普通滤波，Bs 为 1,2,3</span></span><br><span class="line"><span class="comment"> * 垂直 Vertical 滤波器</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> * 边界 ==========</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deblock_v_luma_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> stride, <span class="keyword">int</span> `alpha`, <span class="keyword">int</span> beta, <span class="keyword">int8_t</span> *tc0)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// xstride = stride（用于选择滤波的像素）</span></span><br><span class="line">    <span class="comment">// ystride = 1</span></span><br><span class="line">    deblock_luma_c(pix, stride, <span class="number">1</span>, alpha, beta, tc0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>deblock_v_luma_c()</code> 调用了另一个函数 <code>deblock_luma_c()</code>。需要注意传递给 <code>deblock_luma_c()</code> 是一个水平滤波器和垂直滤波器都会调用的通用滤波器函数。在这里传递给 <code>deblock_luma_c()</code> 第二个参数 <code>xstride</code> 的值为 <code>stride</code>，第三个参数 <code>ystride</code> 的值为 1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deblock_luma_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> xstride, <span class="keyword">intptr_t</span> ystride, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta, <span class="keyword">int8_t</span> *tc0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tc0[i] &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">            pix += <span class="number">4</span>*ystride;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++, pix += ystride)</span><br><span class="line">            deblock_edge_luma_c(pix, xstride, alpha, beta, tc0[i] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的滤波在 <code>deblock_edge_luma_c()</code> 中完成。处理完一个像素后，会继续处理与当前像素距离为 <code>ystride</code> 的像素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deblock_edge_luma_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> xstride, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta, <span class="keyword">int8_t</span> tc0)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * p 和 q</span></span><br><span class="line"><span class="comment">     * 如果 xstride = stride，ystride = 1</span></span><br><span class="line"><span class="comment">     * 就是处理纵向的 6 个像素</span></span><br><span class="line"><span class="comment">     * 对应的是方块的横向边界的滤波，即如下所示：</span></span><br><span class="line"><span class="comment">     *         p2</span></span><br><span class="line"><span class="comment">     *         p1</span></span><br><span class="line"><span class="comment">     *         p0</span></span><br><span class="line"><span class="comment">     * ===== 图像边界 =====</span></span><br><span class="line"><span class="comment">     *         q0</span></span><br><span class="line"><span class="comment">     *         q1</span></span><br><span class="line"><span class="comment">     *         q2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果 xstride = 1，ystride = stride</span></span><br><span class="line"><span class="comment">     * 就是处理纵向的 6 个像素</span></span><br><span class="line"><span class="comment">     * 对应的是方块的横向边界的滤波，即如下所示：</span></span><br><span class="line"><span class="comment">     *           ||</span></span><br><span class="line"><span class="comment">     *  p2 p1 p0 || q0 q1 q2</span></span><br><span class="line"><span class="comment">     *           ||</span></span><br><span class="line"><span class="comment">     *          边界</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：这里乘的是 xstride</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> p2 = pix[<span class="number">-3</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> p1 = pix[<span class="number">-2</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> p0 = pix[<span class="number">-1</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> q0 = pix[<span class="number">0</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> q1 = pix[<span class="number">1</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> q2 = pix[<span class="number">2</span>*xstride];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方法参考相关的标准</span></span><br><span class="line">    <span class="comment">// alpha 和 beta 是用于检查图像内容的 2 个参数</span></span><br><span class="line">    <span class="comment">// 只有满足 if() 里面 3 个取值条件的时候（只涉及边界旁边的 4 个点），才会滤波</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>( p0 - q0) &lt; alpha &amp;&amp; <span class="built_in">abs</span>( p1 - p0 ) &lt; beta &amp;&amp; <span class="built_in">abs</span>( q1 - q0 ) &lt; beta ) &#123;</span><br><span class="line">        <span class="keyword">int</span> tc = tc0;</span><br><span class="line">        <span class="keyword">int</span> delta;</span><br><span class="line">        <span class="comment">// 上面 2 个点（p0，p2）满足条件的时候，滤波 p1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>( p2 - p0) &lt; beta ) &#123;</span><br><span class="line">            <span class="comment">// p1&#x27; = (p2 + ( ( p0 + q0 + 1) &gt;&gt; 1) – 2p1 ) &gt;&gt; 1</span></span><br><span class="line">            <span class="comment">//     = (p2 + ( ( p0 + q0 + 1) &gt;&gt; 1)) &gt;&gt; 1 - p1</span></span><br><span class="line">            <span class="keyword">if</span> (tc0) pix[<span class="number">-2</span>*xstride] = p1 + x264_clip3( (( p2 + ((p0 + q0 + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>)) &gt;&gt; <span class="number">1</span>) - p1, -tc0, tc0 );</span><br><span class="line">            tc++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面 2 个点（q0，q2）满足条件的时候，滤波 q1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>( q2 - q0) &lt; beta ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tc0) pix[<span class="number">1</span>*xstride] = q1 + x264_clip3( (( q2 + ((p0 + q0 + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>)) &gt;&gt; <span class="number">1</span>) - q1, -tc0, tc0 );</span><br><span class="line">            tc++;</span><br><span class="line">        &#125;</span><br><span class="line">        delta = x264_clip3((((q0 - p0) &lt;&lt; <span class="number">2</span>) + (p1 - q1) + <span class="number">4</span>) &gt;&gt; <span class="number">3</span>, -tc, tc );</span><br><span class="line">        <span class="comment">// p0&#x27; = p0 + (((q0 - p0) &lt;&lt; 2) + (p1 - q1) + 4) &gt;&gt; 3</span></span><br><span class="line">        pix[<span class="number">-1</span>*xstride] = x264_clip_pixel( p0 + delta );    <span class="comment">/* p0&#x27; */</span></span><br><span class="line">        pix[<span class="number">0</span>*xstride] = x264_clip_pixel( q0 - delta );     <span class="comment">/* q0&#x27; */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">x264_clip3</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> i_min, <span class="keyword">int</span> i_max)</span> </span>&#123;   <span class="comment">// 将 v 限制在 i_min 和 i_max 之间</span></span><br><span class="line">    <span class="keyword">return</span> ((v &lt; i_min) ? i_min : (v &gt; i_max) ? i_max : v );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> pixel <span class="title">x264_clip_pixel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;                  <span class="comment">// 将 x 限制在 0 和 255 之间</span></span><br><span class="line">    <span class="keyword">return</span> ((x &amp; ~PIXEL_MAX) ? (-x)&gt;&gt;<span class="number">31</span> &amp; PIXEL_MAX : x );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="deblock-h-luma-c"><a href="#deblock-h-luma-c" class="headerlink" title="deblock_h_luma_c"></a>deblock_h_luma_c</h3><p><code>deblock_h_luma_c()</code> 是一个普通强度的水平滤波器，用于处理边界强度 <code>Bs</code> 为 1，2，3 的垂直边界。该函数的定义如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 去块效应滤波 - 普通滤波，Bs 为 1,2,3</span></span><br><span class="line"><span class="comment"> * 水平 Horizontal 滤波器</span></span><br><span class="line"><span class="comment"> *      边界</span></span><br><span class="line"><span class="comment"> *       ||</span></span><br><span class="line"><span class="comment"> * x x x || x x x</span></span><br><span class="line"><span class="comment"> *       ||</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deblock_h_luma_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> stride, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta, <span class="keyword">int8_t</span> *tc0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// xstride = 1（用于选择滤波的像素）</span></span><br><span class="line">    <span class="comment">// ystride = stride</span></span><br><span class="line">    deblock_luma_c(pix, <span class="number">1</span>, stride, alpha, beta, tc0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 <code>deblock_v_luma_c()</code> 类似，<code>deblock_h_luma_c()</code> 同样调用了 <code>deblock_luma_c()</code> 函数。唯一的不同在于它传递给 <code>deblock_luma_c()</code> 的第 2 个参数 <code>xstride</code> 为 1，第 3 个参数 <code>ystride</code> 为 <code>stride</code>。</p>
<h2 id="强滤波函数"><a href="#强滤波函数" class="headerlink" title="强滤波函数"></a>强滤波函数</h2><h3 id="deblock-v-luma-intra-c"><a href="#deblock-v-luma-intra-c" class="headerlink" title="deblock_v_luma_intra_c"></a>deblock_v_luma_intra_c</h3><p><code>deblock_v_luma_intra_c()</code> 是一个强滤波的垂直滤波器，用于处理边界强度 <code>Bs</code> 为 4 的水平边界。该函数的定义位于 <code>common/deblock.c</code>，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 垂直 Vertical 强滤波器 - Bs 为 4</span></span><br><span class="line"><span class="comment"> *        边界</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> * 边界 ----------</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> *          x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deblock_v_luma_intra_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> stride, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">    <span class="comment">// xstride = stride</span></span><br><span class="line">    <span class="comment">// ystride = 1</span></span><br><span class="line">    <span class="comment">// 处理完 1 个像素点之后，pix 增加 ystride</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 水平滤波和垂直滤波通用的强滤波函数</span></span><br><span class="line">    deblock_luma_intra_c(pix, stride, <span class="number">1</span>, alpha, beta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>deblock_v_luma_intra_c()</code> 调用了另一个函数 <code>deblock_luma_intra_c()</code>。需要注意 <code>deblock_luma_intra_c()</code> 是一个水平滤波器和垂直滤波器都会调用的通用滤波器函数。在这里传递给 <code>deblock_luma_intra_c()</code> 第二个参数 <code>xstride</code> 的值为 <code>stride</code>，第三个参数 <code>ystride</code> 的值为 1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 水平滤波和垂直滤波通用的强滤波函数 - Bs 为 4</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deblock_luma_intra_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> xstride, <span class="keyword">intptr_t</span> ystride, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环处理 16 个点</span></span><br><span class="line">    <span class="comment">// 处理完 1 个像素点之后，pix 增加 ystride</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">16</span>; d++, pix += ystride)</span><br><span class="line">        <span class="comment">// 每次处理 1 个点</span></span><br><span class="line">        deblock_edge_luma_intra_c(pix, xstride, alpha, beta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的滤波在 <code>deblock_edge_luma_intra_c()</code> 中完成。处理完一个像素后，会继续处理与当前像素距离为 <code>ystride</code> 的像素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 水平滤波和垂直滤波通用的强滤波函数 - 处理 1 个点 - Bs 为 4</span></span><br><span class="line"><span class="comment">// 注意涉及到 8 个像素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deblock_edge_luma_intra_c</span><span class="params">(pixel *pix, <span class="keyword">intptr_t</span> xstride, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 xstride = stride，ystride = 1</span></span><br><span class="line"><span class="comment">     * 就是处理纵向的 6 个像素</span></span><br><span class="line"><span class="comment">     * 对应的是方块的横向边界的滤波。如下所示：</span></span><br><span class="line"><span class="comment">     *         p2</span></span><br><span class="line"><span class="comment">     *         p1</span></span><br><span class="line"><span class="comment">     *         p0</span></span><br><span class="line"><span class="comment">     * ===== 图像边界 =====</span></span><br><span class="line"><span class="comment">     *         q0</span></span><br><span class="line"><span class="comment">     *         q1</span></span><br><span class="line"><span class="comment">     *         q2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果 xstride = 1，ystride = stride</span></span><br><span class="line"><span class="comment">     * 就是处理纵向的 6 个像素</span></span><br><span class="line"><span class="comment">     * 对应的是方块的横向边界的滤波，即如下所示：</span></span><br><span class="line"><span class="comment">     *           ||</span></span><br><span class="line"><span class="comment">     *  p2 p1 p0 || q0 q1 q2</span></span><br><span class="line"><span class="comment">     *           ||</span></span><br><span class="line"><span class="comment">     *          边界</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 注意：这里乘的是 xstride</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> p2 = pix[<span class="number">-3</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> p1 = pix[<span class="number">-2</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> p0 = pix[<span class="number">-1</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> q0 = pix[<span class="number">0</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> q1 = pix[<span class="number">1</span>*xstride];</span><br><span class="line">    <span class="keyword">int</span> q2 = pix[<span class="number">2</span>*xstride];</span><br><span class="line">    <span class="comment">// 满足条件的时候，才滤波</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>( p0 - q0) &lt; alpha &amp;&amp; <span class="built_in">abs</span>( p1 - p0 ) &lt; beta &amp;&amp; <span class="built_in">abs</span>( q1 - q0 ) &lt; beta ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>( p0 - q0) &lt; ((alpha &gt;&gt; <span class="number">2</span>) + <span class="number">2</span>) ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>( p2 - p0) &lt; beta ) <span class="comment">/* p0&#x27;, p1&#x27;, p2&#x27; */</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> p3 = pix[<span class="number">-4</span>*xstride];</span><br><span class="line">                <span class="comment">// p0&#x27; = (p2 + 2*p1 + 2*p0 + 2*q0 + q1 + 4) &gt;&gt; 3</span></span><br><span class="line">                pix[<span class="number">-1</span>*xstride] = ( p2 + <span class="number">2</span>*p1 + <span class="number">2</span>*p0 + <span class="number">2</span>*q0 + q1 + <span class="number">4</span> ) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">                <span class="comment">// p1&#x27; = (p2 + p1 + p0 + q0 + 2) &gt;&gt; 2</span></span><br><span class="line">                pix[<span class="number">-2</span>*xstride] = ( p2 + p1 + p0 + q0 + <span class="number">2</span> ) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// p2&#x27; = (2*p3 + 3*p2 + p1 + p0 + q0 + 4) &gt;&gt; 3</span></span><br><span class="line">                pix[<span class="number">-3</span>*xstride] = ( <span class="number">2</span>*p3 + <span class="number">3</span>*p2 + p1 + p0 + q0 + <span class="number">4</span> ) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">/* p0&#x27; */</span> pix[<span class="number">-1</span>*xstride] = ( <span class="number">2</span>*p1 + p0 + q1 + <span class="number">2</span> ) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>( q2 - q0) &lt; beta ) <span class="comment">/* q0&#x27;, q1&#x27;, q2&#x27; */</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> q3 = pix[<span class="number">3</span>*xstride];</span><br><span class="line">                pix[<span class="number">0</span>*xstride] = ( p1 + <span class="number">2</span>*p0 + <span class="number">2</span>*q0 + <span class="number">2</span>*q1 + q2 + <span class="number">4</span> ) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">                pix[<span class="number">1</span>*xstride] = ( p0 + q0 + q1 + q2 + <span class="number">2</span> ) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">                pix[<span class="number">2</span>*xstride] = ( <span class="number">2</span>*q3 + <span class="number">3</span>*q2 + q1 + q0 + p0 + <span class="number">4</span> ) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">/* q0&#x27; */</span> pix[<span class="number">0</span>*xstride] = ( <span class="number">2</span>*q1 + q0 + p1 + <span class="number">2</span> ) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">/* p0&#x27;, q0&#x27; */</span> &#123;</span><br><span class="line">            pix[<span class="number">-1</span>*xstride] = ( <span class="number">2</span>*p1 + p0 + q1 + <span class="number">2</span> ) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">            pix[<span class="number">0</span>*xstride] = ( <span class="number">2</span>*q1 + q0 + p1 + <span class="number">2</span> ) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li>
<li>[2] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45870269">x264 源代码简单分析：滤波（Filter）部分 雷霄骅的专栏 - CSDN 博客</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>x264</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 x264 - 帧内预测</title>
    <url>/post/2021/b66cfff2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文分析 <code>x264</code> 库中的帧内预测的 <code>C</code> 语言函数。</p>
<a id="more"></a>
<h2 id="16x16-预测"><a href="#16x16-预测" class="headerlink" title="16x16 预测"></a>16x16 预测</h2><p><code>x264</code> 代码通过 <code>x264_predict_16x16_init()</code> 函数初始化 <code>Intra16x16</code> 帧内预测汇编函数，初始化的预测模式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>intra16x16Predmode</code></th>
<th><code>Name of Intra16x16PredMode</code></th>
<th><code>Note</code></th>
<th><code>Function</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>Intra_16x16_Vertical</code></td>
<td>由上边像素推出相应像素值</td>
<td><code>x264_predict_16x16_v_c</code></td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>Intra_16x16_Horicontal</code></td>
<td>由左边像素推出相应像素值</td>
<td><code>x264_predict_16x16_h_c</code></td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>Intra_16x16_DC</code></td>
<td>由上边和左边像素平均值推出相应像素值</td>
<td><code>x264_predict_16x16_dc_c</code></td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>Intra_16x16_Plane</code></td>
<td>利用线性 plan 函数及左、上像素推出相应像素值，适用于亮度变化平缓区域</td>
<td><code>x264_predict_16x16_p_c</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Intra-16x16-Vertical"><a href="#Intra-16x16-Vertical" class="headerlink" title="Intra_16x16_Vertical"></a>Intra_16x16_Vertical</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121220616.png" alt="Intra_16x16_Vertical"></p>
<p><code>x264</code> 中关于模式 <code>Intra_4x4_Vertical</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* common/predict.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_16x16_v_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pixel4 实际上是 uint32_t（占用 32bit），存储 4 个像素的值（每个像素占用 8bit）</span></span><br><span class="line">    pixel4 v0 = MPIXEL_X4(&amp;src[ <span class="number">0</span> - FDEC_STRIDE]);</span><br><span class="line">    pixel4 v1 = MPIXEL_X4(&amp;src[ <span class="number">4</span> - FDEC_STRIDE]);</span><br><span class="line">    pixel4 v2 = MPIXEL_X4(&amp;src[ <span class="number">8</span> - FDEC_STRIDE]);</span><br><span class="line">    pixel4 v3 = MPIXEL_X4(&amp;src[<span class="number">12</span> - FDEC_STRIDE]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Vertical 预测方式</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     * --+-----------</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     *   |X1 X2 X3 X4</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * uint32_t v0 = ((x264_union32_t*)(&amp;src[ 0-FDEC_STRIDE]))-&gt;i;</span></span><br><span class="line"><span class="comment">     * uint32_t v1 = ((x264_union32_t*)(&amp;src[ 4-FDEC_STRIDE]))-&gt;i;</span></span><br><span class="line"><span class="comment">     * uint32_t v2 = ((x264_union32_t*)(&amp;src[ 8-FDEC_STRIDE]))-&gt;i;</span></span><br><span class="line"><span class="comment">     * uint32_t v3 = ((x264_union32_t*)(&amp;src[12-FDEC_STRIDE]))-&gt;i;</span></span><br><span class="line"><span class="comment">     * x264_union32_t 的定义如下：</span></span><br><span class="line"><span class="comment">     * typedef union &#123;uint64_t i; uint32_t d[2]; uint16_t w[4]; uint8_t b[8]; &#125; MAY_ALIAS x264_union64_t;</span></span><br><span class="line"><span class="comment">     * 即将一行 16 字节数据分成 4 次，每次取出 4 个像素（一共 16 个像素），分别赋值给 v0，v1，v2，v3</span></span><br><span class="line"><span class="comment">     * 取出的值源自于 16x16 块上面的一行像素</span></span><br><span class="line"><span class="comment">     *    0|          4          8          12         16</span></span><br><span class="line"><span class="comment">     *    ||    v0    |    v1    |    v2    |    v3    |</span></span><br><span class="line"><span class="comment">     * ---++==========+==========+==========+==========+</span></span><br><span class="line"><span class="comment">     *    ||</span></span><br><span class="line"><span class="comment">     *    ||</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        MPIXEL_X4(src +  <span class="number">0</span>) = v0;</span><br><span class="line">        MPIXEL_X4(src +  <span class="number">4</span>) = v1;</span><br><span class="line">        MPIXEL_X4(src +  <span class="number">8</span>) = v2;</span><br><span class="line">        MPIXEL_X4(src + <span class="number">12</span>) = v3;</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(src +  0))-&gt;i = v0;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(src +  4))-&gt;i = v1;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(src +  8))-&gt;i = v2;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(src + 12))-&gt;i = v3;</span></span><br><span class="line"><span class="comment">     * 即分成 4 次，每次赋值 4 个像素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        src += FDEC_STRIDE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Intra-16x16-Horicontal"><a href="#Intra-16x16-Horicontal" class="headerlink" title="Intra_16x16_Horicontal"></a>Intra_16x16_Horicontal</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121220849.png" alt="Intra_16x16_Horicontal"></p>
<p><code>x264</code> 中关于模式 <code>Intra_16x16_Horicontal</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_SPLAT_X4(x) ((x)*0x01010101U)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_16x16_h_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">const</span> pixel4 v = PIXEL_SPLAT_X4( src[<span class="number">-1</span>] );</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">0</span> ) = v;</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">4</span> ) = v;</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">8</span> ) = v;</span><br><span class="line">        MPIXEL_X4( src+<span class="number">12</span> ) = v;</span><br><span class="line">        <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">         * uint32_t v = src[-1] * 0x01010101U;</span></span><br><span class="line"><span class="comment">         * ((x264_union32_t*)(src +  0))-&gt;i = v;</span></span><br><span class="line"><span class="comment">         * ((x264_union32_t*)(src +  4))-&gt;i = v;</span></span><br><span class="line"><span class="comment">         * ((x264_union32_t*)(src +  8))-&gt;i = v;</span></span><br><span class="line"><span class="comment">         * ((x264_union32_t*)(src + 12))-&gt;i = v;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        src += FDEC_STRIDE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Intra-16x16-DC"><a href="#Intra-16x16-DC" class="headerlink" title="Intra_16x16_DC"></a>Intra_16x16_DC</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121222206.jpg" alt="Intra_16x16_DC"></p>
<p><code>x264</code> 中关于模式 <code>Intra_16x16_DC</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_16x16_DC(v)\</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ )\</span><br><span class="line">    &#123;\</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">0</span> ) = v;\</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">4</span> ) = v;\</span><br><span class="line">        MPIXEL_X4( src+ <span class="number">8</span> ) = v;\</span><br><span class="line">        MPIXEL_X4( src+<span class="number">12</span> ) = v;\</span><br><span class="line">        src += FDEC_STRIDE;\</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_16x16_dc_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ ) &#123;</span><br><span class="line">        dc += src[<span class="number">-1</span> + i * FDEC_STRIDE];</span><br><span class="line">        dc += src[i - FDEC_STRIDE];</span><br><span class="line">    &#125;</span><br><span class="line">    pixel4 dcsplat = PIXEL_SPLAT_X4( ( dc + <span class="number">16</span> ) &gt;&gt; <span class="number">5</span> );</span><br><span class="line">    PREDICT_16x16_DC( dcsplat );</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * uint32_t dcsplat = ((dc + 16) &gt;&gt; 5) * 0x01010101U;</span></span><br><span class="line"><span class="comment">     * for ( int i = 0; i &lt; 16; i++ ) &#123;</span></span><br><span class="line"><span class="comment">     *     ((x264_union32_t*)(src +  0))-&gt;i = v;</span></span><br><span class="line"><span class="comment">     *     ((x264_union32_t*)(src +  4))-&gt;i = v;</span></span><br><span class="line"><span class="comment">     *     ((x264_union32_t*)(src +  8))-&gt;i = v;</span></span><br><span class="line"><span class="comment">     *     ((x264_union32_t*)(src + 12))-&gt;i = v;</span></span><br><span class="line"><span class="comment">     *     src += FDEC_STRIDE;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Intra-16x16-Plane"><a href="#Intra-16x16-Plane" class="headerlink" title="Intra_16x16_Plane"></a>Intra_16x16_Plane</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121222712.png" alt="Intra_16x16_Plane"></p>
<p><code>x264</code> 中关于模式 <code>Intra_16x16_Plane</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_MAX 255</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ALWAYS_INLINE pixel <span class="title">x264_clip_pixel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x &amp; ~PIXEL_MAX) ? (-x)&gt;&gt;<span class="number">31</span> &amp; PIXEL_MAX : x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_16x16_p_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> H = <span class="number">0</span>, V = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calculate H and V */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">        H += (i + <span class="number">1</span>) * ( src[ <span class="number">8</span> + i - FDEC_STRIDE ] - src[<span class="number">6</span> - i - FDEC_STRIDE] );</span><br><span class="line">        V += (i + <span class="number">1</span>) * ( src[<span class="number">-1</span> + (<span class="number">8</span>+i) * FDEC_STRIDE] - src[<span class="number">-1</span> + (<span class="number">6</span>-i) * FDEC_STRIDE] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">16</span> * (src[<span class="number">-1</span> + <span class="number">15</span>*FDEC_STRIDE] + src[<span class="number">15</span> - FDEC_STRIDE] );</span><br><span class="line">    <span class="keyword">int</span> b = (<span class="number">5</span> * H + <span class="number">32</span>) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> c = (<span class="number">5</span> * V + <span class="number">32</span>) &gt;&gt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i00 = a - b * <span class="number">7</span> - c * <span class="number">7</span> + <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">16</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pix = i00;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">16</span>; x++) &#123;</span><br><span class="line">            src[x] = x264_clip_pixel( pix &gt;&gt; <span class="number">5</span> );</span><br><span class="line">            pix += b;</span><br><span class="line">        &#125;</span><br><span class="line">        src += FDEC_STRIDE;</span><br><span class="line">        i00 += c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4x4-预测"><a href="#4x4-预测" class="headerlink" title="4x4 预测"></a>4x4 预测</h2><p><code>x264</code> 中对 <code>4x4</code> 的预测模式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>Intra4x4PredMode[luma4x4BlkIdx]</code></th>
<th><code>Name of Intra4x4PredMode[luma4x4BlkIdx]</code></th>
<th><code>x264 Function</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>Intra_4x4_Vertical</code></td>
<td><code>x264_predict_4x4_v_c()</code></td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>Intra_4x4_Horizontal</code></td>
<td><code>x264_predict_4x4_h_c()</code></td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>Intra_4x4_DC</code></td>
<td><code>x264_predict_4x4_dc_c()</code></td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>Intra_4x4_Diagonal_Down_Left</code></td>
<td><code>predict_4x4_ddl_c()</code></td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>Intra_4x4_Diagonal_Down_Right</code></td>
<td><code>predict_4x4_ddr_c()</code></td>
</tr>
<tr>
<td><code>5</code></td>
<td><code>Intra_4x4_Vertical_Right</code></td>
<td><code>predict_4x4_vr_c()</code></td>
</tr>
<tr>
<td><code>6</code></td>
<td><code>Intra_4x4_Horizontal_Down</code></td>
<td><code>predict_4x4_hd_c()</code></td>
</tr>
<tr>
<td><code>7</code></td>
<td><code>Intra_4x4_Vertical_Left</code></td>
<td><code>predict_4x4_vl_c()</code></td>
</tr>
<tr>
<td><code>8</code></td>
<td><code>Intra_4x4_Horizontal_Up</code></td>
<td><code>predict_4x4_hu_c()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Intra-4x4-Vertical"><a href="#Intra-4x4-Vertical" class="headerlink" title="Intra_4x4_Vertical"></a>Intra_4x4_Vertical</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210120234537.png" alt="Intra_4x4_Vertical"></p>
<p><code>x264</code> 中关于模式 <code>Intra_4x4_Vertical</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC(x,y) src[(x)+(y)*FDEC_STRIDE]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC_X4(x,y) MPIXEL_X4( &amp;SRC(x,y) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_DC(v)\</span></span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">0</span>) = SRC_X4(<span class="number">0</span>,<span class="number">1</span>) = SRC_X4(<span class="number">0</span>,<span class="number">2</span>) = SRC_X4(<span class="number">0</span>,<span class="number">3</span>) = v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_4x4_v_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    PREDICT_4x4_DC(SRC_X4(<span class="number">0</span>,<span class="number">-1</span>));</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+0*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+1*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+2*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+3*FDEC_STRIDE])-&gt;i = ((x264_union32_t*)(&amp;src[0+(-1)*FDEC_STRIDE])-&gt;i;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Intra-4x4-Horizontal"><a href="#Intra-4x4-Horizontal" class="headerlink" title="Intra_4x4_Horizontal"></a>Intra_4x4_Horizontal</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210120235209.png" alt="Intra_4x4_Horizontal"></p>
<p><code>x264</code> 中关于模式 <code>Intra_4x4_Horizontal</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M32(src) (((x264_union32_t*)(src))-&gt;i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPIXEL_X4(src) M32(src)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC(x,y) src[(x)+(y)*FDEC_STRIDE]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC_X4(x,y) MPIXEL_X4( &amp;SRC(x,y) )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIXEL_SPLAT_X4(x) ((x)*0x01010101U)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_4x4_h_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">0</span>) = PIXEL_SPLAT_X4( SRC(<span class="number">-1</span>,<span class="number">0</span>) );</span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">1</span>) = PIXEL_SPLAT_X4( SRC(<span class="number">-1</span>,<span class="number">1</span>) );</span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">2</span>) = PIXEL_SPLAT_X4( SRC(<span class="number">-1</span>,<span class="number">2</span>) );</span><br><span class="line">    SRC_X4(<span class="number">0</span>,<span class="number">3</span>) = PIXEL_SPLAT_X4( SRC(<span class="number">-1</span>,<span class="number">3</span>) );</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+0*FDEC_STRIDE])-&gt;i = src[-1+0*FDEC_STRIDE]*0x01010101U;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+1*FDEC_STRIDE])-&gt;i = src[-1+1*FDEC_STRIDE]*0x01010101U;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+2*FDEC_STRIDE])-&gt;i = src[-1+2*FDEC_STRIDE]*0x01010101U;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[0+3*FDEC_STRIDE])-&gt;i = src[-1+3*FDEC_STRIDE]*0x01010101U;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Intra-4x4-DC"><a href="#Intra-4x4-DC" class="headerlink" title="Intra_4x4_DC"></a>Intra_4x4_DC</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121000124.png" alt="Intra_4x4_DC"></p>
<p><code>x264</code> 中关于模式 <code>Intra_4x4_DC</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> pixel4;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_DC(v) SRC_X4(0,0) = SRC_X4(0,1) = SRC_X4(0,2) = SRC_X4(0,3) = v;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_predict_4x4_dc_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    pixel4 dc = PIXEL_SPLAT_X4((SRC(<span class="number">-1</span>,<span class="number">0</span>) + SRC(<span class="number">-1</span>,<span class="number">1</span>) + SRC(<span class="number">-1</span>,<span class="number">2</span>) + SRC(<span class="number">-1</span>,<span class="number">3</span>) +</span><br><span class="line">                                 SRC(<span class="number">0</span>,<span class="number">-1</span>) + SRC(<span class="number">1</span>,<span class="number">-1</span>) + SRC(<span class="number">2</span>,<span class="number">-1</span>) + SRC(<span class="number">3</span>,<span class="number">-1</span>) + <span class="number">4</span>) &gt;&gt; <span class="number">3</span> );</span><br><span class="line">    PREDICT_4x4_DC(dc);</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * uint32_t dc = (( src[-1+0*FDEC_STRIDE] + src[-1+1*FDEC_STRIDE] +</span></span><br><span class="line"><span class="comment">                        src[-1+2*FDEC_STRIDE] + src[-1+3*FDEC_STRIDE] +</span></span><br><span class="line"><span class="comment">                        src[0+(-1)*FDEC_STRIDE] + src[1+(-1)*FDEC_STRIDE] +</span></span><br><span class="line"><span class="comment">                        src[2+(-1)*FDEC_STRIDE] + src[3+(-1)*FDEC_STRIDE] ) &gt;&gt; 3 ) * 0x01010101U;</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[(0)+(0)*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[(0)+(1)*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[(0)+(2)*FDEC_STRIDE])-&gt;i = \</span></span><br><span class="line"><span class="comment">     * ((x264_union32_t*)(&amp;src[(0)+(3)*FDEC_STRIDE])-&gt;i = dc;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Intra-4x4-Diagonal-Down-Left"><a href="#Intra-4x4-Diagonal-Down-Left" class="headerlink" title="Intra_4x4_Diagonal_Down_Left"></a>Intra_4x4_Diagonal_Down_Left</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121001324.png" alt="Intra_4x4_Diagonal_Down_Left"></p>
<p><code>x264</code> 中关于模式 <code>Intra_4x4_Diagonal_Down_Left</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_LOAD_TOP\</span></span><br><span class="line">    <span class="keyword">int</span> t0 = SRC(<span class="number">0</span>,<span class="number">-1</span>);\</span><br><span class="line">    <span class="keyword">int</span> t1 = SRC(<span class="number">1</span>,<span class="number">-1</span>);\</span><br><span class="line">    <span class="keyword">int</span> t2 = SRC(<span class="number">2</span>,<span class="number">-1</span>);\</span><br><span class="line">    UNUSED <span class="keyword">int</span> t3 = SRC(<span class="number">3</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_LOAD_TOP_RIGHT\</span></span><br><span class="line">    <span class="keyword">int</span> t4 = SRC(<span class="number">4</span>,<span class="number">-1</span>);\</span><br><span class="line">    <span class="keyword">int</span> t5 = SRC(<span class="number">5</span>,<span class="number">-1</span>);\</span><br><span class="line">    <span class="keyword">int</span> t6 = SRC(<span class="number">6</span>,<span class="number">-1</span>);\</span><br><span class="line">    UNUSED <span class="keyword">int</span> t7 = SRC(<span class="number">7</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F2(a,b,c) (((a)+2*(b)+(c)+2)&gt;&gt;2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_ddl_c</span><span class="params">(pixel *src)</span> </span>&#123;</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    PREDICT_4x4_LOAD_TOP_RIGHT</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)= F2(t0,t1,t2);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">0</span>,<span class="number">1</span>)= F2(t1,t2,t3);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">0</span>,<span class="number">2</span>)= F2(t2,t3,t4);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)=SRC(<span class="number">0</span>,<span class="number">3</span>)= F2(t3,t4,t5);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(t4,t5,t6);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">2</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F2(t5,t6,t7);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(t6,t7,t7);</span><br><span class="line">    <span class="comment">/* 展开宏定义如下：</span></span><br><span class="line"><span class="comment">     * int t0 = src[0+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t1 = src[1+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t2 = src[2+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t3 = src[3+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t4 = src[4+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t5 = src[5+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t6 = src[6+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t7 = src[7+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * src[0+0*FDEC_STRIDE] = (t0+2*t1+t2+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[1+0*FDEC_STRIDE] = src[0+1*FDEC_STRIDE] = (t1+2*t2+t3+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[2+0*FDEC_STRIDE] = src[1+1*FDEC_STRIDE] = src[0+2*FDEC_STRIDE] = (t2+2*t3+t4+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[3+0*FDEC_STRIDE] = src[2+1*FDEC_STRIDE] = src[1+2*FDEC_STRIDE] = src[0+3*FDEC_STRIDE] = (t3+2*t4+t5+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[3+1*FDEC_STRIDE] = src[2+2*FDEC_STRIDE] = src[1+3*FDEC_STRIDE] = (t4+2*t5+t6+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[3+2*FDEC_STRIDE] = src[2+3*FDEC_STRIDE] = (t5+2*t6+t7+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[3+3*FDEC_STRIDE] = (t6+2*t7+t7+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Intra-4x4-Diagonal-Down-Right"><a href="#Intra-4x4-Diagonal-Down-Right" class="headerlink" title="Intra_4x4_Diagonal_Down_Right"></a>Intra_4x4_Diagonal_Down_Right</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121003328.png" alt="Intra_4x4_Diagonal_Down_Right"></p>
<p><code>x264</code> 中关于模式 <code>Intra_4x4_Diagonal_Down_Right</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREDICT_4x4_LOAD_LEFT\</span></span><br><span class="line">    <span class="keyword">int</span> l0 = SRC(<span class="number">-1</span>,<span class="number">0</span>);\</span><br><span class="line">    <span class="keyword">int</span> l1 = SRC(<span class="number">-1</span>,<span class="number">1</span>);\</span><br><span class="line">    <span class="keyword">int</span> l2 = SRC(<span class="number">-1</span>,<span class="number">2</span>);\</span><br><span class="line">    UNUSED <span class="keyword">int</span> l3 = SRC(<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_ddr_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lt = SRC(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    PREDICT_4x4_LOAD_LEFT</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)= F2(t3,t2,t1);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">3</span>,<span class="number">1</span>)= F2(t2,t1,t0);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">3</span>,<span class="number">2</span>)= F2(t1,t0,lt);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)=SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(t0,lt,l0);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F2(lt,l0,l1);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">2</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(l0,l1,l2);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">3</span>)= F2(l1,l2,l3);</span><br><span class="line">    <span class="comment">/* 展开宏定义如下，后续类似代码不再进行宏定义展开：</span></span><br><span class="line"><span class="comment">     * int lt = src[-1+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int l0 = src[-1+0*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int l1 = src[-1+1*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int l2 = src[-1+2*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t0 = src[0+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t1 = src[1+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t2 = src[2+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * int t3 = src[3+(-1)*FDEC_STRIDE];</span></span><br><span class="line"><span class="comment">     * src[3+0*FDEC_STRIDE] = (t3+2*t2+t1+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[2+0*FDEC_STRIDE] = src[3+1*FDEC_STRIDE] = (t2+2*t1+t0+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[1+0*FDEC_STRIDE] = src[2+1*FDEC_STRIDE] = src[3+2*FDEC_STRIDE] = (t1+2*t0+lt+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[0+0*FDEC_STRIDE] = src[1+1*FDEC_STRIDE] = src[2+2*FDEC_STRIDE] = src[3+3*FDEC_STRIDE] = (t0+2*lt+l0+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[0+1*FDEC_STRIDE] = src[1+2*FDEC_STRIDE] = src[2+3*FDEC_STRIDE] = (lt+2*l0+l1+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[0+2*FDEC_STRIDE] = src[1+3*FDEC_STRIDE] = (l0+2*l1+l2+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     * src[0+3*FDEC_STRIDE] = (l1+2*l2+l3+2) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Intra-4x4-Vertical-Right"><a href="#Intra-4x4-Vertical-Right" class="headerlink" title="Intra_4x4_Vertical_Right"></a>Intra_4x4_Vertical_Right</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121004449.png" alt="Intra_4x4_Vertical_Right"></p>
<p><code>x264</code> 中关于模式 <code>Intra_4x4_Vertical_Right</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_vr_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lt = SRC(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    PREDICT_4x4_LOAD_LEFT</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">3</span>)= F2(l2,l1,l0);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">2</span>)= F2(l1,l0,lt);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(l0,lt,t0);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)= F1(lt,t0);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F2(lt,t0,t1);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)= F1(t0,t1);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(t0,t1,t2);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">3</span>,<span class="number">2</span>)= F1(t1,t2);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">1</span>)= F2(t1,t2,t3);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)= F1(t2,t3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Intra-4x4-Horizontal-Down"><a href="#Intra-4x4-Horizontal-Down" class="headerlink" title="Intra_4x4_Horizontal_Down"></a>Intra_4x4_Horizontal_Down</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121004515.png" alt="Intra_4x4_Horizontal_Down"></p>
<p><code>x264</code> 中关于模式 <code>Intra_4x4_Horizontal_Down</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_hd_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lt= SRC(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    PREDICT_4x4_LOAD_LEFT</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">3</span>)= F1(l2,l3);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(l1,l2,l3);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">2</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F1(l1,l2);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">2</span>)=SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(l0,l1,l2);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)= F1(l0,l1);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">3</span>,<span class="number">2</span>)= F2(lt,l0,l1);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">1</span>)= F1(lt,l0);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">3</span>,<span class="number">1</span>)= F2(t0,lt,l0);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)= F2(t1,t0,lt);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)= F2(t2,t1,t0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Intra-4x4-Vertical-Left"><a href="#Intra-4x4-Vertical-Left" class="headerlink" title="Intra_4x4_Vertical_Left"></a>Intra_4x4_Vertical_Left</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121004528.png" alt="Intra_4x4_Vertical_Left"></p>
<p><code>x264</code> 中关于模式 <code>Intra_4x4_Vertical_Left</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_vl_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    PREDICT_4x4_LOAD_TOP</span><br><span class="line">    PREDICT_4x4_LOAD_TOP_RIGHT</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)= F1(t0,t1);</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">1</span>)= F2(t0,t1,t2);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)=SRC(<span class="number">0</span>,<span class="number">2</span>)= F1(t1,t2);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">1</span>)=SRC(<span class="number">0</span>,<span class="number">3</span>)= F2(t1,t2,t3);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)= F1(t2,t3);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)= F2(t2,t3,t4);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)=SRC(<span class="number">2</span>,<span class="number">2</span>)= F1(t3,t4);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">1</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)= F2(t3,t4,t5);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">2</span>)= F1(t4,t5);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">3</span>)= F2(t4,t5,t6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Intra-4x4-Horizontal-Up"><a href="#Intra-4x4-Horizontal-Up" class="headerlink" title="Intra_4x4_Horizontal_Up"></a>Intra_4x4_Horizontal_Up</h3><p>在 SPEC 中，关于该预测模式的定义如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121004541.png" alt="Intra_4x4_Horizontal_Up"></p>
<p><code>x264</code> 中关于模式 <code>Intra_4x4_Horizontal_Up</code> 的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">predict_4x4_hu_c</span><span class="params">( pixel *src )</span> </span>&#123;</span><br><span class="line">    PREDICT_4x4_LOAD_LEFT</span><br><span class="line">    SRC(<span class="number">0</span>,<span class="number">0</span>)= F1(l0,l1);</span><br><span class="line">    SRC(<span class="number">1</span>,<span class="number">0</span>)= F2(l0,l1,l2);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">0</span>)=SRC(<span class="number">0</span>,<span class="number">1</span>)= F1(l1,l2);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">0</span>)=SRC(<span class="number">1</span>,<span class="number">1</span>)= F2(l1,l2,l3);</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">1</span>)=SRC(<span class="number">0</span>,<span class="number">2</span>)= F1(l2,l3);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">1</span>)=SRC(<span class="number">1</span>,<span class="number">2</span>)= F2(l2,l3,l3);</span><br><span class="line">    SRC(<span class="number">3</span>,<span class="number">2</span>)=SRC(<span class="number">1</span>,<span class="number">3</span>)=SRC(<span class="number">0</span>,<span class="number">3</span>)=</span><br><span class="line">    SRC(<span class="number">2</span>,<span class="number">2</span>)=SRC(<span class="number">2</span>,<span class="number">3</span>)=SRC(<span class="number">3</span>,<span class="number">3</span>)= l3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8x8-预测"><a href="#8x8-预测" class="headerlink" title="8x8 预测"></a>8x8 预测</h2><p>x264 中对 8x8 的预测模式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>intra8x8Predmodei[luma8x8BlkIdx]</code></th>
<th><code>Name of Intra8x8PredMode[luma8x8BlkIdx]</code></th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>Intra_8x8_Vertical</code></td>
</tr>
<tr>
<td>1</td>
<td><code>Intra_8x8_Horizontal</code></td>
</tr>
<tr>
<td>2</td>
<td><code>Intra_8x8_DC</code></td>
</tr>
<tr>
<td>3</td>
<td><code>Intra_8x8_Diagonal_Down_Left</code></td>
</tr>
<tr>
<td>4</td>
<td><code>Intra_8x8_Diagonal_Down_Right</code></td>
</tr>
<tr>
<td>5</td>
<td><code>Intra_8x8_Vertical_Right</code></td>
</tr>
<tr>
<td>6</td>
<td><code>Intra_8x8_Horizontal_Down</code></td>
</tr>
<tr>
<td>7</td>
<td><code>Intra_8x8_Vertical_Left</code></td>
</tr>
<tr>
<td>8</td>
<td><code>Intra_8x8_Horizontal_Up</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li>
<li>[2] <a href="http://lazybing.github.io/blog/2017/06/30/x264-intra-prediction/#intra4x4vertical-">X264 源码解析之帧内预测 - 懒人李冰</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>x264</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 x264 - 离散余弦变换</title>
    <url>/post/2021/f0753f9a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>x264</code> 中 <code>x264_dct_init</code> 函数中初始化了与离散余弦变换有关的函数，本文分析部分离散余弦变换函数的实现</p>
<a id="more"></a>
<p>DCT 变换的核心理念就是把图像的低频信息（对应大面积平坦区域）变换到系数矩阵的左上角，而把高频信息变换到系数矩阵的右下角，之后在压缩时就可以去除掉人眼不敏感的高频信息（位于矩阵右下角的系数），从而达到压缩数据的目的。</p>
<p>关于 DCT 的计算，都是通过 <code>x264_dct_init</code> 函数内定义的 <code>DCT</code> 和 <code>IDCT</code> 函数完成的，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_dct_init</span><span class="params">(<span class="keyword">uint32_t</span> cpu, <span class="keyword">x264_dct_function_t</span> *dctf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dctf-&gt;sub4x4_dct    = sub4x4_dct;</span><br><span class="line">    dctf-&gt;add4x4_idct   = add4x4_idct;</span><br><span class="line"></span><br><span class="line">    dctf-&gt;sub8x8_dct    = sub8x8_dct;</span><br><span class="line">    dctf-&gt;sub8x8_dct_dc = sub8x8_dct_dc;</span><br><span class="line">    dctf-&gt;add8x8_idct   = add8x8_idct;</span><br><span class="line">    dctf-&gt;add8x8_idct_dc = add8x8_idct_dc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处省略大量平台的汇编函数初始化代码 */</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<h2 id="dct-函数命名规律"><a href="#dct-函数命名规律" class="headerlink" title="dct 函数命名规律"></a>dct 函数命名规律</h2><p>从源代码可以看出，<code>x264_dct_init()</code> 初始化了一系列的 <code>DCT</code> 变换的函数，这些 <code>DCT</code> 函数名称有如下规律：</p>
<ol>
<li><code>DCT</code> 函数名称前面有 <code>sub</code>，代表对两块像素相减得到残差之后，再进行 <code>DCT</code> 变换。</li>
<li><code>DCT</code> 反变换函数名称前面有 <code>add</code>，代表将 <code>DCT</code> 反变换之后的残差数据叠加到预测数据上。</li>
<li>以 <code>dct8</code> 为结尾的函数使用了 <code>8x8DCT</code>，其余函数是用的都是 <code>4x4DCT</code>。</li>
</ol>
<h2 id="sub4x4-dct"><a href="#sub4x4-dct" class="headerlink" title="sub4x4_dct"></a>sub4x4_dct</h2><p><code>sub4x4_dct()</code> 可以将两块 <code>4x4</code> 的图像相减求残差后，进行 <code>DCT</code> 变换，源代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 4x4 DCT 变换</span></span><br><span class="line"><span class="comment"> * 注意首先获取 pix1 和 pix2 两块数据的残差，然后再进行变换</span></span><br><span class="line"><span class="comment"> * 返回 dct[16]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sub4x4_dct</span><span class="params">(dctcoef dct[<span class="number">16</span>], pixel *pix1, pixel *pix2 )</span> </span>&#123;</span><br><span class="line">    dctcoef d[<span class="number">16</span>];</span><br><span class="line">    dctcoef tmp[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    pixel_sub_wxh(d, <span class="number">4</span>, pix1, FENC_STRIDE, pix2, FDEC_STRIDE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s03 = d[i*<span class="number">4</span>+<span class="number">0</span>] + d[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> s12 = d[i*<span class="number">4</span>+<span class="number">1</span>] + d[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> d03 = d[i*<span class="number">4</span>+<span class="number">0</span>] - d[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> d12 = d[i*<span class="number">4</span>+<span class="number">1</span>] - d[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        tmp[<span class="number">0</span>*<span class="number">4</span>+i] =   s03 +   s12;</span><br><span class="line">        tmp[<span class="number">1</span>*<span class="number">4</span>+i] = <span class="number">2</span>*d03 +   d12;</span><br><span class="line">        tmp[<span class="number">2</span>*<span class="number">4</span>+i] =   s03 -   s12;</span><br><span class="line">        tmp[<span class="number">3</span>*<span class="number">4</span>+i] =   d03 - <span class="number">2</span>*d12;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s03 = tmp[i*<span class="number">4</span>+<span class="number">0</span>] + tmp[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> s12 = tmp[i*<span class="number">4</span>+<span class="number">1</span>] + tmp[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> d03 = tmp[i*<span class="number">4</span>+<span class="number">0</span>] - tmp[i*<span class="number">4</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> d12 = tmp[i*<span class="number">4</span>+<span class="number">1</span>] - tmp[i*<span class="number">4</span>+<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        dct[i*<span class="number">4</span>+<span class="number">0</span>] =   s03 +   s12;</span><br><span class="line">        dct[i*<span class="number">4</span>+<span class="number">1</span>] = <span class="number">2</span>*d03 +   d12;</span><br><span class="line">        dct[i*<span class="number">4</span>+<span class="number">2</span>] =   s03 -   s12;</span><br><span class="line">        dct[i*<span class="number">4</span>+<span class="number">3</span>] =   d03 - <span class="number">2</span>*d12;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源代码中涉及函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 求残差用 注意求的是一个方块形像素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数的含义如下：</span></span><br><span class="line"><span class="comment"> * diff：输出的残差数据</span></span><br><span class="line"><span class="comment"> * i_size：方块的大小</span></span><br><span class="line"><span class="comment"> * pix1：输入数据 1</span></span><br><span class="line"><span class="comment"> * i_pix1：输入数据 1 一行像素大小（stride）</span></span><br><span class="line"><span class="comment"> * pix2：输入数据 2</span></span><br><span class="line"><span class="comment"> * i_pix2：输入数据 2 一行像素大小（stride）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pixel_sub_wxh</span><span class="params">( dctcoef *diff, <span class="keyword">int</span> i_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  pixel *pix1, <span class="keyword">int</span> i_pix1, pixel *pix2, <span class="keyword">int</span> i_pix2 )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; i_size; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; i_size; x++)</span><br><span class="line">            diff[x + y * i_size] = pix1[x] - pix2[x];</span><br><span class="line">        pix1 += i_pix1;</span><br><span class="line">        pix2 += i_pix2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="add4x4-idct"><a href="#add4x4-idct" class="headerlink" title="add4x4_idct"></a>add4x4_idct</h2><p><code>add4x4_idct()</code> 可以将残差数据进行 <code>DCT</code> 反变换，并将变换后得到的残差像素数据叠加到预测数据上，源代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ALWAYS_INLINE pixel <span class="title">x264_clip_pixel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x &amp; ~PIXEL_MAX) ? (-x)&gt;&gt;<span class="number">31</span> &amp; PIXEL_MAX : x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add4x4_idct</span><span class="params">(pixel *p_dst, dctcoef dct[<span class="number">16</span>] )</span> </span>&#123;</span><br><span class="line">    dctcoef d[<span class="number">16</span>];</span><br><span class="line">    dctcoef tmp[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s02 =  dct[<span class="number">0</span>*<span class="number">4</span>+i]     +  dct[<span class="number">2</span>*<span class="number">4</span>+i];</span><br><span class="line">        <span class="keyword">int</span> d02 =  dct[<span class="number">0</span>*<span class="number">4</span>+i]     -  dct[<span class="number">2</span>*<span class="number">4</span>+i];</span><br><span class="line">        <span class="keyword">int</span> s13 =  dct[<span class="number">1</span>*<span class="number">4</span>+i]     + (dct[<span class="number">3</span>*<span class="number">4</span>+i]&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> d13 = (dct[<span class="number">1</span>*<span class="number">4</span>+i]&gt;&gt;<span class="number">1</span>) -  dct[<span class="number">3</span>*<span class="number">4</span>+i];</span><br><span class="line"></span><br><span class="line">        tmp[i*<span class="number">4</span>+<span class="number">0</span>] = s02 + s13;</span><br><span class="line">        tmp[i*<span class="number">4</span>+<span class="number">1</span>] = d02 + d13;</span><br><span class="line">        tmp[i*<span class="number">4</span>+<span class="number">2</span>] = d02 - d13;</span><br><span class="line">        tmp[i*<span class="number">4</span>+<span class="number">3</span>] = s02 - s13;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s02 =  tmp[<span class="number">0</span>*<span class="number">4</span>+i]     +  tmp[<span class="number">2</span>*<span class="number">4</span>+i];</span><br><span class="line">        <span class="keyword">int</span> d02 =  tmp[<span class="number">0</span>*<span class="number">4</span>+i]     -  tmp[<span class="number">2</span>*<span class="number">4</span>+i];</span><br><span class="line">        <span class="keyword">int</span> s13 =  tmp[<span class="number">1</span>*<span class="number">4</span>+i]     + (tmp[<span class="number">3</span>*<span class="number">4</span>+i]&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> d13 = (tmp[<span class="number">1</span>*<span class="number">4</span>+i]&gt;&gt;<span class="number">1</span>) -  tmp[<span class="number">3</span>*<span class="number">4</span>+i];</span><br><span class="line"></span><br><span class="line">        d[<span class="number">0</span>*<span class="number">4</span>+i] = ( s02 + s13 + <span class="number">32</span> ) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">        d[<span class="number">1</span>*<span class="number">4</span>+i] = ( d02 + d13 + <span class="number">32</span> ) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">        d[<span class="number">2</span>*<span class="number">4</span>+i] = ( d02 - d13 + <span class="number">32</span> ) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">        d[<span class="number">3</span>*<span class="number">4</span>+i] = ( s02 - s13 + <span class="number">32</span> ) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++)</span><br><span class="line">            p_dst[x] = x264_clip_pixel( p_dst[x] + d[y*<span class="number">4</span>+x] );</span><br><span class="line">        p_dst += FDEC_STRIDE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li>
<li>[2] <a href="http://lazybing.github.io/blog/2017/07/10/x264-dct-init/">X264 源码解析之 x264_dct_init 函数 - 懒人李冰</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>x264</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 x264 - 常用结构体</title>
    <url>/post/2020/e6d88726/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要对 x264 中的重要结构体进行介绍，包括的结构体有：</p>
<ul>
<li>struct x264_param_t</li>
<li>struct cli_opt_t</li>
<li>更多结构体更新中</li>
</ul>
<a id="more"></a>
<hr>
<h2 id="x264-param-t"><a href="#x264-param-t" class="headerlink" title="x264_param_t"></a>x264_param_t</h2><p>结构体 x264_param_t 定义在 x264.h 中，是 x264 中最重要的结构体之一，主要用于初始化编码器。</p>
<!-- more -->
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">x264_param_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* CPU flags */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cpu;</span><br><span class="line">    <span class="keyword">int</span>         i_threads;           <span class="comment">/* encode multiple frames in parallel */</span></span><br><span class="line">    <span class="keyword">int</span>         i_lookahead_threads; <span class="comment">/* multiple threads for lookahead analysis */</span></span><br><span class="line">    <span class="keyword">int</span>         b_sliced_threads;  <span class="comment">/* Whether to use slice-based threading. */</span></span><br><span class="line">    <span class="keyword">int</span>         b_deterministic; <span class="comment">/* whether to allow non-deterministic optimizations when threaded */</span></span><br><span class="line">    <span class="keyword">int</span>         b_cpu_independent; <span class="comment">/* force canonical behavior rather than cpu-dependent optimal algorithms */</span></span><br><span class="line">    <span class="keyword">int</span>         i_sync_lookahead; <span class="comment">/* threaded lookahead buffer */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video Properties */</span></span><br><span class="line">    <span class="keyword">int</span>         i_width;</span><br><span class="line">    <span class="keyword">int</span>         i_height;</span><br><span class="line">    <span class="keyword">int</span>         i_csp;         <span class="comment">/* CSP of encoded bitstream */</span></span><br><span class="line">    <span class="keyword">int</span>         i_bitdepth;</span><br><span class="line">    <span class="keyword">int</span>         i_level_idc;</span><br><span class="line">    <span class="keyword">int</span>         i_frame_total; <span class="comment">/* number of frames to encode if known, else 0 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NAL HRD</span></span><br><span class="line"><span class="comment">     * Uses Buffering and Picture Timing SEIs to signal HRD</span></span><br><span class="line"><span class="comment">     * The HRD in H.264 was not designed with VFR in mind.</span></span><br><span class="line"><span class="comment">     * It is therefore not recommendeded to use NAL HRD with VFR.</span></span><br><span class="line"><span class="comment">     * Furthermore, reconfiguring the VBV (via x264_encoder_reconfig)</span></span><br><span class="line"><span class="comment">     * will currently generate invalid HRD. */</span></span><br><span class="line">    <span class="keyword">int</span>         i_nal_hrd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">/* they will be reduced to be 0 &lt; x &lt;= 65535 and prime */</span></span><br><span class="line">        <span class="keyword">int</span>         i_sar_height;</span><br><span class="line">        <span class="keyword">int</span>         i_sar_width;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>         i_overscan;    <span class="comment">/* 0=undef, 1=no overscan, 2=overscan */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* see h264 annex E for the values of the following */</span></span><br><span class="line">        <span class="keyword">int</span>         i_vidformat;</span><br><span class="line">        <span class="keyword">int</span>         b_fullrange;</span><br><span class="line">        <span class="keyword">int</span>         i_colorprim;</span><br><span class="line">        <span class="keyword">int</span>         i_transfer;</span><br><span class="line">        <span class="keyword">int</span>         i_colmatrix;</span><br><span class="line">        <span class="keyword">int</span>         i_chroma_loc;    <span class="comment">/* both top &amp; bottom */</span></span><br><span class="line">    &#125; vui;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bitstream parameters */</span></span><br><span class="line">    <span class="keyword">int</span>         i_frame_reference;  <span class="comment">/* Maximum number of reference frames */</span></span><br><span class="line">    <span class="keyword">int</span>         i_dpb_size;         <span class="comment">/* Force a DPB size larger than that implied by B-frames and reference frames.</span></span><br><span class="line"><span class="comment">                                     * Useful in combination with interactive error resilience. */</span></span><br><span class="line">    <span class="keyword">int</span>         i_keyint_max;       <span class="comment">/* Force an IDR keyframe at this interval */</span></span><br><span class="line">    <span class="keyword">int</span>         i_keyint_min;       <span class="comment">/* Scenecuts closer together than this are coded as I, not IDR. */</span></span><br><span class="line">    <span class="keyword">int</span>         i_scenecut_threshold; <span class="comment">/* how aggressively to insert extra I frames */</span></span><br><span class="line">    <span class="keyword">int</span>         b_intra_refresh;    <span class="comment">/* Whether or not to use periodic intra refresh instead of IDR frames. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>         i_bframe;   <span class="comment">/* how many b-frame between 2 references pictures */</span></span><br><span class="line">    <span class="keyword">int</span>         i_bframe_adaptive;</span><br><span class="line">    <span class="keyword">int</span>         i_bframe_bias;</span><br><span class="line">    <span class="keyword">int</span>         i_bframe_pyramid;   <span class="comment">/* Keep some B-frames as references: 0=off, 1=strict hierarchical, 2=normal */</span></span><br><span class="line">    <span class="keyword">int</span>         b_open_gop;</span><br><span class="line">    <span class="keyword">int</span>         b_bluray_compat;</span><br><span class="line">    <span class="keyword">int</span>         i_avcintra_class;</span><br><span class="line">    <span class="keyword">int</span>         i_avcintra_flavor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>         b_deblocking_filter;</span><br><span class="line">    <span class="keyword">int</span>         i_deblocking_filter_alphac0;    <span class="comment">/* [-6, 6] -6 light filter, 6 strong */</span></span><br><span class="line">    <span class="keyword">int</span>         i_deblocking_filter_beta;       <span class="comment">/* [-6, 6]  idem */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>         b_cabac;</span><br><span class="line">    <span class="keyword">int</span>         i_cabac_init_idc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>         b_interlaced;</span><br><span class="line">    <span class="keyword">int</span>         b_constrained_intra;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>         i_cqm_preset;</span><br><span class="line">    <span class="keyword">char</span>        *psz_cqm_file;      <span class="comment">/* filename (in UTF-8) of CQM file, JM format */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>     cqm_4iy[<span class="number">16</span>];        <span class="comment">/* used only if i_cqm_preset == X264_CQM_CUSTOM */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>     cqm_4py[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span>     cqm_4ic[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span>     cqm_4pc[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span>     cqm_8iy[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span>     cqm_8py[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span>     cqm_8ic[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span>     cqm_8pc[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Log */</span></span><br><span class="line">    <span class="keyword">void</span>        (*pf_log)( <span class="keyword">void</span> *, <span class="keyword">int</span> i_level, <span class="keyword">const</span> <span class="keyword">char</span> *psz, va_list );</span><br><span class="line">    <span class="keyword">void</span>        *p_log_private;</span><br><span class="line">    <span class="keyword">int</span>         i_log_level;</span><br><span class="line">    <span class="keyword">int</span>         b_full_recon;   <span class="comment">/* fully reconstruct frames, even when not necessary for encoding.  Implied by psz_dump_yuv */</span></span><br><span class="line">    <span class="keyword">char</span>        *psz_dump_yuv;  <span class="comment">/* filename (in UTF-8) for reconstructed frames */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Encoder analyser parameters */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> intra;     <span class="comment">/* intra partitions */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> inter;     <span class="comment">/* inter partitions */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>          b_transform_8x8;</span><br><span class="line">        <span class="keyword">int</span>          i_weighted_pred; <span class="comment">/* weighting for P-frames */</span></span><br><span class="line">        <span class="keyword">int</span>          b_weighted_bipred; <span class="comment">/* implicit weighting for B-frames */</span></span><br><span class="line">        <span class="keyword">int</span>          i_direct_mv_pred; <span class="comment">/* spatial vs temporal mv prediction */</span></span><br><span class="line">        <span class="keyword">int</span>          i_chroma_qp_offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>          i_me_method; <span class="comment">/* motion estimation algorithm to use (X264_ME_*) */</span></span><br><span class="line">        <span class="keyword">int</span>          i_me_range; <span class="comment">/* integer pixel motion estimation search range (from predicted mv) */</span></span><br><span class="line">        <span class="keyword">int</span>          i_mv_range; <span class="comment">/* maximum length of a mv (in pixels). -1 = auto, based on level */</span></span><br><span class="line">        <span class="keyword">int</span>          i_mv_range_thread; <span class="comment">/* minimum space between threads. -1 = auto, based on number of threads. */</span></span><br><span class="line">        <span class="keyword">int</span>          i_subpel_refine; <span class="comment">/* subpixel motion estimation quality */</span></span><br><span class="line">        <span class="keyword">int</span>          b_chroma_me; <span class="comment">/* chroma ME for subpel and mode decision in P-frames */</span></span><br><span class="line">        <span class="keyword">int</span>          b_mixed_references; <span class="comment">/* allow each mb partition to have its own reference number */</span></span><br><span class="line">        <span class="keyword">int</span>          i_trellis;  <span class="comment">/* trellis RD quantization */</span></span><br><span class="line">        <span class="keyword">int</span>          b_fast_pskip; <span class="comment">/* early SKIP detection on P-frames */</span></span><br><span class="line">        <span class="keyword">int</span>          b_dct_decimate; <span class="comment">/* transform coefficient thresholding on P-frames */</span></span><br><span class="line">        <span class="keyword">int</span>          i_noise_reduction; <span class="comment">/* adaptive pseudo-deadzone */</span></span><br><span class="line">        <span class="keyword">float</span>        f_psy_rd; <span class="comment">/* Psy RD strength */</span></span><br><span class="line">        <span class="keyword">float</span>        f_psy_trellis; <span class="comment">/* Psy trellis strength */</span></span><br><span class="line">        <span class="keyword">int</span>          b_psy; <span class="comment">/* Toggle all psy optimizations */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>          b_mb_info;            <span class="comment">/* Use input mb_info data in x264_picture_t */</span></span><br><span class="line">        <span class="keyword">int</span>          b_mb_info_update; <span class="comment">/* Update the values in mb_info according to the results of encoding. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* the deadzone size that will be used in luma quantization */</span></span><br><span class="line">        <span class="keyword">int</span>          i_luma_deadzone[<span class="number">2</span>]; <span class="comment">/* &#123;inter, intra&#125; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>          b_psnr;    <span class="comment">/* compute and print PSNR stats */</span></span><br><span class="line">        <span class="keyword">int</span>          b_ssim;    <span class="comment">/* compute and print SSIM stats */</span></span><br><span class="line">    &#125; analyse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rate control parameters */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span>         i_rc_method;    <span class="comment">/* X264_RC_* */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>         i_qp_constant;  <span class="comment">/* 0=lossless */</span></span><br><span class="line">        <span class="keyword">int</span>         i_qp_min;       <span class="comment">/* min allowed QP value */</span></span><br><span class="line">        <span class="keyword">int</span>         i_qp_max;       <span class="comment">/* max allowed QP value */</span></span><br><span class="line">        <span class="keyword">int</span>         i_qp_step;      <span class="comment">/* max QP step between frames */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>         i_bitrate;</span><br><span class="line">        <span class="keyword">float</span>       f_rf_constant;  <span class="comment">/* 1pass VBR, nominal QP */</span></span><br><span class="line">        <span class="keyword">float</span>       f_rf_constant_max;  <span class="comment">/* In CRF mode, maximum CRF as caused by VBV */</span></span><br><span class="line">        <span class="keyword">float</span>       f_rate_tolerance;</span><br><span class="line">        <span class="keyword">int</span>         i_vbv_max_bitrate;</span><br><span class="line">        <span class="keyword">int</span>         i_vbv_buffer_size;</span><br><span class="line">        <span class="keyword">float</span>       f_vbv_buffer_init; <span class="comment">/* &lt;=1: fraction of buffer_size.&gt;1: kbit */</span></span><br><span class="line">        <span class="keyword">float</span>       f_ip_factor;</span><br><span class="line">        <span class="keyword">float</span>       f_pb_factor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* VBV filler: force CBR VBV and use filler bytes to ensure hard-CBR.</span></span><br><span class="line"><span class="comment">         * Implied by NAL-HRD CBR. */</span></span><br><span class="line">        <span class="keyword">int</span>         b_filler;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>         i_aq_mode;      <span class="comment">/* psy adaptive QP. (X264_AQ_*) */</span></span><br><span class="line">        <span class="keyword">float</span>       f_aq_strength;</span><br><span class="line">        <span class="keyword">int</span>         b_mb_tree;      <span class="comment">/* Macroblock-tree ratecontrol. */</span></span><br><span class="line">        <span class="keyword">int</span>         i_lookahead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2pass */</span></span><br><span class="line">        <span class="keyword">int</span>         b_stat_write;   <span class="comment">/* Enable stat writing in psz_stat_out */</span></span><br><span class="line">        <span class="keyword">char</span>        *psz_stat_out;  <span class="comment">/* output filename (in UTF-8) of the 2pass stats file */</span></span><br><span class="line">        <span class="keyword">int</span>         b_stat_read;    <span class="comment">/* Read stat from psz_stat_in and use it */</span></span><br><span class="line">        <span class="keyword">char</span>        *psz_stat_in;   <span class="comment">/* input filename (in UTF-8) of the 2pass stats file */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2pass params (same as ffmpeg ones) */</span></span><br><span class="line">        <span class="keyword">float</span>       f_qcompress;    <span class="comment">/* 0.0 =&gt; cbr, 1.0 =&gt; constant qp */</span></span><br><span class="line">        <span class="keyword">float</span>       f_qblur;        <span class="comment">/* temporally blur quants */</span></span><br><span class="line">        <span class="keyword">float</span>       f_complexity_blur; <span class="comment">/* temporally blur complexity */</span></span><br><span class="line">        <span class="keyword">x264_zone_t</span> *zones;         <span class="comment">/* ratecontrol overrides */</span></span><br><span class="line">        <span class="keyword">int</span>         i_zones;        <span class="comment">/* number of zone_t&#x27;s */</span></span><br><span class="line">        <span class="keyword">char</span>        *psz_zones;     <span class="comment">/* alternate method of specifying zones */</span></span><br><span class="line">    &#125; rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cropping Rectangle parameters: added to those implicitly defined by</span></span><br><span class="line"><span class="comment">       non-mod16 video resolutions. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i_left;</span><br><span class="line">        <span class="keyword">int</span> i_top;</span><br><span class="line">        <span class="keyword">int</span> i_right;</span><br><span class="line">        <span class="keyword">int</span> i_bottom;</span><br><span class="line">    &#125; crop_rect;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* frame packing arrangement flag */</span></span><br><span class="line">    <span class="keyword">int</span> i_frame_packing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* alternative transfer SEI */</span></span><br><span class="line">    <span class="keyword">int</span> i_alternative_transfer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Muxing parameters */</span></span><br><span class="line">    <span class="keyword">int</span> b_aud;                  <span class="comment">/* generate access unit delimiters */</span></span><br><span class="line">    <span class="keyword">int</span> b_repeat_headers;       <span class="comment">/* put SPS/PPS before each keyframe */</span></span><br><span class="line">    <span class="keyword">int</span> b_annexb;               <span class="comment">/* if set, place start codes (4 bytes) before NAL units,</span></span><br><span class="line"><span class="comment">                                 * otherwise place size (4 bytes) before NAL units. */</span></span><br><span class="line">    <span class="keyword">int</span> i_sps_id;               <span class="comment">/* SPS and PPS id number */</span></span><br><span class="line">    <span class="keyword">int</span> b_vfr_input;            <span class="comment">/* VFR input.  If 1, use timebase and timestamps for ratecontrol purposes.</span></span><br><span class="line"><span class="comment">                                 * If 0, use fps only. */</span></span><br><span class="line">    <span class="keyword">int</span> b_pulldown;             <span class="comment">/* use explicity set timebase for CFR */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i_fps_num;</span><br><span class="line">    <span class="keyword">uint32_t</span> i_fps_den;</span><br><span class="line">    <span class="keyword">uint32_t</span> i_timebase_num;    <span class="comment">/* Timebase numerator */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i_timebase_den;    <span class="comment">/* Timebase denominator */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_tff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pulldown:</span></span><br><span class="line"><span class="comment">     * The correct pic_struct must be passed with each input frame.</span></span><br><span class="line"><span class="comment">     * The input timebase should be the timebase corresponding to the output framerate. This should be constant.</span></span><br><span class="line"><span class="comment">     * e.g. for 3:2 pulldown timebase should be 1001/30000</span></span><br><span class="line"><span class="comment">     * The PTS passed with each frame must be the PTS of the frame after pulldown is applied.</span></span><br><span class="line"><span class="comment">     * Frame doubling and tripling require b_vfr_input set to zero (see H.264 Table D-1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Pulldown changes are not clearly defined in H.264. Therefore, it is the calling app&#x27;s responsibility to manage this.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_pic_struct;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fake Interlaced.</span></span><br><span class="line"><span class="comment">     * 仅在 b_interlaced = 0 时使用</span></span><br><span class="line"><span class="comment">     * 设置此标志可以将流标记为 PAFF 隔行，并且对所有帧进行渐进编码</span></span><br><span class="line"><span class="comment">     * 对于编码 25p 和 30p 蓝光流非常有用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_fake_interlaced;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t optimize header parameters based on video content, e.g. ensure that splitting an input video, compressing</span></span><br><span class="line"><span class="comment">     * each part, and stitching them back together will result in identical SPS/PPS. This is necessary for stitching</span></span><br><span class="line"><span class="comment">     * with container formats that don&#x27;t allow multiple SPS/PPS. */</span></span><br><span class="line">    <span class="keyword">int</span> b_stitchable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_opencl;            <span class="comment">/* use OpenCL when available */</span></span><br><span class="line">    <span class="keyword">int</span> i_opencl_device;     <span class="comment">/* specify count of GPU devices to skip, for CLI users */</span></span><br><span class="line">    <span class="keyword">void</span> *opencl_device_id;  <span class="comment">/* pass explicit cl_device_id as void*, for API users */</span></span><br><span class="line">    <span class="keyword">char</span> *psz_clbin_file;    <span class="comment">/* filename (in UTF-8) of the compiled OpenCL kernel cache file */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Slicing parameters */</span></span><br><span class="line">    <span class="keyword">int</span> i_slice_max_size;    <span class="comment">/* Max size per slice in bytes; includes estimated NAL overhead. */</span></span><br><span class="line">    <span class="keyword">int</span> i_slice_max_mbs;     <span class="comment">/* Max number of MBs per slice; overrides i_slice_count. */</span></span><br><span class="line">    <span class="keyword">int</span> i_slice_min_mbs;     <span class="comment">/* Min number of MBs per slice */</span></span><br><span class="line">    <span class="keyword">int</span> i_slice_count;       <span class="comment">/* Number of slices per frame: forces rectangular slices. */</span></span><br><span class="line">    <span class="keyword">int</span> i_slice_count_max;   <span class="comment">/* Absolute cap on slices per frame; stops applying slice-max-size</span></span><br><span class="line"><span class="comment">                              * and slice-max-mbs if this is reached. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optional callback for freeing this x264_param_t when it is done being used.</span></span><br><span class="line"><span class="comment">     * Only used when the x264_param_t sits in memory for an indefinite period of time,</span></span><br><span class="line"><span class="comment">     * i.e. when an x264_param_t is passed to x264_t in an x264_picture_t or in zones.</span></span><br><span class="line"><span class="comment">     * Not used when x264_encoder_reconfig is called directly. */</span></span><br><span class="line">    <span class="keyword">void</span> (*param_free)( <span class="keyword">void</span>* );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optional low-level callback for low-latency encoding.  Called for each output NAL unit</span></span><br><span class="line"><span class="comment">     * immediately after the NAL unit is finished encoding.  This allows the calling application</span></span><br><span class="line"><span class="comment">     * to begin processing video data (e.g. by sending packets over a network) before the frame</span></span><br><span class="line"><span class="comment">     * is done encoding.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This callback MUST do the following in order to work correctly:</span></span><br><span class="line"><span class="comment">     * 1) Have available an output buffer of at least size nal-&gt;i_payload*3/2 + 5 + 64.</span></span><br><span class="line"><span class="comment">     * 2) Call x264_nal_encode(h, dst, nal), where dst is the output buffer.</span></span><br><span class="line"><span class="comment">     * After these steps, the content of nal is valid and can be used in the same way as if</span></span><br><span class="line"><span class="comment">     * the NAL unit were output by x264_encoder_encode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This does not need to be synchronous with the encoding process: the data pointed to</span></span><br><span class="line"><span class="comment">     * by nal (both before and after x264_nal_encode) will remain valid until the next</span></span><br><span class="line"><span class="comment">     * x264_encoder_encode call.  The callback must be re-entrant.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This callback does not work with frame-based threads; threads must be disabled</span></span><br><span class="line"><span class="comment">     * or sliced-threads enabled.  This callback also does not work as one would expect</span></span><br><span class="line"><span class="comment">     * with HRD -- since the buffering period SEI cannot be calculated until the frame</span></span><br><span class="line"><span class="comment">     * is finished encoding, it will not be sent via this callback.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note also that the NALs are not necessarily returned in order when sliced threads is</span></span><br><span class="line"><span class="comment">     * enabled.  Accordingly, the variable i_first_mb and i_last_mb are available in</span></span><br><span class="line"><span class="comment">     * x264_nal_t to help the calling application reorder the slices if necessary.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When this callback is enabled, x264_encoder_encode does not return valid NALs;</span></span><br><span class="line"><span class="comment">     * the calling application is expected to acquire all output NALs through the callback.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It is generally sensible to combine this callback with a use of slice-max-mbs or</span></span><br><span class="line"><span class="comment">     * slice-max-size.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The opaque pointer is the opaque pointer from the input frame associated with this</span></span><br><span class="line"><span class="comment">     * NAL unit. This helps distinguish between nalu_process calls from different sources,</span></span><br><span class="line"><span class="comment">     * e.g. if doing multiple encodes in one process.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*nalu_process)( <span class="keyword">x264_t</span> *h, <span class="keyword">x264_nal_t</span> *nal, <span class="keyword">void</span> *opaque );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For internal use only */</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">&#125; <span class="keyword">x264_param_t</span>;</span><br></pre></td></tr></table></figure>
<h2 id="cli-opt-t"><a href="#cli-opt-t" class="headerlink" title="cli_opt_t"></a>cli_opt_t</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> b_progress;</span><br><span class="line">    <span class="keyword">int</span> i_seek;</span><br><span class="line">    <span class="keyword">hnd_t</span> hin;</span><br><span class="line">    <span class="keyword">hnd_t</span> hout;</span><br><span class="line">    FILE *qpfile;</span><br><span class="line">    FILE *tcfile_out;</span><br><span class="line">    <span class="keyword">double</span> timebase_convert_multiplier;</span><br><span class="line">    <span class="keyword">int</span> i_pulldown;</span><br><span class="line">&#125; <span class="keyword">cli_opt_t</span>;</span><br></pre></td></tr></table></figure>
<h2 id="x264-sps-t"><a href="#x264-sps-t" class="headerlink" title="x264_sps_t"></a>x264_sps_t</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i_profile_idc;</span><br><span class="line">    <span class="keyword">int</span> i_level_idc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_constraint_set0;</span><br><span class="line">    <span class="keyword">int</span> b_constraint_set1;</span><br><span class="line">    <span class="keyword">int</span> b_constraint_set2;</span><br><span class="line">    <span class="keyword">int</span> b_constraint_set3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i_log2_max_frame_num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i_poc_type;</span><br><span class="line">    <span class="comment">/* poc 0 */</span></span><br><span class="line">    <span class="keyword">int</span> i_log2_max_poc_lsb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i_num_ref_frames;</span><br><span class="line">    <span class="keyword">int</span> b_gaps_in_frame_num_value_allowed;</span><br><span class="line">    <span class="keyword">int</span> i_mb_width;</span><br><span class="line">    <span class="keyword">int</span> i_mb_height;</span><br><span class="line">    <span class="keyword">int</span> b_frame_mbs_only;</span><br><span class="line">    <span class="keyword">int</span> b_mb_adaptive_frame_field;</span><br><span class="line">    <span class="keyword">int</span> b_direct8x8_inference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_crop;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i_left;</span><br><span class="line">        <span class="keyword">int</span> i_right;</span><br><span class="line">        <span class="keyword">int</span> i_top;</span><br><span class="line">        <span class="keyword">int</span> i_bottom;</span><br><span class="line">    &#125; crop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_vui;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">vui</span> <span class="title">vui</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_qpprime_y_zero_transform_bypass;</span><br><span class="line">    <span class="keyword">int</span> i_chroma_format_idc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_avcintra;</span><br><span class="line">    <span class="keyword">int</span> i_cqm_preset;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *scaling_list[<span class="number">8</span>]; <span class="comment">/* could be 12, but we don&#x27;t allow separate Cb/Cr lists */</span></span><br><span class="line">&#125; <span class="keyword">x264_sps_t</span>;</span><br></pre></td></tr></table></figure>
<h3 id="struct-vui"><a href="#struct-vui" class="headerlink" title="struct __vui"></a>struct __vui</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">vui</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> b_aspect_ratio_info_present;</span><br><span class="line">    <span class="keyword">int</span> i_sar_width;</span><br><span class="line">    <span class="keyword">int</span> i_sar_height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_overscan_info_present;</span><br><span class="line">    <span class="keyword">int</span> b_overscan_info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_signal_type_present;</span><br><span class="line">    <span class="keyword">int</span> i_vidformat;</span><br><span class="line">    <span class="keyword">int</span> b_fullrange;</span><br><span class="line">    <span class="keyword">int</span> b_color_description_present;</span><br><span class="line">    <span class="keyword">int</span> i_colorprim;</span><br><span class="line">    <span class="keyword">int</span> i_transfer;</span><br><span class="line">    <span class="keyword">int</span> i_colmatrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_chroma_loc_info_present;</span><br><span class="line">    <span class="keyword">int</span> i_chroma_loc_top;</span><br><span class="line">    <span class="keyword">int</span> i_chroma_loc_bottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_timing_info_present;</span><br><span class="line">    <span class="keyword">uint32_t</span> i_num_units_in_tick;</span><br><span class="line">    <span class="keyword">uint32_t</span> i_time_scale;</span><br><span class="line">    <span class="keyword">int</span> b_fixed_frame_rate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_nal_hrd_parameters_present;</span><br><span class="line">    <span class="keyword">int</span> b_vcl_hrd_parameters_present;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i_cpb_cnt;</span><br><span class="line">        <span class="keyword">int</span> i_bit_rate_scale;</span><br><span class="line">        <span class="keyword">int</span> i_cpb_size_scale;</span><br><span class="line">        <span class="keyword">int</span> i_bit_rate_value;</span><br><span class="line">        <span class="keyword">int</span> i_cpb_size_value;</span><br><span class="line">        <span class="keyword">int</span> i_bit_rate_unscaled;</span><br><span class="line">        <span class="keyword">int</span> i_cpb_size_unscaled;</span><br><span class="line">        <span class="keyword">int</span> b_cbr_hrd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i_initial_cpb_removal_delay_length;</span><br><span class="line">        <span class="keyword">int</span> i_cpb_removal_delay_length;</span><br><span class="line">        <span class="keyword">int</span> i_dpb_output_delay_length;</span><br><span class="line">        <span class="keyword">int</span> i_time_offset_length;</span><br><span class="line">    &#125; hrd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b_pic_struct_present;</span><br><span class="line">    <span class="keyword">int</span> b_bitstream_restriction;</span><br><span class="line">    <span class="keyword">int</span> b_motion_vectors_over_pic_boundaries;</span><br><span class="line">    <span class="keyword">int</span> i_max_bytes_per_pic_denom;</span><br><span class="line">    <span class="keyword">int</span> i_max_bits_per_mb_denom;</span><br><span class="line">    <span class="keyword">int</span> i_log2_max_mv_length_horizontal;</span><br><span class="line">    <span class="keyword">int</span> i_log2_max_mv_length_vertical;</span><br><span class="line">    <span class="keyword">int</span> i_num_reorder_frames;</span><br><span class="line">    <span class="keyword">int</span> i_max_dec_frame_buffering;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FIXME to complete */</span></span><br><span class="line">&#125; vui;</span><br></pre></td></tr></table></figure>
<h2 id="x264-pixel-function-t"><a href="#x264-pixel-function-t" class="headerlink" title="x264_pixel_function_t"></a>x264_pixel_function_t</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">x264_pixel_cmp_t</span>  sad[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">x264_pixel_cmp_t</span>  ssd[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">x264_pixel_cmp_t</span> satd[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">x264_pixel_cmp_t</span> ssim[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">x264_pixel_cmp_t</span> sa8d[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">x264_pixel_cmp_t</span> mbcmp[<span class="number">8</span>]; <span class="comment">/* either satd or sad for subpel refine and mode decision */</span></span><br><span class="line">    <span class="keyword">x264_pixel_cmp_t</span> mbcmp_unaligned[<span class="number">8</span>]; <span class="comment">/* unaligned mbcmp for subpel */</span></span><br><span class="line">    <span class="keyword">x264_pixel_cmp_t</span> fpelcmp[<span class="number">8</span>]; <span class="comment">/* either satd or sad for fullpel motion search */</span></span><br><span class="line">    <span class="keyword">x264_pixel_cmp_x3_t</span> fpelcmp_x3[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">x264_pixel_cmp_x4_t</span> fpelcmp_x4[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">x264_pixel_cmp_t</span> sad_aligned[<span class="number">8</span>]; <span class="comment">/* Aligned SAD for mbcmp */</span></span><br><span class="line">    <span class="keyword">int</span> (*vsad)( pixel *, <span class="keyword">intptr_t</span>, <span class="keyword">int</span> );</span><br><span class="line">    <span class="keyword">int</span> (*asd8)( pixel *pix1, <span class="keyword">intptr_t</span> stride1, pixel *pix2, <span class="keyword">intptr_t</span> stride2, <span class="keyword">int</span> <span class="built_in">height</span> );</span><br><span class="line">    <span class="keyword">uint64_t</span> (*sa8d_satd[<span class="number">1</span>])( pixel *pix1, <span class="keyword">intptr_t</span> stride1, pixel *pix2, <span class="keyword">intptr_t</span> stride2 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> (*var[<span class="number">4</span>])( pixel *pix, <span class="keyword">intptr_t</span> stride );</span><br><span class="line">    <span class="keyword">int</span> (*var2[<span class="number">4</span>])( pixel *fenc, pixel *fdec, <span class="keyword">int</span> ssd[<span class="number">2</span>] );</span><br><span class="line">    <span class="keyword">uint64_t</span> (*hadamard_ac[<span class="number">4</span>])( pixel *pix, <span class="keyword">intptr_t</span> stride );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*ssd_nv12_core)( pixel *pixuv1, <span class="keyword">intptr_t</span> stride1,</span><br><span class="line">                           pixel *pixuv2, <span class="keyword">intptr_t</span> stride2, <span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>,</span><br><span class="line">                           <span class="keyword">uint64_t</span> *ssd_u, <span class="keyword">uint64_t</span> *ssd_v );</span><br><span class="line">    <span class="keyword">void</span> (*ssim_4x4x2_core)( <span class="keyword">const</span> pixel *pix1, <span class="keyword">intptr_t</span> stride1,</span><br><span class="line">                             <span class="keyword">const</span> pixel *pix2, <span class="keyword">intptr_t</span> stride2, <span class="keyword">int</span> sums[<span class="number">2</span>][<span class="number">4</span>] );</span><br><span class="line">    <span class="keyword">float</span> (*ssim_end4)( <span class="keyword">int</span> sum0[<span class="number">5</span>][<span class="number">4</span>], <span class="keyword">int</span> sum1[<span class="number">5</span>][<span class="number">4</span>], <span class="keyword">int</span> <span class="built_in">width</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* multiple parallel calls to cmp. */</span></span><br><span class="line">    <span class="keyword">x264_pixel_cmp_x3_t</span> sad_x3[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">x264_pixel_cmp_x4_t</span> sad_x4[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">x264_pixel_cmp_x3_t</span> satd_x3[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">x264_pixel_cmp_x4_t</span> satd_x4[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* abs-diff-sum for successive elimination.</span></span><br><span class="line"><span class="comment">     * may round width up to a multiple of 16. */</span></span><br><span class="line">    <span class="keyword">int</span> (*ads[<span class="number">7</span>])( <span class="keyword">int</span> enc_dc[<span class="number">4</span>], <span class="keyword">uint16_t</span> *sums, <span class="keyword">int</span> delta,</span><br><span class="line">                   <span class="keyword">uint16_t</span> *cost_mvx, <span class="keyword">int16_t</span> *mvs, <span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> thresh );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calculate satd or sad of V, H, and DC modes. */</span></span><br><span class="line">    <span class="keyword">void</span> (*intra_mbcmp_x3_16x16)( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_satd_x3_16x16) ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_sad_x3_16x16)  ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_mbcmp_x3_4x4)  ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_satd_x3_4x4)   ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_sad_x3_4x4)    ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_mbcmp_x3_chroma)( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_satd_x3_chroma) ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_sad_x3_chroma)  ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_mbcmp_x3_8x16c) ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_satd_x3_8x16c)  ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_sad_x3_8x16c)   ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_mbcmp_x3_8x8c)  ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_satd_x3_8x8c)   ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_sad_x3_8x8c)    ( pixel *fenc, pixel *fdec, <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_mbcmp_x3_8x8)  ( pixel *fenc, pixel edge[<span class="number">36</span>], <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_sa8d_x3_8x8)   ( pixel *fenc, pixel edge[<span class="number">36</span>], <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">void</span> (*intra_sad_x3_8x8)    ( pixel *fenc, pixel edge[<span class="number">36</span>], <span class="keyword">int</span> res[<span class="number">3</span>] );</span><br><span class="line">    <span class="comment">/* find minimum satd or sad of all modes, and set fdec.</span></span><br><span class="line"><span class="comment">     * may be NULL, in which case just use pred+satd instead. */</span></span><br><span class="line">    <span class="keyword">int</span> (*intra_mbcmp_x9_4x4)( pixel *fenc, pixel *fdec, <span class="keyword">uint16_t</span> *bitcosts );</span><br><span class="line">    <span class="keyword">int</span> (*intra_satd_x9_4x4) ( pixel *fenc, pixel *fdec, <span class="keyword">uint16_t</span> *bitcosts );</span><br><span class="line">    <span class="keyword">int</span> (*intra_sad_x9_4x4)  ( pixel *fenc, pixel *fdec, <span class="keyword">uint16_t</span> *bitcosts );</span><br><span class="line">    <span class="keyword">int</span> (*intra_mbcmp_x9_8x8)( pixel *fenc, pixel *fdec, pixel edge[<span class="number">36</span>], <span class="keyword">uint16_t</span> *bitcosts, <span class="keyword">uint16_t</span> *satds );</span><br><span class="line">    <span class="keyword">int</span> (*intra_sa8d_x9_8x8) ( pixel *fenc, pixel *fdec, pixel edge[<span class="number">36</span>], <span class="keyword">uint16_t</span> *bitcosts, <span class="keyword">uint16_t</span> *satds );</span><br><span class="line">    <span class="keyword">int</span> (*intra_sad_x9_8x8)  ( pixel *fenc, pixel *fdec, pixel edge[<span class="number">36</span>], <span class="keyword">uint16_t</span> *bitcosts, <span class="keyword">uint16_t</span> *satds );</span><br><span class="line">&#125; <span class="keyword">x264_pixel_function_t</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>x264</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 x264 - 简介</title>
    <url>/post/2020/ee0dad8c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="x264-简介"><a href="#x264-简介" class="headerlink" title="x264 简介"></a>x264 简介</h2><p>x264 是一个免费的软件库和应用程序，用于将视频流编码为 H.264/MPEG-4 AVC 压缩格式，并且根据 GNU GPL 的条款发布。</p>
<h3 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h3><ul>
<li>提供一流的性能、压缩和功能。</li>
<li>在单个消费级计算机上实时编码 4 个或更多 1080p 流，实现显著性能。</li>
<li>提供最佳质量，具有最先进的心理视觉优化。</li>
<li>支持许多不同应用所需的功能，如电视广播、蓝光低延迟视频应用程序和 Web 视频。</li>
<li>x264 是许多网络视频服务的核心，如 Youtube、Facebook、Vimeo 和 Hulu。它被电视广播公司和 ISP 广泛使用。</li>
</ul>
<a id="more"></a>
<h3 id="获取-x264"><a href="#获取-x264" class="headerlink" title="获取 x264"></a>获取 x264</h3><p>最新的 x264 源代码可通过git 存储库获得：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://code.videolan.org/videolan/x264.git</span><br></pre></td></tr></table></figure>
<p>应用程序二进制文件，适用于 Windows、Linux 和 MacOSX 的官方版本可从<a href="https://artifacts.videolan.org/x264/">这里</a>获得。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://www.videolan.org/developers/x264.html">x264, the best H.264/AVC encoder - VideoLAN</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>x264</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 x264 - 编码 API</title>
    <url>/post/2020/eb0de708/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <a href="/post/2020/3bc2314a/" title="源码阅读 x264 - 命令行工具">源码阅读 x264 - 命令行工具</a> 中我们分析到 <code>encode()</code> 的流程中涉及到 <code>libx264</code> 的几个关键的 API，这些函数有：</p>
<ul>
<li><code>x264_encoder_open()</code>：打开 H.264 编码器。</li>
<li><code>x264_encoder_headers()</code>：输出 SPS/PPS/SEI。</li>
<li><code>x264_encoder_encode()</code>：编码一帧数据。</li>
<li><code>x264_encoder_close()</code>：关闭 H.264 编码器。</li>
</ul>
<a id="more"></a>
<h2 id="x264-encoder-open"><a href="#x264-encoder-open" class="headerlink" title="x264_encoder_open"></a>x264_encoder_open</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief                            创建一个新的编码 handler</span></span><br><span class="line"><span class="comment">* @param[in]        param           x264_param_t 结构体指针</span></span><br><span class="line"><span class="comment">* @return                           x264_t 结构体指针</span></span><br><span class="line"><span class="comment">                                    # not nullptr   执行成功</span></span><br><span class="line"><span class="comment">*                                   # nullptr       执行失败</span></span><br><span class="line"><span class="comment">* @note:    all parameters from x264_param_t are copied</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">X264_API <span class="keyword">x264_t</span> *<span class="title">x264_encoder_open</span><span class="params">(<span class="keyword">x264_param_t</span> *param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>根据函数调用的顺序，看一下 <code>x264_encoder_open()</code> 调用的下面几个函数：</p>
<h3 id="参数集初始化"><a href="#参数集初始化" class="headerlink" title="参数集初始化"></a>参数集初始化</h3><ul>
<li><code>x264_sps_init()</code>：根据输入参数生成 <code>H.264</code> 码流的 <code>SPS</code> 信息。</li>
<li><code>x264_pps_init()</code>：根据输入参数生成 <code>H.264</code> 码流的 <code>PPS</code> 信息。</li>
</ul>
<blockquote>
<p>参数集初始化的函数解析见：<a href="/post/2021/2633a00a/" title="源码阅读 x264 - SPS &amp; PPS">源码阅读 x264 - SPS &amp; PPS</a></p>
</blockquote>
<h3 id="帧内预测初始化"><a href="#帧内预测初始化" class="headerlink" title="帧内预测初始化"></a>帧内预测初始化</h3><ul>
<li><code>x264_predict_16x16_init()</code> 用于初始化 <code>Intra16x16</code> 帧内预测函数</li>
<li><code>x264_predict_4x4_init()</code> 用于初始化 <code>Intra4x4</code> 帧内预测函数</li>
</ul>
<blockquote>
<p>帧内预测的相关内容详见：<a href="/post/2020/7d82ecd5/" title="编解码技术：H264 - 帧内预测">编解码技术：H264 - 帧内预测</a><br>帧内预测的函数解析详见：<a href="/post/2021/b66cfff2/" title="源码阅读 x264 - 帧内预测">源码阅读 x264 - 帧内预测</a></p>
</blockquote>
<ul>
<li><code>x264_pixel_init()</code> 用于初始化帧内预测方法选择需要计算的代价函数</li>
</ul>
<blockquote>
<p><code>SAD</code>、<code>SATD</code>、<code>SSD</code>、<code>SSIM</code> 的介绍详见：<a href="/post/2020/65d41c1f/" title="编解码技术：H264 - 代价计算">编解码技术：H264 - 代价计算</a><br><code>SAD</code>、<code>SATD</code>、<code>SSD</code>、<code>SSIM</code> 的函数解析见：<a href="/post/2021/ae3a0f38/" title="源码阅读 x264 - 代价计算">源码阅读 x264 - 代价计算</a></p>
</blockquote>
<h3 id="变换参数初始化"><a href="#变换参数初始化" class="headerlink" title="变换参数初始化"></a>变换参数初始化</h3><ul>
<li><code>x264_dct_init()</code> 初始化了一系列的 <code>DCT</code> 变换的函数</li>
</ul>
<blockquote>
<p>离散余弦变换的函数解析见：<a href="/post/2021/f0753f9a/" title="源码阅读 x264 - 离散余弦变换">源码阅读 x264 - 离散余弦变换</a></p>
</blockquote>
<h3 id="量化参数初始化"><a href="#量化参数初始化" class="headerlink" title="量化参数初始化"></a>量化参数初始化</h3><ul>
<li><code>x264_quant_init()</code> 函数中初始化了量化有关的函数</li>
</ul>
<blockquote>
<p>离散余弦变换的函数解析见：<a href="/post/2021/f0753f9a/" title="源码阅读 x264 - 离散余弦变换">源码阅读 x264 - 离散余弦变换</a></p>
</blockquote>
<h3 id="滤波参数初始化"><a href="#滤波参数初始化" class="headerlink" title="滤波参数初始化"></a>滤波参数初始化</h3><ul>
<li><code>x264_deblock_init()</code>：初始化去块效应滤波器相关的汇编函数</li>
</ul>
<blockquote>
<p>离散余弦变换的函数解析见：<a href="/post/2021/10604d20/" title="源码阅读 x264 - 去块效应滤波">源码阅读 x264 - 去块效应滤波</a></p>
</blockquote>
<h2 id="x264-encoder-headers"><a href="#x264-encoder-headers" class="headerlink" title="x264_encoder_headers"></a>x264_encoder_headers</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* x264_encoder_headers:</span></span><br><span class="line"><span class="comment"> *      return the SPS and PPS that will be used for the whole stream.</span></span><br><span class="line"><span class="comment"> *      *pi_nal is the number of NAL units outputted in pp_nal.</span></span><br><span class="line"><span class="comment"> *      returns the number of bytes in the returned NALs.</span></span><br><span class="line"><span class="comment"> *      returns negative on error.</span></span><br><span class="line"><span class="comment"> *      the payloads of all output NALs are guaranteed to be sequential in memory. */</span></span><br><span class="line"><span class="function">X264_API <span class="keyword">int</span> <span class="title">x264_encoder_headers</span><span class="params">(<span class="keyword">x264_t</span> *param, <span class="keyword">x264_nal_t</span> **pp_nal, <span class="keyword">int</span> *pi_nal)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="x264-encoder-encode"><a href="#x264-encoder-encode" class="headerlink" title="x264_encoder_encode"></a>x264_encoder_encode</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* x264_encoder_encode:</span></span><br><span class="line"><span class="comment"> *      encode one picture.</span></span><br><span class="line"><span class="comment"> *      *pi_nal is the number of NAL units outputted in pp_nal.</span></span><br><span class="line"><span class="comment"> *      returns the number of bytes in the returned NALs.</span></span><br><span class="line"><span class="comment"> *      returns negative on error and zero if no NAL units returned.</span></span><br><span class="line"><span class="comment"> *      the payloads of all output NALs are guaranteed to be sequential in memory. */</span></span><br><span class="line"><span class="function">X264_API <span class="keyword">int</span> <span class="title">x264_encoder_encode</span><span class="params">(<span class="keyword">x264_t</span> *param, <span class="keyword">x264_nal_t</span> **pp_nal, <span class="keyword">int</span> *pi_nal, <span class="keyword">x264_picture_t</span> *pic_in, <span class="keyword">x264_picture_t</span> *pic_out)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="x264-encoder-close"><a href="#x264-encoder-close" class="headerlink" title="x264_encoder_close"></a>x264_encoder_close</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* x264_encoder_close:</span></span><br><span class="line"><span class="comment"> *      close an encoder handler */</span></span><br><span class="line"><span class="function">X264_API <span class="keyword">void</span> <span class="title">x264_encoder_close</span><span class="params">(<span class="keyword">x264_t</span> *param)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li>
<li>[2] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45719905">x264 源代码简单分析：编码器主干部分 - 2 雷霄骅的专栏 - CSDN 博客</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>x264</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 x264 - 运动补偿</title>
    <url>/post/2021/83dc3ab7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要记录 <code>x264</code> 中的 <code>x264_mc_init</code> 函数，该函数主要对 <code>x264_mc_functions_t</code> 结构体中的函数指针进行赋值， 完成了像素内插、拷贝、求平均的等运动补偿相关函数的初始化。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_mc_init</span><span class="params">(<span class="keyword">uint32_t</span> cpu, <span class="keyword">x264_mc_functions_t</span> *pf, <span class="keyword">int</span> cpu_independent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pf-&gt;mc_luma   = mc_luma;</span><br><span class="line">    pf-&gt;get_ref   = get_ref;</span><br><span class="line"></span><br><span class="line">    pf-&gt;mc_chroma = mc_chroma;</span><br><span class="line"></span><br><span class="line">    pf-&gt;avg[PIXEL_16x16]= pixel_avg_16x16;</span><br><span class="line">    pf-&gt;avg[PIXEL_16x8] = pixel_avg_16x8;</span><br><span class="line">    pf-&gt;avg[PIXEL_8x16] = pixel_avg_8x16;</span><br><span class="line">    pf-&gt;avg[PIXEL_8x8]  = pixel_avg_8x8;</span><br><span class="line">    pf-&gt;avg[PIXEL_8x4]  = pixel_avg_8x4;</span><br><span class="line">    pf-&gt;avg[PIXEL_4x16] = pixel_avg_4x16;</span><br><span class="line">    pf-&gt;avg[PIXEL_4x8]  = pixel_avg_4x8;</span><br><span class="line">    pf-&gt;avg[PIXEL_4x4]  = pixel_avg_4x4;</span><br><span class="line">    pf-&gt;avg[PIXEL_4x2]  = pixel_avg_4x2;</span><br><span class="line">    pf-&gt;avg[PIXEL_2x8]  = pixel_avg_2x8;</span><br><span class="line">    pf-&gt;avg[PIXEL_2x4]  = pixel_avg_2x4;</span><br><span class="line">    pf-&gt;avg[PIXEL_2x2]  = pixel_avg_2x2;</span><br><span class="line"></span><br><span class="line">    pf-&gt;weight    = mc_weight_wtab;</span><br><span class="line">    pf-&gt;offsetadd = mc_weight_wtab;</span><br><span class="line">    pf-&gt;offsetsub = mc_weight_wtab;</span><br><span class="line">    pf-&gt;weight_cache = weight_cache;</span><br><span class="line"></span><br><span class="line">    pf-&gt;copy_16x16_unaligned = mc_copy_w16;</span><br><span class="line">    pf-&gt;copy[PIXEL_16x16] = mc_copy_w16;</span><br><span class="line">    pf-&gt;copy[PIXEL_8x8]   = mc_copy_w8;</span><br><span class="line">    pf-&gt;copy[PIXEL_4x4]   = mc_copy_w4;</span><br><span class="line"></span><br><span class="line">    pf-&gt;store_interleave_chroma       = store_interleave_chroma;</span><br><span class="line">    pf-&gt;load_deinterleave_chroma_fenc = load_deinterleave_chroma_fenc;</span><br><span class="line">    pf-&gt;load_deinterleave_chroma_fdec = load_deinterleave_chroma_fdec;</span><br><span class="line"></span><br><span class="line">    pf-&gt;plane_copy = x264_plane_copy_c;</span><br><span class="line">    pf-&gt;plane_copy_swap = x264_plane_copy_swap_c;</span><br><span class="line">    pf-&gt;plane_copy_interleave = x264_plane_copy_interleave_c;</span><br><span class="line"></span><br><span class="line">    pf-&gt;plane_copy_deinterleave = x264_plane_copy_deinterleave_c;</span><br><span class="line">    pf-&gt;plane_copy_deinterleave_yuyv = x264_plane_copy_deinterleave_c;</span><br><span class="line">    pf-&gt;plane_copy_deinterleave_rgb = plane_copy_deinterleave_rgb_c;</span><br><span class="line">    pf-&gt;plane_copy_deinterleave_v210 = plane_copy_deinterleave_v210_c;</span><br><span class="line"></span><br><span class="line">    pf-&gt;hpel_filter = hpel_filter;</span><br><span class="line"></span><br><span class="line">    pf-&gt;prefetch_fenc_400 = prefetch_fenc_null;</span><br><span class="line">    pf-&gt;prefetch_fenc_420 = prefetch_fenc_null;</span><br><span class="line">    pf-&gt;prefetch_fenc_422 = prefetch_fenc_null;</span><br><span class="line">    pf-&gt;prefetch_ref  = prefetch_ref_null;</span><br><span class="line">    pf-&gt;memcpy_aligned = <span class="built_in">memcpy</span>;</span><br><span class="line">    pf-&gt;memzero_aligned = memzero_aligned;</span><br><span class="line">    pf-&gt;frame_init_lowres_core = frame_init_lowres_core;</span><br><span class="line"></span><br><span class="line">    pf-&gt;integral_init4h = integral_init4h;</span><br><span class="line">    pf-&gt;integral_init8h = integral_init8h;</span><br><span class="line">    pf-&gt;integral_init4v = integral_init4v;</span><br><span class="line">    pf-&gt;integral_init8v = integral_init8v;</span><br><span class="line"></span><br><span class="line">    pf-&gt;mbtree_propagate_cost = mbtree_propagate_cost;</span><br><span class="line">    pf-&gt;mbtree_propagate_list = mbtree_propagate_list;</span><br><span class="line">    pf-&gt;mbtree_fix8_pack      = mbtree_fix8_pack;</span><br><span class="line">    pf-&gt;mbtree_fix8_unpack    = mbtree_fix8_unpack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处省略台的汇编函数初始化代码 */</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于运动估计和运动补偿在 <code>x264</code> 中属于相对复杂的环节，其中许多函数的作用很难三言两语表述出来，因此只分析两个相对重要的例子：</p>
<ol>
<li>半像素内插函数 <code>hpel_filter()</code></li>
<li>获取亚像素数据的函数 <code>get_ref()</code></li>
</ol>
<h2 id="半像素内插函数"><a href="#半像素内插函数" class="headerlink" title="半像素内插函数"></a>半像素内插函数</h2><p><code>hpel_filter()</code> 用于进行半像素插值，函数定义如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 半像素插值公式</span></span><br><span class="line"><span class="comment">// b = (E - 5F + 20G + 20H - 5I + J) / 32</span></span><br><span class="line"><span class="comment">// d 取 1，水平滤波器</span></span><br><span class="line"><span class="comment">// d 取 stride，垂直滤波器（这里没有除以 32）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAPFILTER(pix, d) ((pix)[x-2*d] + (pix)[x+3*d] - 5*((pix)[x-d] + (pix)[x+2*d]) + 20*((pix)[x] + (pix)[x+d]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x &gt; 0 return 0;</span></span><br><span class="line"><span class="comment">// 0 &lt;= x &lt;= 255 return x;</span></span><br><span class="line"><span class="comment">// x &gt; 255 return 255;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ALWAYS_INLINE pixel <span class="title">x264_clip_pixel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x &amp; ~PIXEL_MAX) ? (-x)&gt;&gt;<span class="number">31</span> &amp; PIXEL_MAX : x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 半像素插值</span></span><br><span class="line"><span class="comment"> * dsth : 水平滤波得到的半像素点 (aa,bb,b,s,gg,hh)</span></span><br><span class="line"><span class="comment"> * dstv : 垂直滤波的到的半像素点 (cc,dd,h,m,ee,ff)</span></span><br><span class="line"><span class="comment"> * dstc : &quot;水平 + 垂直&quot; 滤波得到的位于 4 个像素中间的半像素点（j）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hpel_filter</span><span class="params">( pixel *dsth, pixel *dstv, pixel *dstc, pixel *src,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">intptr_t</span> stride, <span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int16_t</span> *buf )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> pad = (BIT_DEPTH&gt; <span class="number">9</span>) ? (<span class="number">-10</span> * PIXEL_MAX) : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 几种半像素点之间的位置关系</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * X : 像素点</span></span><br><span class="line"><span class="comment">     * H : 水平滤波半像素点</span></span><br><span class="line"><span class="comment">     * V : 垂直滤波半像素点</span></span><br><span class="line"><span class="comment">     * C : 中间位置半像素点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * X   H   X       X       X</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * V   C</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * X       X       X       X</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * X       X       X       X</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 一行一行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">-2</span>; x &lt; <span class="built_in">width</span> + <span class="number">3</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = TAPFILTER(src,stride);</span><br><span class="line">            dstv[x] = x264_clip_pixel( (v + <span class="number">16</span>) &gt;&gt; <span class="number">5</span> );</span><br><span class="line">            <span class="comment">/* transform v for storage in a 16-bit integer */</span></span><br><span class="line">            buf[x+<span class="number">2</span>] = v + pad;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)</span><br><span class="line">            dstc[x] = x264_clip_pixel( (TAPFILTER(buf+<span class="number">2</span>,<span class="number">1</span>) - <span class="number">32</span>*pad + <span class="number">512</span>) &gt;&gt; <span class="number">10</span> );</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)</span><br><span class="line">            dsth[x] = x264_clip_pixel( (TAPFILTER(src,<span class="number">1</span>) + <span class="number">16</span>) &gt;&gt; <span class="number">5</span> );</span><br><span class="line">        dsth += stride;</span><br><span class="line">        dstv += stride;</span><br><span class="line">        dstc += stride;</span><br><span class="line">        src  += stride;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>半像素插值示意图如下：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210123210246.png" alt="半像素插值示意图"></p>
<p>半像素点的计算关系如下：</p>
<ul>
<li>m : 由 B、D、H、N、S、U 计算</li>
<li>h : 由 A、C、G、M、R、T 计算</li>
<li>s : 由 K、L、M、N、P、Q 计算</li>
<li>j : 由 cc、dd、h、m、ee、ff 计算。需要注意 j 点的运算量比较大，因为 cc、dd、ee、ff 都需要通过半像素内插方法进行计算。</li>
</ul>
<h2 id="获取亚像素数据"><a href="#获取亚像素数据" class="headerlink" title="获取亚像素数据"></a>获取亚像素数据</h2><p><code>get_ref()</code> 函数用于获取亚像素数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> x264_hpel_ref0[<span class="number">16</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> x264_hpel_ref1[<span class="number">16</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运动矢量中亚像素的部分的数据</span></span><br><span class="line"><span class="comment">// 可以是半像素数据或者 1/4 像素数据</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> pixel *<span class="title">get_ref</span><span class="params">( pixel *dst,   <span class="keyword">intptr_t</span> *i_dst_stride,</span></span></span><br><span class="line"><span class="function"><span class="params">                       pixel *src[<span class="number">4</span>], <span class="keyword">intptr_t</span> i_src_stride,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> mvx, <span class="keyword">int</span> mvy,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> i_width, <span class="keyword">int</span> i_height, <span class="keyword">const</span> <span class="keyword">x264_weight_t</span> *weight )</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * qpel_idx 为 hpel_ref0[]，hpel_ref1[] 的索引值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 运动矢量 (mvy,mvx) 位置和 qpel_idx 对应关系如下</span></span><br><span class="line"><span class="comment">     *  0pixel |   0p   | 1/4p   | 1/2p   | 3/4p   | 1pixel |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *      0p | 0&lt;&lt;2+0 | 0&lt;&lt;2+1 | 0&lt;&lt;2+2 | 0&lt;&lt;2+3 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *    1/4p | 1&lt;&lt;2+0 | 1&lt;&lt;2+1 | 1&lt;&lt;2+2 | 1&lt;&lt;2+3 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *    1/2p | 2&lt;&lt;2+0 | 2&lt;&lt;2+1 | 2&lt;&lt;2+2 | 2&lt;&lt;2+3 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *    3/4p | 3&lt;&lt;2+0 | 3&lt;&lt;2+1 | 3&lt;&lt;2+2 | 3&lt;&lt;2+3 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *  1pixel |</span></span><br><span class="line"><span class="comment">     * --------+</span></span><br><span class="line"><span class="comment">     * 计算出来后</span></span><br><span class="line"><span class="comment">     *  0pixel |   0p   | 1/4p   | 1/2p   | 3/4p   | 1pixel |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *      0p |      0 |      1 |      2 |      3 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *    1/4p |      4 |      5 |      6 |      7 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *    1/2p |      8 |      9 |     10 |     11 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *    3/4p |     12 |     13 |     14 |     15 |        |</span></span><br><span class="line"><span class="comment">     * --------+--------+--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment">     *  1pixel |</span></span><br><span class="line"><span class="comment">     * --------+</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> qpel_idx = ((mvy&amp;<span class="number">3</span>)&lt;&lt;<span class="number">2</span>) + (mvx&amp;<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// offset 是匹配块相对当前宏块的整数偏移量</span></span><br><span class="line">    <span class="keyword">int</span> offset = (mvy&gt;&gt;<span class="number">2</span>)*i_src_stride + (mvx&gt;&gt;<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// src[4] 中有 4 个分量，分别代表：整像素点 Full，水平半像素点 H，垂直半像素点 V，对角线半像素点 C 的取值</span></span><br><span class="line">    <span class="comment">// 几种半像素点的值已经提前计算出来，而 1/4 像素点的值则是临时计算</span></span><br><span class="line">    <span class="comment">// 注意上述几种半像素点是按照 &quot;分量&quot; 的方式存储的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// src1[] 为选择后的半像素数据</span></span><br><span class="line">    <span class="comment">// 选择了 Full,H,V,C 几种 &quot;分量&quot; 中的 1 种</span></span><br><span class="line">    pixel *src1 = src[x264_hpel_ref0[qpel_idx]] + offset + ((mvy&amp;<span class="number">3</span>) == <span class="number">3</span>) * i_src_stride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// qpel_idx &amp; 5，5 是 0101， 代表 qpel_idx 最后 1 位（对应 x 分量）为 1 或者倒数第 3 位为 1（对应 y 分量）</span></span><br><span class="line">    <span class="comment">// 即 x 或者 y 中有 1/4 或者 3/4 像素点（此时需要 1/4 像素内插）</span></span><br><span class="line">    <span class="comment">// 只有需要 1/4 内插的点才会 qpel_idx &amp; 5!=0。这时候需要通过线性内插获得 1/4 像素点的值</span></span><br><span class="line">    <span class="keyword">if</span> (qpel_idx &amp; <span class="number">5</span>) <span class="comment">/* qpel interpolation needed */</span> &#123;</span><br><span class="line">        <span class="comment">// src2[] 为用于内插的数据另一组数据</span></span><br><span class="line">        pixel *src2 = src[x264_hpel_ref1[qpel_idx]] + offset + ((mvx&amp;<span class="number">3</span>) == <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 进行 1/4 像素线性内插</span></span><br><span class="line">        pixel_avg( dst, *i_dst_stride, src1, i_src_stride,</span><br><span class="line">                   src2, i_src_stride, i_width, i_height );</span><br><span class="line">        <span class="keyword">if</span> (weight-&gt;weightfn )</span><br><span class="line">            mc_weight(dst, *i_dst_stride, dst, *i_dst_stride, weight, i_width, i_height);</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weight-&gt;weightfn ) &#123;</span><br><span class="line">        mc_weight(dst, *i_dst_stride, src1, i_src_stride, weight, i_width, i_height);</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *i_dst_stride = i_src_stride; <span class="comment">// 只需要半像素滤波</span></span><br><span class="line">        <span class="keyword">return</span> src1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>x264</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - CAVLC</title>
    <url>/post/2020/4f888bde/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>CAVLC(Context-based Adaptive Variable-Length Code)</code>：基于上下文的可变长度编码，是 <code>H.264</code> 中进行 <code>4x4</code> 像素块进行熵编码的方法，基本 (baseline) 档次中只能使用 <code>CAVLC</code>，只有主要 (main) 档次和扩展 (extern) 档次才能使用 <code>CABAC</code>。</p>
<a id="more"></a>
<blockquote>
<p>CLBAC 编码详见：<a href="#">Post not found: 编解码技术：H264 - CABAC</a></p>
</blockquote>
<h2 id="CAVLC-的基本原理"><a href="#CAVLC-的基本原理" class="headerlink" title="CAVLC 的基本原理"></a>CAVLC 的基本原理</h2><p>在 <code>H.264</code> 的 <code>CAVLC</code> 中，通过根据已编码句法元素的情况动态调整编码中使用的码表，取得了极高的压缩比。</p>
<p><code>CAVLC</code> 用于亮度和色度残差数据的编码。残差经过变换量化后的数据表现出如下特性：<code>4*4</code> 块数据经过预测、变换、量化后，非零系数主要集中在低频部分，而高频系数大部分是零；量化后的数据经过<code>zig-zag</code> 扫描，<code>DC</code> 系数附近的非零系数值较大，而高频位置上的非零系数值大部分是 <code>+1</code> 和<br><code>-1</code>；相邻的 <code>4*4</code> 块的非零系数的数目是相关的。<code>CAVLC</code> 充分利用残差经过整数变换、量化后数据的特性进行压缩，进一步减少数据中的冗余信息，为 <code>H.264</code> 卓越的编码效率奠定了基础。</p>
<h2 id="CAVLC-的上下文模型"><a href="#CAVLC-的上下文模型" class="headerlink" title="CAVLC 的上下文模型"></a>CAVLC 的上下文模型</h2><p>利用相邻已编码符号所提供的相关性，为所要编码的符号选择合适的上下文模型。利用合适的上下文模型，就可以大大降低符号间的冗余度。在 <code>CAVLC</code> 中上下文模型的选择主要体现在两个方面, 非零系数编码所需表格的选择以及拖尾系数后缀长度的更新，以下有详细的论述。</p>
<h2 id="CAVLC-的编码过程"><a href="#CAVLC-的编码过程" class="headerlink" title="CAVLC 的编码过程"></a>CAVLC 的编码过程</h2>]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读 x264 - 量化</title>
    <url>/post/2021/6f5ffb09/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>x264</code> 中 <code>x264_quant_init</code> 函数中初始化了量化有关的函数，本文分析部分量化函数的实现</p>
<a id="more"></a>
<p>量化是 <code>H.264</code> 视频压缩编码中对视频质量影响最大的地方，也是会导致信息丢失的地方。量化的原理可以表示为下面公式：</p>
<script type="math/tex; mode=display">FQ = round(y / Qstep)</script><p>其中:</p>
<ul>
<li>$y$ 为输入样本点编码</li>
<li>$Qstep$ 为量化步长</li>
<li>$FQ$ 为 $y$ 的量化值</li>
<li>$round()$ 为取整函数（其输出为与输入实数最近的整数）</li>
</ul>
<p>其相反过程，即反量化为：</p>
<script type="math/tex; mode=display">y' = FQ \times Qstep</script><p>如果 <code>Qstep</code> 较大，则量化值 <code>FQ</code> 取值较小，其相应的编码长度较小，但是但反量化时损失较多的图像细节信息。简而言之，<code>Qstep</code> 越大，视频压缩编码后体积越小，视频质量越差。</p>
<p>在 <code>H.264</code> 中，量化步长 <code>Qstep</code> 共有 <code>52</code> 个值，如下表所示。其中 <code>QP</code> 是量化参数，是量化步长的序号。当 <code>QP</code> 取最小值 0 时代表最精细的量化，当 <code>QP</code> 取最大值 51 时代表最粗糙的量化。<code>QP</code> 每增加 6，<code>Qstep</code> 增加一倍。</p>
<h3 id="x264-quant-init"><a href="#x264-quant-init" class="headerlink" title="x264_quant_init"></a>x264_quant_init</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x264_quant_init</span><span class="params">(<span class="keyword">x264_t</span> *h, <span class="keyword">uint32_t</span> cpu, <span class="keyword">x264_quant_function_t</span> *pf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pf-&gt;quant_8x8 = quant_8x8;                              <span class="comment">// 针对 8x8DCT 的量化</span></span><br><span class="line">    pf-&gt;quant_4x4 = quant_4x4;                              <span class="comment">// 量化 4x4=16 个</span></span><br><span class="line">    pf-&gt;quant_4x4x4 = quant_4x4x4;                          <span class="comment">// 处理 4 个 4x4 的块</span></span><br><span class="line">    <span class="comment">//Intra16x16 中，16 个 DC 系数 Hadamard 变换后对的它们量化</span></span><br><span class="line">    pf-&gt;quant_4x4_dc = quant_4x4_dc;</span><br><span class="line">    pf-&gt;quant_2x2_dc = quant_2x2_dc;</span><br><span class="line"></span><br><span class="line">    pf-&gt;dequant_4x4 = dequant_4x4;                          <span class="comment">// 反量化 4x4=16 个</span></span><br><span class="line">    pf-&gt;dequant_4x4_dc = dequant_4x4_dc;                    <span class="comment">// 处理 4 个 4x4 的块</span></span><br><span class="line">    pf-&gt;dequant_8x8 = dequant_8x8;                          <span class="comment">// 针对 8x8DCT 的反量化</span></span><br><span class="line">    <span class="comment">// Intra16x16 中，16 个 DC 系数 Hadamard 变换后对的它们反量化</span></span><br><span class="line">    pf-&gt;idct_dequant_2x4_dc = idct_dequant_2x4_dc;</span><br><span class="line">    pf-&gt;idct_dequant_2x4_dconly = idct_dequant_2x4_dconly;</span><br><span class="line"></span><br><span class="line">    pf-&gt;optimize_chroma_2x2_dc = optimize_chroma_2x2_dc;</span><br><span class="line">    pf-&gt;optimize_chroma_2x4_dc = optimize_chroma_2x4_dc;</span><br><span class="line"></span><br><span class="line">    pf-&gt;denoise_dct = denoise_dct;</span><br><span class="line">    pf-&gt;decimate_score15 = decimate_score15;</span><br><span class="line">    pf-&gt;decimate_score16 = decimate_score16;</span><br><span class="line">    pf-&gt;decimate_score64 = decimate_score64;</span><br><span class="line"></span><br><span class="line">    pf-&gt;coeff_last4 = coeff_last4;</span><br><span class="line">    pf-&gt;coeff_last8 = coeff_last8;</span><br><span class="line">    pf-&gt;coeff_last[DCT_LUMA_AC] = coeff_last15;</span><br><span class="line">    pf-&gt;coeff_last[DCT_LUMA_4x4] = coeff_last16;</span><br><span class="line">    pf-&gt;coeff_last[DCT_LUMA_8x8] = coeff_last64;</span><br><span class="line">    pf-&gt;coeff_level_run4 = coeff_level_run4;</span><br><span class="line">    pf-&gt;coeff_level_run8 = coeff_level_run8;</span><br><span class="line">    pf-&gt;coeff_level_run[DCT_LUMA_AC] = coeff_level_run15;</span><br><span class="line">    pf-&gt;coeff_level_run[DCT_LUMA_4x4] = coeff_level_run16;</span><br><span class="line">    <span class="comment">/* 此处省略大量平台的汇编函数初始化代码 */</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<h2 id="quant-4x4"><a href="#quant-4x4" class="headerlink" title="quant_4x4"></a>quant_4x4</h2><p><code>quant_4x4()</code> 用于对 <code>4x4</code> 的 <code>DCT</code> 残差矩阵进行量化。该函数的定义位于 <code>common/quant.c</code>，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 功能：quant_4x4() 用于对 4x4 的 DCT 残差矩阵进行量化 */</span></span><br><span class="line"><span class="comment">// 输入输出都是 dct[16]</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quant_4x4</span><span class="params">(dctcoef dct[<span class="number">16</span>], udctcoef mf[<span class="number">16</span>], udctcoef bias[<span class="number">16</span>] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        QUANT_ONE(dct[i], mf[i], bias[i] );</span><br><span class="line">    <span class="keyword">return</span> !!nz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其中 QUANT_ONE 定义如下 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUANT_ONE(coef, mf, f) &#123; \</span></span><br><span class="line">    <span class="keyword">if</span>((coef) &gt; <span class="number">0</span> ) (coef) = (f + (coef)) * (mf) &gt;&gt; <span class="number">16</span>; \</span><br><span class="line">    <span class="keyword">else</span> (coef) = - ((f - (coef)) * (mf) &gt;&gt; <span class="number">16</span>); \</span><br><span class="line">    nz |= (coef); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>QUANT_ONE()</code> 完成了一个 <code>DCT</code> 系数的量化工作，从 <code>QUANT_ONE()</code> 的定义可以看出，它实现了上文提到的 <code>H.264</code> 标准中的量化公式：</p>
<script type="math/tex; mode=display">\left | Z_{ij}\right | = (\left | W_{ij}\right | \cdot MF + f) >> qbits</script><p>可以看出 <code>quant_4x4()</code> 循环 <code>16</code> 次调用了 <code>QUANT_ONE()</code> 完成了量化工作。并且将 <code>DCT</code> 系数值，<code>MF</code> 值，<code>bias</code> 偏移值直接传递给了该宏。</p>
<h2 id="quant-4x4x4"><a href="#quant-4x4x4" class="headerlink" title="quant_4x4x4"></a>quant_4x4x4</h2><p><code>quant_4x4x4()</code> 用于对 4 个 4x4 的 DCT 残差矩阵进行量化。该函数的定义位于 <code>common/quant.c</code>，从 <code>quant_4x4x4()</code> 的定义可以看出，该函数相当于调用了 4 次 <code>quant_4x4()</code> 函数。对应的代码分析如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对 4 个 4x4 的 DCT 残差矩阵进行量化, 从 quant_4x4x4() 的定义可以看出，该函数相当于调用了 4 次 quant_4x4() 函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quant_4x4x4</span><span class="params">(dctcoef dct[<span class="number">4</span>][<span class="number">16</span>], udctcoef mf[<span class="number">16</span>], udctcoef bias[<span class="number">16</span>] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nza = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            QUANT_ONE(dct[j][i], mf[i], bias[i] );</span><br><span class="line">        nza |= (!!nz)&lt;&lt;j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="quant-8x8"><a href="#quant-8x8" class="headerlink" title="quant_8x8"></a>quant_8x8</h2><p><code>quant_8x8()</code> 函数的定义位于 <code>common/quant.c</code> 中，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quant_8x8</span><span class="params">(dctcoef dct[<span class="number">64</span>], udctcoef mf[<span class="number">64</span>], udctcoef bias[<span class="number">64</span>] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">        QUANT_ONE(dct[i], mf[i], bias[i] );</span><br><span class="line">    <span class="keyword">return</span> !!nz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/leixiaohua1020/article/details/45644367">x264 源代码简单分析：编码器主干部分 - 1 雷霄骅的专栏 - CSDN 博客</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>x264</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - Level</title>
    <url>/post/2020/3552c034/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="H-264-Level"><a href="#H-264-Level" class="headerlink" title="H.264 Level"></a>H.264 Level</h2><p>在 H.264 标准中，有许多不同的 “级别” 指定约束，指示配置文件所需的解码器性能程度，这些 “级别” 即为 Level。Level 指定设备可以播放的最大数据速率和视频分辨率。</p>
<p>例如，配置文件中的支持级别将指定解码器可能能够使用的最大图像分辨率、帧速率和比特率。较低的级别意味着较低的分辨率、允许的最大比特率较低以及存储参考帧的内存要求更低。需要符合给定级别的解码器才能解码为该级别和所有较低级别编码的所有位流。</p>
<a id="more"></a>
<h3 id="基础通用-Level-限制"><a href="#基础通用-Level-限制" class="headerlink" title="基础通用 Level 限制"></a>基础通用 Level 限制</h3><p>基础通用 Level 限制的适用于 Baseline, Main and Extended profiles，下表该说明了通用 Level 限制：</p>
<ul>
<li>如果表条目标记为 “-“，则变量的值不受限制，这是在指定 Level 对 Profile 进行位流一致性的要求。</li>
<li>否则，表条目将为相关限制指定变量的值，该限制是对 Level 符合 Profile 的级别的要求。</li>
</ul>
<p>为 Level 能力比较的目的，如果一个 Level 比另一 Level 更接近于下表的表头（表底），该 Level 应认为比另一 Level 更低（高）。</p>
<p>与比特流相一致的 Level 应在语法元素 level_idc 与 constraint_set3_flag 里指明，如下所示：</p>
<ul>
<li>如果 level_idc 等于 11 且 constraint_set3_flag 也等于 1，表明 Level 为 1b 级</li>
<li>否则（level_idc 不等于 11，或 constraint_set3_flag 不等于 1），level_idc 应设为等于下表中 Level 号的 10 倍的值，且 constraint_set3_flag 应设为 0。</li>
</ul>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200809221330.jpg" alt="Level limits"></p>
<h3 id="其他通用-Level-限制"><a href="#其他通用-Level-限制" class="headerlink" title="其他通用 Level 限制"></a>其他通用 Level 限制</h3><p>其他通用 Level 限制的适用于 High, Progressive High, Constrained High, High 10, Progressive High 10,High 4:2:2, High 4:4:4 Predictive, High 10 Intra, High 4:2:2 Intra, High 4:4:4 Intra, and CAVLC 4:4:4 Intra profiles，变量 level_idc 指示比特流符合指定级别：</p>
<p>– 如果 level_idc 等于 9, 表明 Level 为 1b 级<br>– 否则（level_idc 不等于 9）, level_idc 应设为等于上表中 Level 号的 10 倍的值。</p>
<h2 id="不同-Level-最大帧率"><a href="#不同-Level-最大帧率" class="headerlink" title="不同 Level 最大帧率"></a>不同 Level 最大帧率</h2><p>不同 Level 最大帧率举例：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200805232842.jpg" alt="不同 Level 最大帧率举例"></p>
]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - NAL Unit</title>
    <url>/post/2020/f2a4ae37/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="NAL-Unit-简介"><a href="#NAL-Unit-简介" class="headerlink" title="NAL Unit 简介"></a>NAL Unit 简介</h2><p>NAL(Network Abstract Layer), 即网络抽象层。</p>
<p>在 H.264/AVC 视频编码标准中，整个系统框架被分为了两个层面：视频编码层面（VCL, Video Coding Layer）和网络抽象层面（NAL, Network Abstract Layer）。其中，前者负责有效表示视频数据的内容，而后者则负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输。</p>
<p>NAL unit 是 NAL 的基本语法结构，它包含一个字节的头信息和一系列来自 VCL 的称为拓展字节序列载荷（EBSP）的字节流。</p>
<a id="more"></a>
<h2 id="NAL-Unit-结构"><a href="#NAL-Unit-结构" class="headerlink" title="NAL Unit 结构"></a>NAL Unit 结构</h2><p>H.264 标准中规定的一个 NAL Unit 的结构如下图：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200810224434.png" alt="NAL Unit 结构"></p>
<p>从上图可看出，NAL Unit 的结构主要分为两部分：</p>
<ol>
<li>NAL Header</li>
<li>NAL Body</li>
</ol>
<h3 id="NAL-Header"><a href="#NAL-Header" class="headerlink" title="NAL Header"></a>NAL Header</h3><p>对于基本版本的 H.264 标准（不考虑 SVC 和 MVC 扩展），一个 NAL Header 的长度固定为 1 字节，即 8bit。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200810225427.png" alt="NAL Header"></p>
<p>这 8bit 的含义分别如下：</p>
<ul>
<li>forbidden_zero_bit：每一个 NAL Header 的第一个 bit，规定必须为 0；</li>
<li><p>nal_ref_idc：第 2 和 3 位，主要表示 NAL 的优先级。当该值不等于 0 时，表示当前 NAL Unit 中包含了 SPS、PPS 和作为参考帧的 Slice 等重要数据。</p>
<ul>
<li>对于 nal_unit_type 等于 7、8、13、15 的 NAL 单元，nal_ref_idc 不得等于 0</li>
<li>对于 nal_unit_type 等于 5 的 NAL 单元，nal_ref_idc 不得等于 0。</li>
<li>对于所有 nal_unit_type 等于 6、9、10、11 或 12 的 NAL 单元，nal_ref_idc 均应等于 0。</li>
</ul>
</li>
<li><p>nal_unit_type：表示 NAL Unit 的类型，包括 VCL 层和非 VCL 层的多种数据类型。常见的 nal_unit_type 取值见下表：</p>
</li>
</ul>
<!--
![常见 nal_unit_type](https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200810225932.png)
-->
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200811221628.png" alt="常见 nal_unit_type"></p>
<h3 id="NAL-Body"><a href="#NAL-Body" class="headerlink" title="NAL Body"></a>NAL Body</h3><p>在 NAL Header 之后，NAL Unit 的其余部分，即 NAL Body 包含了有效负载数据的封装。从 NAL Body 到实际的语法元素的码流共 3 层封装：</p>
<h4 id="EBSP（扩展字节序列载荷）"><a href="#EBSP（扩展字节序列载荷）" class="headerlink" title="EBSP（扩展字节序列载荷）"></a>EBSP（扩展字节序列载荷）</h4><p>EBSP 全称为 Extended Byte String Payload，等同于 NAL Body 的数据本身。在 EBSP 中包含了一个特殊的字节 emulation_prevention_three_byte(0x03)，表示防止竞争校验字节：</p>
<p>emulation_prevention_three_byte：0x03，设置该值的目的是为了防止 NAL Body 内部出现于 NAL Unit 起始码 0x 00 00 01 或 0x 00 00 00 01 冲突。</p>
<p>当内部的连续 3 字节数据出现了下列情况时：</p>
<pre><code>· 0x 00 00 00
· 0x 00 00 01
· 0x 00 00 02
· 0x 00 00 03
</code></pre><p>在两个 0 字节之后会插入值为 3 的一个字节，形成下列情况：</p>
<pre><code>· 0x 00 00 03 00
· 0x 00 00 03 01
· 0x 00 00 03 02
· 0x 00 00 03 03
</code></pre><p>在进行解析时需要将附加的 03 字节去掉，得到 RBSP 数据。</p>
<h4 id="RBSP（原始字节序列载荷）"><a href="#RBSP（原始字节序列载荷）" class="headerlink" title="RBSP（原始字节序列载荷）"></a>RBSP（原始字节序列载荷）</h4><p>RBSP 全称为 Raw Byte Sequence Payload，相当于 NAL Body 去掉 emulation_prevention_three_byte 之后的数据，是对原始的语法元素码流进一步处理后产生的数据。相比于原始的语法元素码流，RBSP 在末尾添加了 rbsp_trailing_bits() 部分，其主要目的是字节对齐。</p>
<p>rbsp_trailing_bits 结构如下图所示：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200810232046.png" alt="rbsp_trailing_bits"></p>
<p>从图中可以看出，每个 rbsp_trailing_bits() 包括一个 1bit 和若干个 0bit，0bit 的个数不定，以实现字节的对齐。</p>
<h4 id="SODB（数据比特串）"><a href="#SODB（数据比特串）" class="headerlink" title="SODB（数据比特串）"></a>SODB（数据比特串）</h4><p>SODB 全称为 String Of Data Bits，表示 H.264 的语法元素编码完成后的实际的原始二进制码流。SODB 通常不能保证字节对齐。</p>
<h2 id="NAL-Unit-的传输"><a href="#NAL-Unit-的传输" class="headerlink" title="NAL Unit 的传输"></a>NAL Unit 的传输</h2><p>在 H264 编码时，为了方便解码器识别 NAL Unit 的位置，在每个 NAL Unit 前添加3个字节的起始码 0x000001，解码器一旦在码流中检测到起始码，这就说明刚刚解码的 NAL Unit 结束，新的 NAL Unit 即将开始。</p>
<p>为防止 NAL Unit 内部出现 0x000001 数据，H264 采取了一种防竞争机制，即使用 EBSP 替代 RBSP（见上文）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 《 T-REC-H.264-201906-I.pdf 》</li>
<li>[2] 《 新一代视频压缩编码标准 — H264/AVC（第二版）》</li>
<li>[3] 《 H.265/HEVC 视频编码新标准及其拓展 》</li>
</ul>
]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - PPS</title>
    <url>/post/2020/49096de1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="PPS-简介"><a href="#PPS-简介" class="headerlink" title="PPS 简介"></a>PPS 简介</h2><p>除了序列参数集 SPS 之外，H.264 中另一重要的参数集合为图像参数集 Picture Paramater Set(PPS)。通常情况下，PPS 类似于 SPS，在 H.264 的裸码流中单独保存在一个 NAL Unit 中，只是 PPS NAL Unit 的 nal_unit_type 值为 8；而在封装格式中，PPS 通常与 SPS 一起，保存在视频文件的文件头中。</p>
<h2 id="PPS-语法元素及其含义"><a href="#PPS-语法元素及其含义" class="headerlink" title="PPS 语法元素及其含义"></a>PPS 语法元素及其含义</h2><p>在编解码过程中，如果需要使用 PPS 中包含的参数，必须对其中的数据进行解析。其中 H.264 标准协议中规定的 PPS 格式位于文档的 7.3.2.2 部分，如下图所示：</p>
<a id="more"></a>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200815224220.jpg" alt="Picture parameter set RBSP syntax"></p>
<p>其中的每一个语法元素及其含义如下：</p>
<h3 id="必选参数部分"><a href="#必选参数部分" class="headerlink" title="必选参数部分"></a>必选参数部分</h3><h4 id="pic-parameter-set-id"><a href="#pic-parameter-set-id" class="headerlink" title="pic_parameter_set_id"></a>pic_parameter_set_id</h4><p>pic_parameter_set_id 表示当前 PPS 的 id。某个 PPS 在码流中会被相应的 slice 引用，slice 引用 PPS 的方式就是在 Slice header 中保存 PPS 的 id 值。该值的取值范围为 [0,255]。</p>
<h4 id="seq-parameter-set-id"><a href="#seq-parameter-set-id" class="headerlink" title="seq_parameter_set_id"></a>seq_parameter_set_id</h4><p>seq_parameter_set_id 是指活动的序列参数集。变量 seq_parameter_set_id 的值应该在 0 到 31 的范围内（包括 0 和 31）。</p>
<h4 id="entropy-coding-mode-flag"><a href="#entropy-coding-mode-flag" class="headerlink" title="entropy_coding_mode_flag"></a>entropy_coding_mode_flag</h4><p>entropy_coding_mode_flag 用于选取语法元素的熵编码方式，在语法表中由两个标识符代表，具体如下：</p>
<ul>
<li>如果 entropy_coding_mode_flag 等于 0，那么采用语法表中左边的描述符所指定的方法</li>
<li>否则（entropy_coding_mode_flag 等于 1），就采用语法表中右边的描述符所指定的方法</li>
</ul>
<p>例如：在一个宏块语法元素中，宏块类型 mb_type 的语法元素描述符为 “ue(v) | ae(v)”，在 baseline profile 等设置下采用指数哥伦布编码，在 main profile 等设置下采用 CABAC 编码。</p>
<h4 id="bottom-field-pic-order-in-frame-present-flag"><a href="#bottom-field-pic-order-in-frame-present-flag" class="headerlink" title="bottom_field_pic_order_in_frame_present_flag"></a>bottom_field_pic_order_in_frame_present_flag</h4><p>标识位，用于表示另外条带头中的两个语法元素 delta_pic_order_cnt_bottom 和 delta_pic_order_cn 是否存在的标识。这两个语法元素表示了某一帧的底场的 POC 的计算方法。</p>
<h4 id="num-slice-groups-minus1"><a href="#num-slice-groups-minus1" class="headerlink" title="num_slice_groups_minus1"></a>num_slice_groups_minus1</h4><p>num_slice_groups_minus1 加 1 表示一个图像中的条带组数。当 num_slice_groups_minus1 等于 0 时，图像中所有的条带属于同一个条带组。</p>
<h4 id="num-ref-idx-l0-active-minus1"><a href="#num-ref-idx-l0-active-minus1" class="headerlink" title="num_ref_idx_l0_active_minus1"></a>num_ref_idx_l0_active_minus1</h4><p>num_ref_idx_l0_active_minus1 表示参考图像列表 0 的最大参考索引号，该索引号将用来在一幅图像中 num_ref_idx_active_override_flag 等于 0 的条带使用列表 0 预测时，解码该图像的这些条带。当 MbaffFrameFlag 等于 1 时，num_ref_idx_l0_active_minus1 是帧宏块解码的最大索引号值，而 2 * num_ref_idx_l0_active_minus1 + 1 是场宏块解码的最大索引号值。num_ref_idx_l0_active_minus1 的值应该在 0 到 31 的范围内（包括 0 和 31）。</p>
<h4 id="num-ref-idx-l1-active-minus1"><a href="#num-ref-idx-l1-active-minus1" class="headerlink" title="num_ref_idx_l1_active_minus1"></a>num_ref_idx_l1_active_minus1</h4><p>num_ref_idx_l1_active_minus1 与 num_ref_idx_l0_active_minus1 具有同样的定义，只是分别用 11 和列表 1 取代 10 和列表 0。</p>
<h4 id="weighted-pred-flag"><a href="#weighted-pred-flag" class="headerlink" title="weighted_pred_flag"></a>weighted_pred_flag</h4><p>weighted_pred_flag 等于 0 表示加权的预测不应用于 P 和 SP 条带。weighted_pred_flag 等于 1 表示在 P 和 SP 条带中应使用加权的预测。</p>
<h4 id="weighted-bipred-idc"><a href="#weighted-bipred-idc" class="headerlink" title="weighted_bipred_idc"></a>weighted_bipred_idc</h4><p>weighted_bipred_idc 的值应该在 0 到 2 之间（包括 0 和 2）:</p>
<ul>
<li>weighted_bipred_idc 等于 0 表示 B 条带应该采用默认的加权预测。</li>
<li>weighted_bipred_idc 等于 1 表示 B 条带应该采用具体指明的加权预测。</li>
<li>weighted_bipred_idc 等于 2 表示 B 条带应该采用隐含的加权预测。</li>
</ul>
<h4 id="pic-init-qp-minus26"><a href="#pic-init-qp-minus26" class="headerlink" title="pic_init_qp_minus26"></a>pic_init_qp_minus26</h4><p>pic_init_qp_minus26 表示每个条带的 SliceQPY 初始值减 26。当解码非 0 值的 slice_qp_delta 时，该初始值在条带层被修正，并且在宏块层解码非 0 值的 mb_qp_delta 时进一步被修正。pic_init_qp_minus26 的值应该在 -(26 + QpBdOffsetY) 到 +25 之间（包括边界值）。</p>
<h4 id="pic-init-qs-minus26"><a href="#pic-init-qs-minus26" class="headerlink" title="pic_init_qs_minus26"></a>pic_init_qs_minus26</h4><p>pic_init_qs_minus26 表示在 SP 或 SI 条带中的所有宏块的 SliceQSY 初始值减 26。当解码非 0 值的 slice_qs_delta 时，该初始值在条带层被修正。pic_init_qs_minus26 的值应该在 -26 到 +25 之间（包括边界值）。</p>
<h4 id="chroma-qp-index-offset"><a href="#chroma-qp-index-offset" class="headerlink" title="chroma_qp_index_offset"></a>chroma_qp_index_offset</h4><p>chroma_qp_index_offset 表示为在 QPC 值的表格中寻找 Cb 色度分量而应加到参数 QPY 和 QSY 上的偏移。chroma_qp_index_offset 的值应在 -12 到 +12 范围内（包括边界值）。</p>
<h4 id="deblocking-filter-control-present-flag"><a href="#deblocking-filter-control-present-flag" class="headerlink" title="deblocking_filter_control_present_flag"></a>deblocking_filter_control_present_flag</h4><ul>
<li>deblocking_filter_control_present_flag 等于 1 表示控制去块效应滤波器的特征的一组语法元素将出现在条带头中。</li>
<li>deblocking_filter_control_present_flag 等于 0 表示控制去块效应滤波器的特征的一组语法元素不会出现在条带头中，并且它们的推定值将会生效。</li>
</ul>
<h4 id="constrained-intra-pred-flag"><a href="#constrained-intra-pred-flag" class="headerlink" title="constrained_intra_pred_flag"></a>constrained_intra_pred_flag</h4><ul>
<li>constrained_intra_pred_flag 等于 0 表示帧内预测允许使用残余数据，且使用帧内宏块预测模式编码的宏块的预测可以使用帧间宏块预测模式编码的相邻宏块的解码样值。</li>
<li>constrained_intra_pred_flag 等于 1 表示受限制的帧内预测，在这种情况下，使用帧内宏块预测模式编码的宏块的预测仅使用残余数据和来自 I 或 SI 宏块类型的解码样值。</li>
</ul>
<h4 id="redundant-pic-cnt-present-flag"><a href="#redundant-pic-cnt-present-flag" class="headerlink" title="redundant_pic_cnt_present_flag"></a>redundant_pic_cnt_present_flag</h4><ul>
<li>redundant_pic_cnt_present_flag 等于 0 表示 redundant_pic_cnt 语法元素不会在条带头、图像参数集中指明（直接或与相应的数据分割块 A 关联）的数据分割块 B 和数据分割块 C 中出现。</li>
<li>redundant_pic_cnt_present_flag 等于 1 表示 redundant_pic_cnt 语法元素将出现在条带头、图像参数集中指明（直接或与相应的数据分割块 A 关联）的数据分割块 B 和数据分割块 C 中。</li>
</ul>
<h3 id="可选参数部分"><a href="#可选参数部分" class="headerlink" title="可选参数部分"></a>可选参数部分</h3><h4 id="slice-group-map-type"><a href="#slice-group-map-type" class="headerlink" title="slice_group_map_type"></a>slice_group_map_type</h4><p>slice_group_map_type 表示条带组中条带组映射单元的映射是如何编码的。lice_group_map_type 的取值范围应该在 0 到 6 内（包括 0 和 6）。</p>
<ul>
<li>slice_group_map_type 等于 0 表示隔行扫描的条带组。</li>
<li>slice_group_map_type 等于 1 表示一种分散的条带组映射。</li>
<li>slice_group_map_type 等于 2 表示一个或多个前景条带组和一个残余条带组。</li>
<li>slice_group_map_type 的值等于 3、4 和 5 表示变换的条带组。当 num_slice_groups_minus1 不等于 1 时，slice_group_map_type 不应等于 3、4 或 5。</li>
<li>slice_group_map_type 等于 6 表示对每个条带组映射单元清楚地分配一个条带组。条带组映射单元规定如下：<ul>
<li>如果 frame_mbs_only_flag 等于 0，mb_adaptive_frame_field_flag 等于 1，而且编码图像是一个帧，那么条带组映射单元就是宏块对单元。</li>
<li>否则，如果 frame_mbs_only_flag 等于 1 或者一个编码图像是一个场，条带组映射单元就是宏块的单元。</li>
<li>否则（frame_mbs_only_flag 等于 0， mb_adaptive_frame_field_flag 等于 0，并且编码图像是一个帧），条带组映射单元就是像在一个 MBAFF 帧中的一个帧宏块对中一样垂直相邻的两个宏块的单元。</li>
</ul>
</li>
</ul>
<h4 id="run-length-minus1"><a href="#run-length-minus1" class="headerlink" title="run_length_minus1"></a>run_length_minus1</h4><p>run_length_minus1[i] 用来指定条带组映射单元的光栅扫描顺序中分配给第 i 个条带组的连续条带组映射单元的数目。run_length_minus1[i] 的取值范围应该在 0 到 PicSizeInMapUnits – 1 内（包括边界值）。</p>
<h4 id="top-left-bottom-right"><a href="#top-left-bottom-right" class="headerlink" title="top_left, bottom_right"></a>top_left, bottom_right</h4><p>top_left[i] 和 bottom_right[i] 分别表示一个矩形的左上角和右下角。top_left[i] 和 bottom_right[i] 是条带组映射单元所在图像的光栅扫描中的条带组映射单元位置。对于每个矩形 i，语法元素 top_left[i] 和 bottom_right[i] 的值都应该遵从下面所有的规定。</p>
<ul>
<li><code>top_left[i] &lt;= bottom_right[i] &amp;&amp; bottom_right[i] &lt; PicSizeInMapUnits</code></li>
<li><code>(top_left[i] % PicWidthInMbs) &lt; (bottom_right[i] % PicWidthInMbs)</code></li>
</ul>
<h2 id="PPS-示例"><a href="#PPS-示例" class="headerlink" title="PPS 示例"></a>PPS 示例</h2><pre><code>0000   68 ee 3c 80                                       h.&lt;.

============================= Wirshark 解析 =============================
H.264
    NAL unit header or first byte of the payload
        0... .... = F bit: No bit errors or other syntax violations
        .11. .... = Nal_ref_idc (NRI): 3
        ...0 1000 = Type: NAL unit - Picture parameter set (8)
    H264 NAL Unit Payload
        1... .... = pic_parameter_set_id: 0
        .1.. .... = seq_parameter_set_id: 0
        ..1. .... = entropy_coding_mode_flag: 1
        ...0 .... = pic_order_present_flag: 0
        .... 1... = num_slice_groups_minus1: 0
        .... .1.. = num_ref_idx_l0_active_minus1: 0
        .... ..1. = num_ref_idx_l1_active_minus1: 0
        .... ...0 = weighted_pred_flag: 0
        00.. .... = weighted_bipred_idc: 0
        ..1. .... = pic_init_qp_minus26: 0
        ...1 .... = pic_init_qs_minus26: 0
        .... 1... = chroma_qp_index_offset: 0
        .... .1.. = deblocking_filter_control_present_flag: 1
        .... ..0. = constrained_intra_pred_flag: 0
        .... ...0 = redundant_pic_cnt_present_flag: 0
        1... .... = rbsp_stop_bit: 1
        .000 0000 = rbsp_trailing_bits: 0
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 《 T-REC-H.264-201906-I.pdf 》</li>
<li>[2] <a href="https://zhuanlan.zhihu.com/p/27896239">H264 码流中 SPS PPS 详解 - 知乎</a></li>
<li>[3] 《 新一代视频压缩编码标准 — H264/AVC（第二版）》</li>
</ul>
]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - Profile</title>
    <url>/post/2020/5224fbf9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="H-264-Profiles"><a href="#H-264-Profiles" class="headerlink" title="H.264 Profiles"></a>H.264 Profiles</h2><p>2003 年，MPEG 完成了称为 MPEG-4 第 10 部分（H.264）的压缩标准的第一个版本。虽然 H.264 并不是唯一的压缩方法，但它已成为录制、压缩和流式处理高清视频最常用的格式。</p>
<p>H.264 是一个 “系列” 标准，包括许多不同的功能集， 即 profiles。所有的 profile 都严重依赖时态压缩和运动预测来减少帧数。最常用的三个配置文件是 Baseline, Main 和 High。每个 profile 定义用于压缩文件的特定编码技术和算法。</p>
<a id="more"></a>
<h3 id="Baseline-Profile"><a href="#Baseline-Profile" class="headerlink" title="Baseline Profile"></a>Baseline Profile</h3><h4 id="Baseline-Profile-简介"><a href="#Baseline-Profile-简介" class="headerlink" title="Baseline Profile 简介"></a>Baseline Profile 简介</h4><p>这是最简单的 Profile，主要用于低功耗、低成本设备，包括一些视频会议和移动应用程序。基线配置文件可以达到大约 1000：1 的压缩比，即 1 Gbps 的流可以压缩到大约 1 Mbps。它们使用 4：2：0 色度采样，这意味着颜色信息采样为黑白信息的一半垂直分辨率和水平分辨率的一半。基线配置文件的其他重要功能是使用通用可变长度编码 （UVLC） 和上下文自适应可变长度编码 （CAVLC） 熵编码技术。</p>
<h4 id="Baseline-Profile-约束"><a href="#Baseline-Profile-约束" class="headerlink" title="Baseline Profile 约束"></a>Baseline Profile 约束</h4><p>根据 H264 官方文档，Baseline Profile 有如下限制：</p>
<ul>
<li>只有 I 与 P 条带；</li>
<li>NAL unit 流不应包含取值范围为 2 到 4 的 nal_unit_type，包括 2 与 4；</li>
<li>序列参数集中 frame_mbs_only_flag 应为 1；</li>
<li>语法元素 chroma_format_idc ， bit_depth_luma_minus8, bit_depth_chroma_minus8, qpprime_y_zero_<br>transform_bypass_flag，seq_scaling_matrix_present_flag 不应出现在序列参数集中；</li>
<li>图像参数集中的参数 weighted_pred_flag 与 weighted_bipred_idc 的取值应该为 0；</li>
<li>图像参数集中的参数 entropy_coding_mode_flag 的取值应为 0；</li>
<li>图像参数集中 slice_groups_minus1 取值应该在 0 到 7 之间，包括 0 与 7；</li>
<li>语法元素 transform_8x8_mode_flag，pic_scaling_matrix_present_flag，与 second_chroma_qp_index_offset<br>不应出现在图像参数集中；</li>
<li>语法元素 level_prefix 的取值不应大于 15；</li>
<li>应满足 A.3 节中对于 Baseline Profile 所定义的级别规定。</li>
</ul>
<h4 id="Baseline-Profile-配置"><a href="#Baseline-Profile-配置" class="headerlink" title="Baseline Profile 配置"></a>Baseline Profile 配置</h4><p>Baseline Profile 的 profile_idc 的取值为 66 。</p>
<h4 id="Baseline-Profile-解码"><a href="#Baseline-Profile-解码" class="headerlink" title="Baseline Profile 解码"></a>Baseline Profile 解码</h4><p>与 Baseline Profile 某一级别相一致的解码器应可以对所有满足 profile_idc 等于 66 或 constraint_set0 等于 1，且 level_idc 和 constraint_set3_flag 所表征的级别小于或等于该级别的流进行解码。</p>
<h3 id="Main-Profile"><a href="#Main-Profile" class="headerlink" title="Main Profile"></a>Main Profile</h3><h4 id="Main-Profile-简介"><a href="#Main-Profile-简介" class="headerlink" title="Main Profile 简介"></a>Main Profile 简介</h4><p>Main Profile 包括 Baseline Profile 的所有功能，但改进了帧预测算法。它用于使用 MPEG-4 格式的 SD 数字电视广播，但不包括高清广播。</p>
<h4 id="Main-Profile-约束"><a href="#Main-Profile-约束" class="headerlink" title="Main Profile 约束"></a>Main Profile 约束</h4><p>根据 H264 官方文档，Main Profile 有如下限制：</p>
<ul>
<li>只有 I、P 和 B 条带；</li>
<li>NAL unit 流不应包含从 2 到 4 取值的 nal_unit_type，包括 2 与 4；</li>
<li>不允许任意的条带顺序；</li>
<li>语法元素 hroma_format_idc, bit_depth_luma_minus8, bit_depth_chroma_minus8, qpprime_y_zero_<br>transform_bypass_flag, 与 seq_scaling_matrix_present_flag 不应在序列参数集中出现。</li>
<li>图像参数集中应该具有只等于 0 的 num_slice_groups_minus1；</li>
<li>图像参数集中应该具有只等于 0 的 redundant_pic_cnt_present_flag；</li>
<li>语法元素 transform_8x8_mode_flag, pic_scaling_matrix_present_flag, 与 second_chroma_qp_index_offset 不应出现在图像参数集中；</li>
<li>语法元素 level_prefix 不应大于 15（如果出现时）；<br>– 语法元素 pcm_sample_luma[i] (i = 0..255)，和 pcm_sample_chroma[i] (i = 0..2 <em> MbWidthC </em> MbHeightC − 1) 不应等于 0 (如果出现时)。</li>
<li>应满足 A.3 节中对于 Main Profile 所定义的级别的规定。</li>
</ul>
<h4 id="Main-Profile-配置"><a href="#Main-Profile-配置" class="headerlink" title="Main Profile 配置"></a>Main Profile 配置</h4><p>Main Profile 的 profile_idc 的取值为 77 。</p>
<h4 id="Main-Profile-解码"><a href="#Main-Profile-解码" class="headerlink" title="Main Profile 解码"></a>Main Profile 解码</h4><p>与 Main Profile 某一级别相一致的解码器应可以对所有满足 profile_idc 等于 77 或 constraint_set1 等于 1，且 level_idc 和 constraint_set3_flag 所表征的级别小于或等于该级别的流进行解码。</p>
<h3 id="High-Profile"><a href="#High-Profile" class="headerlink" title="High Profile"></a>High Profile</h3><h4 id="High-Profile-简介"><a href="#High-Profile-简介" class="headerlink" title="High Profile 简介"></a>High Profile 简介</h4><p>H.264 High Profile 是 H.264 系列中最高效、最强大的配置文件，是广播和光盘存储的主要配置文件，尤其是 HDTV 和 Bluray 光盘存储格式。它可以达到约 2000：1 的压缩比。高轮廓还使用可选择 4x4 或 8x8 像素块的自适应变换。例如，4x4 块用于图片中细节密集的部分，而细节很少的部分使用 8x8 块进行压缩。结果是保持视频图像质量，同时将网络带宽要求降低高达 50%。通过应用 H.264 高配置文件压缩，1 Gbps 流可以压缩到大约 512 Kbps。</p>
<h4 id="High-Profile-约束"><a href="#High-Profile-约束" class="headerlink" title="High Profile 约束"></a>High Profile 约束</h4><p>根据 H264 官方文档，High Profile 有如下限制：</p>
<ul>
<li>只有 I，P 与 B 条带；</li>
<li>NAL unit 流不应包含取值为 2 到 4 的 nal_unit_type 参数，包括 2 和 4；</li>
<li>不允许任意的条带顺序；</li>
<li>图像参数集中应有只为 0 的 num_slice_groups_minus1 参数；</li>
<li>图像参数集中应有只为 0 的 redundant_pic_cnt_present_flag 参数；</li>
<li>序列参数集中应有取值为 0 到 1，包括 0 与 1 的 chroma_format_idc 参数；</li>
<li>列参数集中应有只为 0 的 bit_depth_luma_minus8 参数；</li>
<li>序列参数集中应有只为 0 的 bit_depth_chroma_minus8 参数；</li>
<li>序列参数集中应有只为 0 的 qpprime_y_zero_transform_bypass_flag 参数。</li>
<li>应满足 A.3 节中规定的 High Profile 的级别限制。</li>
</ul>
<h4 id="High-Profile-配置"><a href="#High-Profile-配置" class="headerlink" title="High Profile 配置"></a>High Profile 配置</h4><p>High Profile 的 profile_idc 的取值为 100 。</p>
<h4 id="High-Profile-解码"><a href="#High-Profile-解码" class="headerlink" title="High Profile 解码"></a>High Profile 解码</h4><p>与 High Profile 某一级别相一致的解码器应可以对所有满足下列两个条件之一的流进行解码，：</p>
<ul>
<li>Profile_idc 为 77 或 constraint_set1_flag 为 1，并且 level_idc 和 constraint_set3_flag 组合所表征的级别小于或等于该级别的流进行解码。</li>
<li>profile_idc 为 100 并且 level_idc 所表征的级别小于或等于该级别的流进行解码。</li>
</ul>
<h3 id="其他-Profile"><a href="#其他-Profile" class="headerlink" title="其他 Profile"></a>其他 Profile</h3><ul>
<li>Extended profile : profile_idc = 88.</li>
<li>High 10 profile : profile_idc = 110.</li>
<li>High 4:2:2 profile : profile_idc = 122.</li>
<li>High 4:4:4 Predictive profile : profile_idc = 244.</li>
<li>High 10 Intra profile : profile_idc = 100/110.</li>
<li>High 4:2:2 Intra profile : profile_idc = 100/110/122.</li>
<li>High 4:4:4 Intra profile : profile_idc = 44/100/110/122/244.</li>
<li>CAVLC 4:4:4 Intra profile : profile_idc = 44.</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 《 T-REC-H.264-201906-I.pdf 》</li>
<li>[2] 《 T-REC-H.264-200503-S.pdf 官方中文版 》</li>
</ul>
]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - SPS</title>
    <url>/post/2020/4b4fd3b8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SPS-简介"><a href="#SPS-简介" class="headerlink" title="SPS 简介"></a>SPS 简介</h2><p>在 H.264 标准协议中规定了多种不同的 NAL Unit 类型，其中类型 7 表示该 NAL Unit 内保存的数据为 Sequence Paramater Set（序列参数集）。</p>
<p>在 H.264 的各种语法元素中，SPS 中的信息至关重要。如果其中的数据丢失或出现错误，那么解码过程很可能会失败。</p>
<p>SPS 即 Sequence Paramater Set，又称作序列参数集。SPS 中保存了一组编码视频序列 (Coded<br>videosequence) 的全局参数。所谓的编码视频序列即原始视频的一帧一帧的像素数据经过编码之后的结构组成的序列。而每一帧的编码后数据所依赖的参数保存于图像参数集中。一般情况 SPS 和 PPS 的 NAL Unit 通常位于整个码流的起始位置。但在某些特殊情况下，在码流中间也可能出现这两种结构，主要原因可能为：</p>
<ul>
<li>解码器需要在码流中间开始解码</li>
<li>编码器在编码的过程中改变了码流的参数（如图像分辨率等）</li>
</ul>
<a id="more"></a>
<h2 id="SPS-语法元素及其含义"><a href="#SPS-语法元素及其含义" class="headerlink" title="SPS 语法元素及其含义"></a>SPS 语法元素及其含义</h2><p>在编解码过程中，如果需要使用 SPS 中包含的参数，必须对其中的数据进行解析。其中 H.264 标准协议中规定的 SPS 格式位于文档的 7.3.2.1 部分，如下图所示：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200804220842.jpg" alt="Sequence parameter set data syntax"></p>
<p>其中的每一个语法元素及其含义如下：</p>
<h3 id="profile-idc"><a href="#profile-idc" class="headerlink" title="profile_idc"></a>profile_idc</h3><p>标识当前 H.264 码流的 profile，H.264 中定义了三种常用的档次 profile：</p>
<ul>
<li><p>基准档次：baseline profile;</p>
</li>
<li><p>主要档次：main profile;</p>
</li>
<li><p>扩展档次：extended profile;</p>
</li>
</ul>
<blockquote>
<p>参见：<a href="/post/2020/5224fbf9/" title="编解码技术：H264 - Profile">编解码技术：H264 - Profile</a></p>
</blockquote>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>根据上图所示，在 profile_idc 取值为一些特殊值时，存在一些可选参数</p>
<h5 id="chroma-format-idc"><a href="#chroma-format-idc" class="headerlink" title="chroma_format_idc"></a>chroma_format_idc</h5><ul>
<li>chroma_format_idc 是指与亮度取样对应的色度取样。chroma_format_idc 的值应该在 0<br>到 3 的范围内（包括 0 和 3）。</li>
<li>chroma_format_idc 不存在时，应推断其值为 1（4：2：0 的色度格式）。</li>
</ul>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200808192638.jpg" alt="SubWidthC, and SubHeightC values derived from chroma_format_idc and separate_colour_plane_flag"></p>
<h5 id="separate-colour-plane-flag"><a href="#separate-colour-plane-flag" class="headerlink" title="separate_colour_plane_flag"></a>separate_colour_plane_flag</h5><ul>
<li><p>separate_colour_plane_flag 等于 1 表示三个颜色分量 Y、Cb、Cr 分别进行编码。</p>
</li>
<li><p>split_colour_plane_flag 等于 0 表示颜色分量未单独编码。</p>
</li>
</ul>
<p>根据 separate_colour_plane_flag 的值，变量 ChromaArrayType 的值有如下规定：</p>
<ul>
<li>如果 eparate_colour_plane_flag 等于 0，则将 ChromaArrayType 设置为等于 chroma_format_idc。</li>
<li>否则（separate_colour_plane_flag 等于 1），将 ChromaArrayType 设置为等于 0。</li>
</ul>
<h5 id="bit-depth-luma-minus8"><a href="#bit-depth-luma-minus8" class="headerlink" title="bit_depth_luma_minus8"></a>bit_depth_luma_minus8</h5><p>bit_depth_luma_minus8 是指亮度队列样值的比特深度以及亮度量化参数范围的取值偏移 QpBdOffsetY ，如<br>下所示：</p>
<pre><code>BitDepthY = 8 + bit_depth_luma_minus8
QpBdOffsetY = 6 * bit_depth_luma_minus8
</code></pre><ul>
<li>当 bit_depth_luma_minus8 不存在时，应推定其值为 0。</li>
<li>bit_depth_luma_minus8 取值范围应该在 0 到 4 之间（包括 0 和 4）。</li>
</ul>
<h5 id="bit-depth-chroma-minus8"><a href="#bit-depth-chroma-minus8" class="headerlink" title="bit_depth_chroma_minus8"></a>bit_depth_chroma_minus8</h5><p>bit_depth_chroma_minus8 是指色度队列样值的比特深度以及色度量化参数范围的取值偏移 QpBdOffsetC，如下所示：</p>
<pre><code>BitDepthC = 8 + bit_depth_chroma_minus8
QpBdOffsetC = 6 * (bit_depth_chroma_minus8 + residual_colour_transform_flag)
</code></pre><ul>
<li>当 bit_depth_chroma_minus8 不存在时，应推定其值为 0。</li>
<li>bit_depth_chroma_minus8 取值范围应该在 0 到 4 之间（包括 0 和 4）。</li>
</ul>
<blockquote>
<p>当 ChromaArrayType 等于 0 时，在解码过程中不使用 bit_depth_chroma_minus8 的值。特别是，当 separate_colour_plane_flag 等于 1 时，使用亮度分量解码过程将每个颜色平面解码为一个不同的单色图片（除了 比例矩阵的选择）和亮度位深度用于所有三个颜色分量。</p>
</blockquote>
<p>变量 RawMbBits 按下列公式得出：</p>
<pre><code>RawMbBits = 256 * BitDepthY + 2 * MbWidthC * MbHeightC * BitDepthC
</code></pre><h5 id="qpprime-y-zero-transform-bypass-flag"><a href="#qpprime-y-zero-transform-bypass-flag" class="headerlink" title="qpprime_y_zero_transform_bypass_flag"></a>qpprime_y_zero_transform_bypass_flag</h5><ul>
<li>qpprime_y_zero_transform_bypass_flag 等于 1 是指当 QP’Y 等于 0 时变换系数解码过程的变换旁路操作和图像构建过程将会在 H264 官方文档第 8.5 节给出的去块效应滤波过程之前执行。</li>
<li>qpprime_y_zero_transform_bypass_flag 等于 0 是指变换系数解码过程和图像构建过程在去块效应滤波过程之前执行而不使用变换旁路操作。</li>
<li>当 qpprime_y_zero_transform_bypass_flag 没有特别指定时，应推定其值为 0。</li>
</ul>
<h5 id="seq-scaling-matrix-present-flag"><a href="#seq-scaling-matrix-present-flag" class="headerlink" title="seq_scaling_matrix_present_flag"></a>seq_scaling_matrix_present_flag</h5><ul>
<li>seq_scaling_matrix_present_flag 等于 1 表示存在 i = 0..7 的标志 seq_scaling_list_present_flag[i] 。</li>
<li>seq_scaling_matrix_present_flag 等于 0 则表示不存在这些标志并且由 Flat_4x4_16 表示的序列级别的缩放比例列表应被推断出来（对应 i = 0..5），由 Flat_8x8_16 表示的序列级别的缩放比例列表应被推断出来（对应 i = 6..7）。</li>
<li>当 seq_scaling_matrix_present_flag 没有特别指定时，应推定其值为 0。</li>
</ul>
<p>缩放比例列表 Flat_4x4_16 和 Flat_8x8_16 规定如下：<br>    Flat_4x4_16[i] = 16, i = 0..15,<br>    Flat_8x8_16[i] = 16, i = 0..63.</p>
<p>seq_scaling_list_present_flag[i] 等于 1 是指视频序列参数集中存在缩放比例列表 i 的语法结构。<br>seq_scaling_list_present_flag[i] 等于 0 表示视频序列参数集中不存在缩放比例列表 i 的语法结构并且 H264 官方文档表 7-2 中列出的缩放比例序列后退规则集 A 应用于以 i 值为索引的序列级别的缩放比例列表。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200808194737.png" alt="缩放比例列表的记忆名索引号分配以及后退规则的规范"><br><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200808194822.png" alt="默认缩放比例列表 Default_4x4_Intra 和 Default_4x4_Inter 的规范"></p>
<h3 id="constraint-set-flag"><a href="#constraint-set-flag" class="headerlink" title="constraint_set*_flag"></a>constraint_set*_flag</h3><p>constraint_set0_flag ~ constraint_set5_flag 是在编码的档次方面对码流增加的其他一些额外限制性条件：</p>
<h4 id="constraint-set0-flag"><a href="#constraint-set0-flag" class="headerlink" title="constraint_set0_flag"></a>constraint_set0_flag</h4><ul>
<li><p>constraint_set0_flag 等于 1 表示编码视频序列遵守 Baseline profile 的所有约束。</p>
</li>
<li><p>constraint_set0_flag 等于 0 表示编码视频序列可能遵守也可能不遵守条款 Baseline profile 的所有约束。</p>
</li>
</ul>
<h4 id="constraint-set1-flag"><a href="#constraint-set1-flag" class="headerlink" title="constraint_set1_flag"></a>constraint_set1_flag</h4><ul>
<li><p>constraint_set1_flag 等于 1 表示编码视频序列遵守 Main profile 的所有约束。</p>
</li>
<li><p>constraint_set1_flag 等于 0 表示编码视频序列可能遵守也可能不遵守 Main profile 的所有约束。</p>
</li>
</ul>
<h4 id="constraint-set2-flag"><a href="#constraint-set2-flag" class="headerlink" title="constraint_set2_flag"></a>constraint_set2_flag</h4><ul>
<li><p>constraint_set2_flag 等于 1 表示编码视频序列遵守 Extended profile 的所有约束。</p>
</li>
<li><p>constraint_set2_flag 等于 0 表示编码视频序列可能遵守也可能不遵守 Extended profile 的所有约束。</p>
</li>
</ul>
<blockquote>
<p>当 constraint_set0_flag，constraint_set1_flag 或 constraint_set2_flag 中的一个或多个等于 1 时，编码的视频序列必须服从官方文档 附录 A.2 中所有指示的子句的约束。<br>当 profile_idc 等于 44、100、110、122 或 244 时，constraint_set0_flag，constraint_set1_flag 和 constraint_set2_flag 的值都必须等于 0。</p>
</blockquote>
<h4 id="constraint-set3-flag"><a href="#constraint-set3-flag" class="headerlink" title="constraint_set3_flag"></a>constraint_set3_flag</h4><ul>
<li>如果 profile_idc 等于 66、77 或 88 并且 level_ idc 等于 11，constraint_set3_flag 等于 1 是指该比特流遵从 H264 官方文档附件 A 中对 Level 1.1 的所有规定；constraint_set3_flag 等于 0 是指该比特流可以遵从也可以不遵从附件 A 中有关 1b 级别的所有规定。</li>
<li>否则，如果 profile_idc 等于 100 或 110，constraint_set3_flag 等于 1 表示编码视频<br>序列遵循 H264 官方文档附件 A 中针对 High 10 Intra Profile 指定的所有约束，constraint_set3_flag 等于 0 表示编码视频序列可能遵守也可能不遵守这些相应的约束。</li>
<li>否则，如果 profile_idc 等于 122，constraint_set3_flag 等于 1 表示编码视频序列服从<br>H264 官方文档附件 A 中针对高 4：2：2 帧内配置文件指定的所有约束，constraint_set3_flag 等于 0 表示编码的视频序列可能会也可能不会遵守这些相应的约束。</li>
<li>否则，如果 profile_idc 等于 44，constraint_set3_flag 应等于 1。当 profile_idc 等于 44 时，不允许 constraint_set3_flag 的值等于 0。</li>
<li>否则，如果 profile_idc 等于 244，constraint_set3_flag 等于 1 表示编码视频序列服从<br>H264 官方文档附件 A 中针对高 4：4：4 帧内配置文件指定的所有约束，且 constraint_set3_flag 等于 0 表示编码的视频序列可能会也可能不会遵守这些相应的约束。</li>
<li>否则（profile_idc 等于 66、77 或 88，level_idc 不等于 11，或者 profile_idc 不等于 66、77、88、100、110、122、244 或 44），constraint_set3_flag 的值 1 保留给 ITU-T | ISO / IEC。 对于 profile_idc 等于 66、77 或 88，level_idc 不等于 11 的编码视频序列，以及 profile_idc 不等于 66、77、88、100、110、122、244 或 44 的编码视频序列，constraint_set3_flag 应当等于 0，符合本建议书的比特流 | 国际标准。 当 profile_idc 等于 66、77 或 88 且 level_idc 不等于 11 或 profile_idc 不等于 66、77、88、100、110、122、244 或 44 时，解码器应忽略 constraint_set3_flag 的值。</li>
</ul>
<blockquote>
<p>constraint_set4_flag ~ constraint_set5_flag 详见 H.264 官方文档</p>
</blockquote>
<h3 id="level-idc"><a href="#level-idc" class="headerlink" title="level_idc"></a>level_idc</h3><p>标识当前码流的 Level。编码的 Level 定义了某种条件下的最大视频分辨率、最大视频帧率等参数，码流所遵从的 level 由 level_idc 指定。</p>
<blockquote>
<p>参见：<a href="/post/2020/3552c034/" title="编解码技术：H264 - Level">编解码技术：H264 - Level</a></p>
</blockquote>
<h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><h4 id="seq-parameter-set-id"><a href="#seq-parameter-set-id" class="headerlink" title="seq_parameter_set_id"></a>seq_parameter_set_id</h4><p>表示当前的序列参数集的 id。通过该 id 值，图像参数集 pps 可以引用其代表的 sps 中的参数。</p>
<h4 id="log2-max-frame-num-minus4"><a href="#log2-max-frame-num-minus4" class="headerlink" title="log2_max_frame_num_minus4"></a>log2_max_frame_num_minus4</h4><p>这个句法元素主要是为读取另一个句法元素 frame_num 服务的，frame_num 是最重要的句法元素之一，它标识所属图像的解码顺序。可以在句法表看到，frame_num 的解码函数是 ue（v），函数中的 v 在这里指定：</p>
<pre><code>v = log2_max_frame_num_minus4 + 4
</code></pre><p>从另一个角度看，这个句法元素同时也指明了 frame_num 的所能达到的最大值 MaxFrameNum，计算公式为：</p>
<pre><code>MaxFrameNum = 2^(log2_max_frame_num_minus4 + 4)
</code></pre><p>值得注意的是 frame_num 是循环计数的，即当它到达 MaxFrameNum 后又从 0 重新开始新一轮<br>的计数。解码器必须要有机制检测这种循环，不然会引起类似千年虫的问题，在图像的顺序上造成<br>混乱。</p>
<h4 id="pic-order-cnt-type"><a href="#pic-order-cnt-type" class="headerlink" title="pic_order_cnt_type"></a>pic_order_cnt_type</h4><p>表示解码 picture order count(POC) 的方法。POC 是另一种计量图像序号的方式，与 frame_num 有着不同的计算方法。POC 标识图像的播放顺序。由于 H.264 使用了 B 帧预测，使得图像的解码顺序并不一定等于播放顺序，但它们之间存在一定的映射关系。POC 可以由 frame-num 通过映射关系计算得来，也可以索性由编码器显式地传送。H.264 中一共定义了三种 POC 的编码方法，这个句法元素就是用来通知解码器该用哪种方法来计算 POC。而以下的几个句法元素是分别在各种方法中用到的数据。</p>
<p>在如下的视频序列中本句法元素不应该等于 2：</p>
<ul>
<li>一个非参考帧的接入单元后面紧跟着一个非参考图像（指参考帧或参考场）的接入单元</li>
<li>两个分别包含互补非参考场对的接入单元后面紧跟着一个非参考图像的接入单元.</li>
<li>一个非参考场的接入单元后面紧跟着另外一个非参考场, 并且这两个场不能构成一个互补场对</li>
</ul>
<p>本句法元素的取值为 0、1 或 2。</p>
<h4 id="log2-max-pic-order-cnt-lsb-minus4"><a href="#log2-max-pic-order-cnt-lsb-minus4" class="headerlink" title="log2_max_pic_order_cnt_lsb_minus4"></a>log2_max_pic_order_cnt_lsb_minus4</h4><p>用于计算 MaxPicOrderCntLsb 的值，该值表示 POC 的上限。计算公式为：</p>
<pre><code>MaxPicOrderCntLsb = 2^(log2_max_pic_order_cnt_lsb_minus4 + 4)。
</code></pre><p>本句法元素在 pic_order_cnt_type = 0 时使用。</p>
<h4 id="delta-pic-order-always-zero-flag"><a href="#delta-pic-order-always-zero-flag" class="headerlink" title="delta_pic_order_always_zero_flag"></a>delta_pic_order_always_zero_flag</h4><p>本句法元素等于 1 时, 句法元素 delta_pic_order_cnt[0] 和 delta_pic_order_cnt[1] 不在片头出现, 并且它们的值默认为 0;</p>
<p>本句法元素等于 0 时, 上述的两个句法元素将在片头出现。</p>
<h4 id="offset-for-non-ref-pic"><a href="#offset-for-non-ref-pic" class="headerlink" title="offset_for_non_ref_pic"></a>offset_for_non_ref_pic</h4><p>本句法元素被用来计算非参考帧或场的 picture order count(POC), 本句法元素的值应该在 <code>[-231 , 231 – 1]</code> 范围内。</p>
<h4 id="offset-for-top-to-bottom-field"><a href="#offset-for-top-to-bottom-field" class="headerlink" title="offset_for_top_to_bottom_field"></a>offset_for_top_to_bottom_field</h4><p>本句法元素被用来计算帧的底场的 picture order count(POC), 本句法元素的值应该在 <code>[-231 , 231 – 1]</code> 范围内。</p>
<h4 id="num-ref-frames-in-pic-order-cnt-cycle"><a href="#num-ref-frames-in-pic-order-cnt-cycle" class="headerlink" title="num_ref_frames_in_pic_order_cnt_cycle"></a>num_ref_frames_in_pic_order_cnt_cycle</h4><p>本句法元素被用来解码 picture order count(POC), 本句法元素的值应该在 [0,255] 范围内。</p>
<h4 id="offset-for-ref-frame"><a href="#offset-for-ref-frame" class="headerlink" title="offset_for_ref__frame"></a>offset_for_ref__frame</h4><p>offset_for_ref__frame[i] 在 picture order count type=1 时用，用于解码 POC，本句法元素对循环 num_ref_frames_in_pic_order_cycle 中的每一个元素指定一个偏移。</p>
<h4 id="max-num-ref-frames"><a href="#max-num-ref-frames" class="headerlink" title="max_num_ref_frames"></a>max_num_ref_frames</h4><p>用于表示参考帧的最大数目。</p>
<p>解码器可依照这个句法元素的值开辟存储区，这个存储区用于存放已解码的参考帧，H.264 规定最多可用 16 个参考帧，本句法元素的值最大为 16。值得注意的是这个长度以帧为单位，如果在场模式下，应该相应地扩展一倍。</p>
<h4 id="gaps-in-frame-num-value-allowed-flag"><a href="#gaps-in-frame-num-value-allowed-flag" class="headerlink" title="gaps_in_frame_num_value_allowed_flag"></a>gaps_in_frame_num_value_allowed_flag</h4><p>标识位，说明 frame_num 中是否允许不连续的值。</p>
<p>这个句法元素等于 1 时，表示允许句法元素 frame_num 可以不连续。当传输信道堵塞严重时，编码器来不及将编码后的图像全部发出，这时允许丢弃若干帧图像。在正常情况下每一帧图像都有依次连续的 frame_num 值，解码器检查到如果 frame_num 不连续，便能确定有图像被编码器丢弃。这时，解码器必须启动错误掩藏的机制来近似地恢复这些图像，因为这些图像有可能被后续图像用作参考帧。</p>
<p>当这个句法元素等于 0 时，表不允许 frame_num 不连续，即编码器在任何情况下都不能丢弃图像。<br>这时，H.264 允许解码器可以不去检查 frame_num 的连续性以减少计算量。这种情况下如果依然发<br>生 frame_num 不连续，表示在传输中发生丢包，解码器会通过其他机制检测到丢包的发生，然后启<br>动错误掩藏的恢复图像。</p>
<h4 id="pic-width-in-mbs-minus1"><a href="#pic-width-in-mbs-minus1" class="headerlink" title="pic_width_in_mbs_minus1"></a>pic_width_in_mbs_minus1</h4><p>用于计算图像的宽度。单位为宏块个数：</p>
<pre><code>PicWidthInMbs = pic_width_in_mbs_minus1 + 1     /* 以宏块为单位的图像宽度 */
</code></pre><p>通过这个句法元素解码器可以计算得到亮度和色度分量以像素为单位的图像宽度：</p>
<pre><code>PicWidthInSamplesL = PicWidthInMbs * 16         /* 亮度分量图像宽度（像素） */
PicWidthInSamplesC = PicWidthInMbs * MbWidthC   /* 色度分量图像宽度（像素） */
</code></pre><p>H.264 将图像的大小在序列参数集中定义，意味着可以在通信过程中随着序列参数集动态地改变图<br>像的大小，甚至可以将传送的图像剪裁后输出。</p>
<h4 id="pic-height-in-map-units-minus1"><a href="#pic-height-in-map-units-minus1" class="headerlink" title="pic_height_in_map_units_minus1"></a>pic_height_in_map_units_minus1</h4><p>使用 PicHeightInMapUnits 来度量视频中一帧图像的高度。PicHeightInMapUnits 并非图像明确的以像素或宏块为单位的高度，而需要考虑该宏块是帧编码或场编码。PicHeightInMapUnits 和 PicSizeInMapUnits 的计算方式为：</p>
<pre><code>PicHeightInMapUnits = pic_height_in_map_units_minus1 + 1
PicSizeInMapUnits = PicWidthInMbs * PicHeightInMapUnits
</code></pre><p>注意：PicHeightInMapUnits 和 PicSizeInMapUnits 是以 map_unit 为单位。</p>
<h4 id="frame-mbs-only-flag"><a href="#frame-mbs-only-flag" class="headerlink" title="frame_mbs_only_flag"></a>frame_mbs_only_flag</h4><p>标识位，说明宏块的编码方式。</p>
<p>本句法元素等于 1 时表示本序列中所有图像的编码模式都是帧，没有其他编码模式存在；</p>
<p>本句法元素等于 0 时表示本序列中图像的编码模式可能是帧，也可能是场或帧场自适应，某个图像具体是哪一种要由其他句法元素决定。</p>
<p>根据该标识位取值不同，PicHeightInMapUnits 的含义也不同，为 0 时表示一场数据按宏块计算的高度，为 1 时表示一帧数据按宏块计算的高度。</p>
<p>结合 map_unit 的含义，这里给出上一个句法元素 pic_height_in_map_units_minus1 的进一步解析步骤：</p>
<ul>
<li>当 frame_mbs_only_flag 等于 1，pic_height_in_map_units_minus1 指的是一个 picture 中帧的高度；</li>
<li><p>当 frame_mbs_only_flag 等于 0，pic_heght_in_map_units_minus1 指的是一个 picture 中场的高度，所以可以得到如下以宏块为单位的图像高度：</p>
<p>  FrameHeightInMbs = (2 – frame_mbs_only_flag) * PicHeightInMapUnits</p>
</li>
</ul>
<h4 id="mb-adaptive-frame-field-flag"><a href="#mb-adaptive-frame-field-flag" class="headerlink" title="mb_adaptive_frame_field_flag"></a>mb_adaptive_frame_field_flag</h4><p>标识位，说明是否采用了宏块级的帧场自适应编码。当该标识位为 0 时，不存在帧编码和场编码之间的切换；当标识位为 1 时，宏块可能在帧编码和场编码模式之间进行选择。</p>
<p>指明本序列是否属于帧场自适应模式。</p>
<ul>
<li><p>mb_adaptive_frame_field_flag 等于 1 时表明在本序列中的图像如果不是场模式就是帧场自适应模式，</p>
</li>
<li><p>mb_adaptive_frame_field_flag 等于 0 时表示本序列中的图像如果不是场模式就是帧模式。</p>
</li>
</ul>
<p>以下列举了一个序列中可能出现的编码模式：</p>
<ol>
<li>全部是帧，对应于 frame_mbs_only_flag = 1 的情况。</li>
<li>帧和场共存。frame_mbs_only_flag = 0, mb_adaptive_frame_field_flag = 0</li>
<li>帧场自适应和场共存。frame_mbs_only_flag = 0, mb_adaptive_frame_field_flag = 1</li>
</ol>
<p>注意：帧和帧场自适应不能共存在一个序列中。</p>
<h4 id="direct-8x8-inference-flag"><a href="#direct-8x8-inference-flag" class="headerlink" title="direct_8x8_inference_flag"></a>direct_8x8_inference_flag</h4><p>标识位，用于 B_Skip、B_Direct 模式运动矢量的推导计算。</p>
<h4 id="frame-cropping-flag"><a href="#frame-cropping-flag" class="headerlink" title="frame_cropping_flag"></a>frame_cropping_flag</h4><p>标识位，说明是否需要对输出的图像帧进行裁剪，如果是的话，后面紧跟着的四个句法元素分别指出左右、上下裁剪的宽度。</p>
<h4 id="frame-crop-xxx-offset"><a href="#frame-crop-xxx-offset" class="headerlink" title="frame_crop_xxx_offset"></a>frame_crop_xxx_offset</h4><p>如上一句法元素所述，包括：</p>
<ul>
<li>frame_crop_left_offset</li>
<li>frame_crop_right_offset</li>
<li>frame_crop_bottom_offset</li>
<li>frame_crop_bottom_offset</li>
</ul>
<h4 id="vui-parameters-present-flag"><a href="#vui-parameters-present-flag" class="headerlink" title="vui_parameters_present_flag"></a>vui_parameters_present_flag</h4><p>标识位，说明 SPS 中是否存在 VUI 信息。VUI 用以表征视频格式等额外信息。</p>
<h2 id="SPS-示例"><a href="#SPS-示例" class="headerlink" title="SPS 示例"></a>SPS 示例</h2><pre><code>0000   67 4d 00 32 96 35 40 50 01 6b 4d c0 40 40 50 00   gM.2.5@P.kM.@@P.
0010   00 70 80 00 15 f9 00 40                           .p.....@

============================= Wirshark 解析 =============================
H.264
    NAL unit header or first byte of the payload
        0... .... = F bit: No bit errors or other syntax violations
        .11. .... = Nal_ref_idc (NRI): 3
        ...0 0111 = Type: NAL unit - Sequence parameter set (7)
    H264 NAL Unit Payload
        0100 1101 = Profile_idc: Main profile (77)
        0... .... = Constraint_set0_flag: 0
        .0.. .... = Constraint_set1_flag: 0
        ..0. .... = Constraint_set2_flag: 0
        ...0 .... = Constraint_set3_flag: 0
        .... 0... = Constraint_set4_flag: 0
        .... .0.. = Constraint_set5_flag: 0
        .... ..00 = Reserved_zero_2bits: 0
        0011 0010 = Level_id: 50 [Level 5.0 135 Mb/s]
        1... .... = seq_parameter_set_id: 0
        .001 01.. = log2_max_frame_num_minus4: 4
        .... ..1. = pic_order_cnt_type: 0
        .... ...0  0011 01.. = log2_max_pic_order_cnt_lsb_minus4: 12
        .... ..01  0... .... = num_ref_frames: 1
        .1.. .... = gaps_in_frame_num_value_allowed_flag: 1
        ..00 0000  0101 0000  0... .... = pic_width_in_mbs_minus1: 159
        .000 0001  0110 10.. = pic_height_in_map_units_minus1: 89
        .... ..1. = frame_mbs_only_flag: 1
        .... ...1 = direct_8x8_inference_flag: 1
        0... .... = frame_cropping_flag: 0
        .1.. .... = vui_parameters_present_flag: 1
        ..0. .... = aspect_ratio_info_present_flag: 0
        ...0 .... = overscan_info_present_flag: 0
        .... 1... = video_signal_type_present_flag: 1
        .... .101 = video_format: Unspecified video format (5)
        1... .... = video_full_range_flag: 1
        .1.. .... = colour_description_present_flag: 1
        ..00 0000  01.. .... = colour_primaries: 1
        ..00 0000  01.. .... = transfer_characteristics: 1
        ..00 0000  01.. .... = matrix_coefficients: 1
        ..0. .... = chroma_loc_info_present_flag: 0
        ...1 .... = timing_info_present_flag: 1
        .... 0000  0000 0000  0000 0000  0111 0000  1000 .... = num_units_in_tick: 1800
        .... 0000  0000 0000  0001 0101  1111 1001  0000 .... = time_scale: 90000
        .... 0... = fixed_frame_rate_flag: 0
        .... .0.. = nal_hrd_parameters_present_flag: 0
        .... ..0. = vcl_hrd_parameters_present_flag: 0
        .... ...0 = pic_struct_present_flag: 0
        0... .... = bitstream_restriction_flag: 0
        .1.. .... = rbsp_stop_bit: 1
        ..00 0000 = rbsp_trailing_bits: 0
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 《 T-REC-H.264-201906-I.pdf 》</li>
<li>[2] <a href="https://zhuanlan.zhihu.com/p/27896239">H264 码流中 SPS PPS 详解 - 知乎</a></li>
<li>[3] 《 新一代视频压缩编码标准 — H264/AVC（第二版）》</li>
</ul>
]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - Slice</title>
    <url>/post/2020/92167482/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>一个 Slice 包含一帧图像的部分或全部数据，换言之，一帧视频图像可以编码为一个或若干个 Slice。一个 Slice 最少包含一个宏块，最多包含整帧图像的数据。在不同的编码实现中，同一帧图像中所构成的 Slice 数目不一定相同。</p>
<p>在 H.264 中设计 Slice 的目的主要在于防止误码的扩散。因为不同的 slice 之间，其解码操作是独立的。某一个 slice 的解码过程所参考的数据（例如预测编码）不能越过 slice 的边界。</p>
<a id="more"></a>
<h3 id="Slice-的类型"><a href="#Slice-的类型" class="headerlink" title="Slice 的类型"></a>Slice 的类型</h3><p>根据码流中不同的数据类型，H.264 标准中共定义了 5 种 Slice 类型：</p>
<ul>
<li>I slice: 帧内编码的条带；</li>
<li>P slice: 单向帧间编码的条带；</li>
<li>B slice: 双向帧间编码的条带；</li>
<li>SI slice: 切换 I 条带，用于扩展档次中码流切换使用；</li>
<li>SP slice: 切换 P 条带，用于扩展档次中码流切换使用；</li>
</ul>
<p>在 I slice 中只包含 I 宏块，不能包含 P 或 B 宏块；在 P 和 B slice 中，除了相应的 P 和 B 类型宏块之外，还可以包含 I 类型宏块。</p>
<h3 id="Slice-的组成"><a href="#Slice-的组成" class="headerlink" title="Slice 的组成"></a>Slice 的组成</h3><p>每一个 Slice 总体来看都由两部分组成，一部分作为 Slice header，用于保存 Slice 的总体信息（如当前 Slice 的类型等），另一部分为 Slice body，通常是一组连续的宏块结构（或者宏块跳过信息），如下图所示：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200811225155.png" alt="Slice 的组成"></p>
<h3 id="Slice-Header-结构"><a href="#Slice-Header-结构" class="headerlink" title="Slice Header 结构"></a>Slice Header 结构</h3><p>Slice header 中主要保存了当前 slice 的一些全局的信息，slice body 中的宏块在进行解码时需依赖这些信息。Slice Header 结构如下图所示：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200811230024.jpg" alt="Slice Header 结构"></p>
<h3 id="Slice-Header-语义"><a href="#Slice-Header-语义" class="headerlink" title="Slice Header 语义"></a>Slice Header 语义</h3><ul>
<li><p>first_mb_in_slice 表示在条带中第一个宏块的地址。</p>
<p>  当如附件 A 中规定的那样不允许任意的条带顺序时，本条带的 first_mb_in_slice 的值应不小于当前图像的任何在该条带之前（按解码顺序）的其他条带的 first_mb_in_slice 的值。<br>  条带中第一个宏块的地址按如下方式得到：</p>
<ul>
<li>如果 MbaffFrameFlag 等于 0， first_mb_in_slice 就是该条带中第一个宏块的地址，并且 first_mb_in_slice 的值应在 0 到 PicSizeInMbs – 1 的范围内（包括边界值）。</li>
<li>否则（MbaffFrameFlag 等于 1），first_mb_in_slice * 2 就是该条带中的第一个宏块地址，该宏块是该条带中第一个宏块对中的顶宏块，并且 first_mb_in_slice 的值应该在 0 到 PicSizeInMbs / 2 – 1 的范围内（包括边界值）</li>
</ul>
</li>
<li><p>slice_type 表示条带的编码类型：</p>
<p>  <img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200811230957.jpg" alt="Name association to slice_type"></p>
<p>  slice_type 的值在 5 到 9 范围内表示，除了当前条带的编码类型，所有当前编码图像的其他条带的 slice_type 值应与当前条带的 slice_type 值 一样，或者等于当前条带的 slice_type 值减 5。<br>  当 nal_unit_type 等于 5（IDR 图片）时，slice_type 应等于 2、4、7 或 9。<br>  当 max_num_ref_frames 等于 0 时，slice_type 应等于 2、4、7 或 9。</p>
</li>
<li><p>pic_parameter_set_id 指定使用的图像参数集。</p>
<p>  pic_parameter_set_id 的值应该在 0 到 255 范围内（包括 0 和 255）。</p>
</li>
<li><p>frame_num 用作一个图像标识符。</p>
<p>  frame_num 在比特流中应由 log2_max_frame_num_minus4 + 4 个比特表示。关于 frame_num 的规定如下：<br>  变量 PrevRefFrameNum 按如下方式得到：</p>
<ul>
<li>如果当前的图像是一个 IDR 图像， PrevRefFrameNum 将设为 0。</li>
<li><p>否则（当前图像不是一个 IDR 图像），PrevRefFrameNum 设置如下：</p>
<ul>
<li>如果对包含一个非参考图像，且按解码顺序其前面一个访问单元包含一个参考图像的访问单元解码的过程调用 8.2.5.2 节规定的 frame_num 出现中断的解码过程，PrevRefFrameNum 应设为等于最后一个 “不存在的”，由 8.2.5.2 节规定的 frame_num 出现中断的解码过程推定的参考帧的 frame_num 值。</li>
<li>否则 PrevRefFrameNum 设为等于按解码过程包含参考图像的前一个访问单元的 frame_num 值。</li>
</ul>
<p>frame_num 的取值规定如下：</p>
</li>
<li>如果当前图像是一个 IDR 图像， frame_num 应等于 0。</li>
<li><p>否则（当前图像不是一个 IDR 图像），则按解码顺序前一个访问单元包含一个参考图像作为前导参考图像，该访问单元中有基本编码图像，当前图像的 frame_num 值不应等于 PrevRefFrameNum ，除非满足下面所有三个条件：</p>
<ul>
<li>按解码顺序当前图像和前导参考图像属于连续的访问单元。</li>
<li>当前图像和前导参考图像是具有相反奇偶性的参考场。</li>
<li>满足下面的一个或多个条件：<ul>
<li>前导参考图像是一个 IDR 图像</li>
<li>前导参考图像包括一个值等于 5 的 memory_management_control_语法元素<ul>
<li>注：当前导参考图像包括一个 memory_management_control_operation 语法元素等于 5 时，PrevRefFrameNum 应等于 0。</li>
</ul>
</li>
<li>在前导参考图像之前存在一个基本编码图像，并且该基本编码图像的 frame_num 不等于 PrevRefFrameNum。</li>
<li>在前导参考图像之前存在一个基本编码图像，并且该基本编码图像不是一个参考图像。</li>
</ul>
</li>
</ul>
<p>当 frame_num 的值不等于 PrevRefFrameNum 时，下列几条将被应用：</p>
</li>
<li>按解码顺序，不应有任何前面的场或帧当前被标记为 “用于短期参考” 并具有一个 frame_num 值等于由变量 UnusedShortTermFrameNum 按下列公式得出的任何值：<blockquote>
<p>UnusedShortTermFrameNum = (PrevRefFrameNum + 1) % MaxFrameNum while( UnusedShortTermFrameNum != frame_num )<br>UnusedShortTermFrameNum = (UnusedShortTermFrameNum + 1) % MaxFrameNum</p>
</blockquote>
</li>
<li>frame_num 的值规定如下：<ul>
<li>如果 gaps_in_frame_num_value_allowed_flag 等于 0 ， 当前图像的 frame_num 值将等于 (PrevRefFrameNum + 1) % MaxFrameNum。</li>
<li>否则（gaps_in_frame_num_value_allowed_flag 等于 1），下面几条将应用：<ul>
<li>如果 frame_num 大于 PrevRefFrameNum，按解码顺序比特流中在前面参考图像之后应不会有任何非参考图像在当前图像之前，且此段解码序列满足下面两个条件。<ul>
<li>非参考图像的 frame_num 值小于 PrevRefFrameNum。</li>
<li>非参考图像的 frame_num 值大于当前图像的 frame_num 值。</li>
</ul>
</li>
<li>否则（frame_num 小于 PrevRefFrameNum），按解码顺序比特流中在前面参考图像之后应不会有任何非参考图像在当前图像之前，且此段解码序列满足下面两个条件。<ul>
<li>非参考图像的 frame_num 的值小于 PrevRefFrameNum。</li>
<li>非参考图像的 frame_num 值大于当前图像的 frame_num 值。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Slice-Group"><a href="#Slice-Group" class="headerlink" title="Slice Group"></a>Slice Group</h2>]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - 代价计算</title>
    <url>/post/2020/65d41c1f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <code>H264</code> 编码预测时，选择哪种预测方式是一个永远躲避不了的一个问题，我们希望找到一个最优的预测方式，即预测的亮度 / 色度值与真实的亮度 / 色度值最为接近。这就需要有一种计算方法来评价各种预测方式的效果，我们称这种计算方法为代价计算。</p>
<a id="more"></a>
<h2 id="常用代价计算函数"><a href="#常用代价计算函数" class="headerlink" title="常用代价计算函数"></a>常用代价计算函数</h2><h3 id="SAD"><a href="#SAD" class="headerlink" title="SAD"></a>SAD</h3><p><code>SAD(Sum of Absolute Difference)</code> 也可以称为 <code>SAE(Sum of Absolute Error)</code>，即绝对误差和。它的计算方法就是求出两个像素块对应像素点的差值，将这些差值分别求绝对值之后再进行累加。</p>
<h3 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h3><p><code>SSD(Sum of Squared Difference)</code> 也可以称为 <code>SSE(Sum of Squared Error)</code>，即差值的平方和。它和 <code>SAD</code> 的区别在于多了一个平方。</p>
<h3 id="SATD"><a href="#SATD" class="headerlink" title="SATD"></a>SATD</h3><p><code>SATD(Sum of Absolute Transformed Difference)</code> 即 <code>Hadamard</code> 变换后再绝对值求和。它和 <code>SAD</code> 的区别在于多了一个变换。</p>
<h4 id="Hadamard-变换"><a href="#Hadamard-变换" class="headerlink" title="Hadamard 变换"></a>Hadamard 变换</h4><p>阿达马变换（<code>Hadamard transform</code>），是一种广义傅立叶变换，作为变换编码的一种在影片编码当中使用有很久的历史。在近来的影片编码标准中，阿达马变换多被用来计算 <code>SATD</code></p>
<h5 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h5><p>在 <code>H.264</code> 中使用了 <code>4</code> 阶和 <code>8</code> 阶的阿达马变换来计算 <code>SATD</code>，其变换矩阵为：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210121232312.png" alt="4 阶和 8 阶 Hadamard 矩阵"></p>
<h5 id="SATD-计算方法"><a href="#SATD-计算方法" class="headerlink" title="SATD 计算方法"></a>SATD 计算方法</h5><p>当计算 4x4 块 $\begin{bmatrix}L_4\end{bmatrix}$ 的 <code>SATD</code> 时，先使用下面的方法进行二维的 <code>Hadamard</code> 变换</p>
<script type="math/tex; mode=display">\begin{bmatrix}L_4'\end{bmatrix} = \begin{bmatrix}H_4\end{bmatrix} \times \begin{bmatrix}L_4\end{bmatrix}  \times \begin{bmatrix}H_4\end{bmatrix}</script><p>然后计算 $\begin{bmatrix}L_4’\end{bmatrix}$ 所有系数绝对值之和并归一化。</p>
<p>类似的，当计算 8x8 块 $\begin{bmatrix}L_8\end{bmatrix}$ 的 <code>SATD</code> 时，先使用下面的方法进行二维的 <code>Hadamard</code> 变换：</p>
<script type="math/tex; mode=display">\begin{bmatrix}L_8'\end{bmatrix} = \begin{bmatrix}H_8\end{bmatrix} \times \begin{bmatrix}L_8\end{bmatrix} \times \begin{bmatrix}H_8\end{bmatrix}</script><p>然后计算 $\begin{bmatrix}L_8’\end{bmatrix}$ 所有系数绝对值之和并归一化。</p>
<h2 id="H-264-中的代价计算函数选择"><a href="#H-264-中的代价计算函数选择" class="headerlink" title="H.264 中的代价计算函数选择"></a>H.264 中的代价计算函数选择</h2><p><code>H.264</code> 中使用 <code>SAD</code> 和 <code>SATD</code> 进行宏块预测模式的判断。早期的编码器使用 <code>SAD</code> 进行计算，近期的编码器多使用 <code>SATD</code> 进行计算。</p>
<blockquote>
<p>为什么使用 <code>SATD</code> 而不使用 <code>SAD</code> 呢？关键原因在于编码之后码流的大小是和图像块 <code>DCT</code> 变换后频域信息紧密相关的，而和变换前的时域信息关联性小一些。SAD 只能反应时域信息；SATD 却可以反映频域信息，而且计算复杂度也低于 <code>DCT</code> 变换，因此是比较合适的模式选择的依据。</p>
</blockquote>
<p>使用 <code>SAD</code> 进行模式选择的示例如下所示。下面这张图代表了一个普通的 <code>Intra16x16</code> 的宏块的像素。它的下方包含了使用 <code>Vertical</code>，<code>Horizontal</code>，<code>DC</code> 和 <code>Plane</code> 四种帧内预测模式预测的像素。通过计算可以得到这几种预测像素和原始像素之间的 <code>SAD(SAE)</code> 分别为 <code>3985</code>，<code>5097</code>，<code>4991</code>，<code>2539</code>。由于 <code>Plane</code> 模式的 <code>SAD</code> 取值最小，由此可以断定 <code>Plane</code> 模式对于这个宏块来说是最好的帧内预测模式。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200910003000.png" alt="原始图像"></p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200910003018.png" alt="不同方式的帧内预测后图像以及 `SAD` 值"></p>
]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - 基础概念</title>
    <url>/post/2020/977d1006/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="帧-amp-场"><a href="#帧-amp-场" class="headerlink" title="帧 &amp; 场"></a>帧 &amp; 场</h2><p>视频的一场或一帧可用来产生一个编码图像。通常，视频帧可分成两种类型：连续或隔行视频帧。</p>
<p>在电视中，为减少大面积闪烁现象，把一帧分成两个隔行的场。</p>
<p>显然，这时场内邻行之间的时间相关性较强，而帧内邻近行空间相关性强，因此活动量较小或静止的图像宜采用帧编码方式，对活动量较大的运动图像则宜采用场编码方式。</p>
<a id="more"></a>
<h2 id="宏块、条带"><a href="#宏块、条带" class="headerlink" title="宏块、条带"></a>宏块、条带</h2><p>一个编码图像通常划分成若干宏块组成，一个宏块由一个 16×16 亮度像素和附加的一个 8×8 Cb 和一个 8×8 Cr 彩色像素块组成。每个图象中，若干宏块被排列成条带的形式。</p>
<p>I 条带只包含 I 宏块，P 条带可包含 P 和 I 宏块，而 B 条带可包含 B 和 I 宏块。</p>
<p>I 宏块利用从当前条带中已解码的像素作为参考进行帧内预测（不能取其它条带中的已解码像素作为参考进行帧内预测）。</p>
<p>P 宏块利用前面已编码图象作为参考图象进行帧内预测，一个帧内编码的宏块可进一步作宏块的分割：即 16×16、16×8、8×16 或 8×8 亮度像素块（以及附带的彩色像素）；如果选了 8×8 的子宏块，则可再分成各种子宏块的分割，其尺寸为 8×8、8×4、4×8 或 4×4 亮度像素块（以及附带的彩色像素）。</p>
<p>B 宏块则利用双向的参考图象（当前和未来的已编码图象帧）进行帧内预测。</p>
<h2 id="档次和级"><a href="#档次和级" class="headerlink" title="档次和级"></a>档次和级</h2><p>H.264 规定了三种档次，每个档次支持一组特定的编码功能，并支持一类特定的应用。</p>
<ol>
<li>基本档次：利用 I 条带和 P 条带支持帧内和帧间编码，支持利用基于上下文的自适应的变长编码<br> 进行的熵编码（CAVLC）。主要用于可视电话、会议电视、无线通信等实时视频通信；</li>
<li>主要档次：支持隔行视频，采用 B 条带片的帧间编码和采用加权预测的帧内编码；支持利用基于<br> 上下文的自适应的算术编码（CABAC）。主要用于数字广播电视与数字视频存储；</li>
<li>扩展档次：支持码流之间有效的切换（SP 和 SI 条带）、改进误码性能（数据分割），但不支持<br> 隔行视频和 CABAC。</li>
</ol>
<blockquote>
<p>详见：<a href="/post/2020/5224fbf9/" title="编解码技术：H264 - Profile">编解码技术：H264 - Profile</a> 和 <a href="/post/2020/3552c034/" title="编解码技术：H264 - Level">编解码技术：H264 - Level</a></p>
</blockquote>
<h2 id="VCL-和-NAL"><a href="#VCL-和-NAL" class="headerlink" title="VCL 和 NAL"></a>VCL 和 NAL</h2><p>制订 H.264 的主要目标有二个：</p>
<ol>
<li>高的视频压缩比，当初提出的指标是比 H.263，MPEG-4，约为它们的 2 倍，现在都已基本实<br> 现；</li>
<li>良好的网络亲和性，即可适用于各种传输网络。</li>
</ol>
<p>为此，H.264 的功能分为两层，即视频编码层（VCL）和网络提取层（NAL，Network Abstraction<br>Layer）。</p>
<p>VCL 数据即编码处理的输出，它表示被压缩编码后的视频数据序列。在 VCL 数据传输或存<br>储之前，这些编码的 VCL 数据，先被映射或封装进 NAL 单元中。</p>
<p>每个 NAL 单元包括一个原始字节序列负荷（RBSP）、一组对应于视频编码数据的 NAL 头信息。</p>
<p>NAL 单元序列的结构见下图：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200809232753.png" alt="NAL 单元序列的结构"></p>
<blockquote>
<p>详见：<a href="/post/2020/f2a4ae37/" title="编解码技术：H264 - NAL Unit">编解码技术：H264 - NAL Unit</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 《 T-REC-H.264-201906-I.pdf 》</li>
<li>[2] 《 新一代视频压缩编码标准 — H264/AVC（第二版）》</li>
</ul>
]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - 去块效应滤波</title>
    <url>/post/2021/e059d0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们知道现在的主流编码器都是使用基于块的混合编码框架，以编码块为单位进行预测、变换、量化。</p>
<p>这就导致不同的编码块会使用不同的编码参数，进而不同编码重建块之间的存在一定的差异，尤其在编码块边界处较为明显。编码块边界处不连续的现象就是块效应，产生这种效应的原因主要有两个：</p>
<ol>
<li>预测时出现不准的地方称为残量（<code>Residual</code>），残量会利用离散余弦变换（<code>Discrete Cosine Transform, DCT</code>）做量化（<code>Quantization</code>），由于量化与反量化会产生误差，因此会在区块边界上产生视觉上的不连续。</li>
<li>运动补偿，同一个画面内相邻区块可能不是从前几个编码影像中相邻区块获取来做预测，因此造成不连续的现象。同样地，画面内预测的方式也可能会造成影像不连续。</li>
</ol>
<p>这种现象在 <code>QP</code> 较大时比较明显，因此 <code>QP</code> 越大 <code>Deblocking</code> 的强度也越大。</p>
<p>正是由于这种块效应的存在，才需要添加环路滤波器调整相邻的块边缘上的像素值以减轻这种视觉上的不连续感。</p>
<a id="more"></a>
<p>去区块滤波器主要有三个工作，分别是边界强度计算（Boundary Strength Computation）、边界分析（Boundary Analysis）及滤波器应用（Filter Implementation）。</p>
<ol>
<li>边界强度计算：主要是去计算边界强度（Boundary Strength, Bs）这个参数，边界强度呈现出相邻区块边界不连续的程度，而这个参数会跟量化的方式、区块类型、移动向量以及边界取样的梯度有关。</li>
<li>边界分析：因为区块边缘不连续的现象可能真的是对象边缘所产生，并非所谓的人造边界，这个工作主要在判断是否为人造边界。</li>
<li>滤波器的应用：做完前面两个工作可以决定边界强度以及判断是否真的为人造边界，这个工作主要对人造边界依造对应的边界强度选择该应用的滤波器。</li>
</ol>
<h2 id="边界强度"><a href="#边界强度" class="headerlink" title="边界强度"></a>边界强度</h2><p>每一个 4x4 的亮度区块中需要做滤波的区块都会计算出一个边界强度。色度区块的边界强度是对亮度区块已经求得的边界强度做取样，如图所示：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210201230151.png" alt="色度区块的边界强度与亮度区块边界强度的关系"></p>
<p><code>H.264</code> 的边界强度 <code>Bs</code> 的判定方式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>条件（针对两边的图像块）</th>
<th>Bs</th>
</tr>
</thead>
<tbody>
<tr>
<td>若两个区块皆属于帧内预测且边界属于宏区块的边界</td>
<td>4</td>
</tr>
<tr>
<td>有一个块为帧内预测或是不在宏区块的边界上</td>
<td>3</td>
</tr>
<tr>
<td>区块的转换系数非 0</td>
<td>2</td>
</tr>
<tr>
<td>如果使用不同的参考影像或是两个区块间的移动向量大于等于 4</td>
<td>1</td>
</tr>
<tr>
<td>其它</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>《ITU-T Rec. H.264-200305》 8.7.2.1 亮度的依赖内容的边界滤波强度的推导过程</p>
</blockquote>
<p>从上表得出边界强度的判断流程如图所示：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210201231001.png" alt="边界强度的判断流程"></p>
<h2 id="边界分析"><a href="#边界分析" class="headerlink" title="边界分析"></a>边界分析</h2><p>并不是所有的块的边界处都需要环路滤波。例如画面中物体的边界正好和块的边界重合的话，就不能进行滤波，否则会使画面中物体的边界变模糊。因此需要区别开物体边界和块效应边界。一般情况下，物体边界两边的像素值差别很大，而块效应边界两边像素值差别比较小。</p>
<p>边界强度如果大于 0 则对这个边界进行分析，判断是否为人造边界。下图是利用水平滤波器对垂直边界做滤波的示意图，一行有八个点 p3、p2、p1、p0、q0、q1、q2 以及 q3，p0 及 q0 之间为两区块的边界。H.264 标准定义了 2 个变量 <code>α</code> 和 <code>β</code> 来判决边界是否需要进行环路滤波。只有满足下面条件的时候才能进行环路滤波：：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210201221354.png" alt="描述一个 4x4 块横向或者纵向边界的样点的惯例"></p>
<pre><code> Bs != 0
|p0 - q0| &lt;α (IndexA)
|p1 - p0| &lt;β (IndexA)
|q1 - q0| &lt;β (IndexB)
</code></pre><p>简而言之，就是边界两边的两个点的像素值不能太大，即不能超过 <code>α</code>；边界一边的前两个点之间的像素值也不能太大，即不能超过 <code>β</code>。其中 <code>α</code> 和 <code>β</code> 是根据量化参数 <code>QP</code> 推算出来（具体方法不再记录）。总体说来 <code>QP</code> 越大，<code>α</code> 和 <code>β</code> 的值也越大，也就越容易触发环路滤波。由于 <code>QP</code> 越大表明压缩的程度越大，所以也可以得知高压缩比的情况下更需要进行环路滤波。</p>
<p><code>α</code> 与 <code>β</code> 两个函数一般利用查表法计算值，而 <code>IndexA</code> 和 <code>IndexB</code> 计算方式如下</p>
<pre><code>IndexA = Min（Max(0,QP + OffsetA）, 51)
IndexB = Min（Max(0,QP + OffsetB）, 51)
</code></pre><p>其中 <code>OffsetA</code> 和 <code>OffsetB</code> 为编码器的参数，<code>QP</code> 为量化参数（<code>Quantization Parameter</code>）。如果上面四个条件是都成立则 <code>p0</code> 与 <code>q0</code> 之间的边界为人造边界。</p>
]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - 描述符 &amp; 熵编码</title>
    <url>/post/2020/6343ec86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="描述符介绍"><a href="#描述符介绍" class="headerlink" title="描述符介绍"></a>描述符介绍</h2><p>描述符描述了从比特流提取句法元素的方法，即句法元素的解码算法，每个句法元素都有相对应的描述符。由于 H.264 编码的最后一步是熵编码，所以这里的描述子大多是熵编码的解码算法。H.264 定义了如下几种描述符：</p>
<ul>
<li>ae(v)：基于上下文自适应的二进制算术熵编码</li>
<li>b(8)：任意形式的 8 比特字节</li>
<li>ce(v)：基于上下文自适应的可变长熵编码语法元素，左位在先</li>
<li>f(n)：n 位固定模式比特串，左位在先</li>
<li>i(n)/i(v)：n 比特的有符号整数，如果是 i(v)，其比特数由其它语法元素值确定</li>
<li>me(v)：映射指数哥伦布熵编码的语法元素，左位在先</li>
<li>se(v)：有符号整数指数哥伦布熵编码的语法元素，左位在先</li>
<li>te(v)：截断指数哥伦布熵编码语法元素，左位在先</li>
<li>u(n)/u(v)：n 位无符号整数，如果是 u(v)，其比特数由其它语法元素值确定</li>
<li>ue(v)：无符号整数指数哥伦布编码的语法元素，左位在先</li>
</ul>
<a id="more"></a>
<p>从上述列表中看出，大部分的描述符采用了熵编码进行编码，所以我们主要讨论其中涉及到的熵编码方式：</p>
<ul>
<li>指数哥伦布熵编码（Exp-Golomb code）<ul>
<li>无符号整数指数哥伦布编码（unsigned integer Exp-Golomb-code）</li>
<li>有符号整数指数哥伦布熵编码（signed integer Exp-Golomb-code）</li>
<li>映射指数哥伦布熵编码（mapped Exp-Golomb-code）</li>
<li>截断指数哥伦布熵编码（truncated Exp-Golomb-code）</li>
</ul>
</li>
<li>基于上下文自适应的二进制算术熵编码（CABAC）</li>
<li>基于上下文自适应的可变长熵编码（CAVLC）</li>
</ul>
<h2 id="熵编码"><a href="#熵编码" class="headerlink" title="熵编码"></a>熵编码</h2><p>熵编码压缩是一种无损压缩，其实现原理是使用新的编码来表示输入的数据，从而达到压缩的效果。常用的熵编码有游程编码，哈夫曼编码和 CAVLC 编码等。</p>
<h3 id="Exp-Golomb-code"><a href="#Exp-Golomb-code" class="headerlink" title="Exp-Golomb-code"></a>Exp-Golomb-code</h3><p>指数哥伦布码（Exponential-Golomb coding）是一种无损数据压缩方法。</p>
<p>用来表示非负整数的 k 阶指数哥伦布码可用如下步骤生成：</p>
<ol>
<li>将数字以二进制形式写出 (B)，去掉最低的 k 个比特 (D)，之后加 1 (A = B + 1)</li>
<li>计算 A 的比特个数 (C)，将此数减一，即是需要增加的前导零个数 (Z = C -1)</li>
<li>将第一步中去掉的最低 k 个比特位补回比特串尾部 (ExpG = Z 个 0 + A + D)</li>
</ol>
<p>0 阶指数哥伦布编码如下所示：</p>
<pre><code>    Step 1                            Step 2            Step 3
0   =&gt; B = 0,    D = None, A = 1      =&gt; C = 1, Z = 0   =&gt; 1
1   =&gt; B = 1,    D = None, A = 10     =&gt; C = 2, Z = 1   =&gt; 010
2   =&gt; B = 10,   D = None, A = 11     =&gt; C = 2, Z = 1   =&gt; 011
3   =&gt; B = 11,   D = None, A = 100    =&gt; C = 3, Z = 2   =&gt; 00100
4   =&gt; B = 100,  D = None, A = 101    =&gt; C = 3, Z = 2   =&gt; 00101
5   =&gt; B = 101,  D = None, A = 110    =&gt; C = 3, Z = 2   =&gt; 00110
6   =&gt; B = 110,  D = None, A = 111    =&gt; C = 3, Z = 2   =&gt; 00111
7   =&gt; B = 111,  D = None, A = 1000   =&gt; C = 4, Z = 3   =&gt; 0001000
8   =&gt; B = 1000, D = None, A = 1001   =&gt; C = 4, Z = 3   =&gt; 0001001
9   =&gt; B = 1001, D = None, A = 1010   =&gt; C = 4, Z = 3   =&gt; 0001010
</code></pre><p>以数字 9 为例：</p>
<ol>
<li>2 进制值 B 为 1001, 因为 K 为 0 阶，去除 0 个比特，故 D 值为 None，把 B 值加 1 得到 A，值为 1010</li>
<li>计算 A 的比特个数，得到 C 值为 4，故减 1 后得到前导零 Z , 值为 3</li>
<li>最后组合 Z + A + D 之后，得到 000 + 1010 + None ，故 Exp-G 值为 0001010</li>
</ol>
<p>1 阶指数哥伦布编码如下所示：</p>
<pre><code>      Step 1                        Step 2            Step 3
0   =&gt; B = 0,    D = 0, A = 1     =&gt; C = 1, Z = 0   =&gt; 10
1   =&gt; B = 1,    D = 1, A = 1     =&gt; C = 1, Z = 0   =&gt; 11
2   =&gt; B = 10,   D = 0, A = 10    =&gt; C = 2, Z = 1   =&gt; 0100
3   =&gt; B = 11,   D = 1, A = 10    =&gt; C = 2, Z = 1   =&gt; 0101
4   =&gt; B = 100,  D = 0, A = 11    =&gt; C = 2, Z = 1   =&gt; 0110
5   =&gt; B = 101,  D = 1, A = 11    =&gt; C = 2, Z = 1   =&gt; 0111
6   =&gt; B = 110,  D = 0, A = 100   =&gt; C = 3, Z = 2   =&gt; 001000
7   =&gt; B = 111,  D = 1, A = 100   =&gt; C = 3, Z = 2   =&gt; 001001
8   =&gt; B = 1000, D = 0, A = 101   =&gt; C = 3, Z = 2   =&gt; 001010
9   =&gt; B = 1001, D = 1, A = 101   =&gt; C = 3, Z = 2   =&gt; 001011
</code></pre><h4 id="unsigned-integer-Exp-Golomb-code"><a href="#unsigned-integer-Exp-Golomb-code" class="headerlink" title="unsigned integer Exp-Golomb-code"></a>unsigned integer Exp-Golomb-code</h4><p>H264 编码中无符号整数指数哥伦布编码即为标准 0 阶指数哥伦布编码方式：</p>
<ul>
<li><p>编码过程：</p>
<blockquote>
<p>编码过程与 0 阶指数哥伦布编完全相同</p>
</blockquote>
</li>
<li><p>解码过程：</p>
<ol>
<li><p>获取开头 0 字节的个数 leadingZeroBits：</p>
<pre><code> leadingZeroBits = -1;
 for(b = 0; !b; leadingZeroBits++)
     b = read_bits(1)
</code></pre></li>
<li><p>计算编码前数字 unsigncodeNum：</p>
<pre><code> unsigncodeNum = 2 ^ leadingZeroBits − 1 + read_bits(leadingZeroBits)
 注：read_bits(leadingZeroBits) 的返回值使用高位在先的二进制无符号整数表示。
</code></pre><p>例如：解码 0001010 过程如下：</p>
<ol>
<li>read_bits 指向解码二进制流开头：0 001010<br>获取开头 0 字节的个数：leadingZeroBits = 3<br>此时 read_bits 指向了二进制流中首个 1 的后一位：0001 0 10</li>
<li>read_bits(leadingZeroBits) = read_bits(3) = 010 = 2<br>unsigncodeNum = 2 ^ 3 - 1 + 2 = 9</li>
</ol>
</li>
</ol>
</li>
</ul>
<ul>
<li>如果语法元素编码为 te(v)，首先应该判断语法元素的范围。语法元素的范围可以是在 0 和 x 之间，x 大于或者等于 1，语法元素的值按照如下方法取得：<ul>
<li>如果 x 大于 1，codeNum 和语法元素值的取得应该和 ue(v) 相同。</li>
<li>否则 (x 等于 1)，与语法元素值相等的 codeNum 的解析过程由如下计算方法取得：</li>
</ul>
</li>
</ul>
<h4 id="signed-integer-Exp-Golomb-code"><a href="#signed-integer-Exp-Golomb-code" class="headerlink" title="signed integer Exp-Golomb-code"></a>signed integer Exp-Golomb-code</h4><ul>
<li>编码过程：</li>
</ul>
<ul>
<li>如果待编码数据为非正整数，则将待编码数据乘 -2 后进行无符号整数指数哥伦布编码</li>
<li>如果待编码数据为正整数，则将待编码数据乘 2 并减 1 后进行无符号整数指数哥伦布编码</li>
</ul>
<p>有符号整数指数哥伦布熵编码如下所示：</p>
<pre><code>    0   ⇒ 0   ⇒ 1      ⇒ 1
    1   ⇒ 1   ⇒ 10     ⇒ 010
   −1   ⇒ 2   ⇒ 11     ⇒ 011
    2   ⇒ 3   ⇒ 100    ⇒ 00100
   −2   ⇒ 4   ⇒ 101    ⇒ 00101
    3   ⇒ 5   ⇒ 110    ⇒ 00110
   −3   ⇒ 6   ⇒ 111    ⇒ 00111
    4   ⇒ 7   ⇒ 1000   ⇒ 0001000
   −4   ⇒ 8   ⇒ 1001   ⇒ 0001001
</code></pre><ul>
<li>解码过程</li>
</ul>
<p>可以通过简单的计算将 unsigned integer Exp-Golomb-code 得出的 unsigncodeNum 转换为 signedcodeNum：</p>
<pre><code>signedcodeNum = (-1) ^ unsigncodeNum * ⌈ unsigncodeNum ÷ 2 ⌉
</code></pre><h4 id="mapped-Exp-Golomb-code"><a href="#mapped-Exp-Golomb-code" class="headerlink" title="mapped Exp-Golomb-code"></a>mapped Exp-Golomb-code</h4><p>可以通过下表将 unsigned integer Exp-Golomb-code 得出的 unsigncodeNum 映射为 mapcodeNum（）：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200816141139.jpg" alt="Assignment of codeNum to values of coded_block_pattern for macroblock prediction modes"></p>
<h4 id="truncated-Exp-Golomb-code"><a href="#truncated-Exp-Golomb-code" class="headerlink" title="truncated Exp-Golomb-code"></a>truncated Exp-Golomb-code</h4><ul>
<li>编码过程</li>
</ul>
<p>截断指数哥伦布熵编码在编码时先判断待编码值的取值范围的上限 x：</p>
<ul>
<li>如果 x 大于 1，则用 ue(v) 规则直接编码。</li>
<li>如果 x 等于 1，则待编码值为 1 编码后的值为 0，待编码的值为 0 编码后的值为 1。</li>
</ul>
<ul>
<li>解码过程</li>
</ul>
<p>解码时先判断待编码值的取值范围的上限 x：</p>
<ul>
<li>如果 x 大于 1，则用 ue(v) 规则直接解码。</li>
<li>如果 x 等于 1，则待解码值为 1 解码后的值为 0，如果待解码的值为 0 解码后的值为 1。</li>
</ul>
<h3 id="CABAC"><a href="#CABAC" class="headerlink" title="CABAC"></a>CABAC</h3><p>CABAC(ContextAdaptive Binary Arithmatic Coding) 是 H.264/MPEG-4AVC 中使用的熵编码算法。CABAC 在不同的上下文环境中使用不同的概率模型来编码。其编码过程大致是这样：首先，将欲编码的符号用二进制 bit 表示；然后对于每个 bit，编码器选择一个合适的概率模型，并通过相邻元素的信息来优化这个概率模型；最后，使用算术编码压缩数据。</p>
<blockquote>
<p>详见：编解码技术：H264 - CABAC</p>
</blockquote>
<h3 id="CAVLC"><a href="#CAVLC" class="headerlink" title="CAVLC"></a>CAVLC</h3><p>CAVLC(Context Adaptive VariableLength Coding) 是在 H.264/MPEG-4AVC 中使用的熵编码方式。在 H.264 中，CAVLC 以 zig-zag 顺序用于对变换后的残差块进行编码。CAVLC 是 CABAC 的替代品，虽然其压缩效率不如 CABAC，但 CAVLC 实现简单，并且在所有的 H.264 profile 中都支持。</p>
<blockquote>
<p>详见：编解码技术：H264 - CABVLC</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 《 T-REC-H.264-201906-I.pdf 》</li>
<li>[2] 《 新一代视频压缩编码标准 — H264/AVC（第二版）》</li>
<li>[3] <a href="https://en.wikipedia.org/wiki/Exponential-Golomb_coding">Exponential-Golomb coding - Wikipedia</a></li>
</ul>
]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - 帧内预测</title>
    <url>/post/2020/7d82ecd5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在帧内预测模式中，预测块 P 是基于已编码重建块和当前块形成的。对亮度像素而言，P 块用于 4×4 子块或者 16×16 宏块的相关操作。4×4 亮度子块有 9 种可选预测模式，独立预测每一个 4×4 亮度子块，适用于带有大量细节的图像编码；16×16 亮度块有 4 种预测模式，预测整个 16×16 亮度块，适用于平坦区域图像编码；色度块也有 4 种预测模式，类似于 16×16 亮度块预测模式。编码器通常选择使 P 块和编码块之间差异最小的预测模式。</p>
<a id="more"></a>
<h2 id="4×4-亮度预测模式"><a href="#4×4-亮度预测模式" class="headerlink" title="4×4 亮度预测模式"></a>4×4 亮度预测模式</h2><p>如图 1 所示，4×4 亮度块的上方和左方像素 A~Q 为已编码和重构像素，用作编解码器中的<br>预测参考像素。a~p 为待预测像素，利用 A~Q 值和 9 种模式实现。其中模式 2 (DC 预测) 根据 A~Q 中已编码像素预测，而其余模式只有在所需预测像素全部提供才能使用。图 2 箭头表明了每种<br>模式预测方向。对模式 3~8，预测像素由 A~Q 加权平均而得。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200903222127.png" alt="图 1"></p>
<center> 图 1 : a) 利用像素 A-Q 对方块中 a-p 像素进行帧内 4×4 预测 </center>
<center> b) 帧内 4×4 预测的 8 个预测方向 </center>

<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200903222615.png" alt="图 2"></p>
<center> 图 2 : 4×4 亮度块预测模式 </center>

<p>例如，模式 4 中，<code>p = round(b/4+C/2+D/4)</code>。</p>
<p>表 1 给出了这 9 种模式的描述。</p>
<center> 表 1 : 预测模式描述 </center>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式 0（垂直）</td>
<td style="text-align:center">由 A、B、C、D 垂直推出相应像素值</td>
</tr>
<tr>
<td style="text-align:center">模式 1（水平）</td>
<td style="text-align:center">由 I、J、K、L 水平推出相应像素值</td>
</tr>
<tr>
<td style="text-align:center">模式 2（DC）</td>
<td style="text-align:center">由 A~D 及 I~L 平均值推出所有像素值</td>
</tr>
<tr>
<td style="text-align:center">模式 3（左下对角线）</td>
<td style="text-align:center">由 45° 方向像素内插得出相应像素值</td>
</tr>
<tr>
<td style="text-align:center">模式 4（右下对角线）</td>
<td style="text-align:center">由 45° 方向像素内插得出相应像素值</td>
</tr>
<tr>
<td style="text-align:center">模式 5（右垂直）</td>
<td style="text-align:center">由 26.6° 方向像素值内插得出相应像素值</td>
</tr>
<tr>
<td style="text-align:center">模式 6（下水平）</td>
<td style="text-align:center">由 26.6° 方向像素值内插得出相应像素值</td>
</tr>
<tr>
<td style="text-align:center">模式 7（左垂直）</td>
<td style="text-align:center">由 26.6° 方向像素值内插得出相应像素值</td>
</tr>
<tr>
<td style="text-align:center">模式 8（上水平）</td>
<td style="text-align:center">由 26.6° 方向像素值内插得出相应像素值</td>
</tr>
</tbody>
</table>
</div>
<h2 id="16×16-亮度预测模式"><a href="#16×16-亮度预测模式" class="headerlink" title="16×16 亮度预测模式"></a>16×16 亮度预测模式</h2><p>宏块的全部 16×16 亮度成分可以整体预测，有 4 种预测模式，如表 2 和图 3 所示。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200903223829.png" alt="图 3"></p>
<center> 图 3 : 16×16 预测模式 </center>

<center> 表 2 : 16×16 预测模式 </center>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式 0（垂直）</td>
<td style="text-align:center">由上边像素推出相应像素值</td>
</tr>
<tr>
<td style="text-align:center">模式 1（水平）</td>
<td style="text-align:center">由左边像素推出相应像素值</td>
</tr>
<tr>
<td style="text-align:center">模式 2（DC）</td>
<td style="text-align:center">由上边和左边像素平均值推出相应像素值</td>
</tr>
<tr>
<td style="text-align:center">模式 3（平面）</td>
<td style="text-align:center">利用线形 “plane” 函数及左、上像素推出相应像素值，适用于亮度变化平缓区域</td>
</tr>
</tbody>
</table>
</div>
<h2 id="8×8-色度块预测模式"><a href="#8×8-色度块预测模式" class="headerlink" title="8×8 色度块预测模式"></a>8×8 色度块预测模式</h2><p>每个帧内编码宏块的 8×8 色度成分由已编码左上方色度像素预测而得，两种色度成分常用同一<br>种预测模式。4 种预测模式类似于帧内 16×16 预测的 4 种预测模式，只是模式编号不同。其中模式 0（DC）、模式 1（水平）、模式 2（垂直）、模式 3（平面）。</p>
<h2 id="信号化帧内预测模式"><a href="#信号化帧内预测模式" class="headerlink" title="信号化帧内预测模式"></a>信号化帧内预测模式</h2><p>每个 4×4 块帧内预测模式必须转变成信号传给解码器。该信息可能需大量比特表示，但邻近块的帧内模式通常是相关的。例如，A、B、E 分别为左边、上边和当前块，如果 A 和 B 预测模式为模式 1，E 的最佳预测模式很可能也为模式 1。所以通常利用这种关联性信号化 4×4 帧内模式。对每个当前块 E，编码器和解码器计算最可能预测模式和 A、B 预测模式的较小者。如果这些相邻块不被提供（当前片外或者非帧内 4×4 模式），相应值 A 或 B 置 2（DC 预测模式）。编码器分配每个 4×4 块一个标志 prev_intra4×4_pred_mode。该标志置 1 时，使用最可能预测模式；置 0 时，使用参数 rem_intra4×4_pred_mode 来指明模式变化。rem_intra4×4_pred_mode 小于当前最可能模式时，预测模式选 rem_intra4×4_pred_mode。否则预测模式为 rem_intra4×4_pred_mode＋1。rem_intra4×4_pred_mode 值为 0~7。</p>
<p>举例：块 A 和 B 分别用模式 3 和模式 1 预测。最可能模式则为 1，prev_intra4×4_pred_mode 置 0，rem_intra4×4_pred_mode 被传送。取决于 rem_intra4×4_pred_mode 的值，表 6.5 所示的 8 种预测模式中的一种被选定。</p>
<center> 表 3 : 预测模式选择（最可能模式为 1）</center>

<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200903224857.png" alt="表 3 : 预测模式选择（最可能模式为 1）"></p>
<p>帧内 16×16 亮度和色度预测模式在宏块头中指明。<br>这里需说明的是，包括帧内预测的所有预测都不能跨片边界预测，每片必须独立编解码。</p>
<p>帧内预测以绝对误差和（SAE, Sum of Absolute Errors）为标准选取最佳预测模式，使预测帧更加接近原始帧，减少了相互间的差异，去除时间上的数据冗余，提高了编码的压缩效率。帧内预测中，块或宏块利用已编码并重建的块作为参考，进行预测。具体编程时，编码器通过计算并比较各种模式下的 SAE，选取 SAE 值最小的模式作为最佳预测模式，并将该模式信息化，同时传送至解码端，以供正确解码。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] [《 新一代视频压缩编码标准 — H264/AVC（第二版）》]</li>
</ul>
]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频封装 - FLV 封装格式</title>
    <url>/post/2020/dff5a5c3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于 FLV 封装格式，随便在网络上一搜索，便能搜到一张包浆图：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201115225122.png" alt="FLV 封装格式"></p>
<a id="more"></a>
<h2 id="The-FLV-header"><a href="#The-FLV-header" class="headerlink" title="The FLV header"></a>The FLV header</h2><p>An FLV file shall begin with the FLV header:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>Signature</td>
<td>uint_8</td>
<td>Signature byte always ‘F’ (0x46)</td>
</tr>
<tr>
<td>Signature</td>
<td>uint_8</td>
<td>Signature byte always ‘L’ (0x4C)</td>
</tr>
<tr>
<td>Signature</td>
<td>uint_8</td>
<td>Signature byte always ‘V’ (0x56)</td>
</tr>
<tr>
<td>Version</td>
<td>uint_8</td>
<td>File version (for example, 0x01 for FLV version 1)</td>
</tr>
<tr>
<td>TypeFlagsReserved</td>
<td>ubit[5]</td>
<td>Shall be 0</td>
</tr>
<tr>
<td>TypeFlagsAudio</td>
<td>ubit[1]</td>
<td>1 = Audio tags are present</td>
</tr>
<tr>
<td>TypeFlagsReserved</td>
<td>ubit[1]</td>
<td>Shall be 0</td>
</tr>
<tr>
<td>TypeFlagsVideo</td>
<td>ubit[1]</td>
<td>1 = Video tags are present</td>
</tr>
<tr>
<td>DataOffset</td>
<td>uint_32</td>
<td>The length of this header in bytes</td>
</tr>
</tbody>
</table>
</div>
<p>The DataOffset field usually has a value of 9 for FLV version 1. This field is present to accommodate larger headers<br>in future versions.</p>
<h2 id="The-FLV-File-Body"><a href="#The-FLV-File-Body" class="headerlink" title="The FLV File Body"></a>The FLV File Body</h2><p>After the FLV header, the remainder of an FLV file shall consist of alternating back-pointers and tags. They<br>interleave as shown in the following table:</p>
<p>FLV File Body</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>PreviousTagSize0</td>
<td>uint_32</td>
<td>Always 0</td>
</tr>
<tr>
<td>Tag1</td>
<td>FLVTAG</td>
<td>First tag</td>
</tr>
<tr>
<td>PreviousTagSize1</td>
<td>uint_32</td>
<td>Size of previous tag, including its header, in bytes. For FLV version1, this value is 11 plus the DataSize of the previous tag.</td>
</tr>
<tr>
<td>Tag2</td>
<td>FLVTAG</td>
<td>Second tag</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>PreviousTagSizeN-1</td>
<td>uint_32</td>
<td>Size of second-to-last tag, including its header, in bytes.</td>
</tr>
<tr>
<td>TagN</td>
<td>FLVTAG</td>
<td>Last tag</td>
</tr>
<tr>
<td>PreviousTagSizeN</td>
<td>uint_32</td>
<td>Size of last tag, including its header, in bytes.</td>
</tr>
</tbody>
</table>
</div>
<h2 id="FLV-Tag-Definition"><a href="#FLV-Tag-Definition" class="headerlink" title="FLV Tag Definition"></a>FLV Tag Definition</h2><h3 id="FLV-Tag-Header"><a href="#FLV-Tag-Header" class="headerlink" title="FLV Tag Header"></a>FLV Tag Header</h3><p>The FLV tag contains metadata for audio, video, or scriPTS, optional encryption metadata, and the payload.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved</td>
<td>ubit[2]</td>
<td>保留字段 恒为 0</td>
</tr>
<tr>
<td>Filter</td>
<td>ubit[1]</td>
<td>0：无需预处理 1：需要对包进行预处理（如解密）</td>
</tr>
<tr>
<td>TagType</td>
<td>ubit[5]</td>
<td>tag 类型</td>
</tr>
<tr>
<td>DataSize</td>
<td>uint_24</td>
<td>消息长度，包括从 StreamID 以后到 tag 末尾的数据</td>
</tr>
<tr>
<td>Timestamp</td>
<td>uint_24</td>
<td>当前 tag 的时间戳，以毫秒为单位</td>
</tr>
<tr>
<td>TimestampExtended</td>
<td>uint_8</td>
<td>时间戳的拓展字节</td>
</tr>
<tr>
<td>StreamID</td>
<td>uint_24</td>
<td>≡ 0</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>TagType（tag 类型）<ul>
<li>8 = 音频</li>
<li>9 = 视频</li>
<li>18 = 脚本数据</li>
</ul>
</li>
</ul>
<p>In playback, the time sequencing of FLV tags depends on the FLV timestamps only. Any timing mechanisms built<br>into the payload data format shall be ignored.</p>
<h3 id="Audio-Tags"><a href="#Audio-Tags" class="headerlink" title="Audio Tags"></a>Audio Tags</h3><p>FLV 对 AAC 音频格式封装比较特殊，本文中忽略对 AAC 格式音频的 FLV 封装介绍</p>
<p>The AudioTagHeader contains audio-specific metadata.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>SoundFormat</td>
<td>ubit[4]</td>
<td>音频格式</td>
</tr>
<tr>
<td>SoundRate</td>
<td>ubit[2]</td>
<td>音频采样率</td>
</tr>
<tr>
<td>SoundSize</td>
<td>ubit[1]</td>
<td>音频采样大小</td>
</tr>
<tr>
<td>SoundType</td>
<td>ubit[1]</td>
<td>单声道 / 立体声</td>
</tr>
<tr>
<td>AACPacketType</td>
<td>IF (SoundFormat == 10) uint_8</td>
</tr>
<tr>
<td>AUDIODATA</td>
<td>Varies by SoundFormat</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>SoundFormat<ul>
<li>0 = Linear PCM, platform endian</li>
<li>1 = ADPCM</li>
<li>2 = MP3</li>
<li>3 = Linear PCM, little endian</li>
<li>4 = Nellymoser 16 kHz mono</li>
<li>5 = Nellymoser 8 kHz mono</li>
<li>6 = Nellymoser</li>
<li>7 = G.711 A-law logarithmic PCM</li>
<li>8 = G.711 mu-law logarithmic PCM</li>
<li>9 = reserved</li>
<li>10 = AAC</li>
<li>11 = Speex</li>
<li>14 = MP3 8 kHz</li>
<li>15 = Device-specific sound</li>
</ul>
</li>
<li>SoundRate<ul>
<li>0 = 5.5 kHz</li>
<li>1 = 11 kHz</li>
<li>2 = 22 kHz</li>
<li>3 = 44 kHz</li>
</ul>
</li>
<li>SoundSize<ul>
<li>0 = 8-bit samples</li>
<li>1 = 16-bit samples</li>
</ul>
</li>
<li>SoundType<ul>
<li>0 = Mono sound</li>
<li>1 = Stereo sound</li>
</ul>
</li>
<li>AACPacketType<ul>
<li>0 = AAC sequence header</li>
<li>1 = AAC raw</li>
</ul>
</li>
</ul>
<h3 id="Video-Tags"><a href="#Video-Tags" class="headerlink" title="Video Tags"></a>Video Tags</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>Frame Type</td>
<td>ubit[4]</td>
<td>视频帧类型</td>
</tr>
<tr>
<td>CodecID</td>
<td>ubit[4]</td>
<td>视频编码格式</td>
</tr>
<tr>
<td>AVCPacketType</td>
<td>IF (CodecID == 7) uint_8</td>
<td>AVC 包类型</td>
</tr>
<tr>
<td>CompositionTime</td>
<td>IF (CodecID == 7) uint_24</td>
<td>单声道 / 立体声</td>
</tr>
<tr>
<td>VIDEODATA</td>
<td>VideoTagBody</td>
<td>Video frame payload or frame info</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Frame Type<br>  1 = key frame (for AVC, a seekable frame)<br>  2 = inter frame (for AVC, a non-seekable frame)<br>  3 = disposable inter frame (H.263 only)<br>  4 = generated key frame (reserved for server use only)<br>  5 = video info/command frame</li>
<li>CodecID<br>  2 = Sorenson H.263<br>  3 = Screen video<br>  4 = On2 VP6<br>  5 = On2 VP6 with alpha channel<br>  6 = Screen video version 2<br>  7 = AVC</li>
<li>AVCPacketType<br>  0 = AVC sequence header<br>  1 = AVC NALU<br>  2 = AVC end of sequence (lower level NALU sequence ender is not required or supported)</li>
<li>CompositionTime<ul>
<li>IF (AVCPacketType == 1) CTS 偏移</li>
<li>IF (AVCPacketType == 0) 0</li>
</ul>
</li>
</ul>
<div class="note info no-icon"><p>关于 CTS：这是一个比较难以理解的概念，需要和 PTS，DTS 配合一起理解。<br>首先，PTS（presentation time stamps），DTS(decoder timestamps)，CTS(CompositionTime) 的概念：<br>PTS：显示时间，也就是接收方在显示器显示这帧的时间。单位为 1/90000 秒。<br>DTS：解码时间，也就是 RTP 包中传输的时间戳，表明解码的顺序。单位单位为 1/90000 秒。根据后面的理解，PTS 就是标准中的 CompositionTime<br>CTS 偏移：CTS = (PTS - DTS) / 90 。CTS 的单位是毫秒。<br>PTS 和 DTS 的时间不一样，应该只出现在含有 B 帧的情况下，也就是 main profile 以上。baseline 是没有这个问题的，baseline 的 PTS 和 DTS 一直 x 相同，所以 CTS 一直为 0。</p>
</div>
<h3 id="Data-Tags"><a href="#Data-Tags" class="headerlink" title="Data Tags"></a>Data Tags</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>SCRIPTDATAVALUE</td>
<td>Method or object name. SCRIPTDATAVALUE.Type = 2 (String)</td>
</tr>
<tr>
<td>Value</td>
<td>SCRIPTDATAVALUE</td>
<td>AMF arguments or object properties. SCRIPTDATAVALUE.Type = 8 (ECMA array)</td>
</tr>
</tbody>
</table>
</div>
<p>SCRIPTDATAVALUE 类型类似于 AMF 类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type</td>
<td>uint_8</td>
<td>Type of the ScriptDataValue.</td>
</tr>
<tr>
<td>ScriptDataValue</td>
<td>Varies by Type</td>
<td>Script data value.</td>
</tr>
</tbody>
</table>
</div>
<p>每种 Type 的取值对应的 ScriptDataValue 如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Type Value</th>
<th>Type</th>
<th>ScriptDataValue</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Number</td>
<td>DOUBLE</td>
</tr>
<tr>
<td>1</td>
<td>Boolean</td>
<td>uint_8</td>
</tr>
<tr>
<td>2</td>
<td>String</td>
<td>SCRIPTDATASTRING</td>
</tr>
<tr>
<td>3</td>
<td>Object</td>
<td>SCRIPTDATAOBJECT</td>
</tr>
<tr>
<td>4</td>
<td>MovieClip (reserved, not supported)</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Null</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>Undefined</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>Reference</td>
<td>uint_16</td>
</tr>
<tr>
<td>8</td>
<td>ECMA array</td>
<td>SCRIPTDATAECMAARRAY</td>
</tr>
<tr>
<td>9</td>
<td>Object end marker</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>Strict array</td>
<td>SCRIPTDATASTRICTARRAY</td>
</tr>
<tr>
<td>11</td>
<td>Date</td>
<td>SCRIPTDATADATE</td>
</tr>
<tr>
<td>12</td>
<td>Long string</td>
<td>SCRIPTDATALONGSTRING</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Number: 8 字节 DOUBLE 类型，比如十六进制 <code>00 40 10 00 00 00 00 00 00</code> 就表示的是一个 double 数 <code>4.0</code></li>
<li>Boolean: 1 字节，使用 <code>00</code> 表示 <code>false</code>，使用 <code>01</code> 表示 <code>true</code></li>
<li>String: 16 位整数表示字符串的长度 + 字符串</li>
<li>Object: 内容由多组 String 类型的 SCRIPTDATAVALUE 作为 Key，其他类型的 SCRIPTDATAVALUE 作为 Value 的哈希列表组成，由 3 个字节：<code>00 00 09</code> 来表示结束</li>
<li>Null: 仅占用 1 字节，那就是 Null 对象标识 0x05</li>
<li>ECMA array: 32 位整数表示 Object 对象中元素个数 + Object 类型的 SCRIPTDATAVALUE</li>
<li>Strict array: 32 位整数表示数组元素个数 + 多个其他类型的 SCRIPTDATAVALUE</li>
<li>Date: 8 字节 double 来表示从 1970/1/1 到表示的时间所经过的毫秒数 + 2 字节无符号整数表示时区</li>
<li>Long string: 32 位整数表示字符串的长度 + 字符串</li>
</ul>
<p>如 FLV 的 Data Tags 信息中最主要的 onMetaData 信息如下：</p>
<pre><code>02 20 0a 6f 6e 4d 65 74 61 44 61 74 61 08 20 20 20 0d 20 08 64 75 72 61 74 69 6f 6e 20 40 32 0c
49 ba 5e 35 3f 20 05 77 69 64 74 68 20 40 8a c0 20 20 20 20 20 20 06 68 65 69 67 68 74 20 40 7e
20 20 20 20 20 20 20 0d 76 69 64 65 6f 64 61 74 61 72 61 74 65 20 40 95 41 68 20 20 20 20 20 09
66 72 61 6d 65 72 61 74 65 20 40 38 20 20 20 20 20 20 20 0c 76 69 64 65 6f 63 6f 64 65 63 69 64
20 40 1c 20 20 20 20 20 20 20 0d 61 75 64 69 6f 64 61 74 61 72 61 74 65 20 40 5f 40 20 20 20 20
20 20 0f 61 75 64 69 6f 73 61 6d 70 6c 65 72 61 74 65 20 40 e5 88 80 20 20 20 20 20 0f 61 75 64
69 6f 73 61 6d 70 6c 65 73 69 7a 65 20 40 30 20 20 20 20 20 20 20 06 73 74 65 72 65 6f 01 01 20
0c 61 75 64 69 6f 63 6f 64 65 63 69 64 20 40 24 20 20 20 20 20 20 20 07 65 6e 63 6f 64 65 72 02
20 0d 4c 61 76 66 35 38 2e 32 39 2e 31 30 30 20 08 66 69 6c 65 73 69 7a 65 20 41 4a 9e 05 80 20
20 20 20 20 09 20 20 01 30 09
</code></pre><p>解析后以上数据如下所示：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117000710.png" alt="onMetaData 信息"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      <categories>
        <category>音视频封装</category>
      </categories>
      <tags>
        <tag>FLV</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频封装 - MP4 封装格式</title>
    <url>/post/2020/e90af351/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>mp4</code> 文件封装格式，对应的标准为 <code>ISO/IEC 14496-12</code> 和 <code>ISO/IEC 14496-14</code>。</p>
<p><code>ISO/IEC 14496-12</code> 定义了一种封装媒体数据的基础文件格式，<code>mp4</code>、<code>3gp</code>、<code>ismv</code> 等我们常见媒体封装格式都是以这种基础文件格式为基础衍生的。</p>
<p><code>ISO/IEC 14496-14</code> 基于 <code>ISO-14496-12</code> 定义了 <code>mp4</code> 文件格式。</p>
<a id="more"></a>
<h2 id="基础文件格式-Box"><a href="#基础文件格式-Box" class="headerlink" title="基础文件格式 - Box"></a>基础文件格式 - Box</h2><p>按照 <code>ISO-14496-12</code>，文件由一系列对象 <code>Box</code> 构成, <code>Box</code> 可以嵌套包含其他 <code>Box</code></p>
<p><code>Box</code> 分为两类: 一类是元数据 <code>Box</code>，一类是媒体数据 <code>Box</code></p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130213738.png" alt="Box"></p>
<p><code>Box Header</code> 的格式可用如下代码表示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">Box</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) boxtype, optional <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">8</span>)[<span class="number">16</span>] extended_type)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> <span class="built_in">size</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> type </span>= boxtype;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> largesize</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// box extends to end of file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (boxtype == <span class="string">&quot;uuid&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">8</span>)[<span class="number">16</span>] usertype = extended_type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些 <code>Box</code> 对象的 <code>Box Header</code> 可能会包含有版本号和标志域:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">FullBox</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) boxtype, <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">8</span>) v, <span class="built_in">bit</span>(<span class="number">24</span>) f)</span> extends <span class="title">Box</span><span class="params">(boxtype)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">8</span>)</span> version </span>= v;</span><br><span class="line">    <span class="built_in">bit</span>(<span class="number">24</span>) flags = f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MP4-格式介绍"><a href="#MP4-格式介绍" class="headerlink" title="MP4 格式介绍"></a>MP4 格式介绍</h2><p><code>Box</code> 种类非常多，下图中例举了一些重要的 <code>Box</code> 类型:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130214743.png" alt="MP4"></p>
<ol>
<li>分析时会从外到里进行分析，先分析第一层的 <code>Box</code> 各个字段，再分析第二层 <code>Box</code> 各个字段，以此类推</li>
<li><code>Box</code> 由于种类非常多，这里只分析一个标准的 <code>mp4</code> 文件的 <code>Box</code> 含义</li>
<li><code>Box</code> 里面字段也不是所有的都需要关注，我们只需要关注核心和有用的，对于一些不太用的就可以忽略不计了</li>
</ol>
<h2 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h2><p>使用 <code>mp4info</code> 打开一个 <code>mp4</code> 文件，可以看到，该 <code>mp4</code> 文件第一层 <code>Box</code> 有 <code>4</code> 种:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130215440.png" alt="第一层"></p>
<ol>
<li><code>ftyp</code></li>
<li><code>free</code></li>
<li><code>mdat</code></li>
<li><code>moov</code></li>
</ol>
<p>我们逐个分析该 <code>4</code> 种 <code>Box</code> 的含义和内容。</p>
<h3 id="ftyp"><a href="#ftyp" class="headerlink" title="ftyp"></a>ftyp</h3><p><code>ftyp</code> 是 <code>mp4</code> 文件的第一个 <code>Box</code>，包含了视频文件使用的编码格式、标准等，这个 <code>Box</code> 作用基本就是 <code>mp4</code> 这种封装格式的标识，同时在一份 <code>mp4</code> 文件中只有一个这样的 <code>Box</code>。<code>ftyp box</code> 通常放在文件的开始，通过对该 <code>Box</code> 解析可以让我们的软件（播放器、demux、解析器）知道应该使用哪种协议对这该文件解析，是后续解读文件基础。</p>
<p>分析如下码流:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130234447.png" alt="ftyp box"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class FileTypeBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;ftyp&quot;</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> major_brand</span>;           <span class="comment">// 不同厂商要实现这种规范都要向 ISO 注册的一个四字节的标识码</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> minor_version</span>;         <span class="comment">// 商标版本号</span></span><br><span class="line">    unsigned int(32) compatible_brands[];   // 兼容其他的版本号，表示可以兼容和遵从那些协议标准，是一个列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 00 1C</code> 表示该 <code>Box</code> 长度为 <code>28</code> 字节</li>
<li>Box type: <code>0x66 74 79 70</code> 是 <code>ftyp</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
</ul>
</li>
<li>Box Data<ul>
<li>major brand: <code>0x69 73 6F 6D</code> 是 <code>isom</code> 的 <code>ASCII</code> 值，说明本文件是符合这个规范的。</li>
<li>minor version: <code>0x00 00 02 00</code> 代表 <code>isom</code> 的版本号</li>
<li>compatible brand: <code>0x69 73 6F 6D 69 73 6F 32 6D 70 34 31</code> <code>ASCII</code> 值为 <code>iosmios2mp4l</code> 表示本文件可以兼容的协议和标准</li>
</ul>
</li>
</ul>
<p>通过 <code>Mp4Explorer</code> 验证分析结果:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201130235834.png" alt="ftyp Mp4Explorer"></p>
<h3 id="moov"><a href="#moov" class="headerlink" title="moov"></a>moov</h3><ul>
<li><code>Container</code>: <code>File</code></li>
<li><code>Mandatory</code>: <code>Yes</code></li>
<li><code>Quantity</code>: <code>Exactly one</code></li>
</ul>
<p><code>moov Box</code> 这个 <code>Box</code> 也是 <code>MP4</code> 文件中必须有但是只存在一个的 <code>Box</code>, 这个 <code>Box</code> 里面一般存的是媒体文件的元数据，这个 <code>Box</code> 本身是很简单的，是一种 Container <code>Box</code>，里面的数据是子 <code>Box</code>, 自己更像是一个分界标识。</p>
<p>所谓的媒体元数据主要包含类似 <code>SPS</code>、<code>PPS</code> 的编解码参数信息，还有音视频的时间戳等信息。对于 <code>MP4</code> 还有一个重要的采样表 <code>stbl</code> 信息，这里面定义了采样 <code>Sample</code>、<code>Chunk</code>、<code>Track</code> 的映射关系，是 <code>MP4</code> 能够进行随机拖动和播放的关键，也是需要好好理解的部分，对于实现一些音视频特殊操作很有帮助。</p>
<p>根据 <code>ISO-14496-12</code>，文件中必须要包括唯一一个元数据容器: <code>Movie Box(moov)</code>，该 <code>Box</code> 一般在文件的头部或尾部，方便定位。</p>
<p>分析如下码流:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201000619.png" alt="moov box"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MovieBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;moov&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 2E 49</code> 表示该 <code>Box</code> 长度为 <code>11849</code> 字节</li>
<li>Box type: <code>0x6D 6F 6F 76</code> 就是 <code>moov</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
</ul>
</li>
<li>Box Data<ul>
<li>参见: <a href="#mvhd">第二层 - mvhd</a></li>
<li>参见: <a href="#iods">第二层 - iods</a></li>
<li>参见: <a href="#trak">第二层 - trak</a></li>
</ul>
</li>
</ul>
<p>通过 <code>Mp4Explorer</code> 验证分析结果:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201000000.png" alt="moov Mp4Explorer"></p>
<h3 id="mdat"><a href="#mdat" class="headerlink" title="mdat"></a>mdat</h3><p><code>mdat Box</code> 这个 <code>Box</code> 是存储音视频数据的 <code>Box</code>，要从这个 <code>Box</code> 解封装出真实的媒体数据。当然这个 <code>Box</code> 一般都会存在，但是不是必须的。</p>
<p>说明:</p>
<ol>
<li><code>mdat Box</code> 基本组成还是有头部和数据两部分组成，但是这里注意如果 <code>Box length</code> 长度不够时，要用后面 <code>8</code> 字节的扩展长度字段，<code>Box Type</code> 还是 <code>mdat</code> 的 <code>ASCII</code> 码值</li>
<li>真实的数据字段是一个个 <code>NALU header</code> + <code>NALU Data</code>，但是没有用 <code>NALU</code> 的分解符 <code>00 00 00 01</code>, 是在每个 <code>NALU</code> 前面加了长度字段，和 <code>RTP</code> 打包类似</li>
<li>这里的 <code>NLAU</code> 一般不再包含 <code>SPS</code> <code>PPS</code> 等数据，这些数据已经放到 <code>moov Box</code> 里面了，至于是如何放到 <code>moov Box</code> 的，下面文章会讲解。这里一般 <code>NALU</code> 类型就是 <code>I\B\P</code> 帧数据以及 <code>SEI</code> 用户增强信息</li>
</ol>
<p>分析如下码流:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201001516.png" alt="mdat box"></p>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 25 4B F7</code> 表示该 <code>Box</code> 长度为 <code>2444279</code> 字节，即后面的 <code>NALU</code> 整个长度为 <code>2444279 - 8 = 2444271</code> 字节</li>
<li>Box type: <code>0x6D 64 61 74</code> 这就是 <code>mdat</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
</ul>
</li>
<li>Box Data</li>
</ul>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><code>free Box</code> 中的内容是无关紧要的，可以被忽略即该 <code>Box</code> 被删除后，不会对播放产生任何影响。这种类型的 <code>Box</code> 也不是必须的，可有可无，类似的 <code>Box</code> 还有 <code>sikp Box</code>. 虽然在解析是可以忽略，但是需要注意该 <code>Box</code> 的删除对其它 <code>Box</code> 的偏移量影响，特别是当 <code>moov Box</code> 放到 <code>mdat Box</code> 后面的情况。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201222436.png" alt="free box"></p>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 00 08</code> 表示该 <code>Box</code> 长度为 <code>9</code> 字节</li>
<li>Box type: <code>0x66 72 65 65</code> 这就是 <code>free</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
</ul>
</li>
<li>Box Data</li>
</ul>
<h2 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h2><p>从第二层开始，后续的每一层基本都封装于 <code>moov Box</code>。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201224431.png" alt="moov Box"></p>
<h3 id="mvhd"><a href="#mvhd" class="headerlink" title="mvhd"></a>mvhd</h3><p>这个 Box 也是全文件唯一的一个 Box, 一般处于 moov Box 的第一个子 Box, 这个 Box 对整个媒体文件所包含的媒体数据（包含 Video track 和 Audio Track 等）进行全面的描述。其中包含了媒体的创建和修改时间，默认音量、色域、时长等信息。</p>
<p>分析如下码流:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201231209.png" alt="mvhd Box"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MovieHeaderBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;mvhd&quot;</span>, version, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (version==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> creation_time</span>;     <span class="comment">// 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> modification_time</span>; <span class="comment">// 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> timescale</span>;         <span class="comment">// 文件媒体在 1 秒时间内的刻度值，可以理解为 1 秒长度的时间单元数，这个只用来计算了该 Mp4 文件的长度，但是没有参与 PTS 和 DTS 的计算。</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> duration</span>;          <span class="comment">// 该影片的播放时长，该值除以 time scale 字段即可以得到该影片的总时长单位秒 s</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// version==0</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) creation_time;     <span class="comment">// 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> modification_time</span>; <span class="comment">// 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> timescale</span>;         <span class="comment">// 文件媒体在 1 秒时间内的刻度值，可以理解为 1 秒长度的时间单元数，这个只用来计算了该 Mp4 文件的长度，但是没有参与 PTS 和 DTS 的计算。</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> duration</span>;          <span class="comment">// 该影片的播放时长，该值除以 time scale 字段即可以得到该影片的总时长单位秒 s</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> rate </span>= <span class="number">0x00010000</span>; <span class="comment">// 推荐播放速率，[16.16] 格式，1.0 表示 1 倍速播放</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> volume </span>= <span class="number">0x0100</span>;   <span class="comment">// 与 rate 类似，[8.8] 格式，1.0 表示最大音量</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">bit</span><span class="params">(<span class="number">16</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">    const unsigned int(32)[2] reserved = 0;</span><br><span class="line">    template int(32)[9] matrix =</span><br><span class="line">    &#123;<span class="number">0x00010000</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x00010000</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x40000000</span>&#125;; <span class="comment">// Unity matrix</span></span><br><span class="line">    <span class="built_in">bit</span>(<span class="number">32</span>)[<span class="number">6</span>] pre_defined = <span class="number">0</span>;     <span class="comment">// 预览相关的信息，一般都是填充 0，所以不用太关心</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> next_track_ID</span>; <span class="comment">// 下一个 Track 使用的 id 号，通过该值减去 1 可以判断当前文件的 Track 数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 00 6c</code> 表示该 <code>Box</code> 长度为 <code>108</code> 字节</li>
<li>Box type: <code>0x6d 76 68 64</code> 这就是 <code>mvhd</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
<li>Box version: <code>0x00</code></li>
<li>Box flags: <code>0x00 00 00</code></li>
</ul>
</li>
<li>Box Data<ul>
<li>creation time: <code>0x00 00 00 00</code></li>
<li>modification time: <code>0x00 00 00 00</code></li>
<li>time_scale: <code>0x00 00 03 E8</code> 代表 <code>1</code> 秒的时间单位是 <code>1000</code>，即把 <code>1</code> 秒划分为 <code>1000</code> 份，这样描述的更精确</li>
<li>duration: <code>0x00 00 46 68</code> 这样我们换算下该段 <code>mp4</code> 文件的时长是 <code>18024/1000</code> 即 <code>18.024</code> 秒</li>
<li>rate: <code>0x00 01 00 00</code> 推荐采样原始倍速播放，一般就是 <code>1</code> 倍速进行播放该视频</li>
<li>volume: <code>01 00</code> 推荐采样原始视频音量进行播放</li>
<li>next_track_id: <code>0x00 00 00 03</code> 这个值表示如果要增加下一个 <code>Track</code> 时，需要的编号是 <code>3</code>，那同时也就说明本文件里面有 <code>2</code> 个 <code>Track</code>，实际发现刚好是 <code>2</code> 个 <code>Track</code></li>
</ul>
</li>
</ul>
<p>通过 <code>Mp4Explorer</code> 验证分析结果:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201224755.png" alt="mvhd Mp4Explorer"></p>
<h3 id="iods"><a href="#iods" class="headerlink" title="iods"></a>iods</h3><p>这个 <code>Box</code> 也是非必须 <code>Box</code>，不算核心 <code>Box</code>, 实际也是 <code>24</code> 字节的固定值，解析时直接跳过即可。封装直接给填写固定 <code>24</code> 字节即可，注意该 <code>Box</code> 也是 Full <code>Box</code> 意味这 <code>Header</code> 里面有 <code>1</code> 字节的 <code>Version</code> 和 <code>3</code> 字节的 <code>Flag</code> 字段。</p>
<p>定义的内容应该是 <code>Audio</code> 和 <code>Video ProfileLevel</code> 方面的描述。但是现在没有用。</p>
<h3 id="trak"><a href="#trak" class="headerlink" title="trak"></a>trak</h3><p><code>trak Box</code> 定义了媒体文件中媒体中一个 <code>Track</code> 的信息，视频有 <code>Video Track</code>, 音频有 <code>Audio Track</code>，媒体文件中可以有多个 <code>Track</code>，每个 <code>Track</code> 具有自己独立的时间和空间的信息，可以进行独立操作。</p>
<p>每个 <code>trak Box</code> 都需要有一个 <code>tkhd Box</code> 和 <code>mdia Box</code>，其它的 <code>Box</code> 都是可选择的</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201233103.png" alt="trak Box"></p>
<p><code>Trak Box</code> 这里自身只是一个分界符，属于 <code>Container Box</code>，它的 <code>Box Data</code> 其实是其他的 <code>Box</code> 类型。</p>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 10 1E</code> 表示该 <code>Box</code> 长度为 <code>4126</code> 字节</li>
<li>Box type: <code>0x74 72 61 6B</code> 这就是 <code>trak</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
</ul>
</li>
<li>Box Data<ul>
<li>参见: <a href="#tkhd">第三层 - tkhd</a></li>
<li>参见: <a href="#edts">第三层 - edts</a></li>
<li>参见: <a href="#mdia">第三层 - mdia</a></li>
</ul>
</li>
</ul>
<h2 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h2><h3 id="tkhd"><a href="#tkhd" class="headerlink" title="tkhd"></a>tkhd</h3><p><code>Container</code>: <code>Track Box</code> (<code>&quot;trak&quot;</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p>
<p>该 <code>Box</code> 描述了该 <code>Track</code> 的媒体整体信息包括时长、图像的宽度和高度等，实际比较重要，同时该 <code>Box</code> 是 <code>Full Box</code> 即 <code>Box Header</code> 后面有 <code>Version</code> 和 <code>Flag</code> 字段。</p>
<p>分析如下码流:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201234750.png" alt="tkhd Box"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class TrackHeaderBox extends <span class="title">FullBox</span><span class="params">(‘tkhd’, version, flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (version==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> creation_time</span>;     <span class="comment">// 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> modification_time</span>; <span class="comment">// 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> track_ID</span>;          <span class="comment">// 唯一标识该 Track 的一个非零值</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> duration</span>;          <span class="comment">// 该影片的播放时长，该值除以 time scale 字段即可以得到该影片的总时长单位秒 s</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// version==0</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) creation_time;     <span class="comment">// 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> modification_time</span>; <span class="comment">// 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> track_ID</span>;          <span class="comment">// 唯一标识该 Track 的一个非零值</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> duration</span>;          <span class="comment">// 该影片的播放时长，该值除以 time scale 字段即可以得到该影片的总时长单位秒 s</span></span><br><span class="line">    &#125;</span><br><span class="line">    const unsigned int(32)[2] reserved = 0;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> layer </span>= <span class="number">0</span>;             <span class="comment">// 视频层，值小的在上层</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> alternate_group </span>= <span class="number">0</span>;   <span class="comment">// Track 分组信息，一般默认为 0，表示该 Track 和其它 Track 没有建立群组关系</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> volume </span>= &#123;<span class="keyword">if</span> track_is_audio <span class="number">0x0100</span> <span class="keyword">else</span> <span class="number">0</span>&#125;; <span class="comment">// [8.8] 格式，1.0 表示最大音量</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">    template int(32)[9] matrix=</span><br><span class="line">    &#123;<span class="number">0x00010000</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x00010000</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x40000000</span>&#125;;</span><br><span class="line">    <span class="comment">// unity matrix</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> <span class="built_in">width</span></span>;     <span class="comment">// 如果该 Track 为 Video Track，则表示图像的宽度（16.16 浮点表示）</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> <span class="built_in">height</span></span>;    <span class="comment">// 如果该 Track 为 Video Track，则表示图像的高度（16.16 浮点表示）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 00 5c</code> 表示该 <code>Box</code> 长度为 <code>92</code> 字节</li>
<li>Box type: <code>0x74 6B 68 64</code> 这就是 <code>tkhd</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
<li>Box version: <code>0x00</code></li>
<li>Box flags: <code>0x00 00 03</code></li>
</ul>
</li>
<li>Box Data<ul>
<li>creation time: <code>0x00 00 00 00</code></li>
<li>modification time: <code>0x00 00 00 00</code></li>
<li>track_id: <code>0x00 00 00 01</code> 这是该 <code>Track</code> 的唯一标识</li>
<li>duration: <code>0x00 00 46 50</code> 这样我们换算下该段 <code>mp4</code> 文件的时长是 <code>18000/1000</code> 即 <code>18</code> 秒</li>
<li>layer: <code>0x00 00</code></li>
<li>alternate_group: <code>0x00 00</code></li>
<li>volume: <code>00 00</code></li>
<li>width: <code>0x03 55 55 55</code> 表示该视频图像的宽度是 <code>853.21845</code></li>
<li>height: <code>0x01 e0 00 00</code> 表示该视频图像的宽度是 <code>480.0</code></li>
</ul>
</li>
</ul>
<p>通过 <code>Mp4Explorer</code> 验证分析结果:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201201235125.png" alt="tkhd Mp4Explorer"></p>
<h3 id="edts"><a href="#edts" class="headerlink" title="edts"></a>edts</h3><h3 id="mdia"><a href="#mdia" class="headerlink" title="mdia"></a>mdia</h3><ul>
<li><code>Container</code>: <code>Track Box</code> (<code>trak</code>)</li>
<li><code>Mandatory</code>: <code>Yes</code></li>
<li><code>Quantity</code>: <code>Exactly one</code></li>
</ul>
<p>这个 <code>Box</code> 也是 <code>Container Box</code>，里面包含子 <code>Box</code>，一般必须有 <code>mdhd Box</code>、<code>hdlr Box</code>、<code>minf Box</code>。基本就是当前 <code>Track</code> 媒体头信息和媒体句柄以及媒体信息。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202001301.png" alt="mdia Box"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MediaBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;mdia&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 10 1E</code> 表示该 <code>Box</code> 长度为 <code>4126</code> 字节</li>
<li>Box type: <code>0x74 72 61 6B</code> 这就是 <code>trak</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
</ul>
</li>
<li>Box Data<ul>
<li>参见: <a href="#hdlr">第四层 - mdhd</a></li>
<li>参见: <a href="#hdlr">第四层 - hdlr</a></li>
<li>参见: <a href="#minf">第四层 - minf</a></li>
</ul>
</li>
</ul>
<h2 id="第四层"><a href="#第四层" class="headerlink" title="第四层"></a>第四层</h2><h3 id="mdhd"><a href="#mdhd" class="headerlink" title="mdhd"></a>mdhd</h3><ul>
<li><code>Container</code>: <code>Media Box</code> (<code>mdia</code>)</li>
<li><code>Mandatory</code>: <code>Yes</code></li>
<li><code>Quantity</code>: <code>Exactly one</code></li>
</ul>
<p>这个 <code>Box</code> 是 <code>Full Box</code>，意味这 <code>Box Header</code> 有 <code>Version</code> 和 <code>Flag</code> 字段，该 <code>Box</code> 里面主要定义了该 <code>Track</code> 的媒体头信息，其中我们最关心的两个字段是 <code>Time scale</code> 和 <code>Duration</code>，分别表示了该 <code>Track</code> 的时间戳和时长信息，这个时间戳信息也是 <code>PTS</code> 和 <code>DTS</code> 的单位。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202001857.png" alt="mdhd Box"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MediaHeaderBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;mdhd&quot;</span>, version, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (version==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> creation_time</span>;     <span class="comment">// 当前 Track 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> modification_time</span>; <span class="comment">// 当前 Track 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> timescale</span>;         <span class="comment">// 当前 Track 的时间计算单位</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> duration</span>;          <span class="comment">// 当前 Track 的播放时长，需要参考前面的 timescale 计算</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// version==0</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) creation_time;     <span class="comment">// 当前 Track 创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> modification_time</span>; <span class="comment">// 当前 Track 修改时间（相对于 UTC 时间 1904-01-01 零点的秒数）</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> timescale</span>;         <span class="comment">// 当前 Track 的时间计算单位</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> duration</span>;          <span class="comment">// 当前 Track 的播放时长，需要参考前面的 timescale 计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bit</span>(<span class="number">1</span>) pad = <span class="number">0</span>;</span><br><span class="line">    unsigned int(5)[3] language;            // 媒体语言码，参考 ISO-639-2/T</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> pre_defined </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 00 20</code> 表示该 <code>Box</code> 长度为 <code>32</code> 字节</li>
<li>Box type: <code>0x6d 64 68 64</code> 这就是 <code>mdhd</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
<li>Box version: <code>0x00</code></li>
<li>Box flags: <code>0x00 00 00</code></li>
</ul>
</li>
<li>Box Data<ul>
<li>creation time: <code>0x00 00 00 00</code></li>
<li>modification time: <code>0x00 00 00 00</code></li>
<li>timescale: <code>0x00 00 30 00</code> 表示当前 <code>Track</code> 的时间戳单位是 <code>12288</code></li>
<li>duration: <code>0x00 03 60 00</code> 这样我们换算下该段 <code>mp4</code> 文件的时长是 <code>221184/12288</code> 即 <code>18</code> 秒</li>
<li>language: <code>0x55 c4</code> 最高位为 <code>0</code>，后面 <code>15</code> 位代表三个字符<ul>
<li><code>0x55 c4</code> 转为二进制 <code>BIN: 01010101 11000100</code> 去掉首位 <code>0</code> 得到 <code>15</code> 位二进制数字</li>
<li>每 <code>5</code> 位二进制一组: <code>10101 01110 00100</code> 代表三个数字 <code>21</code>、<code>15</code>、<code>4</code></li>
<li>三个数字对应从 <code>a</code> 开始的第 <code>21</code>、<code>15</code>、<code>4</code> 个字母，即 <code>u</code>、<code>n</code>、<code>d</code>，查询 <a href="https://en.wikipedia.org/wiki/List_of_ISO_639-2_codes">ISO 639-2/T</a> 可知其含义</li>
</ul>
</li>
<li>qualiiy: <code>0x00 00</code></li>
</ul>
</li>
</ul>
<p>通过 <code>Mp4Explorer</code> 验证分析结果:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202001924.png" alt="mdhd Mp4Explorer"></p>
<h3 id="hdlr"><a href="#hdlr" class="headerlink" title="hdlr"></a>hdlr</h3><p><code>Container</code>: <code>Media Box</code> (<code>mdia</code>) or <code>Meta Box</code> (<code>meta</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p>
<p>这个 <code>Box</code> 是 <code>Full Box</code>，该 <code>Box</code> 解释了媒体的播放过程信息，用来设置不同 <code>Track</code> 的处理方式，标识了该 <code>Track</code> 的类型。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202003746.png" alt="hdlr Box"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class HandlerBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;hdlr&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> pre_defined </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> handler_type</span>;  <span class="comment">// Handle 的类型: 视频: &#x27;vide&#x27;，音频: &#x27;soun&#x27;</span></span><br><span class="line">    const unsigned int(32)[3] reserved = 0;</span><br><span class="line">    <span class="built_in">string</span> name; <span class="comment">// 这个 component 的名字，其实这里就是你给该 Track 其的名字，打包时填写一个有意义字符串就可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 00 2d</code> 表示该 <code>Box</code> 长度为 <code>45</code> 字节</li>
<li>Box type: <code>0x68 64 6c 72</code> 这就是 <code>hdlr</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
<li>Box version: <code>0x00</code></li>
<li>Box flags: <code>0x00 00 00</code></li>
</ul>
</li>
<li>Box Data<ul>
<li>handle type: <code>0x76 69 64 65</code> 即’vide’，代表当前 Track 为视频数据</li>
<li>name: <code>VideoHandler</code></li>
</ul>
</li>
</ul>
<p>通过 <code>Mp4Explorer</code> 验证分析结果:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202003621.png" alt="hdlr Mp4Explorer"></p>
<h3 id="minf"><a href="#minf" class="headerlink" title="minf"></a>minf</h3><p><code>Container</code>: <code>Media Box</code> (<code>mdia</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p>
<p>这个 <code>Box</code> 是我认为 moov <code>Box</code> 里面最重要最复杂的 <code>Box</code>，内部还有子 <code>Box</code>。该 <code>Box</code> 建立了时间到真实音视频 <code>Sample</code> 的映射关系，对于音视频数据操作时很有帮助的。</p>
<p>同时该 <code>Box</code> 是 <code>Container Box</code>，下面一般含有三大必须的子 <code>Box</code>:</p>
<ul>
<li>媒体信息头 <code>Box</code>: <code>vmhd Box</code> 或者 <code>smhd Box</code>;</li>
<li>数据信息 <code>Box</code>: <code>dinf Box</code></li>
<li>采样表 <code>Box</code>:<code>stbl Box</code></li>
</ul>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202124113.png" alt="minf Box"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class MediaInformationBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;minf&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 0f 41</code> 表示该 <code>Box</code> 长度为 <code>3905</code> 字节</li>
<li>Box type: <code>0x6d 69 6e 66</code> 这就是 <code>trak</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
</ul>
</li>
<li>Box Data<ul>
<li>参见: <a href="#vmhd">第五层 - vmhd</a></li>
<li>参见: <a href="#smhd">第五层 - smhd</a></li>
<li>参见: <a href="#dinf">第五层 - dinf</a></li>
<li>参见: <a href="#stbl">第五层 - stbl</a></li>
</ul>
</li>
</ul>
<h2 id="第五层"><a href="#第五层" class="headerlink" title="第五层"></a>第五层</h2><h3 id="vmhd"><a href="#vmhd" class="headerlink" title="vmhd"></a>vmhd</h3><ul>
<li><code>Container</code>: <code>Media Information Box</code> (<code>minf</code>)</li>
<li><code>Mandatory</code>: <code>Yes</code></li>
<li><code>Quantity</code>: <code>Exactly one</code></li>
</ul>
<p>这个 <code>Box</code> 的大小是固定的，大小是 <code>24</code> 字节，一般都是用默认值填充。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202125231.png" alt="vmhd Box"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class VideoMediaHeaderBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;vmhd&quot;</span>, version = <span class="number">0</span>, <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> graphicsmode </span>= <span class="number">0</span>; <span class="comment">// 视频合成模式，为 0 时拷贝原始图像，否则与 opcolor 进行合成</span></span><br><span class="line">    template unsigned int(16)[3] opcolor = &#123;0, 0, 0&#125;; // 颜色值，RGB 颜色值，&#123;R,G,B&#125; 一般默认 0x00 00 00 00 00 00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="smhd"><a href="#smhd" class="headerlink" title="smhd"></a>smhd</h3><ul>
<li><code>Container</code>: <code>Media Information Box</code> (<code>minf</code>)</li>
<li><code>Mandatory</code>: <code>Yes</code></li>
<li><code>Quantity</code>: <code>Exactly one specific media header shall be present</code></li>
</ul>
<p>这个 <code>Box</code> 的大小是固定的，大小是 <code>16</code> 字节，一般都是用默认值填充。</p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SoundMediaHeaderBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;smhd&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> balance </span>= <span class="number">0</span>;   <span class="comment">// 音频的均衡是用来控制计算机的两个扬声器的声音混合效果，一般是 0</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> reserved </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dinf"><a href="#dinf" class="headerlink" title="dinf"></a>dinf</h3><p><code>Container</code>: <code>Media Information Box</code> (<code>minf</code>) or <code>Meta Box</code> (<code>meta</code>)<br><code>Mandatory</code>: <code>Yes</code> (required within <code>minf box</code>) and <code>No</code> (optional within <code>meta box</code>)<br><code>Quantity</code>: <code>Exactly one</code></p>
<p>这个 <code>Box</code> 也是一个 <code>Container Box</code>，一般用来定位媒体信息。一般会包含一个 <code>dref Box</code> 即 <code>data reference box</code>，<code>dref</code> 下面会有若干个 <code>url Box</code> 或者也叫 <code>urn Box</code>，这些 <code>Box</code> 组成一个表，用来定位 <code>Track</code> 的数据。</p>
<p><code>Track</code> 可以被分成若干个段，每一段都可以根据 <code>Url</code> 或者 <code>Urn</code> 指向的地址来获取数据，<code>sample</code> 描述中会用这些片段的序号将这些片段组成一个完整的 <code>track</code>，一般情况下当数据完全包含在文件中，<code>Url</code> 和 <code>urn Box</code> 的字符串是空的。</p>
<p>这个 <code>Box</code> 存在的意义就是允许 <code>MP4</code> 文件的媒体数据分开最后还能进行恢复合并操作，但是实际上，<code>Track</code> 的数据都保存再文件中，所以该字段的重要性还体现不出来。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202130034.png" alt="dinf"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class DataInformationBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;dinf&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 00 24</code> 表示该 <code>Box</code> 长度为 <code>36</code> 字节</li>
<li>Box type: <code>0x64 69 6e 66</code> 这就是 <code>dinf</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
</ul>
</li>
<li>Box Data<ul>
<li>参见: <a href="#dref">第六层 - dref</a></li>
</ul>
</li>
</ul>
<h3 id="stbl"><a href="#stbl" class="headerlink" title="stbl"></a>stbl</h3><ul>
<li><code>Container</code>: <code>Media Information Box</code> (<code>minf</code>)</li>
<li><code>Mandatory</code>: <code>Yes</code></li>
<li><code>Quantity</code>: <code>Exactly one</code></li>
</ul>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202215751.png" alt="stbl"></p>
<p>stbl Box 同样是 Container Box，使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SampleTableBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;stbl&quot;</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 0f 01</code> 表示该 <code>Box</code> 长度为 <code>3841</code> 字节</li>
<li>Box type: <code>0x73 74 62 6c</code> 这就是 <code>stbl</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
</ul>
</li>
<li>Box Data<ul>
<li>参见: <a href="#stsd">第六层 - stsd</a></li>
<li>参见: <a href="#stts">第六层 - stts</a></li>
<li>参见: <a href="#stss">第六层 - stss</a></li>
<li>参见: <a href="#stsc">第六层 - stsc</a></li>
<li>参见: <a href="#stsz">第六层 - stsz</a></li>
<li>参见: <a href="#stco">第六层 - stco</a></li>
</ul>
</li>
</ul>
<h2 id="第六层"><a href="#第六层" class="headerlink" title="第六层"></a>第六层</h2><h3 id="dref"><a href="#dref" class="headerlink" title="dref"></a>dref</h3><p><code>Container</code>: <code>Data Information Box</code> (<code>dinf</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p>
<p>由于 <code>Track</code> 可以分为多个段，所以该 <code>Box</code> 是用来定义当前 <code>Track</code> 各个段的 <code>URL</code> 或 <code>URN</code>。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202130842.png" alt="dref"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">DataEntryUrlBox</span> <span class="params">(<span class="built_in">bit</span>(<span class="number">24</span>) flags)</span> extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;url&quot;</span>, version = <span class="number">0</span>, flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> location;</span><br><span class="line">&#125;</span><br><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">DataEntryUrnBox</span> <span class="params">(<span class="built_in">bit</span>(<span class="number">24</span>) flags)</span> extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;urn&quot;</span>, version = <span class="number">0</span>, flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> location;</span><br><span class="line">&#125;</span><br><span class="line">aligned(<span class="number">8</span>) <span class="function">class DataReferenceBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;dref&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        DataEntryBox(entry_version, entry_flags) data_entry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 00 1c</code> 表示该 <code>Box</code> 长度为 <code>28</code> 字节</li>
<li>Box type: <code>0x64 72 65 66</code> 这就是 <code>dref</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
<li>Box version: <code>0x00</code></li>
<li>Box flags: <code>0x00 00 00</code></li>
</ul>
</li>
<li>Box Data<ul>
<li>entry count: <code>0x00 00 00 01</code> 说明下面的 <code>url</code> 列表数量是 <code>1</code>，只有一个 <code>url Box</code></li>
<li>URL Box 1<ul>
<li>Box Length: <code>0x00 00 00 0c</code> 表示该 <code>Box</code> 长度为 <code>12</code> 字节</li>
<li>Box type: <code>0x75 72 6c 20</code> 这就是 <code>&quot;url&quot;</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
<li>Box version: <code>0x00</code></li>
<li>Box flags: <code>0x00 00 01</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="stsd"><a href="#stsd" class="headerlink" title="stsd"></a>stsd</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p>
<p>该 <code>Box</code> 存储了编码类型和初始化解码器需要的信息，于特定的 <code>track-type</code> 有关，根于不同的 <code>Track</code> 使用不一样的编码标准。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201202220310.png" alt="stsd"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">abstract class <span class="title">SampleEntry</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) format)</span> extends <span class="title">Box</span><span class="params">(format)</span></span>&#123;</span><br><span class="line">    const unsigned int(8)[6] reserved = 0;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> data_reference_index</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">class BitRateBox extends <span class="title">Box</span><span class="params">(<span class="string">&quot;btrt&quot;</span>)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> bufferSizeDB</span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> maxBitrate</span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> avgBitrate</span>;</span><br><span class="line">&#125;</span><br><span class="line">aligned(<span class="number">8</span>) <span class="function">class <span class="title">SampleDescriptionBox</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>(<span class="number">32</span>) handler_type)</span> extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stsd&quot;</span>, version, <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;   <span class="comment">//sample description 数目, 同时不同的 Track 有不同的 sample description</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= entry_count ; i++)&#123;</span><br><span class="line">        SampleEntry(); <span class="comment">// an instance of a class derived from SampleEntry</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 01 09</code> 表示该 <code>Box</code> 长度为 <code>265</code> 字节</li>
<li>Box type: <code>0x73 74 73 64</code> 这就是 <code>stsd</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
<li>Box version: <code>0x00</code></li>
<li>Box flags: <code>0x00 00 00</code></li>
</ul>
</li>
<li>Box Data<ul>
<li>entry count: <code>0x00 00 00 01</code> 说明下面的 <code>Sample Description Box</code> 列表数量是 <code>1</code></li>
<li>Sample Description Box: 参见文档 ISO-IEC 14496-15 AVC file format</li>
</ul>
</li>
</ul>
<h3 id="stts"><a href="#stts" class="headerlink" title="stts"></a>stts</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p>
<p>这个 Box 是 <code>Sample number</code> 和解码时间 <code>DTS</code> 之间的映射表，通过这个表格，我们可以找到任何时间的 <code>Sample</code>，但用这个表格只是能找到当前时间的 <code>Sample</code> 的序号，<code>Sample</code> 的长度和指针还要靠其它表格获取。</p>
<p><code>Sample delta</code> 简单可以理解为采样点 <code>Sample</code> 的 <code>duration</code>，所有 <code>duration</code> 相加应该为总的 <code>Track</code> 的时长。大家把这个时间理解为该帧数据当前的解码时间即可，计算公式：</p>
<pre><code>DT(n+1) = DT(n) + STTS(n)
</code></pre><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203130420.png" alt="stts"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class TimeToSampleBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stts&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entry_count; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_count</span>;  <span class="comment">// 连续相同时间长度 `sample delta` 的 `sample` 个数</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_delta</span>;  <span class="comment">// 每个 `sample delta` 以 `timescale` 为单位的时间长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 00 18</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li>
<li>Box type: <code>0x73 74 74 73</code> 这就是 <code>stts</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
<li>Box version: <code>0x00</code></li>
<li>Box flags: <code>0x00 00 00</code></li>
</ul>
</li>
<li>Box Data<ul>
<li>entry count: <code>0x00 00 00 01</code> 说明下面的 <code>sample conut</code> 和 <code>sample delta</code> 组成的二元组信息个数 列表数量是 <code>1</code></li>
<li>entry 1<ul>
<li>sample conut: <code>0x00 00 01 b0</code> 值为 <code>sample delta</code> 的 <code>sample</code> 个数为 <code>432</code> 个</li>
<li>sample delta: <code>0x00 00 02 00</code> 值为 <code>512</code>，这样我们计算出帧率就是 <code>12288/512</code> 即 <code>24fps</code>，参见 <a href="#mdhd">第四层 - mdhd</a>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通过 <code>Mp4Explorer</code> 验证分析结果:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203131946.png" alt="stts Mp4Explorer"></p>
<h3 id="ctts"><a href="#ctts" class="headerlink" title="ctts"></a>ctts</h3><h3 id="stss"><a href="#stss" class="headerlink" title="stss"></a>stss</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p>
<p><code>I</code> 帧是播放的起始位置，只有编码器拿到第一个 <code>I</code> 帧才能渲染出第一幅画面。所以后续的一些特殊随机操作，高标清切换时都需要找 <code>I</code> 帧，只有随机找到 <code>I</code> 帧才能完成这些特殊操作。</p>
<p>其中该 <code>Box</code> 就是存储了那些 <code>Sample</code> 是 <code>I</code> 帧，很显然音频 <code>Track</code> 也是不存在这个 <code>Box</code> 的。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203132044.png" alt="stss"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SyncSampleBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stss&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;           <span class="comment">// 关键帧的 sample 个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entry_count; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_number</span>;     <span class="comment">// 关键帧 sample 序号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 00 18</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li>
<li>Box type: <code>0x73 74 73 73</code> 这就是 <code>stss</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
<li>Box version: <code>0x00</code></li>
<li>Box flags: <code>0x00 00 00</code></li>
</ul>
</li>
<li>Box Data<ul>
<li>entry count: <code>0x00 00 00 02</code> 说明本文件有 <code>2</code> 个关键帧</li>
<li>sample number 1: <code>0x00 00 00 01</code> 关键帧 <code>1</code> 的 <code>Sample</code> 序号为 <code>1</code></li>
<li>sample number 2: <code>0x00 00 00 fb</code> 关键帧 <code>2</code> 的 <code>Sample</code> 序号为 <code>251</code></li>
</ul>
</li>
</ul>
<h3 id="stsc"><a href="#stsc" class="headerlink" title="stsc"></a>stsc</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one</code></p>
<p>这个 <code>Box</code> 就是说明那些 <code>Sample</code> 可以划分为一个 <code>Trunk</code></p>
<p>媒体数据被分为若干个 <code>Chunk</code>, <code>Chunk</code> 可以有不同的大小，同一个 <code>Chunk</code> 中的样点 <code>Sample</code> 也允许有不同的大小；通过本表可以定位一个样点的 <code>Chunk</code> 位置，并可以得知该 <code>MP4</code> 中有多少个 <code>Chunks</code>，每个 <code>Chunks</code> 有多少个 <code>Samples</code>。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203132226.png" alt="stsc"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SampleToChunkBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stsc&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        <span class="comment">/* 具有相同采样点 sample 和 `sample_description_index 的 chunk 中，第一个 chunk 的索引值</span></span><br><span class="line"><span class="comment">        ** 也就是说该 chunk 索引值一直到下一个索引值之间的所有 chunk 都具有相同的 sample 个数</span></span><br><span class="line"><span class="comment">        ** 同时这些 sample 的描述 description 也一样； */</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> first_chunk</span>;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> samples_per_chunk</span>;         <span class="comment">// 上面所有 chunk 的 sample 个数</span></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_description_index</span>;  <span class="comment">// 描述采样点的采样描述项的索引值，范围为 1 到样本描述表中的表项数目</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 00 18</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li>
<li>Box type: <code>0x73 74 73 73</code> 这就是 <code>stss</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
<li>Box version: <code>0x00</code></li>
<li>Box flags: <code>0x00 00 00</code></li>
</ul>
</li>
<li>Box Data<ul>
<li>entry count: <code>0x00 00 00 01</code> 这说明三元组信息的个数只有 <code>1</code> 个</li>
<li>first chunk 1: <code>0x00 00 00 01</code> 具有相同 <code>Sample</code> 个数和 <code>description</code> 的 <code>Chunk</code> 起始索引是 <code>1</code></li>
<li>samples per chunk 1: <code>0x00 00 00 01</code> 每个 <code>Chunk</code> 具有的 <code>Sample</code> 的个数是 <code>1</code></li>
<li>sample description index 1 <code>0x00 00 00 01</code> 这些 <code>Sample</code> 的 <code>description index</code> 是 1，一般用默认值即可</li>
</ul>
</li>
</ul>
<p>通过 <code>Mp4Explorer</code> 验证分析结果:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203231441.png" alt="stsc Mp4Explorer"></p>
<h3 id="stsz"><a href="#stsz" class="headerlink" title="stsz"></a>stsz</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one variant must be present</code></p>
<p>前面分析了 <code>Sample</code> 的 <code>PTS</code>、<code>DTS</code> 等，也分析了 <code>Chunk</code> 里面 <code>Sample</code> 的信息，但是没有分析 <code>Sample</code> 的大小，这是我们在文件读取和解析 <code>Sample</code> 的关键。这里给出每个 <code>Sample</code> 的 <code>Size</code> 即包含的字节数。</p>
<p>包含了媒体中全部 <code>Sample</code> 的数目和一张给出每个 <code>Sample</code> 大小的表。这个 <code>Box</code> 相对来说体积是比较大的。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203233016.png" alt="stsz"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class SampleSizeBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stsz&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_size</span>;   <span class="comment">// 指定默认的 Sample 大小，如果每个 Sample 大小不相等，则这个字段值为 0，每个 Sample 大小存在下表中</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> sample_count</span>;  <span class="comment">// 该 Track 中所有 Sample 的数量</span></span><br><span class="line">    <span class="keyword">if</span> (sample_size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sample_count; i++) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_size</span>;    <span class="comment">// 每个 Sample 的大小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 06 d4</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li>
<li>Box type: <code>0x73 74 73 7a</code> 这就是 <code>stsz</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
<li>Box version: <code>0x00</code></li>
<li>Box flags: <code>0x00 00 00</code></li>
</ul>
</li>
<li>Box Data<ul>
<li>sample size: <code>0x00 00 00 00</code> 说明 <code>Sample</code> 的具体大小在表后面项目中的 <code>entry size</code></li>
<li>sample count: <code>0x00 00 01 b0</code> 说明本 <code>Track</code> 的大小为 <code>432</code> 个 <code>Sample</code></li>
<li>entry size 1: <code>0x00 00 73 5f</code> 说明第一个 <code>Sample</code> 大小为 <code>29535</code> 字节</li>
<li>entry size 2: <code>0x00 00 06 e6</code> 说明第二个 <code>Sample</code> 大小为 <code>1766</code> 字节</li>
<li>entry size 3: <code>0x00 00 1f be</code> 说明第三个 <code>Sample</code> 大小为 <code>8126</code> 字节</li>
<li>entry size 4: <code>0x00 00 1b e2</code> 说明第四个 <code>Sample</code> 大小为 <code>7138</code> 字节</li>
<li>entry size 5: <code>0x00 00 25 eb</code> 说明第五个 <code>Sample</code> 大小为 <code>9707</code> 字节</li>
<li>…</li>
</ul>
</li>
</ul>
<p>通过 <code>Mp4Explorer</code> 验证分析结果:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201203232256.png" alt="stsz Mp4Explorer"></p>
<h3 id="stco-co64"><a href="#stco-co64" class="headerlink" title="stco | co64"></a>stco | co64</h3><p><code>Container</code>: <code>Sample Table Box</code> (<code>stbl</code>)<br><code>Mandatory</code>: <code>Yes</code><br><code>Quantity</code>: <code>Exactly one variant must be present</code></p>
<p>该 <code>Box</code> 存储了 <code>Chunk Offset</code>，表示了每个 <code>Chunk</code> 在文件中的位置，这样我们就能找到了 <code>Chunk</code> 在文件的偏移量，然后根据其它表的关联关系就可以读取每个 <code>Sample</code> 的大小。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201204000004.png" alt="stco"></p>
<p>使用代码描述其结构:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="function">class ChunkOffsetBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;stco&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> chunk_offset</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aligned(<span class="number">8</span>) <span class="function">class ChunkLargeOffsetBox extends <span class="title">FullBox</span><span class="params">(<span class="string">&quot;co64&quot;</span>, version = <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> chunk_offset</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Box Header<ul>
<li>Box Length: <code>0x00 00 06 d0</code> 表示该 <code>Box</code> 长度为 <code>24</code> 字节</li>
<li>Box type: <code>0x73 74 63 6f</code> 这就是 <code>stco</code> 的 <code>ASCII</code> 值，标识了该 <code>Box</code> 的类型</li>
<li>Box version: <code>0x00</code></li>
<li>Box flags: <code>0x00 00 00</code></li>
</ul>
</li>
<li>Box Data<ul>
<li>entry count: <code>0x00 00 01 b0</code> 说明本 <code>Track</code> 的大小为 <code>432</code> 个 <code>Sample</code></li>
<li>chunk offset 1: <code>0x00 00 00 43</code> 说明本文件第一个 <code>Chunk</code> 的偏移量是 <code>67</code> 字节</li>
<li>chunk offset 2: <code>0x00 00 74 a2</code> 说明本文件第二个 <code>Chunk</code> 的偏移量是 <code>29858</code> 字节</li>
<li>chunk offset 3: <code>0x00 00 7e 35</code> 说明本文件第三个 <code>Chunk</code> 的偏移量是 <code>32309</code> 字节</li>
<li>chunk offset 4: <code>0x00 00 a0 53</code> 说明本文件第四个 <code>Chunk</code> 的偏移量是 <code>41043</code> 字节</li>
<li>chunk offset 5: <code>0x00 00 be 3f</code> 说明本文件第五个 <code>Chunk</code> 的偏移量是 <code>48703</code> 字节</li>
<li>…</li>
</ul>
</li>
</ul>
<p>通过 <code>Mp4Explorer</code> 验证分析结果:</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201204000821.png" alt="stco Mp4Explorer"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="/slave/MP4/ISO-IEC-14496-12-Base-Format-2015.pdf">ISO/IEC 14496-12</a></li>
<li>[2] <a href="/slave/MP4/ISO-IEC-14496-14-MP4-2003.pdf">ISO/IEC 14496-14</a></li>
</ul>
]]></content>
      <categories>
        <category>音视频封装</category>
      </categories>
      <tags>
        <tag>MP4</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码技术：H264 - 运动补偿</title>
    <url>/post/2021/b556f4df/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>运动补偿是一种描述相邻帧（相邻在这里表示在编码关系上相邻，在播放顺序上两帧未必相邻）差别的方法，具体来说是描述前面一帧（相邻在这里表示在编码关系上的前面，在播放顺序上未必在当前帧前面）的每个小块怎样移动到当前帧中的某个位置去。这种方法经常被视频压缩 / 视频编解码器用来减少视频序列中的时域冗余。它也可以用来进行去交织（deinterlacing）以及运动插值（motion interpolation）的操作。</p>
<a id="more"></a>
<h2 id="运动补偿原理"><a href="#运动补偿原理" class="headerlink" title="运动补偿原理"></a>运动补偿原理</h2><p>一个视频序列包含一定数量的图片 — 通常称为帧（frame）。相邻的图片通常很相似，也就是说，包含了很多冗余。使用运动补偿的目的是通过消除这种冗余，来提高压缩比。</p>
<p>最早的运动补偿的设计只是简单的从当前帧中减去参考帧，从而得到通常含有较少能量（或者称为信息）的 “残差”，从而可以用较低的码率进行编码。解码器可以通过简单的加法完全恢复编码帧。</p>
<p>一个稍微复杂一点的设计是估计一下整帧场景的移动和场景中物体的移动，并将这些运动通过一定的参数编码到码流中去。这样预测帧上的像素值就是由参考帧上具有一定位移的相应像素值而生成的。这样的方法比简单的相减可以获得能量更小的残差，从而获得更好的压缩比 — 当然，用来描述运动的参数不能在码流中占据太大的部分，否则就会抵消复杂的运动估计带来的好处。</p>
<p>通常，图像帧是一组一组进行处理的。每组的第一帧（通常是第一帧）在编码的时候不使用运动估计的办法，这种帧称为帧内编码帧（Intra frame）或者 I 帧。该组中的其它帧使用帧间编码帧（Inter frame），通常是 P 帧。这种编码方式通常被称为 IPPPP，表示编码的时候第一帧是 I 帧，其它帧是 P 帧。</p>
<p>在进行预测的时候，不仅仅可以从过去的帧来预测当前帧，还可以使用未来的帧来预测当前帧。当然在编码的时候，未来的帧必须比当前帧更早的编码，也就是说，编码的顺序和播放的顺序是不同的。通常这样的当前帧是使用过去和未来的 I 帧或者 P 帧同时进行预测，被称为双向预测帧，即 B 帧。这种编码方式的编码顺序的一个例子为 IBBPBBPBBPBB。</p>
<p>运动补偿的方法包含：全局运动补偿、分块运动补偿、可变分块运动补偿、重叠分块运动个补偿。</p>
<h2 id="全局运动补偿"><a href="#全局运动补偿" class="headerlink" title="全局运动补偿"></a>全局运动补偿</h2><p>在全局运动补偿中，运动模型基本上就是反映摄像机的各种运动，包括平移，旋转，变焦等等。这种模型特别适合对没有运动物体的静止场景的编码。 全局运动补偿有下面的一些优点：</p>
<ol>
<li>该模型仅仅使用少数的参数对全局的运行进行描述，参数所占用的码率基本上可以忽略不计。</li>
<li>该方法不对帧进行分区编码，这避免了分区造成的块效应。</li>
<li>在时间方向的一条直线的点如果在空间方向具有相等的间隔，就对应了在实际空间中连续移动的点。其它的运动估计算法通常会在时间方向引入非连续性。<br>但是，缺点是，如果场景中有运动物体的话，全局运动补偿就不足以表示了。这时候应该选用其它的方法。</li>
</ol>
<h2 id="分块运动补偿"><a href="#分块运动补偿" class="headerlink" title="分块运动补偿"></a>分块运动补偿</h2><p>在分块运动补偿（BMC for block motion compensation）中，每帧被分为若干像素块（在大多数视频编码标准，如 MPEG 中，是分为 16x16 的像素块）。从参考帧的某个位置的等大小的块对当前块进行预测，预测的过程中只有平移，平移的大小被称为运动矢量。</p>
<p>对分块运动补偿来说，运动矢量是模型的必要参数，必须一起编码加入码流中。由于运动矢量之间并不是独立的（例如属于同一个运动物体的相邻两块通常运动的相关性很大），通常使用差分编码来降低码率。这意味着在相邻的运动矢量编码之前对它们作差，只对差分的部分进行编码。使用熵编码对运动矢量的成分进行编码可以进一步消除运动矢量的统计冗余（通常运动矢量的差分集中于 0 矢量附近）。</p>
<p>运动矢量的值可以是非整数的，此时的运动补偿被称为亚像素精度的运动补偿。这是通过对参考帧像素值进行亚像素级插值，而后进行运动补偿做到的。最简单的亚像素精度运动补偿使用半像素精度，也有使用 1/4 像素和 1/8 像素精度的运动补偿算法。更高的亚像素精度可以提高运动补偿的精确度，但是大量的插值操作大大增加了计算复杂度。</p>
<p>分块运动补偿的一个大缺点在于在块之间引入的非连续性，通常称为块效应。当块效应严重时，解码图像看起来会有像马赛克一样的效果，严重影响视觉质量。另外一个缺点是，当高频分量较大时，会引起振铃效应。关于高频分量，请参见对运动补偿后的残差进行变换的方法：变换编码。</p>
<h2 id="可变分块运动补偿"><a href="#可变分块运动补偿" class="headerlink" title="可变分块运动补偿"></a>可变分块运动补偿</h2><p>可变分块运动补偿（VBSMC，全称 Variable Block Size Motion Compensation）是 BMC 的变种，编码器可以动态选择分块大小。进行视频编码时，使用大的分块可以减少表征运动向量所需的比特数，使用小的分块则可以在编码时产生更少的预测余量信息。较老的设计，象 H.261 和 MPEG-1 视频编码，典型的使用了固定分块，而较新的设计，像 H.263、MPEG-4 Part 2、H.264/MPEG-4 AVC 和 VC-1 则赋予了编码器动态选择何种分块来表征运动图像的能力。</p>
<h2 id="重叠分块运动补偿"><a href="#重叠分块运动补偿" class="headerlink" title="重叠分块运动补偿"></a>重叠分块运动补偿</h2><p>重叠分块运动补偿（OBMC for Overlapped block motion compensation）是一种更好的解决方案，它不但能增加预测精度，而且能够避免块失真。 因此，每个像素第属于 4 个分块。基于此方案，每个像素的 4 个预测值求和后得到一个加权平均数。</p>
<p>为此目的，分块被关联到一个窗口函数，该窗口函数具有任何地方的 4 个重叠窗口的总和为 1 的特质。</p>
<h2 id="运动估计"><a href="#运动估计" class="headerlink" title="运动估计"></a>运动估计</h2><p>运动估计就是寻找最优或次优的运动向量的过程。某个块的预测误差量常常是指在运动补偿区域所有像素中，预测像素和实际像素数值的均方差或者绝对差别总和。</p>
<p>发现最优向量，一个最基本的方法是不得不为在固定探测范围内，给每一个运动向量，计算块的预测误差计算邻近祯之中找寻前后 frame 之中相似的 Macro Block，两者之间的差异值。以及估算表示此 Motion Vector 所需的位元数目，和在错误数和比特数之间挑选一个最折中作为运动向量值。运动估计技术尽量简单的测试在执行前一个简单的探测测试技术为：估计所有可能的运动表现，比如这样的最优化被称做全探测。</p>
<p>一个稍快但不是最优的方法是用第一个近似值作为一个粗略探测栅格，然后在接下来的步骤里在近似值的周围精确栅格。</p>
<p>一个通用办法是 3 步探测，用 3 次探测栅格；3 个运动向量和 3 个精确步骤来得到 15 次 15 个像素范围内的全面探测。</p>
<p>对于分块运动估计，一个块的像素预测误差和它的附近搭接块，根据此前自乘的窗函数，都被测重和求和。</p>
<p>分块运动估计最主要的缺点是增加计算的复杂性，和实际的预测误差，因而最优向量依靠于临近运动块向量。</p>
<p>因此，没有一个多项式（计算的复杂性）算法可以保证最优运动向量。</p>
<p>然而，在可接受的计算的复杂性上，存在最接近最理想迭代和非迭代方法。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://zh.wikipedia.org/wiki/%E8%BF%90%E5%8A%A8%E8%A1%A5%E5%81%BF">运动补偿 - 维基百科，自由的百科全书</a></li>
</ul>
]]></content>
      <categories>
        <category>编解码技术</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频封装 - PES 封装格式</title>
    <url>/post/2020/f33d2f13/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PES(Packetized elementary stream) 是 MPEG-2 Part 1, Systems（ISO/IEC 13818-1） 和 ITU-T H.222.0 中的规范，它们定义了 PS(MPEG program streams) 和 TS(MPEG transport streams) 中数据包中 ES(elementary stream)（通常是音频或视频编码器的输出）的携带。 通过将 PES 数据包头内 ES 的顺序数据字节封装组成 PES。</p>
<a id="more"></a>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="PES-packet"><a href="#PES-packet" class="headerlink" title="PES packet"></a>PES packet</h3><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200729232326.jpg" alt="PES Packet"></p>
<ul>
<li><p><strong>Packet start code prefix</strong>：包头起始码，固定为 0x000001，占位 24bit；</p>
</li>
<li><p><strong>Stream id</strong>：PES 包中的负载流类型，一般视频为 0xe0，音频为 0xc0，占位 8bit；</p>
</li>
<li><p><strong>PES packet length</strong>：PES 包长度，包括此字节后的可选包头和负载的长度，占位 16bit；</p>
</li>
<li><p>Optional PES Header，顺序依次为：</p>
<ul>
<li>“10” 字段：占位 2bit；</li>
<li>PES scrambling control：加密模式，占 2bit；00 未加密，01 或 10 或 11 由用户定义；</li>
<li>PES priority：有效负载的优先级，占位 1bit；值为 1 比值为 0 的负载优先级高；</li>
<li>Data alignment indicator：数据定位指示器，占位 1bit；</li>
<li>Copyright：版权信息，1 为有版权，0 无版权，占位 1bit；</li>
<li>Original or copy：原始或备份，1 为原始，0 为备份，占位 1bit；</li>
<li><em>后面是 7 个 flags(一般我们关注的就是 PTS DTS 的标志位)：</em></li>
<li>PTS_DTS_flags：PTS 和 DTS 标志位，占位 2bit；10 表示首部有 PTS 字段，11 表示有 PTS 和 DTS 字段，00 表示都没有，01 被禁止，不会出现此种情况；</li>
<li>ESCR_flag：ESCR 标志，占位 1bit；1 表示首部有 ESCR 字段，0 则无此字段</li>
<li>ES_rate_flag：ES_rate 字段，占位 1bit；1 表示首部有此字段，0 无此字段；</li>
<li>DSM_trick_mode_flag：占位 1bit；1 表示有 8 位的 DSM_trick_mode_flag 字段，0 无此字段；</li>
<li>Additional_copy_info_flag：占位 1bit；1 表示首部有此字段，0 表示无此字段；</li>
<li>PES_CRC_flag：占位 1bit；置 1 表示 PES 分组有 CRC 字段，0 无此字段；</li>
<li>PES_extension_flag：占位 1bit；扩展标志位，置 1 表示有扩展字段，0 无此字段；</li>
<li>PES header data length：(UI)PES 首部中可选字段和填充字段的长度；占位 8bit；可选字段的内容由上面 7 个 flags 来进行控制；</li>
</ul>
</li>
<li><p>Optional fields：可选字段的描述信息区域，其内容由上面的 7 个 flag 来控制；</p>
<ul>
<li><p><strong>PTS/DTS 字段</strong>：显示时间戳 / 解码时间戳，占位 (1~2) * 40bit，当 <code>PTS_DTS_flags == 11</code> 时此字段存在 2 个，占 80bit，当 <code>PTS_DTS_flags == 10</code> 时此字段存在 1 个，占 40bit；时间占用 33 个 bit，PTS 和 DTS 的内容是在这 40bit 中取 33 位，方式相同；</p>
<ul>
<li><em>PTS(presentation time stamp) 显示时间戳和 DTS(Decoding Time Stamp) 解码时间戳，是用来音视频同步的，是打在 PES 包的包头里面的，PTS/DTS 是相对 SCR(系统参考) 的时间戳，是以 90000 为单位的，PTS/DTS 到 ms 的转换公式是 PTS/90，系统时钟频率 (H264 采样频率?) 为 90Khz，所以转换到秒为 PTS/90000，所以如果是以 ms 为单位的播放器，PTS/DTS 是要使用公式 ms=pts/90 来转换才行的，而如果是以时钟频率为单位的话，则直接将 PTS/DTS 送进去解码即可；如果没有 B 帧，PTS 和 DTS 的顺序应该是一致的，如果有 B 帧，则需要先解码 P 帧，才能解出来 B 帧，所以需要 PTS 和 DTS 来控制解码时间和显示时间；</em></li>
<li>start_code：起始码，占位 4bit；若 <code>PTS_DTS_flags == &#39;10&#39;</code> ，则说明只有 PTS；若 <code>PTS_DTS_flags == &#39;11&#39;</code> ，则 PTS 和 DTS 都存在，PTS 的起始码为 0011，DTS 的起始码为 0001；</li>
<li>PTS[32..30]：占位 3bit；</li>
<li>marker_bit：占位 1bit；</li>
<li>PTS[29..15]：占位 15bit；</li>
<li>marker_bit：占位 1bit；</li>
<li>PTS[14..0]：占位 15bit；</li>
<li>marker_bit：占位 1bit；</li>
<li><em>PTS/DTS  = （PTS1 &amp; 0x0e) &lt;<29 + (PTS2 & 0xfffe) << 14 + (PTS3 & 0xfffe ) >&gt; 1;</em></li>
</ul>
</li>
<li><p>ESCR 字段：此字段占位 48bit，由 33bit 的 ESCR_base 字段和 9bit 的 ESCR_extension 字段组成， <code>ESCR_flag == 1</code> 时此字段存在；数据依次顺序：</p>
<ul>
<li>Reserved：保留字段，占位 2bit；</li>
<li>ESCR_base[32..30]：占位 3bit；</li>
<li>marker_bit：占位 1bit；</li>
<li>ESCR_base[29..15]：占位 15bit；</li>
<li>marker_bit：占位 1bit；</li>
<li>ESCR_base[14..0]：占位 15bit；</li>
<li>marker_bit：占位 1bit；</li>
<li>ESCR_extension：占位 9bit；周期数，取值范围 0~299；循环一次，base+1；</li>
<li>marker_bit：占位 1bit；</li>
</ul>
</li>
<li><p>ES rate 字段：目标解码器接收 PES 分组字节速率，禁止为 0，占位 24bit， <code>ES_rate_flag == 1</code> 时此字段存在；数据顺序为：</p>
<ul>
<li>marker_bit：占位 1bit；</li>
<li>ES_rate：占位 22bit；</li>
<li>marker_bit：占位 1bit；</li>
</ul>
</li>
<li><p>Trick mode control 字段：表示哪种 trick mode 被应用于相应的视频流，占位 8bit， <code>DSM_trick_mode_flag == 1</code> 时此字段存在；其中 trick_mode_control 占前 3bit，根据其值后面有 5bit 的不同内容；</p>
<ul>
<li>如果 trick_mode_control == ‘000’，依次字节顺序为：<ul>
<li>field_id：占位 2bit；</li>
<li>intra_slice_refresh ：占 1bit；</li>
<li>frequency_truncation：占 2bit；</li>
</ul>
</li>
<li>如果 trick_mode_control == ‘001’，依次字节顺序为：<ul>
<li>rep_cntrl：占位 5bit；</li>
</ul>
</li>
<li>如果 trick_mode_control == ‘010’，依次字节顺序为：<ul>
<li>field_id：占位 2bit；</li>
<li>Reserved：占位 3bit；</li>
</ul>
</li>
<li>如果 trick_mode_control == ‘011’，依次字节顺序为：<ul>
<li>field_id：占位 2bit；</li>
<li>intra_slice_refresh：占 1bit；</li>
<li>frequency_truncation：占 2bit；</li>
</ul>
</li>
<li>如果 trick_mode_control== ‘100’，依次字节顺序为：<ul>
<li>rep_cntrl：占位 5bit；</li>
</ul>
</li>
<li>其他情况，字节顺序为：<ul>
<li>reserved ：占位 5bit；</li>
</ul>
</li>
</ul>
</li>
<li><p>Additional copy info 字段：占 8 个 bit， <code>Additional_copy_info_flag == 1</code> 时此字段存在；数据顺序为：</p>
<ul>
<li>marker_bit：占位 1bit；</li>
<li>copy info 字段：占位 7bit；表示和版权相关的私有数据；</li>
</ul>
</li>
<li><p>Previous PES CRC 字段：占位 16bit 字段，包含 CRC 值， <code>PES_CRC_flag == 1</code> 时此字段存在；</p>
</li>
<li><p>PES extension 字段：PES 扩展字段， <code>PES_extension_flag == 1</code> 时此字段存在；内容如下，字节顺序依次为：</p>
<ul>
<li>PES_private_data_flag：占 1bit，置 1 表示有私有数据，0 则无；</li>
<li>Pack_header_field_flag：占 1bit，置 1 表示有 Pack_header_field 字段，0 则无；</li>
<li>Program_packet_sequence_counter_flag：占 1bit，置 1 表示有此字段，0 则无；</li>
<li>P-STD_buffer_flag：占位 1bit，置 1 表示有 P-STD_buffer 字段，0 则无此字段；</li>
<li>Reserved 字段：3bit；</li>
<li>PES_extension_flag_2：占位 1bit，置 1 表示有扩展字段，0 则无此字段；</li>
</ul>
</li>
<li><p>Optional field ：PES 扩展字段的可选字段内容顺序为：</p>
<ul>
<li>PES_private_data 字段：私有数据内容，占位 128bit， <code>PES_private_data_flag == 1</code> 时此字段存在；</li>
<li>Pack_header_field 字段： <code>Pack_header_field_flag == 1</code> 时此字段存在；字段组成顺序如下：<ul>
<li>Pack_field_length 字段：(UI) 指定后面的 field 的长度，占位 8bit；</li>
<li>pack_header_field()：长度为 Pack_field_length 指定；</li>
</ul>
</li>
<li>Program_packet_sequence_counter 字段：计数器字段，16 个 bit；当 flag 字段 <code>Program_packet_sequence_counter_flag == 1</code> 时此字段存在；字节顺序依次为：<ul>
<li>marker_bit：占位 1bit；</li>
<li>packet_sequence_counter 字段：(UI) 占位 7bit；</li>
<li>marker_bit：占位 1bit；</li>
<li>MPEG1_MPEG2_identifier：占位 1bit；置位 1 表示此 PES 包的负载来自 MPEG1 流，置位 0 表示此 PES 包的负载来自 PS 流；</li>
<li>original_stuff_length：(UI) 占位 6bit；表示 PES 头部填充字节长度；</li>
</ul>
</li>
<li>P-STD_buffer 字段：表示 P-STD_buffer 内容，占位 16bit； <code>P-STD_buffer_flag == &#39;1&#39;</code> 时此字段存在；字节顺序依次为：<ul>
<li>‘01’字段：占位 2bit；</li>
<li>P-STD_buffer_scale：占位 1bit；表示用来解释后面 P-STD_buffer_size 字段的比例因子；如果之前的 stream_id 表示音频流，则此值应为 0，若之前的 stream_id 表示视频流，则此值应为 1，对于其他 stream 类型，此值可以 0 或 1；</li>
<li>P-STD_buffer_size：占位 13bit；无符号整数；大于或等于所有 P-STD 输入缓冲区大小 BSn 的最大值；若 P-STD_buffer_scale == 0，则 P-STD_buffer_size 以 128 字节为单位；若 P-STD_buffer_scale == 1，则 P-STD_buffer_size 以 1024 字节为单位；</li>
</ul>
</li>
<li>PES_extension2 字段：扩展字段的扩展字段；占用 N*8 个 bit， <code>PES_extension_flag_2 == &#39;1&#39;</code> 时此字段存在；字节顺序依次为：<ul>
<li>marker_bit：占位 1bit；</li>
<li>PES_extension_field_length：占位 7bit，表示扩展区域的长度；</li>
<li>Reserved 字段：占位 8*PES_extension_field_length 个 bit；</li>
</ul>
</li>
</ul>
</li>
<li><p>Stuffing bytes：填充字段，固定为 0xFF；不能超过 32 个字节；</p>
</li>
<li><p>PES_packet_data_byte：PES 包负载中的数据，即 ES 原始流数据；</p>
</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] MPEG-2 Part 1, Systems</li>
<li>[2] <a href="https://blog.csdn.net/appledurian/article/details/70851428">PES,TS,PS,RTP等流的打包格式解析之PES流_appledurian的博客</a></li>
<li>[3] <a href="https://en.wikipedia.org/wiki/Packetized_elementary_stream">Packetized elementary stream - Wikipedia</a></li>
</ul>
]]></content>
      <categories>
        <category>音视频封装</category>
      </categories>
      <tags>
        <tag>MPEG2-PES</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频封装 - PS 封装格式</title>
    <url>/post/2020/9064839e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MPEG2-PS-简介"><a href="#MPEG2-PS-简介" class="headerlink" title="MPEG2-PS 简介"></a>MPEG2-PS 简介</h2><p>PS 流（MPEG program stream）是用于多路复用数字音频、视频等的容器格式。PS 格式在 MPEG-1 Part 1 (ISO/IEC 11172-1) 和 MPEG-2 Part 1, Systems (ISO/IEC standard 13818-1/ITU-T H.222.0) 中指定。</p>
<a id="more"></a>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="Program-Stream"><a href="#Program-Stream" class="headerlink" title="Program Stream"></a>Program Stream</h3><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200729221633.jpg" alt="Program Stream 结构"></p>
<blockquote>
<p>pack_start_code – The pack_start_code is the bit string ‘0000 0000 0000 0000 0000 0001 1011 1010’ (0x000001BA). It identifies the beginning of a pack.<br>MPEG_program_end_code – The MPEG_program_end_code is the bit string ‘0000 0000 0000 0000 0000 0001 1011 1001’ (0x000001B9). It terminates the Program Stream.</p>
</blockquote>
<h3 id="Program-Stream-Pack"><a href="#Program-Stream-Pack" class="headerlink" title="Program Stream Pack"></a>Program Stream Pack</h3><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200729222439.png" alt="Program Stream Pack 结构"></p>
<blockquote>
<p>packet_start_code_prefix – The packet_start_code_prefix is a 24-bit code. Together with the stream_id that follows it constitutes a packet start code that identifies the beginning of a packet. The packet_start_code_prefix is the bit string ‘0000 0000 0000 0000 0000 0001’ (0x000001).</p>
</blockquote>
<h3 id="Program-Stream-Pack-Header"><a href="#Program-Stream-Pack-Header" class="headerlink" title="Program Stream Pack Header"></a>Program Stream Pack Header</h3><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200729222901.jpg" alt="Program Stream Pack Header 结构"></p>
<ul>
<li>pack_start_code — pack_start_code 为比特串’0000 0000 0000 0000 0000 0001 1011 1010’ (0x000001BA)。它标识 PS 包的起始。</li>
<li>system_clock_reference_base; system_clock_reference_extension — 系统时钟参考（SCR）为分成两部分编码的 42 比特字段。第一部分 system_clock_reference_base 为 33 比特字段，第二部分 system_clock_reference_extension 为 9 比特字段。SCR 指示在节目目标解码器的输入端包含 system_clock_reference_base 最后比特的字节到达的预期时间。</li>
<li>marker_bit — marker_bit 为 1 比特字段，其值为‘1’。</li>
<li>program_mux_rate — 此为 22 比特整数，指示包期间 P-STD 接收节目流的速率，其中该节目流包含在包中。program_mux_rate 值以 50 字节 / 秒为度量单位。0 值禁用。program_mux_rate 中表示的值用于规定字节到达 2.5.2 中的 P-STD 输入端的时间。在 program_mux_rate 字段中的编码值可以随着 ITU-T H.222.0 建议书 | ISO/IEC 13818-1 节目多路复用流中的包到包的变化而改变。</li>
<li>pack_stuffing_length — 3 比特整数，指示跟随此字段的填充字节数。</li>
<li>stuffing_byte — 此为等于‘1111 1111’的固定 8 比特 值，可以由编码器插入，例如满足信道的要求。它由解码器丢弃。在每个包头中，应存在不多于 7 个的填充字节。</li>
</ul>
<h3 id="System-header"><a href="#System-header" class="headerlink" title="System header"></a>System header</h3><p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200729224213.png" alt="System header 结构"></p>
<ul>
<li>system_header_start_code — 比特串 ‘0000 0000 0000 0000 0000 0001 1011 1011’ (0x000001BB)。它标识 System header 的起始。</li>
<li>header_length — 此 16 比特字段指示跟随 header_length 字段的系统头的字节长度。</li>
<li>rate_bound — 22 比特字段。rate_bound 为大于或等于在任意节目流包中编码的 program_mux_rate 字段的最大值的整数值。它可供解码器使用来评估它是否有能力解码该完整流。</li>
<li>audio_bound — 6 比特字段。为 0 到 32 闭区间内的一个整数，在解码过程同时被激活的 PS 流中，它被设置为大于或等于 ISO/IEC 13818-3 和 ISO/IEC 11172-3 音频流最大数的整数值。</li>
<li>fixed_flag — fixed_flag 为 1 比特标志。置于‘1’时指示固定的比特速率操作。置于‘0’时指示可变比特速率操作。</li>
<li>CSPS_flag — CSPS_flag 为 1 比特字段。若其值置于‘1’，则节目流满足 2.7.9 中规定的限制。</li>
<li>system_audio_lock_flag — system_audio_lock_flag 为 1 比特字段，指示音频采样速率和系统目标解码器的 system_clock_frequency 之间存在特定的常量比率关系。</li>
<li>system_video_lock_flag — system_video_lock_flag 为 1 比特字段，指示视频时间基和系统目标解码器的系统时钟频率之间存在特定的常量比率关系。</li>
<li>video_bound — video_bound 为 5 比特整数，在 0 到 16 的闭区间内取值，在解码过程同时被激活的 PS 流中，它被设置为大于或等于视流的最大数的整数值。</li>
<li>packet_rate_restriction_flag — 1 比特标志。</li>
<li>reserved_bits — 此 7 比特字段由 ISO/IEC 保留供未来使用。值应为‘111 1111’。</li>
<li>stream_id — stream_id 为 8 比特字段， 指示以下 P-STD_buffer_bound_scale 和 P-STD</li>
<li>P-STD_buffer_size_bound 字段所涉及的流的编码与基本流编号。若 stream_id 等于‘ 1011 1000 ’， 则跟随 stream_id 的 P-STD_buffer_bound_scale 和 P-STD_buffer_size_bound 字段涉及节目流中的所有音频流。若 stream_id 等于‘ 1011 1001 ’， 则跟随 stream_id 的 P-STD_buffer_bound_scale 和 P-STD_buffer_size_bound 字段涉及节目流中的所有视频流。<br>若 stream_id 取任何其他值，则它将是大于或等于‘1011 1100’的字节值并将解释为涉及依照表 2-22<br>的流编码和基本流编号。</li>
<li>P-STD_buffer_bound_scale — P-STD_buffer_bound_scale 为 1 比特字段， 指示用于解释后续</li>
<li>P-STD_buffer_size_bound 字段的标度因子。若前导 stream_id 指示音频流，则 P-STD_buffer_bound_scale 必有 0 值。若前导 stream_id 指示视频流，则 P-STD_buffer_bound_scale 必有 1 值。对所有其他流类型，P-STD_buffer_bound_scale 的值可以为 1 或为 0。</li>
<li>P-STD_buffer_size_bound — P-STD_buffer_size_bound 为 13 比特无符号整数，规定该值大于或等于 PS 流中流 n 的所有包上的最大 P-STD 输入缓冲器尺寸 BSn。若 P-STD_buffer_bound_scale 有 0 值，那<br>么 P-STD_buffer_size_bound 以 128 字节为单位度量该缓冲器尺寸限制。若 P-STD_buffer_bound_scale 有‘1’<br>值，那么 P-STD_buffer_size_bound 以 1024 字节为单位度量该缓冲器尺寸限制。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PS 码流格式总结如下图：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201214231955.jpg" alt="PS码流格式"></p>
<blockquote>
<p>PES Packet 参见 <a href="/post/2020/f33d2f13/" title="音视频封装 - PES 封装格式">音视频封装 - PES 封装格式</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] MPEG-2 Part 1, Systems</li>
</ul>
]]></content>
      <categories>
        <category>音视频封装</category>
      </categories>
      <tags>
        <tag>MPEG2-PS</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频封装 - PS 封装解析示例</title>
    <url>/post/2020/1472cc3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章 <a href="/post/2020/9064839e/" title="音视频封装 - PS 封装格式">音视频封装 - PS 封装格式</a> 中分析了 <code>PS</code> 流的结构，但文章中中涉及到的元素过多，难以理解，故通过一段真实的码流的分析来加强对 <code>PS</code> 流结构的理解。</p>
<blockquote>
<p>注 1：本文中的 <code>PS</code> 码流 A 截取自一段经 <code>ffmpeg</code> 转码的网络视频，码流 B 截取自海康摄像机的 <code>GB28181</code> 码流。<br>注 2：本文中的数字一般为十进制表示，如果是其他进制数据，会在数字后携带 <code>(2)</code> 代表二进制，在数字前添加 <code>0x</code> 代表十六进制<br>注 3：截图中的码流信息均使用十六进制</p>
</blockquote>
<a id="more"></a>
<h2 id="PS-Stream-A"><a href="#PS-Stream-A" class="headerlink" title="PS Stream A"></a>PS Stream A</h2><h3 id="PS-Header"><a href="#PS-Header" class="headerlink" title="PS Header"></a>PS Header</h3><p><code>PS</code> 码流由多个 <code>PS Pack</code> 组成，而 <code>PS Pack</code> 的起始符为 <code>0x00 00 01 ba</code>。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117214228.png" alt="PS Header"></p>
<p>接下来跳过 <code>9</code> 个字节，看第 <code>10</code> 个字节，其最后三位数字代表拓展内容的长度，此包中该位置后三位为 <code>0</code>，代表无拓展内容。</p>
<blockquote>
<p>如果该位置后三位非 0，参见 <a href="#PS-Header-Extern">PS Header Extern</a></p>
</blockquote>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117215716.png" alt="拓展内容"></p>
<p>继续读取数据，如果遇到了 <code>0x00 00 01 bb</code>，就代表到了码流中 <code>PS System Header</code> 部分。</p>
<blockquote>
<p>码流中有可能会读取到 <code>0x00 00 01 bc</code>，参见 <a href="#Program-Stream-Map">Program Stream Map</a></p>
</blockquote>
<h3 id="PS-System-Header"><a href="#PS-System-Header" class="headerlink" title="PS System Header"></a>PS System Header</h3><p><code>System Header</code> 当且仅当数据包为第一个数据包时才存在，以 <code>0x00 00 01 bb</code> 的开始。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117220401.png" alt="PS System Header"></p>
<p>之后紧跟着的 <code>0x00 0c</code> 两个字节表示 <code>System Header</code> 的长度，换算为十进制，即为 <code>12</code> 个字节。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117220711.png" alt="PS System Header Length"></p>
<p>之后跳过 <code>6</code> 字节数据，之后如果 <code>nextbit == 1</code>，则该位置为一个 <code>stream_id</code>，<code>stream_id</code> 为 <code>0xe0</code>，指示该 <code>PS</code> 码流中包含视频流。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117221430.png" alt="Stream id e0"></p>
<p>该部分内容 <code>3</code> 字节一个循环，下一个循环中 <code>nextbit == 1</code>，则该位置也为一个 <code>stream_id</code>，<code>stream_id</code> 为 <code>0xc0</code>，指示该 <code>PS</code> 码流中包含音频流。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117221746.png" alt="Stream id c0"></p>
<p>至此 <code>nextbit == 0</code>，说明该循环结束，读取的长度也与上述 <code>PS System Header</code> 的长度值 <code>12</code> 一致。</p>
<p>继续读取数据，遇到了 <code>0x00 00 01</code>，<code>PS</code> 流中这三个字符可视为不同数据的分隔符，而其下一位数据指示了后续数据的类型。</p>
<h3 id="PES-Pack"><a href="#PES-Pack" class="headerlink" title="PES Pack"></a>PES Pack</h3><p>如果读取 PS 流中遇到了 <code>0x00 00 01 e0</code> 或 <code>0x00 00 01 c0</code>，就代表读取到了 <code>PES Pack</code>。</p>
<p><code>PES Pack</code> 分为两个部分，一部分是 <code>Header</code>，一部分是 <code>Payload</code>，<code>Header</code> 用于存储一些描述信息，而 <code>Payload</code> 部分为其存储的原始数据，<code>PES</code> 可能有多个。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117234659.png" alt="PES Pack"></p>
<p><code>0x00 00 01 e0</code> 代表遇到的是一个 <code>PES Video Pack</code>，如果是 <code>0x00 00 01 c0</code>，代表遇到的是一个 <code>PES Audio Pack</code>。</p>
<p>再之后的 <code>0x07 dc</code> 表示长度，即其后的 <code>2012</code> 字节为数据内容长度。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117235040.png" alt="PES Pack Length"></p>
<p>之后参考 <code>PES Pack</code> 结构来解析数据，可参见 <a href="/post/2020/f33d2f13/" title="音视频封装 - PES 封装格式">音视频封装 - PES 封装格式</a>。</p>
<p>跳过 1 字节字段后，下一个字段为 <code>PTS_DTS_flags</code> 字段，占位 2bits。</p>
<blockquote>
<p><code>PTS_DTS_flags</code>：<code>PTS</code> 和 <code>DTS</code> 标志位，占位 2bit；<code>10(2)</code> 表示首部有 <code>PTS</code> 字段，<code>11(2)</code> 表示有 <code>PTS</code> 和 <code>DTS</code> 字段，<code>00(2)</code> 表示都没有，<code>01(2)</code> 被禁止。<br><code>PTS</code> - 显示时间戳（Presentation Time Stamp），用来表示显示单元出现在系统目标解码器的时间。<br><code>DTS</code> - 解码时间戳（Decoding Time Stamp），用来表示将存取单元全部字节从解码缓存取走的时间。<br>如果 <code>PTS_DTS_flags</code> 不是 <code>00(2)</code>，就代表存在 <code>PTS</code> 或 <code>DTS</code> 参见 <a href="#PTS_DTS_flags">PTS_DTS_flags</a></p>
</blockquote>
<p>故该 <code>PES Pack</code> 中无 <code>PTS</code> 和 <code>DTS</code> 字段</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117235708.png" alt="PTS_DTS_flags"></p>
<p>后面 6bits 也是 <code>PES</code> 包中可选字段的 <code>Flag</code> 参数，由上图可知，该 <code>PES Pack</code> 无这些可选字段。</p>
<p>继续读取数据，下一个字段就为 <code>PES_header_data_length</code>，代表 <code>PES Header</code> 中可选字段和填充字段的长度，占位 <code>8bit</code>，该 <code>PES Pack</code> 中该值为 <code>03</code>，即该 <code>PES Pack</code> 中，该字段之后 <code>3</code> 个字节为 <code>PES Header</code> 字段，剩余数据均为数据 <code>Payload</code>。</p>
<h2 id="PS-Stream-B"><a href="#PS-Stream-B" class="headerlink" title="PS Stream B"></a>PS Stream B</h2><h3 id="PS-Header-Extern"><a href="#PS-Header-Extern" class="headerlink" title="PS Header Extern"></a>PS Header Extern</h3><p>如果 <code>PS Pack</code> 第 <code>10</code> 字节后三位不是 <code>000(2)</code>，则代表其后有相应长度的拓展内容，比如下图码流中就有 <code>6</code> 字节拓展内容：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117220016.png" alt="拓展内容 2"></p>
<h3 id="Program-Stream-Map"><a href="#Program-Stream-Map" class="headerlink" title="Program Stream Map"></a>Program Stream Map</h3><p>如果码流中遇到了 <code>0x00 00 01 bc</code>，则之后的数据为 <code>Program Stream Map</code> 数据。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117223419.png" alt="Program Stream Map"></p>
<p><code>Program Stream Map</code>，即 <code>PSM</code>，其格式如下图所示：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117223519.png" alt="Program Stream Map 格式"></p>
<p>可以看出，<code>0x00 00 01 bc</code> 后两位代表该部分数据长度，该 <code>PSM</code> 数据长度为 <code>0x62</code>，转化为十进制，即 <code>98</code> 字节。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117223909.png" alt="Program Stream Map length"></p>
<p>结合上边的 <code>PSM</code> 结构，自 <code>0x00 62</code> 后，跳过两个字节的固定内容，就到了两个字节的 <code>program_stream_info_length</code>，其值为 <code>0x00 2c</code>，说明其后跟着的 <code>descriptor</code> 共占 <code>44</code> 字节。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117230813.png" alt="descriptor"></p>
<p>跳过该长度信息和 <code>44</code> 字节后，接下来的值 <code>0x00 2c</code> 为 <code>element_stream_map_length</code>（基本流映射长度），也就是 <code>44</code> 字节，它表示接下来的 <code>44</code> 字节都是用来描述原始流信息的。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117231212.png" alt="c"></p>
<p>接下来进入了原始流描述的第一次循环，第一个字节 <code>stream_type</code> 值为 <code>0x24</code>，根据《GB/T 28181-2016 修改补充文件》可知其为 <code>H.265</code> 码流。</p>
<pre><code>    a)  MPEG-4  视频流：    0x10
    b)  H.264   视频流：    0x1B
    c)  SVAC    视频流：    0x80
    d)  H.265   视频流：    0x24
    e)  G.711A  音频流：    0x90
    f)  G.711U  音频流：    0x91
    g)  G.722.1 音频流：    0x92
    h)  G.723.1 音频流：    0x93
    i)  G.729   音频流：    0x99
    j)  SVAC    音频流：    0x9B
</code></pre><p>之后的 <code>0xe0</code> 表示其为视频流。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117232429.png" alt="stream_type"></p>
<p>之后的 <code>0x00 10</code> 代表该视频流描述 <code>element_stream_info_length</code> 占 <code>16</code> 字节。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117232540.png" alt="element_stream_info_length"></p>
<p>同理，接着循环下去，接下来的字段 <code>0x91</code> 和 <code>0xc0</code>，代表着其为 <code>G.711U</code> 编码的音频流，并携带有 <code>0x0c</code> 即 <code>12</code> 字节的描述信息。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117232848.png" alt="stream_type Audio"></p>
<p>继续循环，接下来的字段 <code>0xbd bd</code>，是海康的私有数据，携带有 <code>0</code> 字节的描述信息。</p>
<p>继续循环，接下来的字段 <code>0xbf bf</code>，也是海康的私有数据，携带有 <code>0</code> 字节的描述信息。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201117233803.png" alt="私有数据 PSM"></p>
<p>以上四次循环后，他们占用的字节数已经等于 <code>44</code>，跟 <code>element_stream_map_length</code> 值相等。</p>
<p>接下来的内容就是 <code>CRC_32</code>，<code>4bits</code>，从以下码流中可以看出，海康 IPC 中没有对这些字节进行计算。</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118211141.png" alt="CRC_32"></p>
<h3 id="PTS-DTS-flags"><a href="#PTS-DTS-flags" class="headerlink" title="PTS_DTS_flags"></a>PTS_DTS_flags</h3><p>在很多码流中，都会存在 <code>PTS</code> 或 <code>DTS</code> 字段，此时 <code>PTS_DTS_flags</code> 字段就会置位，比如以下码流中，<code>PTS_DTS_flags</code> 为 <code>00(2)</code></p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118212717.png" alt="PTS_DTS_flags"></p>
<p>对比 <a href="/post/2020/f33d2f13/" title="音视频封装 - PES 封装格式">音视频封装 - PES 封装格式</a> 中 <code>PES</code> 码流结构可知，之后由 <code>5</code> 字节的 <code>PTS</code> 数据</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118213841.png" alt="PES Struct"></p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118214049.png" alt="PTS Data"></p>
<h3 id="ES-Stream"><a href="#ES-Stream" class="headerlink" title="ES Stream"></a>ES Stream</h3><p>经过以上步骤分析出 <code>PS</code> 的各层封装后，就能将封装中的 <code>ES</code> 码流提取出来：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201118212109.png" alt="ES"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 文中 <code>PS</code> 码流 <code>A</code> 视频源文件：<a href="/slave/PS/TestVideoA.7z" title="密码：github.com">点击下载</a></li>
<li>[2] 文中 <code>PS</code> 码流 <code>B</code> 视频源文件：<a href="/slave/PS/TestVideoB.7z" title="密码：github.com">点击下载</a></li>
<li>[3] <a href="/post/2020/9064839e/" title="音视频封装 - PS 封装格式">音视频封装 - PS 封装格式</a></li>
<li>[4] <a href="/post/2020/f33d2f13/" title="音视频封装 - PES 封装格式">音视频封装 - PES 封装格式</a></li>
</ul>
]]></content>
      <categories>
        <category>音视频封装</category>
      </categories>
      <tags>
        <tag>MPEG2-PS</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频封装 - TS 封装格式</title>
    <url>/post/2020/c6ae0d94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>TS</code> 全称是 <code>MPEG2-TS</code>，<code>MPEG2-TS</code> 是一种标准容器格式，传输与存储音视频、节目与系统信息协议数据，广泛应用于数字广播系统，我们日常数字机顶盒接收到的就是 <code>TS</code>（<code>Transport Stream</code>，传输流）流。</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先需要先分辨 <code>TS</code> 传输流中几个基本概念：</p>
<ul>
<li><code>ES</code> (<code>Elementary Stream</code>)：基本流，直接从编码器出来的数据流，可以是编码过的音频、视频或其他连续码流</li>
<li><code>PES</code> (<code>Packetized Elementary Streams</code>)：<code>PES</code> 流是 <code>ES</code> 流经过 <code>PES</code> 打包器处理后形成的数据流，在这个过程中完成了将 <code>ES</code> 流分组、加入包头信息（<code>PTS</code>、<code>DTS</code> 等）操作。<code>PES</code> 流的基本单位是 <code>PES</code> 包，<code>PES</code> 包由包头和 payload 组成</li>
<li><code>PS</code> 流 (<code>Program Stream</code>)：节目流，PS 流由 PS 包组成，而一个 PS 包又由若干个 <code>PES</code> 包组成。一个 PS 包由具有同一时间基准的一个或多个 <code>PES</code> 包复合合成。</li>
<li><code>TS</code> 流 (<code>Transport Stream</code>)：传输流，<code>TS</code> 流由固定长度（<code>188</code> 字节）的 <code>TS</code> 包组成，<code>TS</code> 包是对 <code>PES</code> 包的另一种封装方式，同样由具有同一时间基准的一个或多个 <code>PES</code> 包复合合成。PS 包是不固定长度，而 <code>TS</code> 包为固定长度。</li>
</ul>
<h2 id="TS-文件"><a href="#TS-文件" class="headerlink" title="TS 文件"></a>TS 文件</h2><p><code>TS</code> 文件分为三次：<code>TS</code> 层、<code>PES</code> 层、<code>ES</code> 层。<code>ES</code> 层就是音视频数据，<code>PES</code> 层是在音视频数据上加了时间戳等数据帧的说明信息，<code>TS</code> 层是在 <code>PES</code> 层上加入了数据流识别和传输的必要信息。</p>
<pre><code>+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  TS   |  =  |  Packet 1 |  Packet 2 |  Packet 3 |    ...    | Packet n-1|  Packet n |
+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

One Packet:          4bytes              184bytes
+-+-+-+-+-+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Packet  | =  | Packet header |       Packet data       |
+-+-+-+-+-+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h2 id="TS-层"><a href="#TS-层" class="headerlink" title="TS 层"></a>TS 层</h2><p><code>TS</code> 包大小固定为 <code>188</code> 字节，<code>TS</code> 层分为三个部分：<code>TS header</code>、<code>adaptation field</code>、<code>payload</code>：</p>
<ul>
<li><code>TS header</code> 固定 <code>4</code> 个字节</li>
<li><code>adaptation field</code> 可能存在也可能不存在，主要作用是给不足 <code>188</code> 字节的数据做填充</li>
<li><p><code>payload</code> 是 <code>PES</code> 数据</p>
<p>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>  | TS header |  adaptation field |          payload(PES)       |<br>  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p>
</li>
</ul>
<h3 id="TS-header"><a href="#TS-header" class="headerlink" title="TS header"></a>TS header</h3><pre><code>|0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       ①       |②|③|④|             ⑤           | ⑥ | ⑦ |   ⑧   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>大小</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>sync_byte</td>
<td>8bit</td>
<td>同步字节，固定为 0x47</td>
</tr>
<tr>
<td>2</td>
<td>transport_error_indicator</td>
<td>1bit</td>
<td>传输错误指示符，表明在 TS 头的 adapt 域后由一个无用字节，通常都为 0，这个字节算在 adapt 域长度内</td>
</tr>
<tr>
<td>3</td>
<td>payload_unit_start_indicator</td>
<td>1bit</td>
<td>负载单元起始标示符，一个完整的数据包开始时标记为 1</td>
</tr>
<tr>
<td>4</td>
<td>transport_priority</td>
<td>1bit</td>
<td>传输优先级，0 为低优先级，1 为高优先级，通常取 0</td>
</tr>
<tr>
<td>5</td>
<td>PID</td>
<td>13bit</td>
<td>PID 值</td>
</tr>
<tr>
<td>6</td>
<td>transport_scrambling_control</td>
<td>2bit</td>
<td>传输加扰控制，00 表示未加密</td>
</tr>
<tr>
<td>7</td>
<td>adaptation_field_control</td>
<td>2bit</td>
<td>是否包含自适应区，’00’保留；’01’为无自适应域，仅含有效负载；’10’为仅含自适应域，无有效负载；’11’为同时带有自适应域和有效负载。</td>
</tr>
<tr>
<td>8</td>
<td>continuity_counter</td>
<td>4bit</td>
<td>递增计数器，从 0-f，起始值不一定取 0，但必须是连续的</td>
</tr>
</tbody>
</table>
</div>
<p><code>TS</code> 层的内容是通过 <code>PID</code> 值来标识的，主要内容包括：<code>PAT</code> 表、<code>PMT</code> 表、音频流、视频流。解析 <code>TS</code> 流要先找到 <code>PAT</code> 表，只要找到 <code>PAT</code> 就可以找到 <code>PMT</code>，然后就可以找到音视频流了。<code>PAT</code> 表和 <code>PMT</code> 表需要定期插入 <code>TS</code> 流，因为用户随时可能加入 <code>TS</code> 流，这个间隔比较小，通常每隔几个视频帧就要加入 <code>PAT</code> 和 <code>PMT</code>。<code>PAT</code> 和 <code>PMT</code> 表是必须的，还可以加入其它表如 <code>SDT</code>（业务描述表）等，不过 <code>HLS</code> 流只要有 <code>PAT</code> 和 <code>PMT</code> 就可以播放了。</p>
<ul>
<li><code>PAT</code> 表：他主要的作用就是指明了 <code>PMT</code> 表的 <code>PID</code> 值。</li>
<li><code>PMT</code> 表：他主要的作用就是指明了音视频流的 <code>PID</code> 值。</li>
<li>音频流 / 视频流：承载音视频内容。</li>
</ul>
<p><code>PID</code> 是 <code>TS</code> 流中唯一识别标志，<code>Packet Data</code> 是什么内容就是由 <code>PID</code> 决定的。下表给出了一些表的 PID 值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>表类型</th>
<th><code>PID</code> 值</th>
</tr>
</thead>
<tbody>
<tr>
<td>PAT</td>
<td>0x0000</td>
</tr>
<tr>
<td>CAT</td>
<td>0x0001</td>
</tr>
<tr>
<td>TSDT</td>
<td>0x0002</td>
</tr>
<tr>
<td>EIT,ST</td>
<td>0x0012</td>
</tr>
<tr>
<td>RST,ST</td>
<td>0x0013</td>
</tr>
</tbody>
</table>
</div>
<h3 id="adaptation-field"><a href="#adaptation-field" class="headerlink" title="adaptation field"></a>adaptation field</h3><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>adaptation_field_length</td>
<td>8bit</td>
<td>自适应域长度，后面的字节数（从 flag 开始）</td>
</tr>
<tr>
<td>flag</td>
<td>8bit</td>
<td>取 0x50 表示包含 PCR 或 0x40 表示不包含 PCR</td>
</tr>
<tr>
<td>PCR</td>
<td>40bit</td>
<td>Program Clock Reference，节目时钟参考，用于恢复出与编码端一致的系统时序时钟 STC（System Time Clock）。</td>
</tr>
<tr>
<td>stuffing_bytes</td>
<td>xbit</td>
<td>填充字节，取值 0xFF</td>
</tr>
</tbody>
</table>
</div>
<p>自适应区的长度要包含传输错误指示符标识的一个字节。<code>PCR</code> 是节目时钟参考，<code>PCR</code>、<code>DTS</code>、<code>PTS</code> 都是对同一个系统时钟的采样值，pcr 是递增的，因此可以将其设置为 <code>DTS</code> 值，音频数据不需要 <code>PCR</code>。如果没有字段，打包 <code>TS</code> 流时 <code>PAT</code> 和 <code>PMT</code> 表是没有 <code>adaptation field</code> 的，不够的长度直接补 <code>0xFF</code> 即可。视频流和音频流都需要加 <code>adaptation field</code>，通常加在一个帧的第一个 <code>TS</code> 包和最后一个 <code>TS</code> 包里，中间的 <code>TS</code> 包不加。</p>
<h3 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h3><p><code>Program Association Table</code> 节目关联表，每个 <code>TS</code> 流对应一张，用来描述该 <code>TS</code> 流中有多少个节目。</p>
<ul>
<li><code>TS</code> 流中中，<code>PAT</code> 包重复实现，大约 <code>0.5</code> 秒出现一个，保证实时解码性</li>
<li>表示 <code>PAT</code> 表的 <code>TS</code> 包 <code>PID</code> 值为 <code>0</code>，便于识别</li>
<li><code>PAT</code> 的 payload 中传送特殊 <code>PID</code> 的列表，每个 <code>PID</code> 对应一个节目（对应一张 <code>PMT</code> 表）</li>
<li><code>PAT</code> 表是 <code>TS</code> 流的基础，任何一个 <code>TS</code> 流解析寻找节目都是从 <code>PAT</code> 表开始查找</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PAT_Program</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_number       :<span class="number">16</span>;  <span class="comment">// 节目号，为 0x0000 时表示这是 NIT，节目号为 0x0001 时, 表示这是 PMT</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved             :<span class="number">3</span>    <span class="comment">// 保留，固定为 111</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_map_PID      :<span class="number">13</span>;  <span class="comment">// 节目号对应内容的 PID 值</span></span><br><span class="line">&#125; TS_PAT_Program;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PAT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> table_id                     : <span class="number">8</span>;  <span class="comment">// 固定 0x00 ，标志是该表是 PAT</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_syntax_indicator     : <span class="number">1</span>;  <span class="comment">// 段语法标志位，固定为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> zero                         : <span class="number">1</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_length               : <span class="number">12</span>; <span class="comment">// 段长度，表示从下一个字段开始到 CRC32(含) 之间有用的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_stream_id          : <span class="number">16</span>; <span class="comment">// TS 流 ID，一般为 0x0001，区别于一个网络中其它多路复用的流</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_2                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> version_number               : <span class="number">5</span>;  <span class="comment">// PAT 版本号，固定为 00000，如果 PAT 有变化则版本号加 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> current_next_indicator       : <span class="number">1</span>;  <span class="comment">// 固定为 1，表示这个 PAT 表有效，如果为 0 则要等待下一个 PAT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_number               : <span class="number">8</span>;  <span class="comment">// 分段的号码。PAT 可能分为多段传输，第一段为 00，以后每个分段加 1，最多可能有 256 个分段</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_section_number          : <span class="number">8</span>;  <span class="comment">// 最后一个分段的号码</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TS_PAT_Program&gt; program;</span><br><span class="line">    <span class="keyword">unsigned</span> CRC_32                       : <span class="number">32</span>; <span class="comment">// CRC32 校验码</span></span><br><span class="line">&#125; TS_PAT;</span><br></pre></td></tr></table></figure>
<h3 id="PMT"><a href="#PMT" class="headerlink" title="PMT"></a>PMT</h3><p><code>Program Map Table</code>，节目映射表，该表的 <code>PID</code> 是由 <code>PAT</code> 表 提供给出的。表征一路节目所有流信息。包含：</p>
<ol>
<li>当前节目中包含的所有 <code>Video</code> 数据的 <code>PID</code></li>
<li>当前节目中包含的所有 <code>Audio</code> 数据的 <code>PID</code></li>
<li>与当前节目关联在一起的其他数据的 <code>PID</code>（如数字广播, 数据通讯等使用的 <code>PID</code>）</li>
</ol>
<p>如果 <code>TS</code> 流中包含多个节目，那么就会有多个 <code>PMT</code> 表。只要我们处理了 <code>PMT</code> 表，那么我们就可以获取该节目中所有的流信息，如当前节目包含多少个 Video、多少个 <code>Audio</code> 和其他数据及每种数据对用的流 <code>PID</code> 分别是多少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PMT_Stream</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> stream_type              : <span class="number">8</span>;  <span class="comment">// 指示本节目流的类型，H.264 编码对应 0x1b，AAC 编码对应 0x0f，MP3 编码对应 0x03</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved1                : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">    <span class="keyword">unsigned</span> elementary_PID           : <span class="number">13</span>; <span class="comment">// 指示该流的 PID 值</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved2                : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 1111</span></span><br><span class="line">    <span class="keyword">unsigned</span> ES_info_length           : <span class="number">12</span>; <span class="comment">// 前两位 bit 为 00，指示跟随其后的描述相关节目元素的字节数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; descriptor;</span><br><span class="line">&#125; TS_PMT_Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PMT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> table_id                     : <span class="number">8</span>;  <span class="comment">// 取值随意，一般使用 0x02, 表示 PMT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_syntax_indicator     : <span class="number">1</span>;  <span class="comment">// 段语法标志位，固定为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> zero                         : <span class="number">1</span>;  <span class="comment">// 固定为 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_length               : <span class="number">12</span>; <span class="comment">// 段长度，表示从下一个字段开始到 CRC32(含) 之间有用的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_number               : <span class="number">16</span>; <span class="comment">// 当前 PMT 表映射到的节目号，1、2、3</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_2                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> version_number               : <span class="number">5</span>;  <span class="comment">// PMT 版本号码，固定为 00000，如果 PAT 有变化则版本号加 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> current_next_indicator       : <span class="number">1</span>;  <span class="comment">// 发送的 PMT 表 是当前有效还是下一个 PMT 有效</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_number               : <span class="number">8</span>;  <span class="comment">// 分段的号码。PMT 可能分为多段传输，第一段为 00，以后每个分段加 1，最多可能有 256 个分段</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_section_number          : <span class="number">8</span>;  <span class="comment">// 分段数</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_3                   : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">    <span class="keyword">unsigned</span> PCR_PID                      : <span class="number">13</span>; <span class="comment">// 指明 TS 包的 PID 值，该 TS 包含有 PCR 同步时钟，</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_4                   : <span class="number">4</span>;  <span class="comment">// 预留位，固定为 1111</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_info_length          : <span class="number">12</span>; <span class="comment">// 前 2bit 为 00，该域指出跟随其后对节目信息的描述的字节数。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TS_PMT_Stream&gt; PMT_Stream;</span><br><span class="line">    <span class="keyword">unsigned</span> reserved_5                   : <span class="number">3</span>;  <span class="comment">// 保留位，0x07</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_6                   : <span class="number">4</span>;  <span class="comment">// 保留位，0x0F</span></span><br><span class="line">    <span class="keyword">unsigned</span> CRC_32                       : <span class="number">32</span>; <span class="comment">// CRC32 校验码</span></span><br><span class="line">&#125; TS_PMT;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频封装</category>
      </categories>
      <tags>
        <tag>MPEG2-TS</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频封装 - TS 封装解析示例</title>
    <url>/post/2020/a03a01c2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章 <a href="/post/2020/c6ae0d94/" title="音视频封装 - TS 封装格式">音视频封装 - TS 封装格式</a> 中分析了 <code>TS</code> 流的结构，本文通过一段真实的码流的分析来加强对 <code>TS</code> 流结构的理解。</p>
<blockquote>
<p>注 1：本文中的 <code>TS</code> 码流截取自一段从网络下载的网络视频</p>
</blockquote>
<a id="more"></a>
<h2 id="PAT-包解析"><a href="#PAT-包解析" class="headerlink" title="PAT 包解析"></a>PAT 包解析</h2><p>该段码流中第一包并不是 <code>PAT</code> 包，而 TS 封装的解析需要从 <code>PAT</code> 包开始，所以我们向后寻找 PID 为 0 的第一包，该段码流中第二包 PID 为 0，是一个 <code>PAT</code> 包：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128145341.png" alt="Packet 2"></p>
<p>第一部分：<code>TS</code> 包头</p>
<pre><code>HEX 47       40       00       10
BIN 01000111 01000000 00000000 00010000
</code></pre><p>对比该部分结构，可代码定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_HEAD</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> sync_byte                    : <span class="number">8</span>;  <span class="comment">// 同步字节，固定为 0x47</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_error_indicator    : <span class="number">1</span>;  <span class="comment">// 传输错误指示符，0 表明在 TS 头的 adapt 域后没有无用字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> payload_unit_start_indicator : <span class="number">1</span>;  <span class="comment">// 负载单元起始标示符，一个完整的数据包开始时标记为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_priority           : <span class="number">1</span>;  <span class="comment">// 传输优先级，0 为低优先级</span></span><br><span class="line">    <span class="keyword">unsigned</span> pid                          : <span class="number">13</span>; <span class="comment">// PID 值，0 表示 TS 头后面就是 PAT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_scrambling_controls    : <span class="number">2</span>;  <span class="comment">// TS 流 ID，一般为 0x0001，区别于一个网络中其它多路复用的流</span></span><br><span class="line">    <span class="keyword">unsigned</span> adaptation_field_control         : <span class="number">2</span>;  <span class="comment">// 是否包含自适应区，&#x27;01&#x27;为无自适应域，仅含有效负载</span></span><br><span class="line">    <span class="keyword">unsigned</span> continuity_counter               : <span class="number">4</span>;  <span class="comment">// 递增计数器，0-F，起始值不一定取 0，但必须是连续的</span></span><br><span class="line">&#125; TS_HEAD;</span><br></pre></td></tr></table></figure>
<p>第二部分：<code>TS</code> 包调整字节</p>
<pre><code>HEX 00
BIN 00000000
</code></pre><p>对比该部分结构，代码定义分析如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_ADAPT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> adaptation_field_length;  <span class="comment">// 自适应域长度，后面的字节数，此包中为 7 字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flag;                     <span class="comment">// 0x50 表示包含 PCR，0x40 表示不包含 PCR</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0x50</span>) <span class="keyword">unsigned</span> <span class="keyword">char</span> PCR[<span class="number">5</span>]; <span class="comment">// 节目时钟参考 40bit</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; stuffing_bytes;   <span class="comment">// 填充字节，取值 0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>adaptation_field_length</code> 为 <code>0</code>，故该部分后续字节数为 <code>0</code>。</p>
<p>第三部分：<code>TS</code> 包有效载荷 - 即 <code>PSI</code> 表 <code>PAT</code> 的数据：</p>
<pre><code>HEX 00 B0 0D 00 01 C1 00 00  00 01 F0 00 2A B1 04 B2
BIN 00000000 10110000 00001101 00000000 00000001 11000001 00000000 00000000
    00000000 00000001 11110000 00000000 00101010 10110001 00000100 10110010
</code></pre><p>对比该部分结构，代码定义分析如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PAT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> table_id                     : <span class="number">8</span>;  <span class="comment">// 固定 0x00 ，标志是该表是 PAT</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_syntax_indicator     : <span class="number">1</span>;  <span class="comment">// 段语法标志位，固定为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> zero                         : <span class="number">1</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_length               : <span class="number">12</span>; <span class="comment">// 段长度，0000 00001101 值为 13</span></span><br><span class="line">    <span class="keyword">unsigned</span> transport_stream_id          : <span class="number">16</span>; <span class="comment">// TS 流 ID，一般为 0x0001，区别于一个网络中其它多路复用的流</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_2                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> version_number               : <span class="number">5</span>;  <span class="comment">// PAT 版本号，固定为 00000，如果 PAT 有变化则版本号加 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> current_next_indicator       : <span class="number">1</span>;  <span class="comment">// 固定为 1，表示这个 PAT 表有效，如果为 0 则要等待下一个 PAT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_number               : <span class="number">8</span>;  <span class="comment">// 分段的号码。PAT 可能分为多段传输，第一段为 00，以后每个分段加 1，最多可能有 256 个分段</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_section_number          : <span class="number">8</span>;  <span class="comment">// 最后一个分段的号码</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TS_PAT_Program&gt; program; = &#123;    <span class="comment">// 该包中仅有一个 TS_PAT_Program</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> program_number       :<span class="number">16</span>;  <span class="comment">// 节目号，为 0x0000 时表示这是 NIT，节目号为 0x0001 时, 表示这是 PMT</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved             :<span class="number">3</span>    <span class="comment">// 保留，固定为 111</span></span><br><span class="line">            <span class="keyword">if</span> (program_number == <span class="number">0x0000</span>)</span><br><span class="line">                <span class="keyword">unsigned</span> network_PID      :<span class="number">13</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (program_number == <span class="number">0x0001</span>)</span><br><span class="line">                <span class="keyword">unsigned</span> program_map_PID  :<span class="number">13</span>;  <span class="comment">// 节目号对应内容的 PID 值，该 PAT 包取值为 0x1000 = 4096</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> CRC_32                       : <span class="number">32</span>; <span class="comment">// CRC32 校验码</span></span><br><span class="line">&#125; TS_PAT;</span><br></pre></td></tr></table></figure>
<h2 id="PMT-包解析"><a href="#PMT-包解析" class="headerlink" title="PMT 包解析"></a>PMT 包解析</h2><p><code>PAT</code> 信息中可知 <code>PMT</code> 表的 <code>PID</code> 为 <code>4096</code>，我们向后寻找 <code>PID</code> 为 <code>4096</code> 的 <code>TS</code> 包，发现第 <code>3</code> 包 <code>TS</code> 包即为 <code>PMT</code> 包：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128155219.png" alt="PMT"></p>
<p>第一部分：<code>TS</code> 包头</p>
<pre><code>HEX 47       50       00       10
BIN 01000111 01010000 00000000 00010000
</code></pre><p>从 <code>TS</code> 包头可知该 <code>TS</code> 包的 <code>PID</code> 值为 <code>4096</code>，是我们寻找的 <code>PMT</code> 包。</p>
<p>第二部分：<code>TS</code> 包调整字节，该部分只有一个字节 <code>0x00</code>，详见上文解析，此处不再重复。</p>
<p>第三部分：<code>TS</code> 包有效载荷 - <code>PMT</code></p>
<pre><code>HEX 02 B0 23 00 01 C1 00 00  E1 00 F0 00 24 E1 00 F0
    06 05 04 48 45 56 43 03  E1 01 F0 06 0A 04 75 6E
    64 00 DD 33 FC 6A
BIN 00000010 10110000 00100011 00000000 00000001 11000001 00000000 00000000
    11100001 00000000 11110000 00000000 00100100 11100001 00000000 11110000
    00000110 00000101 00000100 01001000 01000101 01010110 01000011 00000011
    11100001 00000001 11110000 00000110 00001010 00000100 01110101 01101110
    01100100 00000000 11011101 00110011 11111100 01101010
</code></pre><p>对比该部分结构，代码定义分析如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_PMT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> table_id                     : <span class="number">8</span>;  <span class="comment">// 取值随意，一般使用 0x02, 表示 PMT 表</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_syntax_indicator     : <span class="number">1</span>;  <span class="comment">// 段语法标志位，固定为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> zero                         : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_length               : <span class="number">12</span>; <span class="comment">// 段长度，0000 00100011 = 35 字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_number               : <span class="number">16</span>; <span class="comment">// 当前 PMT 表映射到的节目号，1、2、3</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_2                   : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 11</span></span><br><span class="line">    <span class="keyword">unsigned</span> version_number               : <span class="number">5</span>;  <span class="comment">// PMT 版本号码，固定为 00000，如果 PAT 有变化则版本号加 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> current_next_indicator       : <span class="number">1</span>;  <span class="comment">// 发送的 PMT 表， 1 当前有效 PMT 有效</span></span><br><span class="line">    <span class="keyword">unsigned</span> section_number               : <span class="number">8</span>;  <span class="comment">// 分段的号码。PMT 可能分为多段传输，第一段为 00，以后每个分段加 1，最多可能有 256 个分段</span></span><br><span class="line">    <span class="keyword">unsigned</span> last_section_number          : <span class="number">8</span>;  <span class="comment">// 分段数</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_3                   : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">    <span class="keyword">unsigned</span> PCR_PID                      : <span class="number">13</span>; <span class="comment">// 指明 TS 包的 PID 值 (0x0100 = 256)，该 TS 包含有 PCR 同步时钟，</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_4                   : <span class="number">4</span>;  <span class="comment">// 预留位，固定为 1111</span></span><br><span class="line">    <span class="keyword">unsigned</span> program_info_length          : <span class="number">12</span>; <span class="comment">// 前 2bit 为 00，该域指出跟随其后对节目信息的描述的字节数 (0x000 = 0)。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; descriptor;      <span class="comment">// 0 字节</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TS_PMT_Stream&gt; PMT_Stream = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> stream_type          : <span class="number">8</span>;  <span class="comment">// 指示本节目流的类型，H.265 编码对应 0x24</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved1            : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">            <span class="keyword">unsigned</span> elementary_PID       : <span class="number">13</span>; <span class="comment">// 指示该流的 PID 值 (0x100 = 256)</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved2            : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 1111</span></span><br><span class="line">            <span class="keyword">unsigned</span> ES_info_length       : <span class="number">12</span>; <span class="comment">// 前两位 bit 为 00，指示跟随其后的描述相关节目元素的字节数 (0x006 = 6)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; descriptor;   <span class="comment">// 6 字节</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> stream_type          : <span class="number">8</span>;  <span class="comment">// 指示本节目流的类型，MP3 编码对应 0x03</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved1            : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 111</span></span><br><span class="line">            <span class="keyword">unsigned</span> elementary_PID       : <span class="number">13</span>; <span class="comment">// 指示该流的 PID 值 (0x101 = 257)</span></span><br><span class="line">            <span class="keyword">unsigned</span> reserved2            : <span class="number">3</span>;  <span class="comment">// 保留位，固定为 1111</span></span><br><span class="line">            <span class="keyword">unsigned</span> ES_info_length       : <span class="number">12</span>; <span class="comment">// 前两位 bit 为 00，指示跟随其后的描述相关节目元素的字节数 (0x006 = 6)</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; descriptor;   <span class="comment">// 6 字节</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> CRC_32                       : <span class="number">32</span>; <span class="comment">// CRC32 校验码</span></span><br><span class="line">&#125; TS_PMT;</span><br></pre></td></tr></table></figure>
<p><code>PMT</code> 是定义每路节目的音视频类型 <code>TYPE</code> 和编号 <code>PID</code> 的关键，该 <code>TS</code> 码流中：</p>
<pre><code>- 视频流格式为 `H.265`，对应 `PID` 为 `256`
- 视频流格式为 `MP3`，对应 `PID` 为 `257`
</code></pre><h2 id="视频包解析"><a href="#视频包解析" class="headerlink" title="视频包解析"></a>视频包解析</h2><p>第 <code>4</code> 包的 <code>PID</code> 值为 <code>256</code>，根据上述分析可知，该包为一个视频包：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128163234.png" alt="视频包"></p>
<p>第一部分：<code>TS</code> 包头</p>
<pre><code>HEX 47       41       00       30
BIN 01000111 01000001 00000000 00110000
</code></pre><p>从 <code>TS</code> 包头可知该 <code>TS</code> 包的 <code>PID</code> 值为 <code>256</code>，是我们寻找的视频包，另外，TS 包头中 <code>adaptation_field_control</code> 字段为 <code>11</code>，代表同时带有自适应域和有效负载。</p>
<p>第二部分：<code>TS</code> 包调整字节</p>
<pre><code>HEX 07 50 00 00 7C F7 7E 00
BIN 00000111 01010000 00000000 00000000 01111100 11110111 01111110 00000000
</code></pre><p>对比该部分结构，代码定义分析如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_ADAPT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> adaptation_field_length;  <span class="comment">// 自适应域长度，后面的字节数，此包中为 7 字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flag;                     <span class="comment">// 0x50 表示包含 PCR</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0x50</span>) <span class="keyword">unsigned</span> <span class="keyword">char</span> PCR[<span class="number">5</span>]; <span class="comment">// 节目时钟参考 40bit</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; stuffing_bytes;   <span class="comment">// 填充字节，取值 0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三部分：<code>TS</code> 包有效载荷 - <code>PES</code></p>
<pre><code>HEX 00 00 01 E0 00 00 80 80  05 21 00 07 E0 0D
BIN 00000000 00000000 00000001 11100000 00000000 00000000 10000000 10000000
    00000101 00100001 00000000 00000111 11100000 00001101
</code></pre><p>对比该部分结构，代码定义分析如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_ADAPT</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> start_code_prefix        : <span class="number">24</span>; <span class="comment">// 包头起始码，固定为 0x000001</span></span><br><span class="line">    <span class="keyword">unsigned</span> stream_id;               : <span class="number">8</span>;  <span class="comment">// PES 包中的负载流类型，一般视频为 0xe0，音频为 0xc0</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_packet_length        : <span class="number">16</span>; <span class="comment">// PES 包长度，包括此字节后的可选包头和负载的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> reserved_1               : <span class="number">2</span>;  <span class="comment">// 保留位，固定为 10</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_scrambling_control   : <span class="number">2</span>;  <span class="comment">// 加密模式，00 未加密，01 或 10 或 11 由用户定义</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_priority             : <span class="number">1</span>;  <span class="comment">// 有效负载的优先级，值为 1 比值为 0 的负载优先级高</span></span><br><span class="line">    <span class="keyword">unsigned</span> Data_alignment_indicator : <span class="number">1</span>;  <span class="comment">// 数据定位指示器</span></span><br><span class="line">    <span class="keyword">unsigned</span> Copyright                : <span class="number">1</span>;  <span class="comment">// 版权信息，1 为有版权，0 无版权</span></span><br><span class="line">    <span class="keyword">unsigned</span> Original_or_copy         : <span class="number">1</span>;  <span class="comment">// 原始或备份，1 为原始，0 为备份</span></span><br><span class="line">    <span class="keyword">unsigned</span> PTS_DTS_flags            : <span class="number">2</span>;  <span class="comment">// PTS 和 DTS 标志位，10 表示首部有 PTS 字段，11 表示有 PTS 和 DTS 字段，00 表示都没有，01 被禁止</span></span><br><span class="line">    <span class="keyword">unsigned</span> ESCR_flag                : <span class="number">1</span>;  <span class="comment">// ESCR 标志，1 表示首部有 ESCR 字段，0 则无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> ES_rate_flag             : <span class="number">1</span>;  <span class="comment">// ES_rate 字段，1 表示首部有此字段，0 无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> DSM_trick_mode_flag      : <span class="number">1</span>;  <span class="comment">// 1 表示有 8 位的 DSM_trick_mode_flag 字段，0 无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> Additional_copy_info_flag: <span class="number">1</span>;  <span class="comment">// 1 表示首部有此字段，0 表示无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_CRC_flag             : <span class="number">1</span>;  <span class="comment">// 1 表示 PES 分组有 CRC 字段，0 无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_extension_flag       : <span class="number">1</span>;  <span class="comment">// 扩展标志位，置 1 表示有扩展字段，0 无此字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> PES_header_data_length   : <span class="number">8</span>;  <span class="comment">// PES 首部中可选字段和填充字段的长度，可选字段的内容由上面 7 个 flags 来进行控制</span></span><br><span class="line">    if (PTS_DTS_flags == &#x27;10&#x27;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> reserved_1           : <span class="number">4</span>;  <span class="comment">// 保留位，固定为 0010</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_32_30            : <span class="number">3</span>;  <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_1             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_29_15            : <span class="number">15</span>; <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_2             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_14_0             : <span class="number">15</span>; <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_3             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    if (PTS_DTS_flags == &#x27;11&#x27;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> reserved_1           : <span class="number">4</span>;  <span class="comment">// 保留位，固定为 0011</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_32_30            : <span class="number">3</span>;  <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_1             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_29_15            : <span class="number">15</span>; <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_2             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> PTS_14_0             : <span class="number">15</span>; <span class="comment">// PTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_3             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> reserved_2           : <span class="number">4</span>;  <span class="comment">// 保留位，固定为 0001</span></span><br><span class="line">        <span class="keyword">unsigned</span> DTS_32_30            : <span class="number">3</span>;  <span class="comment">// DTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_1             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> DTS_29_15            : <span class="number">15</span>; <span class="comment">// DTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_2             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">        <span class="keyword">unsigned</span> DTS_14_0             : <span class="number">15</span>; <span class="comment">// DTS</span></span><br><span class="line">        <span class="keyword">unsigned</span> marker_3             : <span class="number">1</span>;  <span class="comment">// 保留位，固定为 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ESCR_flag) ...</span><br><span class="line">    <span class="keyword">if</span> (ES_rate_flag) ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (PES_extension_flag) ...</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; stuffing_bytes;   <span class="comment">// 填充字段，固定为 0xFF，不得超过 32 字节</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; PES_packet_data_byte <span class="comment">// PES 包的负载数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比代码和码流数据，发现码流中 <code>PES_packet_length</code> 值为 <code>0</code>，其表示 <code>PES</code> 分组长度要么没有规定要么没有限制。这种情况只允许出现在有效负载包含来源于传输流分组中某个视频基本流的字节的 <code>PES</code> 分组中。</p>
<p>该段视频流中 <code>PTS_DTS_flags == &#39;10&#39;</code>，故其还有 <code>5</code> 字节的 <code>PTS</code> 信息，我们尝试解析 <code>PTS</code> 信息：</p>
<ol>
<li><code>PTS</code> 的 <code>5</code> 字节信息为 <code>21 00 07 E0 0D</code>，对应二进制 <code>00100001 00000000 00000111 11100000 00001101</code></li>
<li>除去 <code>reserved</code> 和 <code>marker</code> 字段为 <code>000 00000000 0000011 11100000 0000110</code></li>
<li>整理可得 <code>0 00000000 00000001 11110000 00000110</code>，即 <code>0x001F006</code></li>
<li>转为十进制为 <code>126982</code>，与工具计算结果一致</li>
</ol>
<p><code>PES</code> 包头数据分析完，剩下的数据就是帧视频数据的一部分了。</p>
<h2 id="音频包解析"><a href="#音频包解析" class="headerlink" title="音频包解析"></a>音频包解析</h2><p>音频包与视频包均使用 <code>PES</code> 格式封装，解析方式基本一致，比如：</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20201128192950.png" alt="音频包"></p>
<p>音频包中第三部分：<code>TS</code> 包有效载荷 - <code>PES</code></p>
<pre><code>HEX 00 00 01 C0 09 D3 80 80 05 21 00 07 D8 61 FF
BIN 00000000 00000000 00000001 11000000 00001001 11010011 10000000 10000000
    00000101 00100001 00000000 00000111 11011000 01010001 11111111
</code></pre><p>该段视频流中 <code>PTS_DTS_flags == &#39;10&#39;</code>，故其也有 <code>5</code> 字节的 <code>PTS</code> 信息，我们尝试解析 <code>PTS</code> 信息：</p>
<ol>
<li><code>PTS</code> 的 <code>5</code> 字节信息为 <code>21 00 07 D8 61</code>，对应二进制 <code>00100001 00000000 00000111 11011000 01100001</code></li>
<li>除去 <code>reserved</code> 和 <code>marker</code> 字段为 <code>000 00000000 0000011 11011000 0110000</code></li>
<li>整理可得 <code>0 00000000 00000001 11101100 00110000</code>，即 <code>0x001EC30</code></li>
<li>转为十进制为 <code>126000</code>，与工具计算结果一致</li>
</ol>
<p><code>PES</code> 包头数据分析完，剩下的数据就音频数据的一部分了。</p>
<ul>
<li>[1] <a href="https://cloud.tencent.com/developer/article/1746983">音视频封装：MPTG2-TS 媒体封装实例解析和说明 - 云 + 社区 - 腾讯云</a></li>
<li>[2] <a href="/post/2020/c6ae0d94/" title="音视频封装 - TS 封装格式">音视频封装 - TS 封装格式</a></li>
<li>[3] <a href="https://github.com/daniep01/MPEG-2-Transport-Stream-Packet-Analyser">daniep01/MPEG-2-Transport-Stream-Packet-Analyser: MPEG-2 Transport Stream packet analyser…</a></li>
<li>[4] 文中 <code>TS</code> 码流视频源文件：<a href="/slave/TS/TestVideoTS.7z" title="密码：github.com">点击下载</a></li>
</ul>
]]></content>
      <categories>
        <category>音视频封装</category>
      </categories>
      <tags>
        <tag>MPEG2-TS</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频日记 - Windows 安装 ffmpeg</title>
    <url>/post/2021/a1b64acb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <code>Windows</code> 上编译 <code>ffmpeg</code> 没有在 <code>linux</code> 上简单方便，在此记录编译过程</p>
<a id="more"></a>
<h2 id="配置-MSVC-编译环境"><a href="#配置-MSVC-编译环境" class="headerlink" title="配置 MSVC 编译环境"></a>配置 MSVC 编译环境</h2><p>配置环境变量如下（VS2019）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PATH</span></span><br><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\bin\Hostx64\x64\</span><br><span class="line"><span class="comment"># INCLUDE</span></span><br><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\um</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\winrt</span><br><span class="line"><span class="comment"># LIB</span></span><br><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\lib\x64</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Lib\10.0.18362.0\um\x64</span><br><span class="line">C:\Program Files (x86)\Windows Kits\10\Lib\10.0.18362.0\ucrt\x64</span><br></pre></td></tr></table></figure>
<h2 id="MSYS2-的安装与配置"><a href="#MSYS2-的安装与配置" class="headerlink" title="MSYS2 的安装与配置"></a>MSYS2 的安装与配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到以下内容</span></span><br><span class="line">rem <span class="built_in">set</span> MSYS2_PATH_TYPE=inherit</span><br><span class="line"><span class="comment"># 修改为</span></span><br><span class="line"><span class="built_in">set</span> MSYS2_PATH_TYPE=inherit</span><br></pre></td></tr></table></figure>
<p>执行 <code>cl</code> 命令查看输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cl</span></span><br><span class="line">用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.28.29335 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">用法: cl [ 选项... ] 文件名... [ /link 链接选项... ]</span><br></pre></td></tr></table></figure>
<p>如果是以上返回则配置成功</p>
<p>如果提示 <code>bash: cl: 未找到命令</code> 则需要检查是不是上述配置出了问题，或者重启电脑再试一下。</p>
<h2 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="安装依赖环境"></a>安装依赖环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果网络连接不上，可以尝试使用代理</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;127.0.0.1:10809&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;127.0.0.1:10809&quot;</span></span><br><span class="line"><span class="comment"># 安装以下依赖</span></span><br><span class="line">pacman -S nasm</span><br><span class="line">pacman -S yasm</span><br><span class="line">pacman -S make cmake</span><br><span class="line">pacman -S diffutils</span><br><span class="line">pacman -S pkg-config</span><br><span class="line">pacman -S git</span><br><span class="line">pacman -S mingw-w64-x86_64-SDL2</span><br></pre></td></tr></table></figure>
<h2 id="编译-x264"><a href="#编译-x264" class="headerlink" title="编译 x264"></a>编译 x264</h2><h2 id="编译-x265"><a href="#编译-x265" class="headerlink" title="编译 x265"></a>编译 x265</h2><h2 id="编译-ffmpeg"><a href="#编译-ffmpeg" class="headerlink" title="编译 ffmpeg"></a>编译 ffmpeg</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --<span class="built_in">enable</span>-yasm --<span class="built_in">enable</span>-asm --toolchain=msvc --<span class="built_in">enable</span>-shared --<span class="built_in">enable</span>-static</span><br><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频日记</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频日记 - YUV 格式详解</title>
    <url>/post/2021/a4daf22d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>YUV</code> 是一种彩色编码系统，主要用在视频、图形处理流水线中 (pipeline)。相对于 RGB 颜色空间，设计 <code>YUV</code> 的目的就是为了编码、传输的方便，减少带宽占用和信息出错。</p>
<p>人眼的视觉特点是对亮度更铭感，对位置、色彩相对来说不铭感。在视频编码系统中为了降低带宽，可以保存更多的亮度信息 (luma)，保存较少的色差信息 (chroma)。</p>
<a id="more"></a>
<h2 id="YUV-的相似概念"><a href="#YUV-的相似概念" class="headerlink" title="YUV 的相似概念"></a>YUV 的相似概念</h2><p><code>Y’UV</code>、<code>YUV</code>、<code>YCbCr</code>、<code>YPbPr</code> 几个概念其实是一回事儿。</p>
<p>由于历史关系，<code>Y’UV</code>、<code>YUV</code> 主要是用在彩色电视中，用于模拟信号表示。</p>
<p><code>YCbCr</code> 是用在数字视频、图像的压缩和传输，如 <code>MPEG</code>、<code>JPEG</code>。</p>
<p>今天大家所讲的 <code>YUV</code> 其实就是指 <code>YCbCr</code>。<code>Y</code> 表示亮度（luma），<code>CbCr</code> 表示色度（chroma）。</p>
<p>luminance 亮度，<code>luma</code> 是在视频编码系统中指亮度值；chrominance 色度，<code>chroma</code> 是在视频编码系统中指色度值。</p>
<p><code>Y’UV</code> 设计的初衷是为了使彩色电视能够兼容黑白电视。对于黑白电视信号，没有色度信息也就是 (<code>UV</code>)，那么在彩色电视显示的时候指显示亮度信息。</p>
<p><code>Y’UV</code> 不是 <code>Absolute Color Space</code>，只是一种 <code>RGB</code> 的信息编码，实际的显示还是通过 <code>RGB</code> 来显示。<code>Y’,U,V</code> 叫做不同的 component。</p>
<h2 id="YUV-后数字的含义"><a href="#YUV-后数字的含义" class="headerlink" title="YUV 后数字的含义"></a>YUV 后数字的含义</h2><pre><code>我们一般理解为 yuv444，yuv422，yuv420 的解释是后面三个数字分别对应前面三个字母。
拿 yuv422 来说：
y 对应 4，表示 4 个图形像素中，每个都有亮度值
u 对应 2，表示 4 个图形像素中，Cb 占用两个像素
v 对应 2，表示 4 个图形像素中，Cr 占用两个像素

但是对于 yuv420 解释就不对了，不能说 4 个图形像素中，Cr 占用 0 个像素吧？
</code></pre><p>我们通过下图来理解一下 <code>yuv</code> 各种格式后面数字的含义。图来源于 <a href="https://link.zhihu.com/?target=http%3A//dougkerr.net/Pumpkin/articles/Subsampling.pdf">Chrominance Subsampling in Digital Images</a></p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210103211447.png" alt="YUV"></p>
<p>如上图中所示，左侧一列，每一个小矩形是图形像素表示，黑框矩形是色度像素表示，小黑点是表示色度像素值 (Cb + Cr)，表示图形像素和色度像素在水平和垂直方向的比例关系。比如，</p>
<pre><code>- 4:4:0 水平方向是 1/1，垂直方向是 1/2，表示 1 个色度像素对应了 2 个图形像素。
- 4:2:2 水平方向是 1/2，垂直方向是 1/1，表示 1 个色度像素对应了 2 个图形像素。
- 4:2:0 水平方向是 1/2，垂直方向是 1/2，表示 1 个色度像素对应了 4 个图形像素。
</code></pre><p>右侧一列是二次采样模式记号表示, 是 <code>J:a:b</code> 模式，即 YUV 后数字表示的模式。图中实心黑色圆圈表示包含色度像素 (Cb + Cr），空心圆圈表示不包含色度像素。</p>
<pre><code>对于 J:a:b 模式，定义了一个 J x 2 的矩形参考块
J 通常是 4，此参考块就是宽度有 4 个像素、高度有 2 个像素的矩形
a 表示参考块的第一行包含的色度像素样本数
b 表示在参考块的第二行包含的色度像素样本数

- 4:4:0 参考块第 1 行包含 4 个色度样本，第 2 行没有包含色度样本。
- 4:2:2 参考块第 1 行包含 2 个色度样本，第 2 行也包含 2 个色度样本，他们是交替出现。
- 4:2:0 参考块第 1 行包含 2 个色度样本，第 2 行没有包含色度样本。
</code></pre><blockquote>
<p>存在的一个例外是 4:1:0，其在每个亮度平面分辨率为 4 x 4 的块内提供一个色度样本。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://zhuanlan.zhihu.com/p/85620611">如何理解 YUV ？ - 知乎</a></li>
<li>[2] 多媒体编程开发之 FFmpeg 基础库</li>
</ul>
]]></content>
      <categories>
        <category>音视频日记</category>
      </categories>
      <tags>
        <tag>YUV</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频日记 - ffmpeg 之 IO 架构分析</title>
    <url>/post/2021/ce615ee4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>协议 (文件) 操作的顶层结构是 <code>AVIOContext</code>，该对象实现了带缓冲的读写操作</p>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20210115000338.png" alt="协议操作对象结构"></p>
<a id="more"></a>
<p><code>ffmpeg</code> 的输入对象 <code>AVFormatContext</code> 的 <code>pb</code> 字段指向一个 <code>AVIOContext</code></p>
<p><code>AVIOContext</code> 的 <code>opaque</code> 实际指向一个 <code>URLContext</code> 对象，这个对象封装了协议对象及协议操作对象</p>
<pre><code>- `prot` 指向具体的协议操作对象 `URLProtocol`
- `priv_data` 指向具体的协议对象
</code></pre><p><code>URLProtocol</code> 为协议操作对象，针对每种协议，会有一个这样的对象，每个协议操作对象和一个协议对象关联</p>
<pre><code>- 比如，文件操作对象为 `ff_file_protocol` 关联的结构体是 `FileContext`
</code></pre><h2 id="函数调用关系"><a href="#函数调用关系" class="headerlink" title="函数调用关系"></a>函数调用关系</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+ avformat_open_input()</span><br><span class="line">+---+ init_input()                              <span class="comment">/* 打开输入的视频数据并且探测视频的格式 */</span></span><br><span class="line">    +---- av_probe_input_buffer2()</span><br><span class="line">        +---- avio_read()</span><br><span class="line">        +---- av_probe_input_format2()</span><br><span class="line">            +---- av_probe_input_format3()</span><br><span class="line">    +---+ avio_open2()</span><br><span class="line">        +---+ ffurl_open_whitelist()</span><br><span class="line">            +---+ ffurl_alloc()</span><br><span class="line">                +---- url_find_protocol()</span><br><span class="line">                +---- url_alloc_for_protocol()</span><br><span class="line">            +---+ ffurl_connect()</span><br><span class="line">                +---- prot-&gt;url_open2()</span><br><span class="line">                +---- prot-&gt;url_open()</span><br><span class="line">        +---+ ffio_fdopen()</span><br><span class="line">            +---- avio_alloc_context()</span><br></pre></td></tr></table></figure>
<h2 id="init-input"><a href="#init-input" class="headerlink" title="init_input()"></a>init_input()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Open input file and probe the format if necessary. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_input</span><span class="params">(AVFormatContext *s, <span class="keyword">const</span> <span class="keyword">char</span> *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                      AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    AVProbeData pd = &#123;filename, <span class="literal">NULL</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> score = AVPROBE_SCORE_RETRY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;pb) &#123;</span><br><span class="line">        s-&gt;flags |= AVFMT_FLAG_CUSTOM_IO;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;iformat)</span><br><span class="line">            <span class="keyword">return</span> av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                         s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE)</span><br><span class="line">            av_log(s, AV_LOG_WARNING, <span class="string">&quot;Custom AVIOContext makes no sense and&quot;</span></span><br><span class="line">                                      <span class="string">&quot;will be ignored with AVFMT_NOFILE format.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((s-&gt;iformat &amp;&amp; s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE) ||</span><br><span class="line">        (!s-&gt;iformat &amp;&amp; (s-&gt;iformat = av_probe_input_format2(&amp;pd, <span class="number">0</span>, &amp;score))))</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = s-&gt;io_open(s, &amp;s-&gt;pb, filename, AVIO_FLAG_READ | s-&gt;avio_flags, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;iformat) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                 s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数在短短的几行代码中包含了好几个 <code>return</code>，因此逻辑还是有点复杂的，我们可以梳理一下：</p>
<p>在函数的开头的 <code>score</code> 变量是一个判决 <code>AVInputFormat</code> 的分数的门限值，如果最后得到的 <code>AVInputFormat</code> 的分数低于该门限值，就认为没有找到合适的 <code>AVInputFormat</code>。<code>ffmpeg</code> 内部判断封装格式的原理实际上是对每种 <code>AVInputFormat</code> 给出一个分数，满分是 <code>100</code> 分，越有可能正确的 <code>AVInputFormat</code> 给出的分数就越高。最后选择分数最高的 <code>AVInputFormat</code> 作为推测结果。<code>score</code> 的值是一个宏定义 <code>AVPROBE_SCORE_RETRY</code>，我们可以看一下它的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVPROBE_SCORE_MAX       100 <span class="comment">///&lt; maximum score</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVPROBE_SCORE_RETRY (AVPROBE_SCORE_MAX/4)</span></span><br></pre></td></tr></table></figure>
<p>由此我们可以得出 <code>score</code> 取值是 <code>25</code>，即如果推测后得到的最佳 <code>AVInputFormat</code> 的分值低于 <code>25</code>，就认为没有找到合适的  <code>AVInputFormat</code></p>
<p>整个函数的逻辑大体如下：</p>
<ol>
<li>当使用了自定义的 <code>AVIOContext</code> 的时候（<code>AVFormatContext</code> 中的 <code>AVIOContext</code> 不为空，即 <code>s-&gt;pb!=NULL</code>），如果指定了 <code>AVInputFormat</code> 就直接返回，如果没有指定就调用 <code>av_probe_input_buffer2()</code> 推测 <code>AVInputFormat</code>。这一情况出现的不算很多，但是当我们从内存中读取数据的时候（需要初始化自定义的 <code>AVIOContext</code>），就会执行这一步骤</li>
<li>在更一般的情况下，如果已经指定了 <code>AVInputFormat</code>，就直接返回；如果没有指定 <code>AVInputFormat</code>，就调用 <code>av_probe_input_format(NULL,…)</code> 根据文件路径判断文件格式。这里特意把 <code>av_probe_input_format()</code> 的第 1 个参数写成 <code>NULL</code>，是为了强调这个时候实际上并没有给函数提供输入数据，此时仅仅通过文件路径推测 <code>AVInputFormat</code></li>
<li>如果发现通过文件路径判断不出来文件格式，那么就需要打开文件探测文件格式了，这个时候会首先调用 <code>avio_open2()</code> 打开文件，然后调用 <code>av_probe_input_buffer2()</code> 推测 <code>AVInputFormat</code></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] <a href="https://blog.csdn.net/finewind/article/details/39433055">2——FFMPEG 之协议 (文件) 操作 ——AVIOContext, URLContext, URLProtocol_finewind 的专栏 - CSDN 博客</a></li>
</ul>
]]></content>
      <categories>
        <category>音视频日记</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频日记 - ffmpeg 关键结构体</title>
    <url>/post/2021/e03178b1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><code>AVFormatContext</code> : 封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息</li>
<li><code>AVInputFormat</code> : 每种封装格式（例如 FLV, MKV, MP4, AVI）对应一个该结构体</li>
<li><code>AVStream</code> : 视频文件中每个视频（音频）流对应一个该结构体</li>
<li><code>AVCodecContext</code> : 编码器上下文结构体，保存了视频（音频）编解码相关信息</li>
<li><code>AVCodec</code> : 每种视频（音频）编解码器 (例如 H.264 解码器) 对应一个该结构体</li>
<li><code>AVPacket</code> : 存储一帧压缩编码数据</li>
<li><code>AVFrame</code> : 存储一帧解码后像素（采样）数据</li>
</ul>
<a id="more"></a>
<h2 id="协议封装-amp-解协议"><a href="#协议封装-amp-解协议" class="headerlink" title="协议封装 &amp; 解协议"></a>协议封装 &amp; 解协议</h2><h3 id="AVIOContext"><a href="#AVIOContext" class="headerlink" title="AVIOContext"></a>AVIOContext</h3><p><code>AVIOContext</code> 是 <code>ffmpeg</code> 管理输入输出数据的结构体</p>
<h4 id="AVIOContext-相关函数"><a href="#AVIOContext-相关函数" class="headerlink" title="AVIOContext 相关函数"></a>AVIOContext 相关函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate and initialize an AVIOContext for buffered I/O. It must be later freed with avio_context_free().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param buffer Memory block for input/output operations via AVIOContext.</span></span><br><span class="line"><span class="comment"> *        The buffer must be allocated with av_malloc() and friends.</span></span><br><span class="line"><span class="comment"> *        It may be freed and replaced with a new buffer by libavformat.</span></span><br><span class="line"><span class="comment"> *        AVIOContext.buffer holds the buffer currently in use, which must be later freed with av_free().</span></span><br><span class="line"><span class="comment"> * @param buffer_size The buffer size is very important for performance.</span></span><br><span class="line"><span class="comment"> *        For protocols with fixed blocksize it should be set to this blocksize.</span></span><br><span class="line"><span class="comment"> *        For others a typical size is a cache page, e.g. 4kb.</span></span><br><span class="line"><span class="comment"> * @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.</span></span><br><span class="line"><span class="comment"> * @param opaque An opaque pointer to user-specific data.</span></span><br><span class="line"><span class="comment"> * @param read_packet  A function for refilling the buffer, may be NULL.</span></span><br><span class="line"><span class="comment"> *        For stream protocols, must never return 0 but rather a proper AVERROR code.</span></span><br><span class="line"><span class="comment"> * @param write_packet A function for writing the buffer contents, may be NULL.</span></span><br><span class="line"><span class="comment"> *        The function may not change the input buffers content.</span></span><br><span class="line"><span class="comment"> * @param seek A function for seeking to specified byte position, may be NULL.</span></span><br><span class="line"><span class="comment"> * @return Allocated AVIOContext or NULL on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVIOContext *<span class="title">avio_alloc_context</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="built_in">buffer</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> buffer_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> write_flag,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *opaque,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*read_packet)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*write_packet)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int64_t</span> (*<span class="built_in">seek</span>)(<span class="keyword">void</span> *opaque, <span class="keyword">int64_t</span> offset, <span class="keyword">int</span> whence))</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="AVIOContext-成员变量"><a href="#AVIOContext-成员变量" class="headerlink" title="AVIOContext 成员变量"></a>AVIOContext 成员变量</h4><ul>
<li><code>unsigned char *buffer;</code> : 缓存开始位置</li>
<li><code>int buffer_size;</code> : 缓存大小（默认 <code>32768</code>）</li>
<li><code>unsigned char *buf_ptr;</code> : 当前指针读取到的位置</li>
<li><code>unsigned char *buf_end;</code> : 缓存结束的位置</li>
<li><code>void *opaque;</code> : <code>URLContext</code> 结构体</li>
<li><code>int64_t pos;</code> : 文件读取指针位置</li>
<li><code>int eof_reached;</code> : 在读取失败或读取完成时置位</li>
<li><code>(*read_packet)</code> : 读取音视频数据的函数</li>
<li><code>(*write_packet)</code> : 写入音视频数据的函数</li>
<li><code>(*read_pause)</code> : 暂停或恢复网络流媒体协议的播放</li>
</ul>
<h3 id="URLContext-amp-URLProtocol"><a href="#URLContext-amp-URLProtocol" class="headerlink" title="URLContext &amp; URLProtocol"></a>URLContext &amp; URLProtocol</h3><p><code>URLContext</code> &amp; <code>URLProtocol</code> 并不在 <code>ffmpeg</code> 提供的头文件中，而是在源代码中</p>
<h4 id="URLContext-amp-URLProtocol-定义"><a href="#URLContext-amp-URLProtocol-定义" class="headerlink" title="URLContext &amp; URLProtocol 定义"></a>URLContext &amp; URLProtocol 定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLContext</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> AVClass *av_class;    <span class="comment">/**&lt;information for av_log(). Set by url_open(). */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span> *<span class="title">prot</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *priv_data;</span><br><span class="line">    <span class="keyword">char</span> *filename;             <span class="comment">/**&lt; specified URL */</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> max_packet_size;        <span class="comment">/**&lt; if non zero, the stream is packetized with this max packet size */</span></span><br><span class="line">    <span class="keyword">int</span> is_streamed;            <span class="comment">/**&lt;true if streamed (no seek possible), default = false */</span></span><br><span class="line">    <span class="keyword">int</span> is_connected;</span><br><span class="line">    AVIOInterruptCB interrupt_callback;</span><br><span class="line">    <span class="keyword">int64_t</span> rw_timeout;         <span class="comment">/**&lt;maximum time to wait for (network) read/write operation completion, in mcs */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocol_whitelist;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocol_blacklist;</span><br><span class="line">    <span class="keyword">int</span> min_packet_size;        <span class="comment">/**&lt; if non zero, the stream is packetized with this min packet size */</span></span><br><span class="line">&#125; URLContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span>     (*url_open)( URLContext *h, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This callback is to be used by protocols which open further nested</span></span><br><span class="line"><span class="comment">     * protocols. options are then to be passed to ffurl_open()/ffurl_connect()</span></span><br><span class="line"><span class="comment">     * for those nested protocols.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>     (*url_open2)(URLContext *h, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags, AVDictionary **options);</span><br><span class="line">    <span class="keyword">int</span>     (*url_accept)(URLContext *s, URLContext **c);</span><br><span class="line">    <span class="keyword">int</span>     (*url_handshake)(URLContext *c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read data from the protocol.</span></span><br><span class="line"><span class="comment">     * If data is immediately available (even less than size), EOF is</span></span><br><span class="line"><span class="comment">     * reached or an error occurs (including EINTR), return immediately.</span></span><br><span class="line"><span class="comment">     * Otherwise:</span></span><br><span class="line"><span class="comment">     * In non-blocking mode, return AVERROR(EAGAIN) immediately.</span></span><br><span class="line"><span class="comment">     * In blocking mode, wait for data/EOF/error with a short timeout (0.1s),</span></span><br><span class="line"><span class="comment">     * and return AVERROR(EAGAIN) on timeout.</span></span><br><span class="line"><span class="comment">     * Checking interrupt_callback, looping on EINTR and EAGAIN and until</span></span><br><span class="line"><span class="comment">     * enough data has been read is left to the calling function; see</span></span><br><span class="line"><span class="comment">     * retry_transfer_wrapper in avio.c.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>     (*url_read) (URLContext *h, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">int</span>     (*url_write)(URLContext *h, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_seek) (URLContext *h, <span class="keyword">int64_t</span> pos, <span class="keyword">int</span> whence);</span><br><span class="line">    <span class="keyword">int</span>     (*url_close)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_read_pause)(URLContext *h, <span class="keyword">int</span> pause);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_read_seek)(URLContext *h, <span class="keyword">int</span> stream_index,</span><br><span class="line">                             <span class="keyword">int64_t</span> timestamp, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_file_handle)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_multi_file_handle)(URLContext *h, <span class="keyword">int</span> **handles,</span><br><span class="line">                                     <span class="keyword">int</span> *numhandles);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_short_seek)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_shutdown)(URLContext *h, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> priv_data_size;</span><br><span class="line">    <span class="keyword">const</span> AVClass *priv_data_class;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> (*url_check)(URLContext *h, <span class="keyword">int</span> mask);</span><br><span class="line">    <span class="keyword">int</span> (*url_open_dir)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_read_dir)(URLContext *h, AVIODirEntry **next);</span><br><span class="line">    <span class="keyword">int</span> (*url_close_dir)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_delete)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_move)(URLContext *h_src, URLContext *h_dst);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *default_whitelist;</span><br><span class="line">&#125; URLProtocol;</span><br></pre></td></tr></table></figure>
<p>在 <code>URLProtocol</code> 结构体中，除了一些回调函数接口之外，有一个变量 <code>const char *name</code>，该变量存储了协议的名称。每一种输入协议都对应这样一个结构体对象。比如说，文件协议中代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file.c</span></span><br><span class="line"><span class="keyword">const</span> URLProtocol ff_file_protocol = &#123;</span><br><span class="line">    .name                = <span class="string">&quot;file&quot;</span>,</span><br><span class="line">    .url_open            = file_open,</span><br><span class="line">    .url_read            = file_read,</span><br><span class="line">    .url_write           = file_write,</span><br><span class="line">    .url_seek            = file_seek,</span><br><span class="line">    .url_close           = file_close,</span><br><span class="line">    .url_get_file_handle = file_get_handle,</span><br><span class="line">    .url_check           = file_check,</span><br><span class="line">    .url_delete          = file_delete,</span><br><span class="line">    .url_move            = file_move,</span><br><span class="line">    .priv_data_size      = <span class="keyword">sizeof</span>(FileContext),</span><br><span class="line">    .priv_data_class     = &amp;file_class,</span><br><span class="line">    .url_open_dir        = file_open_dir,</span><br><span class="line">    .url_read_dir        = file_read_dir,</span><br><span class="line">    .url_close_dir       = file_close_dir,</span><br><span class="line">    .default_whitelist   = <span class="string">&quot;file,crypto,data&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="封装-amp-解封装"><a href="#封装-amp-解封装" class="headerlink" title="封装 &amp; 解封装"></a>封装 &amp; 解封装</h2><h3 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h3><h4 id="AVFormatContext-相关函数"><a href="#AVFormatContext-相关函数" class="headerlink" title="AVFormatContext 相关函数"></a>AVFormatContext 相关函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配一个 AVFormatContext</span></span><br><span class="line"><span class="function">AVFormatContext *<span class="title">avformat_alloc_context</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 释放 AVFormatContext 及其所有 AVStream</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avformat_free_context</span><span class="params">(AVFormatContext *s)</span></span>;</span><br><span class="line"><span class="comment">// 打开一个输入流并读取报头，该函数不会打开编解码器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="keyword">const</span> <span class="keyword">char</span> *url, ff_const59 AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br><span class="line"><span class="comment">// 读取媒体文件的数据包以获取流信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="AVFormatContext-成员变量"><a href="#AVFormatContext-成员变量" class="headerlink" title="AVFormatContext 成员变量"></a>AVFormatContext 成员变量</h4><ul>
<li><code>struct AVInputFormat *iformat;</code> : 输入音视频的 <code>AVInputFormat</code></li>
<li><code>struct AVOutputFormat *oformat;</code> : 输出音视频的 <code>AVInputFormat</code></li>
<li><code>AVIOContext *pb;</code> : 输入 / 输出音视频数据的缓存</li>
<li><code>int64_t duration;</code> : 输入 / 输出音视频的时长（以微秒为单位）</li>
<li><code>int64_t bit_rate;</code> : 输入 / 输出音视频的码率</li>
<li><code>unsigned int nb_streams;</code> ： 输入 / 输出音视频的 <code>AVStream</code> 个数</li>
<li><code>AVStream **streams;</code> ： 输入 / 输出音视频的每个视频（音频流）</li>
<li><code>AVDictionary *metadata;</code> ： 元数据</li>
</ul>
<h3 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h3><p>视频文件中每个视频（音频）流对应一个 <code>AVStream</code> 对象</p>
<ul>
<li>在解封装时，<code>AVStream</code> 对象由 <code>libavformat</code> 中的函数 <code>xxxx_read_header()</code> 调用 <code>avformat_open_input()</code> 创建</li>
<li>如果解封装时，未在文件中读到文件头，即标志位 <code>AVFMTCTX_NOHEADER</code> 被置位，由函数 <code>xxxx_read_packet()</code> 调用 <code>avformat_open_input()</code> 创建</li>
<li>在封装时，<code>AVStream</code> 对象由用户调用函数 <code>avformat_new_stream()</code> 创建</li>
<li>调用 <code>libavformat</code> 中的函数 <code>avformat_free_context()</code> 销毁对象</li>
</ul>
<h4 id="AVStream-相关函数"><a href="#AVStream-相关函数" class="headerlink" title="AVStream 相关函数"></a>AVStream 相关函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a new stream to a media file.</span></span><br><span class="line"><span class="comment"> * @param s media file handle</span></span><br><span class="line"><span class="comment"> * @param c If non-NULL, the AVCodecContext corresponding to the new stream will be initialized to use this codec.</span></span><br><span class="line"><span class="comment"> * This is needed for e.g. codec-specific defaults to be set, so codec should be provided if it is known.</span></span><br><span class="line"><span class="comment"> * @return newly created stream or NULL on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVStream *<span class="title">avformat_new_stream</span><span class="params">(AVFormatContext *s, <span class="keyword">const</span> AVCodec *c)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="AVStream-成员变量"><a href="#AVStream-成员变量" class="headerlink" title="AVStream 成员变量"></a>AVStream 成员变量</h4><ul>
<li><code>int index</code> : stream index in AVFormatContext</li>
<li><code>AVCodecContext *codec;</code> : 指向该视频 / 音频流的 AVCodecContext 它们是一一对应的关系</li>
<li><code>AVRational time_base;</code> : 该流的时基 通过该值可以把 PTS/DTS 转化为真正的时间</li>
<li><code>int64_t duration;</code> : 该视频 / 音频流长度</li>
<li><code>AVRational r_frame_rate;</code> : 该流的帧率</li>
<li><code>AVDictionary *metadata;</code> : 元数据信息</li>
<li><code>AVRational avg_frame_rate;</code> : 平均帧率（注 : 对视频来说，这个挺重要的）</li>
<li><code>AVPacket attached_pic;</code> : 附带的图片。比如说一些 MP3，AAC 音频文件附带的专辑封面</li>
<li><code>AVCodecParameters *codecpar;</code> : 与此流相关的编解码器参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AVRational 可以用来表示无理数：</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVRational</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">///&lt; Numerator 分子</span></span><br><span class="line">    <span class="keyword">int</span> den; <span class="comment">///&lt; Denominator 分母</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure>
<h3 id="AVInputFormat"><a href="#AVInputFormat" class="headerlink" title="AVInputFormat"></a>AVInputFormat</h3><p>该结构被称为 <code>demuxer</code>，是音视频文件的一个解封装器</p>
<blockquote>
<p><code>AVOutputFormat</code> 和 <code>AVInputFormat</code> 结构类似，是音视频文件的封装器</p>
</blockquote>
<h4 id="AVInputFormat-相关函数"><a href="#AVInputFormat-相关函数" class="headerlink" title="AVInputFormat 相关函数"></a>AVInputFormat 相关函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If f is NULL, returns the first registered input format,</span></span><br><span class="line"><span class="comment"> * if f is non-NULL, returns the next registered input format after f or NULL if f is the last one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">attribute_deprecated AVInputFormat  *<span class="title">av_iformat_next</span><span class="params">(<span class="keyword">const</span> AVInputFormat  *f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>遍历 <code>ffmpeg</code> 中的解封装器的方法：</p>
<ol>
<li>注册所有解封装器：<code>av_register_all();</code>。注意，需要调用该函数才可以将所有注册的解封装器连接为一个链表</li>
<li>声明一个 <code>AVInputFormat</code> 类型的指针，比如说 <code>AVInputFormat* first_f = nullptr;</code></li>
<li>调用 <code>av_iformat_next()</code> 函数，即可获得指向链表下一个解封装器的指针，循环往复可以获得所有解码器的信息</li>
</ol>
<h4 id="AVInputFormat-成员变量"><a href="#AVInputFormat-成员变量" class="headerlink" title="AVInputFormat 成员变量"></a>AVInputFormat 成员变量</h4><p>每种文件格式对应了一个 <code>AVInputFormat</code> 对象，这些对象中的成员变量基本为 <code>const</code> 类型</p>
<ul>
<li><code>const char *name;</code> : 封装格式名称</li>
<li><code>const char *long_name;</code> : 封装格式的长名称</li>
<li><code>const char *extensions;</code> : 封装格式的扩展名</li>
<li><code>int raw_codec_id;</code> : 封装格式 <code>ID</code></li>
<li>一些封装格式处理的接口回调函数，如 <code>read_header</code>, <code>read_packet</code>, <code>read_close</code>, <code>read_seek</code> 等</li>
</ul>
<h3 id="编码-amp-解码"><a href="#编码-amp-解码" class="headerlink" title="编码 &amp; 解码"></a>编码 &amp; 解码</h3><h3 id="AVCodecContext"><a href="#AVCodecContext" class="headerlink" title="AVCodecContext"></a>AVCodecContext</h3><h3 id="AVCodecContext-相关函数"><a href="#AVCodecContext-相关函数" class="headerlink" title="AVCodecContext 相关函数"></a>AVCodecContext 相关函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配一个 AVCodecContext，并将其字段设置为默认值</span></span><br><span class="line"><span class="function">AVCodecContext *<span class="title">avcodec_alloc_context3</span><span class="params">(<span class="keyword">const</span> AVCodec *codec)</span></span>;</span><br><span class="line"><span class="comment">// 释放 AVCodecContext 及其相关内容，并向提供的指针写入 nullptr</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avcodec_free_context</span><span class="params">(AVCodecContext **avctx)</span></span>;</span><br><span class="line"><span class="comment">// 关闭一个给定的 AVCodecContext 并释放所有与它相关的数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_close</span><span class="params">(AVCodecContext *avctx)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fill the codec context based on the values from the supplied codec parameters.</span></span><br><span class="line"><span class="comment"> * Any allocated fields in codec that have a corresponding field in par are</span></span><br><span class="line"><span class="comment"> * freed and replaced with duplicates of the corresponding field in par.</span></span><br><span class="line"><span class="comment"> * Fields in codec that do not have a counterpart in par are not touched.</span></span><br><span class="line"><span class="comment"> * @return &gt;= 0 on success, a negative AVERROR code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_parameters_to_context</span><span class="params">(AVCodecContext *codec, <span class="keyword">const</span> AVCodecParameters *par)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="AVCodecContext-成员变量"><a href="#AVCodecContext-成员变量" class="headerlink" title="AVCodecContext 成员变量"></a>AVCodecContext 成员变量</h4><ul>
<li><code>const struct AVCodec  *codec;</code> : 编解码器的 <code>AVCodec</code></li>
<li><code>int width, height;</code> : 图像的宽高（只针对视频）</li>
<li><code>int coded_width, coded_height;</code> 未裁剪的图像宽高</li>
<li><code>enum AVPixelFormat pix_fmt;</code> : 像素格式（只针对视频）</li>
<li><code>AVRational time_base;</code> : 帧率的信息</li>
<li><code>int sample_rate;</code> : 采样率（只针对音频）</li>
<li><code>int channels;</code> : 采样率（只针对音频）</li>
<li><code>enum AVSampleFormat sample_fmt;</code> : 采样格式（只针对音频）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    **** width&#x2F;coded_width &amp; height&#x2F;coded_height ****</span><br><span class="line">一些编码器要求帧尺寸是特定数字的倍数，例如 x264 的帧尺寸是 16 的倍数</span><br><span class="line">因此，如果需要，编码器将把帧填充到合适的数字，并为解码器存储裁剪值</span><br><span class="line">coded_width, coded_height 是裁剪前的大小</span><br><span class="line">width, height 是裁剪后的大小</span><br></pre></td></tr></table></figure>
<h3 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h3><p>AVCodec 是存储编解码器信息的结构体</p>
<h4 id="AVCodec-相关函数"><a href="#AVCodec-相关函数" class="headerlink" title="AVCodec 相关函数"></a>AVCodec 相关函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 c 为空，返回第一个注册的编解码器</span></span><br><span class="line"><span class="comment">// 如果 c 非空，返回 c 之后的下一个注册编解码器，如果 c 是最后一个编解码器，返回 nullptr</span></span><br><span class="line"><span class="function">attribute_deprecated AVCodec *<span class="title">av_codec_next</span><span class="params">(<span class="keyword">const</span> AVCodec *c)</span></span>;</span><br><span class="line"><span class="comment">// 查找具有匹配编解码器 ID 的已注册解码器</span></span><br><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span>;</span><br><span class="line"><span class="comment">// 初始化 AVCodecContext 使用给定的 AVCodec。在使用这个函数之前，必须使用 avcodec_alloc_context3() 分配上下文。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_open2</span><span class="params">(AVCodecContext *avctx, <span class="keyword">const</span> AVCodec *codec, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>
<p>遍历 <code>ffmpeg</code> 中的解码器信息的方法：</p>
<ol>
<li>注册所有编解码器：<code>av_register_all();</code>。注意，需要调用该函数才可以将所有注册的解码器连接为一个链表</li>
<li>声明一个 <code>AVCodec</code> 类型的指针，比如说 <code>AVCodec* first_c = nullptr;</code></li>
<li>调用 <code>av_codec_next()</code> 函数，即可获得指向链表下一个解码器的指针，循环往复可以获得所有解码器的信息。注意，如果想要获得指向第一个解码器的指针，则需要将该函数的参数设置为 <code>nullptr</code></li>
</ol>
<h4 id="AVCodec-成员变量"><a href="#AVCodec-成员变量" class="headerlink" title="AVCodec 成员变量"></a>AVCodec 成员变量</h4><ul>
<li><code>const char *name;</code> : 编解码器的名字，比较短</li>
<li><code>const char *long_name;</code> : 编解码器的名字，全称，比较长</li>
<li><code>enum AVMediaType type;</code> : 指明了类型，是视频，音频，还是字幕</li>
<li><code>enum AVCodecID id;</code> : ID，不重复</li>
<li><code>const AVRational *supported_framerates;</code> : 支持的帧率（仅视频）</li>
<li><code>const enum AVPixelFormat *pix_fmts;</code> : 支持的像素格式（仅视频）</li>
<li><code>const int *supported_samplerates;</code> : 支持的采样率（仅音频）</li>
<li><code>const enum AVSampleFormat *sample_fmts;</code> : 支持的采样格式（仅音频）</li>
<li><code>const uint64_t *channel_layouts;</code> : 支持的声道数（仅音频）</li>
<li><code>int priv_data_size;</code> : 私有数据的大小</li>
</ul>
<p>每一个编解码器对应一个该结构体，查看一下 <code>ffmpeg</code> 的源代码，我们可以看一下 <code>H.264</code> 解码器的结构体如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h264.c</span></span><br><span class="line">AVCodec ff_h264_decoder = &#123;</span><br><span class="line">    .name                  = <span class="string">&quot;h264&quot;</span>,</span><br><span class="line">    .long_name             = NULL_IF_CONFIG_SMALL(<span class="string">&quot;H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10&quot;</span>),</span><br><span class="line">    .type                  = AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    .id                    = AV_CODEC_ID_H264,</span><br><span class="line">    .priv_data_size        = <span class="keyword">sizeof</span>(H264Context),</span><br><span class="line">    .init                  = h264_decode_init,</span><br><span class="line">    .<span class="built_in">close</span>                 = h264_decode_end,</span><br><span class="line">    .decode                = h264_decode_frame,</span><br><span class="line">    .capabilities          = <span class="comment">/*AV_CODEC_CAP_DRAW_HORIZ_BAND |*/</span> AV_CODEC_CAP_DR1 |</span><br><span class="line">                             AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS |</span><br><span class="line">                             AV_CODEC_CAP_FRAME_THREADS,</span><br><span class="line">    .hw_configs            = (<span class="keyword">const</span> AVCodecHWConfigInternal *<span class="keyword">const</span> []) &#123; <span class="literal">NULL</span> &#125;,</span><br><span class="line">    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_EXPORTS_CROPPING |</span><br><span class="line">                             FF_CODEC_CAP_ALLOCATE_PROGRESS | FF_CODEC_CAP_INIT_CLEANUP,</span><br><span class="line">    .<span class="built_in">flush</span>                 = h264_decode_flush,</span><br><span class="line">    .update_thread_context = ONLY_IF_THREADS_ENABLED(ff_h264_update_thread_context),</span><br><span class="line">    .profiles              = NULL_IF_CONFIG_SMALL(ff_h264_profiles),</span><br><span class="line">    .priv_class            = &amp;h264_class,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="音视频数据"><a href="#音视频数据" class="headerlink" title="音视频数据"></a>音视频数据</h2><h3 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h3><p><code>AVPacket</code> 是存储压缩编码数据相关信息的结构体</p>
<h4 id="AVPacket-相关函数"><a href="#AVPacket-相关函数" class="headerlink" title="AVPacket 相关函数"></a>AVPacket 相关函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回流的下一帧</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br><span class="line"><span class="comment">// 向解码器提供原始数据包数据作为输入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_send_packet</span><span class="params">(AVCodecContext *avctx, <span class="keyword">const</span> AVPacket *avpkt)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="AVPacket-结构体定义"><a href="#AVPacket-结构体定义" class="headerlink" title="AVPacket 结构体定义"></a>AVPacket 结构体定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVPacket</span> &#123;</span></span><br><span class="line">    AVBufferRef *buf;</span><br><span class="line">    <span class="keyword">int64_t</span> pts;    <span class="comment">///&lt; 显示时间戳</span></span><br><span class="line">    <span class="keyword">int64_t</span> dts;    <span class="comment">///&lt; 解码时间戳</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *data;  <span class="comment">///&lt; 压缩编码数据</span></span><br><span class="line">    <span class="keyword">int</span>   <span class="built_in">size</span>;     <span class="comment">///&lt; 压缩编码数据大小</span></span><br><span class="line">    <span class="keyword">int</span>   stream_index; <span class="comment">///&lt; 所属的 AVStream</span></span><br><span class="line">    <span class="keyword">int</span>   flags;    <span class="comment">///&lt; A combination of AV_PKT_FLAG values</span></span><br><span class="line">    AVPacketSideData *side_data;</span><br><span class="line">    <span class="keyword">int</span> side_data_elems;</span><br><span class="line">    <span class="keyword">int64_t</span> duration;</span><br><span class="line">    <span class="keyword">int64_t</span> pos;    <span class="comment">///&lt; byte position in stream, -1 if unknown</span></span><br><span class="line">&#125; AVPacket;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   *** 对于 H.264 来说。1 个 AVPacket 的 data 通常对应一个 NALU ***</span><br><span class="line">通过查看 ffmpeg 源代码我们发现，AVPacket 中的数据起始处没有分隔符 0x00000001</span><br><span class="line">也不是 0x65、0x67、0x68、0x41 等字节</span><br><span class="line">所以 AVPacket 肯定这不是标准的 NALU</span><br><span class="line">其实，AVPacket 前 4 个字表示的是 NALU 的长度，从第 5 个字节开始才是 NALU 的数据</span><br><span class="line">所以直接将 AVPacket 前 4 个字节替换为 0x00000001 即可得到标准的 NALU 数据</span><br></pre></td></tr></table></figure>
<h3 id="AVFrame"><a href="#AVFrame" class="headerlink" title="AVFrame"></a>AVFrame</h3><h4 id="AVFrame-相关函数"><a href="#AVFrame-相关函数" class="headerlink" title="AVFrame 相关函数"></a>AVFrame 相关函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配 AVFrame 并将其字段设置为默认值</span></span><br><span class="line"><span class="function">AVFrame *<span class="title">av_frame_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 释放 AVFrame 和其中所有动态分配的成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_frame_free</span><span class="params">(AVFrame **frame)</span></span>;</span><br><span class="line"><span class="comment">// 从解码器返回已解码的输出数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_receive_frame</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="AVPacket-成员变量"><a href="#AVPacket-成员变量" class="headerlink" title="AVPacket 成员变量"></a>AVPacket 成员变量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVFrame</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_NUM_DATA_POINTERS 8</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *data[AV_NUM_DATA_POINTERS];    <span class="comment">// 解码后原始数据 对视频来说是 YUV，RGB，对音频来说是 PCM</span></span><br><span class="line">    <span class="keyword">int</span> linesize[AV_NUM_DATA_POINTERS];     <span class="comment">// data 中一行数据的大小。注意：未必等于图像的宽，一般大于图像的宽</span></span><br><span class="line">    <span class="keyword">uint8_t</span> **extended_data;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;  <span class="comment">// 视频帧宽和高（1920x1080, 1280x720 ...）</span></span><br><span class="line">    <span class="keyword">int</span> nb_samples;     <span class="comment">// 音频的一个 AVFrame 中可能包含多个音频帧，在此标记包含了几个</span></span><br><span class="line">    <span class="keyword">int</span> format;         <span class="comment">// 解码后原始数据类型（YUV420, YUV422, RGB24 ...）</span></span><br><span class="line">    <span class="keyword">int</span> key_frame;      <span class="comment">// 1 -&gt; keyframe, 0-&gt; not</span></span><br><span class="line">    <span class="keyword">enum</span> AVPictureType pict_type;   <span class="comment">// 帧类型（I, B, P ...）</span></span><br><span class="line">    AVRational sample_aspect_ratio; <span class="comment">// 宽高比（16:9, 4:3 ...）</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts;        <span class="comment">// 显示时间戳</span></span><br><span class="line">    <span class="keyword">int64_t</span> pkt_dts;</span><br><span class="line">    <span class="keyword">int</span> coded_picture_number;   <span class="comment">// 编码帧序号</span></span><br><span class="line">    <span class="keyword">int</span> display_picture_number; <span class="comment">// 显示帧序号</span></span><br><span class="line">    ... ...</span><br><span class="line">&#125; AVFrame;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 基于 FFmpeg + SDL 的视频播放器的制作 — 雷霄骅</li>
<li>[2] <a href="https://blog.csdn.net/leixiaohua1020/article/details/11693997">FFMPEG 中最关键的结构体之间的关系_雷霄骅 (leixiaohua1020) 的专栏 - CSDN 博客_ffmpeg 结构体</a></li>
</ul>
]]></content>
      <categories>
        <category>音视频日记</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频日记 - ffmpeg 命令行</title>
    <url>/post/2021/4765df61/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>ffmpeg</code> 是一个基于 <code>ffmpeg</code> 库的经典转码程序，几乎被所有的知名系统、软件工具、服务器后台等静默使用，通过命令行启动转码，这里主要以命令行语法讲解为主。</p>
<a id="more"></a>
<h2 id="查看-ffmpeg-帮助命令"><a href="#查看-ffmpeg-帮助命令" class="headerlink" title="查看 ffmpeg 帮助命令"></a>查看 ffmpeg 帮助命令</h2><p>在学习任何一个命令行程序前，首先要知道如何查看对应命令的帮助，在一般情况下，<code>linux</code> 平台下程序的帮助信息是通过 <code>程序名 -h</code> 的方式进行输出，<code>ffmpeg</code> 亦是如此。</p>
<p>精简帮助命令：<code>ffmpeg –h</code><br>更多帮助命令：<code>ffmpeg –h long</code><br>完整帮助命令：<code>ffmpeg –h full</code></p>
<h2 id="ffmpeg-的语法格式"><a href="#ffmpeg-的语法格式" class="headerlink" title="ffmpeg 的语法格式"></a>ffmpeg 的语法格式</h2><p>ffmpeg 的语法格式如下所示</p>
<pre><code>ffmpeg [输入源参数] -i [输入 URL] [输出参数] [输出 URL]

其中 [输入源参数] 和 [输出参数] 的语法格式为：
[options] [value(可以省略)] ... ...
</code></pre><p>示例 1：</p>
<pre><code>ffmpeg -f mpegts -i &quot;http://AVTestFile/AVNormal/52&quot; -vcodec x264Encoder -r 15 -b:v 256000 -vf scale=800:600 -an -copyts -y &quot;51.avi&quot;
* 输入源使用 mpegts 容器 http 协议的 URL
* -vcodec x264Encoder 使用 x264Encoder 视频编码器
* -r 15 视频帧率 15 fps
* -b:v 256000 视频编码码率 265Kbps
* -vf scale=800:600 使用视频滤器 scale 进行缩放到 800x600 尺寸
* -an 禁用音频
* -copyts 时间戳拷贝
* -y 覆盖输出文件
* 输出 URL 默认使用 file 协议，输出到文件 51.avi
</code></pre><p>示例 2：</p>
<pre><code>ffmpeg -i BaiCaoYuan.mp4 -ss 00:00:19 -t 00:06:48 -dcodec copy -b:v 4000K -y cut.mp4
* 输入源使用 file 协议，为 BaiCaoYuan.mp4 文件
* -dcodec copy 使用与源视频一致的编解码器
* -b:v 4000K 视频编码码率 4000Kbps
* -y 覆盖输出文件
* 输出 URL 默认使用 file 协议，输出到文件 cut.mp4
</code></pre><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-t duration</td>
<td>-t 00:06:48</td>
<td>设置处理时间，格式为hh:mm:ss</td>
</tr>
<tr>
<td>-ss position</td>
<td>-ss 00:00:19</td>
<td>设置起始时间，格式为hh:mm:ss</td>
</tr>
<tr>
<td>-b:v bitrate</td>
<td>-b:v 256000</td>
<td>设置视频码率</td>
</tr>
<tr>
<td>-b:a bitrate</td>
<td>-b:a 320000</td>
<td>设置音频码率</td>
</tr>
<tr>
<td>-r fps</td>
<td>-r 25</td>
<td>设置帧率</td>
</tr>
<tr>
<td>-s wxh</td>
<td>-s 800x600</td>
<td>设置帧大小，格式为WxH</td>
</tr>
<tr>
<td>-c:v codec</td>
<td>-c:v h264</td>
<td>设置视频编码器</td>
</tr>
<tr>
<td>-c:a codec</td>
<td>-c:a aac</td>
<td>设置音频编码器</td>
</tr>
<tr>
<td>-ar freq</td>
<td>-ar 44100</td>
<td>设置音频采样率</td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] 基于 FFmpeg + SDL 的视频播放器的制作 — 雷霄骅</li>
<li>[2] 多媒体编程开发之 FFmpeg 基础库</li>
</ul>
]]></content>
      <categories>
        <category>音视频日记</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频日记 - 手写 H264 编码器</title>
    <url>/post/2021/6db02507/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[转载] <a href="https://blog.csdn.net/u012165769/article/details/107700527">深入讲解音视频编码原理，H264 码流详解——手写 H264 编码器_黎程雨的博客 - CSDN 博客</a></p>
<p>要彻底理解视频编码原理，看书都是虚的，需要实际动手，实现一个简单的视频编码器：</p>
<p>知识准备：基本图像处理知识，信号的时域和频域问题，熟练掌握傅立叶正反变换，一维、二维傅立叶变换，以及其变种，<code>dct</code> 变换，快速 <code>dct</code> 变换。</p>
<a id="more"></a>
<h3 id="第一步：实现有损图像压缩和解压"><a href="#第一步：实现有损图像压缩和解压" class="headerlink" title="第一步：实现有损图像压缩和解压"></a>第一步：实现有损图像压缩和解压</h3><p>参考 <code>JPEG</code> 原理，将 <code>RGB-&gt;YUV</code>，然后将 <code>Y/U/V</code> 看成三张不同的图片，将其中一张图片分为 8x8 的 <code>block</code> 进行 <code>dct</code> 变换（可以直接进行二维 <code>dct</code> 变换，或者按一定顺序将 8x8 的二维数组整理成一个 64 字节的一维数组），还是得到一个 8x8 的整数频率数据。于是表示图像大轮廓的低频信号（人眼敏感的信号）集中在 8x8 的左上角；表示图像细节的高频信号集中在右下角。</p>
<p>接着将其量化，所谓量化，就是信号采样的步长，8x8 的整数频率数据块，每个数据都要除以对应位置的步长，左上角相对重要的低频信号步长是 1，也就是说 0-255，是多少就是多少。而右下角是不太重要的高频信号，比如步长取 10，那么这些位置的数据都要 / 10，实际解码的时候再将他们 × 10 恢复出来，这样经过编码的时候 / 10 和解码的时候 × 10，那么步长为 10 的信号 1, 13, 25, 37 就会变成规矩的：0, 10, 20, 30, 对小于步长 10 的部分我们直接丢弃了，因为高频不太重要。</p>
<p>经过量化以后，8x8 的数据块左上角的数据由于步长小，都是比较离散的，而靠近右下角的高频数据，都比较统一，或者是一串 0，因此图像大量的细节被我们丢弃了，这时候，我们用无损压缩方式，比如 <code>lzma2</code> 算法（<code>jpeg</code> 是 <code>rle + huffman</code>）将这 64 个 <code>byte</code> 压缩起来，由于后面高频数据步长大，做了除法以后，这些值都比较小，而且比较靠近，甚至右下部分都是一串 0，十分便于压缩。</p>
<p><code>JPEG</code> 图像有个问题就是低码率时 <code>block</code> 边界比较严重，现代图片压缩技术往往要配合一些 <code>de-block</code> 算法，比如最简单的就是边界部分几个像素点和周围插值模糊一下。</p>
<blockquote>
<p>做到这里我们实现了一个同 <code>jpeg</code> 类似的静态图片有损压缩算法。在视频里面用来保存 I 帧数据。</p>
</blockquote>
<h3 id="2-1-2-第二步：实现宏块误差计算"><a href="#2-1-2-第二步：实现宏块误差计算" class="headerlink" title="2.1.2 第二步：实现宏块误差计算"></a>2.1.2 第二步：实现宏块误差计算</h3><p>视频由连续的若干图像帧组成，分为 I 帧，P 帧，所谓 I 帧，就是不依赖就可以独立解码的视频图像帧，而 P 帧则需要依赖前面已解码的视频帧，配合一定数据才能生成出来。所以视频中 I 帧往往都比较大，而 P 帧比较小，如果播放器一开始收到了 P 帧那么是无法播放的，只有收到下一个 I 帧才能开始播放。I 帧多了视频就变大，I 帧少了，数据量是小了，但视频受到丢包或者数据错误的影响却又会更严重。</p>
<p>那么所谓运动预测编码，其实就是 P 帧的生成过程：继续将图片分成 16x16 的 <code>block</code>（为了简单只讨论 yuv 的 y 分量压缩）。I 帧内部单帧图片压缩我们采用了 8x8 的 <code>block</code>，而这里用 16x16 的 <code>block</code> 来提高帧间编码压缩率（当然也会有更多细节损失），我们用 <code>x</code>,<code>y</code> 表示像素点坐标，而 <code>s</code>,<code>t</code> 表示 <code>block</code> 坐标，那么坐标为（x,y）的像素点所属的 <code>block</code> 坐标为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s = x / <span class="number">16</span> = x &gt;&gt; <span class="number">4</span></span><br><span class="line">t = y / <span class="number">16</span> = y &gt;&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>接着要计算两个 <code>block</code> 的相似度，即矢量的距离，可以表示为一个 256 维矢量（16x16）像素点色彩距离的平方，我们先定义两个颜色的误差为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">PixelDiff(c1, c2) = (c1- c2) ^ 2</span><br></pre></td></tr></table></figure>
<p>那么 256 个点的误差可以表示为所有对应点的像素误差和：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">BlockDiff(b1, b2) = sum( PixelDiff(c1, c2) for c1 in b1 for c2 in b2)</span><br></pre></td></tr></table></figure>
<p>代码化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">block_diff</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> b1[<span class="number">16</span>][<span class="number">16</span>], <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> b2[<span class="number">16</span>][<span class="number">16</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">              <span class="keyword">int</span> c1 = b1[i][j];</span><br><span class="line">              <span class="keyword">int</span> c2 = b2[i][j];</span><br><span class="line">              sum += (c1 - c2) * (c1 - c2);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个 <code>block</code> 求差的函数，我们就可以针对特定 block，搜索另外若干个 <code>block</code> 中哪个和它最相似了（误差最小）。</p>
<h4 id="第三步：实现运动预测编码"><a href="#第三步：实现运动预测编码" class="headerlink" title="第三步：实现运动预测编码"></a>第三步：实现运动预测编码</h4><p>根据上面的宏块比较函数，你已经可以知道两个 <code>block</code> 到底像不像了，越象的 <code>block</code>，<code>block_diff</code> 返回值越低。那么我们有两帧相邻的图片，P1，P2，假设 P1 已经完成编码了，现在要对 P2 进行 P 帧编码，其实就是轮询 P2 里面的每一个 <code>block</code>，为 P2 中每一个 <code>block</code> 找出上一帧中相似度最高的 <code>block</code> 坐标，并记录下来，具体伪代码可以表示为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> block[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= maxt; t++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= maxs; s++) &#123;</span><br><span class="line">         picture_get_block(P2, s * <span class="number">16</span>, t * <span class="number">16</span>, block); <span class="comment">// 取得图片 P2 的 block</span></span><br><span class="line">         <span class="keyword">int</span> x, y;</span><br><span class="line">         block_search_nearest(P1, &amp;x, &amp;y, block); <span class="comment">// 在 P1 中搜索最相似的 block</span></span><br><span class="line">         output(x, y);  <span class="comment">// 将 P1 中最相似的 block 的左上角像素坐标 (x, y) 输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中在 P1 中搜索最相似 <code>block</code> 的 <code>block_search_nearest</code> 函数原理是比较简单的，我们可以暴力点用两个 <code>for</code> 循环轮询 P1 中每个像素点开始的 16x16 的 <code>block</code>（速度较慢），当然实际中不可能这么暴力搜索，而是围绕 P2 中该 <code>block</code> 对应坐标在 P1 中位置作为中心，慢慢四周扩散，搜索一定步长，并得到一个 ：按照一定顺序进行搜索，并且在一定范围内最相似的宏块坐标。</p>
<blockquote>
<p>于是 P2 进行运动预测编码的结果就是一大堆 <code>(x,y)</code> 的坐标，代表 P2 上每个 <code>block</code> 在上一帧 P1 里面最相似的 <code>block</code> 的位置。反过来说可能更容易理解，我们可以把第三步整个过程定义为：</p>
<p>怎么用若干 P1 里不同起始位置的 <code>block</code> 拼凑出图片 P2 来，使得拼凑以后的结果和 P2 最像。</p>
</blockquote>
<h3 id="第四步：实现-P-帧编码"><a href="#第四步：实现-P-帧编码" class="headerlink" title="第四步：实现 P 帧编码"></a>第四步：实现 P 帧编码</h3><p>拼凑的结果就是一系列 <code>(x,y)</code> 的坐标数据，我们继续用 <code>lzma2</code> 将它们先压缩起来，按照 <code>vcd</code> 的分辨率</p>
<p><code>352 x 240</code>，我们横向需要 <code>352 / 16 = 22</code> 个 <code>block</code>，纵向需要 <code>240 / 16 = 15</code> 个 <code>block</code>，可以用 P1 中 <code>22 x 15 = 330</code></p>
<p>个 <code>block</code> 的坐标信息生成一张和 P2 很类似的图片 P2’ ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">15</span>; t++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">22</span>; s++, next++) &#123;</span><br><span class="line">         <span class="keyword">int</span> x = block_positions[next].x;   <span class="comment">// 取得对应 P1 上的 block 像素位置 x</span></span><br><span class="line">         <span class="keyword">int</span> y = block_positions[next].y;   <span class="comment">// 取得对应 P1 上的 block 像素位置 y</span></span><br><span class="line">         <span class="comment">// 将 P1 位置 (x,y) 开始的 16 x 16 的图块拷贝到 P2&#x27;的 (s * 16, t * 16) 处</span></span><br><span class="line">         CopyRect(P2<span class="number">&#x27;</span>, s * <span class="number">16</span>, t * <span class="number">16</span>, P1, x, y, <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把用来生成 P2 的 P1 称为 P2 的参考帧，再把刚才那一堆 P1 内用来拼成 P2 的 block 坐标称为「运动矢量」，这是 P 帧里面最主要的数据内容。但是此时由 P1 和这些坐标数据拼凑出来的 P2，你会发现粗看和 P2 很象，但细看会发现有些支离破碎，并且边缘比较明显，怎么办呢？我们需要第四步。</p>
<h3 id="第五步：实现-P-帧编码"><a href="#第五步：实现-P-帧编码" class="headerlink" title="第五步：实现 P 帧编码"></a>第五步：实现 P 帧编码</h3><p>有了刚才的运动预测矢量（一堆 <code>block</code> 的坐标），我们先用 P1 按照这些数据拼凑出一张类似 P2 的新图片叫做 P2’，然后同 P2 上每个像素做减法，得到一张保存 <code>differ</code> 的图片：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D2 = (P2 - P2<span class="number">&#x27;</span>) / <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>误差图片 D2 上每一个点等于 P2 上对应位置的点的颜色减去 P2’上对应位置的点的颜色再除以 2，用 8 位表示差值，值是循环的，比如 - 2 就是 255，这里一般可以在结果上 + 0x80，即 128 代表 0，129 代表 2，127 代表 - 2。继续用一个 8 位的整数可以表示 [-254, 254] 之间的误差范围，步长精度是 2。</p>
<p>按照第三步实现的逻辑，P2’其实已经很像 P2 了，只是有些误差，我们将这些误差保存成了图片 D2，所以图片 D2 中，信息量其实已经很小了，都是些细节修善，比起直接保存一张完整图片熵要低很多的。所以我们将 D2 用类似第一步提到的有损图片压缩方法进行编码，得到最终的 P 帧数据：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Encode(P2) = Lzma2(block_positions) + 有损图像编码（D2）</span><br></pre></td></tr></table></figure>
<p>具体在操作的时候，D2 的图像块可以用 16x16 进行有损编码，因为前面的运动预测数据是按 16x16 的宏块搜索的，而不用象 I 帧那样精确的用 8x8 表示，同时保存误差图时，量化的精度可以更粗一些用不着象 I 帧那么精确，可以理解成用质量更低的 <code>JPEG</code> 编码，按照 16x16 的块进行编码，加上误差图 D2 本来信息量就不高，这样的保存方式能够节省不少空间。</p>
<p>​</p>
<h3 id="第六步：实现-GOP-生成"><a href="#第六步：实现-GOP-生成" class="headerlink" title="第六步：实现 GOP 生成"></a>第六步：实现 GOP 生成</h3><p>通过前面的代码，我们实现了 I 帧编码和 P 帧编码，P 帧是参考 P1 对 P2 进行编码，而所谓 B 帧，就是参考 P1 和 P3 对 P2 进行编码，当然间隔不一定是 1，比如可以是参考 P1 和 P5 对 P2 进行编码，前提条件是 P5 可以依赖 P1 及以前的数据进行解码。</p>
<p>不过对于一个完整的简版视频编码器，I 帧和 P 帧编码已经够了，市面上任然有很多面向低延迟的商用编码器是直接干掉 B 帧的，因为做实时传输时收到 B 帧没法播放，之后再往后好几帧收到下一个 I 或者 P 帧时，先前收到的 B 帧才能被解码出来，造成不少的延迟。</p>
<p>而所谓的 <code>GOP</code> (<code>Group of picture</code>) 就是由一系列类似 I, P, B, B, P, B, B, P, B, B P 组成的一个可以完整被解码出来的图像组，而所谓视频文件，就是一个接一个的 <code>GOP</code>，每个 <code>GOP</code> 由一个 I 帧开头，然后接下来一组连续的 P 或者 B 构成，播放时只有完整收到下一个 <code>GOP</code> 的 I 帧才能开始播放。</p>
<p>最后是关于参考帧选择，前面提到的 P2 生成过程是参考了 P1，假设一个 <code>GOP</code> 中十张图片，是 I1, P1, P2, P3, P4, … P9 保存的，如果 P1 参考 I1，P2 参考 P1, P3 参考 P2 …. P9 参考 P8 这样每一个 P 帧都是参考上一帧进行编码的话，误差容易越来越大，因为 P1 已经引入一定误差了，P2 在 P1 的基础上误差更大，到了 P9 的话，图片质量可能已经没法看了。</p>
<p>因此正确的参考帧选择往往不需要这样死板，比如可以 P1-P9 全部参考 I1 来生成，或者，P1-P4 参考 I1 来生成，而 P5-P9 则参考 P5 来生成，这样步子小点，误差也不算太离谱。</p>
<h3 id="第七步：容器组装"><a href="#第七步：容器组装" class="headerlink" title="第七步：容器组装"></a>第七步：容器组装</h3><p>我们生成了一组组编码过的 <code>GOP</code> 了，这时候需要一定的文件格式将他们恰当的保存下来，记录视频信息，比如分辨率，帧率，时间索引等，就是一个类似 <code>MP4</code>（<code>h.264</code> 的容器）文件的东西。至此一个简单的小型编码器我们已经完成了，可以用 <code>SDL</code> / <code>DirectX</code> / <code>OpenGL</code> 配合实现一个播放器，愉快的将自己编码器编码的视频播放出来。</p>
<h3 id="第八步：优化改进"><a href="#第八步：优化改进" class="headerlink" title="第八步：优化改进"></a>第八步：优化改进</h3><p>这时候你已经大概学习并掌握了视频编码的基础原理了，接下来大量的优化改进的坑等着你去填呢。优化有两大方向，编码效率优化和编码性能优化：前者追求同质量（同信噪比）下更低的码率，后者追求同样质量和码率的情况下，更快的编码速度。</p>
<p>有这个基础后接下来可以回过头去看 <code>JPEG</code> 标准，<code>MPEG1-2</code> 标准，并阅读相关实现代码，你会发现简单很多了，接着肯 <code>H.264</code> 代码，不用全部看可以针对性的了解以下 <code>H.264</code> 的 I 帧编码和各种搜索预测方法，有 <code>H.264</code> 的底子，你了解 <code>HEVC</code> 和 <code>vpx</code> 就比较容易了。</p>
<p>参考这些编码器一些有意思的实现来改进自己的编码器，试验性质，可以侧重原理，各种优化技巧了解下即可，本来就是 <code>hack</code> 性质的。</p>
<blockquote>
<p>有卯用呢？首先肯定很好玩，其次，当你有需要使用并修改这些编码器为他们增加新特性的时候，你会发现前面的知识很管用了。</p>
</blockquote>
]]></content>
      <categories>
        <category>音视频日记</category>
      </categories>
      <tags>
        <tag>H.264</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频日记 - 音视频技术总览</title>
    <url>/post/2020/8a06ddbd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="音视频技术体系"><a href="#音视频技术体系" class="headerlink" title="音视频技术体系"></a>音视频技术体系</h2><blockquote>
<p><img data-src="https://gitee.com/hezhaojiang/MyPics/raw/master/img/20200821004823.png" alt="音视频核心技术"><br>图转自微信公众号：智媒黑板报</p>
</blockquote>
<a id="more"></a>
<h3 id="音视频封装技术"><a href="#音视频封装技术" class="headerlink" title="音视频封装技术"></a>音视频封装技术</h3><h4 id="1-MPEG2-PS"><a href="#1-MPEG2-PS" class="headerlink" title="1. MPEG2-PS"></a>1. MPEG2-PS</h4><ul>
<li><a href="/post/2020/9064839e/" title="音视频封装 - PS 封装格式">音视频封装 - PS 封装格式</a></li>
<li><a href="/post/2020/f33d2f13/" title="音视频封装 - PES 封装格式">音视频封装 - PES 封装格式</a></li>
<li><a href="/post/2020/1472cc3/" title="音视频封装 - PS 封装解析示例">音视频封装 - PS 封装解析示例</a>
</li>
</ul>
<h4 id="2-MPEG2-TS"><a href="#2-MPEG2-TS" class="headerlink" title="2. MPEG2-TS"></a>2. MPEG2-TS</h4><ul>
<li><a href="/post/2020/c6ae0d94/" title="音视频封装 - TS 封装格式">音视频封装 - TS 封装格式</a></li>
<li><a href="/post/2020/a03a01c2/" title="音视频封装 - TS 封装解析示例">音视频封装 - TS 封装解析示例</a>
</li>
</ul>
<h4 id="3-MP4-FMP4"><a href="#3-MP4-FMP4" class="headerlink" title="3. MP4/FMP4"></a>3. MP4/FMP4</h4><h4 id="4-AVI"><a href="#4-AVI" class="headerlink" title="4. AVI"></a>4. AVI</h4><h4 id="5-FLV"><a href="#5-FLV" class="headerlink" title="5. FLV"></a>5. FLV</h4><ul>
<li><a href="/post/2020/dff5a5c3/" title="音视频封装 - FLV 封装格式">音视频封装 - FLV 封装格式</a>
</li>
</ul>
<h3 id="音视频传输技术（流媒体传输）"><a href="#音视频传输技术（流媒体传输）" class="headerlink" title="音视频传输技术（流媒体传输）"></a>音视频传输技术（流媒体传输）</h3><h4 id="1-RTSP-RTP-RTCP"><a href="#1-RTSP-RTP-RTCP" class="headerlink" title="1. RTSP/RTP/RTCP"></a>1. RTSP/RTP/RTCP</h4><ul>
<li><a href="/post/2020/cf84018a/" title="流媒体传输 - RTSP 协议">流媒体传输 - RTSP 协议</a></li>
<li><a href="/post/2020/c8d9fa71/" title="流媒体传输 - RTSP 协议报文分析">流媒体传输 - RTSP 协议报文分析</a></li>
<li><a href="/post/2020/faccfa50/" title="流媒体传输 - RTP 协议">流媒体传输 - RTP 协议</a></li>
<li><a href="/post/2020/634443fb/" title="流媒体传输 - RTCP 协议">流媒体传输 - RTCP 协议</a></li>
<li><a href="/post/2020/fc237a45/" title="流媒体传输 - RTP 荷载 H264">流媒体传输 - RTP 荷载 H264</a></li>
<li><a href="/post/2020/8b244ad3/" title="流媒体传输 - RTP 荷载 H265">流媒体传输 - RTP 荷载 H265</a></li>
<li><a href="/post/2020/65370ad/" title="流媒体传输 - RTSP Over HTTP">流媒体传输 - RTSP Over HTTP</a></li>
<li><a href="/post/2020/880163e6/" title="流媒体传输 - RTSP Over HTTPS">流媒体传输 - RTSP Over HTTPS</a>
</li>
</ul>
<h4 id="2-SIP-SDP-GB28181"><a href="#2-SIP-SDP-GB28181" class="headerlink" title="2. SIP/SDP/GB28181"></a>2. SIP/SDP/GB28181</h4><ul>
<li><a href="/post/2020/1fa21384/" title="流媒体传输 - SDP 协议">流媒体传输 - SDP 协议</a></li>
<li><a href="/post/2020/de00def7/" title="GB28181 - 注册与注销">GB28181 - 注册与注销</a></li>
<li><a href="#">Post not found: GB28181 - 保活</a></li>
<li>GB28181 - 目录检索 （未更新）</li>
<li>GB28181 - 预览（未更新）</li>
<li>GB28181 - 回放 &amp; 下载 （未更新）</li>
</ul>
<h4 id="3-RTMP"><a href="#3-RTMP" class="headerlink" title="3. RTMP"></a>3. RTMP</h4><h4 id="4-HLS"><a href="#4-HLS" class="headerlink" title="4. HLS"></a>4. HLS</h4><h4 id="5-DASH"><a href="#5-DASH" class="headerlink" title="5. DASH"></a>5. DASH</h4><h3 id="音视频编解码技术"><a href="#音视频编解码技术" class="headerlink" title="音视频编解码技术"></a>音视频编解码技术</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul>
<li><a href="/post/2020/b179cf14/" title="数据压缩技术 - 熵编码原理">数据压缩技术 - 熵编码原理</a></li>
<li><a href="/post/2020/28999b3b/" title="数据压缩技术 - Huffman 编码">数据压缩技术 - Huffman 编码</a></li>
<li><a href="/post/2020/814ee4c2/" title="数据压缩技术 - 算术编码">数据压缩技术 - 算术编码</a></li>
<li><a href="/post/2020/cff0aa33/" title="数据压缩技术 - 游程编码">数据压缩技术 - 游程编码</a>
</li>
</ul>
<h4 id="H264-AVC"><a href="#H264-AVC" class="headerlink" title="H264/AVC"></a>H264/AVC</h4><h5 id="句法与语义"><a href="#句法与语义" class="headerlink" title="句法与语义"></a>句法与语义</h5><ul>
<li><a href="/post/2020/977d1006/" title="编解码技术：H264 - 基础概念">编解码技术：H264 - 基础概念</a></li>
<li><a href="/post/2020/f2a4ae37/" title="编解码技术：H264 - NAL Unit">编解码技术：H264 - NAL Unit</a></li>
<li><a href="/post/2020/5224fbf9/" title="编解码技术：H264 - Profile">编解码技术：H264 - Profile</a></li>
<li><a href="/post/2020/3552c034/" title="编解码技术：H264 - Level">编解码技术：H264 - Level</a></li>
<li><a href="/post/2020/4b4fd3b8/" title="编解码技术：H264 - SPS">编解码技术：H264 - SPS</a></li>
<li><a href="/post/2020/49096de1/" title="编解码技术：H264 - PPS">编解码技术：H264 - PPS</a>
</li>
</ul>
<h5 id="基本编码方式"><a href="#基本编码方式" class="headerlink" title="基本编码方式"></a>基本编码方式</h5><ul>
<li><a href="/post/2020/6343ec86/" title="编解码技术：H264 - 描述符 &amp; 熵编码">编解码技术：H264 - 描述符 &amp; 熵编码</a></li>
<li><a href="/post/2020/4f888bde/" title="编解码技术：H264 - CAVLC">编解码技术：H264 - CAVLC</a> （未完成，暂停更新）</li>
<li><a href="#">Post not found: 编解码技术：H264 - CABAC</a> （未完成，暂停更新）</li>
</ul>
<h5 id="帧内预测"><a href="#帧内预测" class="headerlink" title="帧内预测"></a>帧内预测</h5><h5 id="帧间预测"><a href="#帧间预测" class="headerlink" title="帧间预测"></a>帧间预测</h5><h5 id="码率控制"><a href="#码率控制" class="headerlink" title="码率控制"></a>码率控制</h5><h4 id="H265-HEVC"><a href="#H265-HEVC" class="headerlink" title="H265/HEVC"></a>H265/HEVC</h4><h4 id="H266-VVC"><a href="#H266-VVC" class="headerlink" title="H266/VVC"></a>H266/VVC</h4><h4 id="VP8"><a href="#VP8" class="headerlink" title="VP8"></a>VP8</h4><h4 id="VP9"><a href="#VP9" class="headerlink" title="VP9"></a>VP9</h4><h4 id="AV1"><a href="#AV1" class="headerlink" title="AV1"></a>AV1</h4><h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><h4 id="Nginx-rtmp-module"><a href="#Nginx-rtmp-module" class="headerlink" title="Nginx-rtmp-module"></a>Nginx-rtmp-module</h4><ul>
<li><a href="#">Post not found: Nginx - 介绍</a></li>
<li><a href="/post/2020/8f761f75/" title="Nginx - 环境搭建">Nginx - 环境搭建</a></li>
<li><a href="/post/2020/f45df2c9/" title="Nginx - 命令行参数和信号">Nginx - 命令行参数和信号</a></li>
<li>Nginx - 配置</li>
<li><a href="/post/2020/71c958c4/" title="NRM - 环境搭建">NRM - 环境搭建</a>
</li>
</ul>
<h4 id="Live555"><a href="#Live555" class="headerlink" title="Live555"></a>Live555</h4><h4 id="x264"><a href="#x264" class="headerlink" title="x264"></a>x264</h4><ul>
<li><a href="/post/2020/ee0dad8c/" title="源码阅读 x264 - 简介">源码阅读 x264 - 简介</a></li>
<li><a href="/post/2020/3bc2314a/" title="源码阅读 x264 - 命令行工具">源码阅读 x264 - 命令行工具</a></li>
<li><a href="/post/2020/e6d88726/" title="源码阅读 x264 - 常用结构体">源码阅读 x264 - 常用结构体</a> （未完成，暂停更新）</li>
<li><a href="/post/2020/eb0de708/" title="源码阅读 x264 - 编码 API">源码阅读 x264 - 编码 API</a> （未完成，暂停更新）</li>
</ul>
<h4 id="x265"><a href="#x265" class="headerlink" title="x265"></a>x265</h4><h4 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h4><h4 id="SRS"><a href="#SRS" class="headerlink" title="SRS"></a>SRS</h4><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p><a href="https://github.com/ty6815/AvStackDocs">ty6815/AvStackDocs: 音视频基础知识整理和相关协议文档说明</a></p>
]]></content>
      <categories>
        <category>音视频日记</category>
      </categories>
  </entry>
</search>
